/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from DISMAN-SCRIPT-MIB:
 *   This MIB module defines a set of objects that allow to
 *   delegate management scripts to distributed managers.
 *
 * Revision 2001-08-21 00:00:
 *   Revised version, published as RFC 3165.
 *   
 *   This revision introduces several new objects: smScriptError,
 *   smScriptLastChange, smLaunchError, smLaunchLastChange,
 *   smLaunchRowExpireTime, smRunResultTime, and smRunErrorTime.
 *   
 *   The following existing objects were updated: the maximum
 *   value of smRunLifeTime now disables the timer, an
 *   autostart value was added to the smLaunchAdminStatus
 *   object, and a new expired state was added to the
 *   smLaunchOperStatus object.
 *   
 *   A new smScriptException notification has been added to
 *   support runtime error notifications.
 *   
 *   Created new conformance and compliance statements that
 *   take care of the new objects and notifications.
 *   
 *   Clarifications have been added in several places to remove
 *   ambiguities or contradictions that were discovered and
 *   reported by implementors.
 *
 * Revision 1999-02-22 18:00:
 *   Initial version, published as RFC 2592.
 *
 * $Id$
 */

#include "disman-script-mib.h"

GSnmpEnum const disman_script_mib_enums_smScriptAdminStatus[] = {
    { DISMAN_SCRIPT_MIB_SMSCRIPTADMINSTATUS_ENABLED,	"enabled" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTADMINSTATUS_DISABLED,	"disabled" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTADMINSTATUS_EDITING,	"editing" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smScriptOperStatus[] = {
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_ENABLED,	"enabled" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_DISABLED,	"disabled" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_EDITING,	"editing" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_RETRIEVING,	"retrieving" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_COMPILING,	"compiling" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_NOSUCHSCRIPT,	"noSuchScript" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_ACCESSDENIED,	"accessDenied" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_WRONGLANGUAGE,	"wrongLanguage" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_WRONGVERSION,	"wrongVersion" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_COMPILATIONFAILED,	"compilationFailed" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_NORESOURCESLEFT,	"noResourcesLeft" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_UNKNOWNPROTOCOL,	"unknownProtocol" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_PROTOCOLFAILURE,	"protocolFailure" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS_GENERICERROR,	"genericError" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smScriptStorageType[] = {
    { DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE_OTHER,	"other" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE_VOLATILE,	"volatile" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE_NONVOLATILE,	"nonVolatile" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE_PERMANENT,	"permanent" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smScriptRowStatus[] = {
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_ACTIVE,	"active" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_NOTINSERVICE,	"notInService" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_NOTREADY,	"notReady" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smCodeRowStatus[] = {
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_ACTIVE,	"active" },
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_NOTINSERVICE,	"notInService" },
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_NOTREADY,	"notReady" },
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_CREATEANDGO,	"createAndGo" },
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { DISMAN_SCRIPT_MIB_SMCODEROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smLaunchControl[] = {
    { DISMAN_SCRIPT_MIB_SMLAUNCHCONTROL_ABORT,	"abort" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHCONTROL_SUSPEND,	"suspend" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHCONTROL_RESUME,	"resume" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHCONTROL_NOP,	"nop" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smLaunchAdminStatus[] = {
    { DISMAN_SCRIPT_MIB_SMLAUNCHADMINSTATUS_ENABLED,	"enabled" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHADMINSTATUS_DISABLED,	"disabled" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHADMINSTATUS_AUTOSTART,	"autostart" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smLaunchOperStatus[] = {
    { DISMAN_SCRIPT_MIB_SMLAUNCHOPERSTATUS_ENABLED,	"enabled" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHOPERSTATUS_DISABLED,	"disabled" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHOPERSTATUS_EXPIRED,	"expired" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smLaunchStorageType[] = {
    { DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE_OTHER,	"other" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE_VOLATILE,	"volatile" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE_NONVOLATILE,	"nonVolatile" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE_PERMANENT,	"permanent" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smLaunchRowStatus[] = {
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_ACTIVE,	"active" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_NOTINSERVICE,	"notInService" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_NOTREADY,	"notReady" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_CREATEANDGO,	"createAndGo" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smRunExitCode[] = {
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_NOERROR,	"noError" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_HALTED,	"halted" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_LIFETIMEEXCEEDED,	"lifeTimeExceeded" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_NORESOURCESLEFT,	"noResourcesLeft" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_LANGUAGEERROR,	"languageError" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_RUNTIMEERROR,	"runtimeError" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_INVALIDARGUMENT,	"invalidArgument" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_SECURITYVIOLATION,	"securityViolation" },
    { DISMAN_SCRIPT_MIB_SMRUNEXITCODE_GENERICERROR,	"genericError" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smRunControl[] = {
    { DISMAN_SCRIPT_MIB_SMRUNCONTROL_ABORT,	"abort" },
    { DISMAN_SCRIPT_MIB_SMRUNCONTROL_SUSPEND,	"suspend" },
    { DISMAN_SCRIPT_MIB_SMRUNCONTROL_RESUME,	"resume" },
    { DISMAN_SCRIPT_MIB_SMRUNCONTROL_NOP,	"nop" },
    { 0, NULL }
};

GSnmpEnum const disman_script_mib_enums_smRunState[] = {
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_INITIALIZING,	"initializing" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_EXECUTING,	"executing" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_SUSPENDING,	"suspending" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_SUSPENDED,	"suspended" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_RESUMING,	"resuming" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_ABORTING,	"aborting" },
    { DISMAN_SCRIPT_MIB_SMRUNSTATE_TERMINATED,	"terminated" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_smLangEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 1, 1};

static attribute_t attr_smLangEntry[] = {
    { 2, G_SNMP_OBJECTID, DISMAN_SCRIPT_MIB_SMLANGLANGUAGE, "smLangLanguage" },
    { 3, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLANGVERSION, "smLangVersion" },
    { 4, G_SNMP_OBJECTID, DISMAN_SCRIPT_MIB_SMLANGVENDOR, "smLangVendor" },
    { 5, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLANGREVISION, "smLangRevision" },
    { 6, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLANGDESCR, "smLangDescr" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_smExtsnEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 2, 1};

static attribute_t attr_smExtsnEntry[] = {
    { 2, G_SNMP_OBJECTID, DISMAN_SCRIPT_MIB_SMEXTSNEXTENSION, "smExtsnExtension" },
    { 3, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMEXTSNVERSION, "smExtsnVersion" },
    { 4, G_SNMP_OBJECTID, DISMAN_SCRIPT_MIB_SMEXTSNVENDOR, "smExtsnVendor" },
    { 5, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMEXTSNREVISION, "smExtsnRevision" },
    { 6, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMEXTSNDESCR, "smExtsnDescr" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_smScriptEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1};

static attribute_t attr_smScriptEntry[] = {
    { 3, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMSCRIPTDESCR, "smScriptDescr" },
    { 4, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMSCRIPTLANGUAGE, "smScriptLanguage" },
    { 5, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMSCRIPTSOURCE, "smScriptSource" },
    { 6, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMSCRIPTADMINSTATUS, "smScriptAdminStatus" },
    { 7, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMSCRIPTOPERSTATUS, "smScriptOperStatus" },
    { 8, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMSCRIPTSTORAGETYPE, "smScriptStorageType" },
    { 9, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMSCRIPTROWSTATUS, "smScriptRowStatus" },
    { 10, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMSCRIPTERROR, "smScriptError" },
    { 11, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMSCRIPTLASTCHANGE, "smScriptLastChange" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_smCodeEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1};

static attribute_t attr_smCodeEntry[] = {
    { 2, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMCODETEXT, "smCodeText" },
    { 3, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMCODEROWSTATUS, "smCodeRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_smLaunchEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1};

static attribute_t attr_smLaunchEntry[] = {
    { 3, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLAUNCHSCRIPTOWNER, "smLaunchScriptOwner" },
    { 4, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLAUNCHSCRIPTNAME, "smLaunchScriptName" },
    { 5, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLAUNCHARGUMENT, "smLaunchArgument" },
    { 6, G_SNMP_UNSIGNED32, DISMAN_SCRIPT_MIB_SMLAUNCHMAXRUNNING, "smLaunchMaxRunning" },
    { 7, G_SNMP_UNSIGNED32, DISMAN_SCRIPT_MIB_SMLAUNCHMAXCOMPLETED, "smLaunchMaxCompleted" },
    { 8, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHLIFETIME, "smLaunchLifeTime" },
    { 9, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHEXPIRETIME, "smLaunchExpireTime" },
    { 10, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHSTART, "smLaunchStart" },
    { 11, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHCONTROL, "smLaunchControl" },
    { 12, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHADMINSTATUS, "smLaunchAdminStatus" },
    { 13, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHOPERSTATUS, "smLaunchOperStatus" },
    { 14, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHRUNINDEXNEXT, "smLaunchRunIndexNext" },
    { 15, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHSTORAGETYPE, "smLaunchStorageType" },
    { 16, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHROWSTATUS, "smLaunchRowStatus" },
    { 17, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLAUNCHERROR, "smLaunchError" },
    { 18, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMLAUNCHLASTCHANGE, "smLaunchLastChange" },
    { 19, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMLAUNCHROWEXPIRETIME, "smLaunchRowExpireTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_smRunEntry[] = {1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1};

static attribute_t attr_smRunEntry[] = {
    { 2, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNARGUMENT, "smRunArgument" },
    { 3, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNSTARTTIME, "smRunStartTime" },
    { 4, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNENDTIME, "smRunEndTime" },
    { 5, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMRUNLIFETIME, "smRunLifeTime" },
    { 6, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMRUNEXPIRETIME, "smRunExpireTime" },
    { 7, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMRUNEXITCODE, "smRunExitCode" },
    { 8, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNRESULT, "smRunResult" },
    { 9, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMRUNCONTROL, "smRunControl" },
    { 10, G_SNMP_INTEGER32, DISMAN_SCRIPT_MIB_SMRUNSTATE, "smRunState" },
    { 11, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNERROR, "smRunError" },
    { 12, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNRESULTTIME, "smRunResultTime" },
    { 13, G_SNMP_OCTETSTRING, DISMAN_SCRIPT_MIB_SMRUNERRORTIME, "smRunErrorTime" },
    { 0, 0, 0, NULL }
};


disman_script_mib_smLangEntry_t *
disman_script_mib_new_smLangEntry()
{
    disman_script_mib_smLangEntry_t *smLangEntry;

    smLangEntry = (disman_script_mib_smLangEntry_t *) g_malloc0(sizeof(disman_script_mib_smLangEntry_t) + sizeof(gpointer));
    return smLangEntry;
}

static int
unpack_smLangEntry(GSnmpVarBind *vb, disman_script_mib_smLangEntry_t *smLangEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    smLangEntry->smLangIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smLangEntry(guint32 *base, gint32 smLangIndex)
{
    int idx = 11;

    base[idx++] = smLangIndex;
    return idx;
}

static disman_script_mib_smLangEntry_t *
assign_smLangEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smLangEntry_t *smLangEntry;
    guint32 idx;
    char *p;

    smLangEntry = disman_script_mib_new_smLangEntry();
    if (! smLangEntry) {
        return NULL;
    }

    p = (char *) smLangEntry + sizeof(disman_script_mib_smLangEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smLangEntry((GSnmpVarBind *) vbl->data, smLangEntry) < 0) {
        g_warning("smLangEntry: invalid instance identifier");
        g_free(smLangEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smLangEntry, sizeof(oid_smLangEntry)/sizeof(guint32),
                   attr_smLangEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 128) break;
            smLangEntry->_smLangLanguageLength = vb->syntax_len / sizeof(guint32);
            smLangEntry->smLangLanguage = vb->syntax.ui32;
            break;
        case 3:
            if ((vb->syntax_len > 32)) {
                g_warning("smLangVersion: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smLangVersion: value not within SnmpAdminString size constraints");
                break;
            }
            smLangEntry->_smLangVersionLength = vb->syntax_len;
            smLangEntry->smLangVersion = vb->syntax.uc;
            break;
        case 4:
            if (vb->syntax_len > 128) break;
            smLangEntry->_smLangVendorLength = vb->syntax_len / sizeof(guint32);
            smLangEntry->smLangVendor = vb->syntax.ui32;
            break;
        case 5:
            if ((vb->syntax_len > 32)) {
                g_warning("smLangRevision: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smLangRevision: value not within SnmpAdminString size constraints");
                break;
            }
            smLangEntry->_smLangRevisionLength = vb->syntax_len;
            smLangEntry->smLangRevision = vb->syntax.uc;
            break;
        case 6:
            if ((vb->syntax_len > 255)) {
                g_warning("smLangDescr: value not within SnmpAdminString size constraints");
                break;
            }
            smLangEntry->_smLangDescrLength = vb->syntax_len;
            smLangEntry->smLangDescr = vb->syntax.uc;
            break;
        };
    }

    return smLangEntry;
}

void
disman_script_mib_get_smLangTable(GSnmpSession *s, disman_script_mib_smLangEntry_t ***smLangEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 0};

    *smLangEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_smLangEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smLangEntry = (disman_script_mib_smLangEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smLangEntry_t *));
        if (! *smLangEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smLangEntry)[i] = assign_smLangEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smLangEntry(GSnmpSession *s, disman_script_mib_smLangEntry_t **smLangEntry, gint32 smLangIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smLangEntry, sizeof(oid_smLangEntry));
    len = pack_smLangEntry(base, smLangIndex);
    if (len < 0) {
        g_warning("smLangEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smLangEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_smLangEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smLangEntry = assign_smLangEntry(out);
    }
}

void
disman_script_mib_free_smLangEntry(disman_script_mib_smLangEntry_t *smLangEntry)
{
    GSList *vbl;
    char *p;

    if (smLangEntry) {
        p = (char *) smLangEntry + sizeof(disman_script_mib_smLangEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smLangEntry);
    }
}

void
disman_script_mib_free_smLangTable(disman_script_mib_smLangEntry_t **smLangEntry)
{
    int i;

    if (smLangEntry) {
        for (i = 0; smLangEntry[i]; i++) {
            disman_script_mib_free_smLangEntry(smLangEntry[i]);
        }
        g_free(smLangEntry);
    }
}

disman_script_mib_smExtsnEntry_t *
disman_script_mib_new_smExtsnEntry()
{
    disman_script_mib_smExtsnEntry_t *smExtsnEntry;

    smExtsnEntry = (disman_script_mib_smExtsnEntry_t *) g_malloc0(sizeof(disman_script_mib_smExtsnEntry_t) + sizeof(gpointer));
    return smExtsnEntry;
}

static int
unpack_smExtsnEntry(GSnmpVarBind *vb, disman_script_mib_smExtsnEntry_t *smExtsnEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    smExtsnEntry->smLangIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    smExtsnEntry->smExtsnIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smExtsnEntry(guint32 *base, gint32 smLangIndex, gint32 smExtsnIndex)
{
    int idx = 11;

    base[idx++] = smLangIndex;
    base[idx++] = smExtsnIndex;
    return idx;
}

static disman_script_mib_smExtsnEntry_t *
assign_smExtsnEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smExtsnEntry_t *smExtsnEntry;
    guint32 idx;
    char *p;

    smExtsnEntry = disman_script_mib_new_smExtsnEntry();
    if (! smExtsnEntry) {
        return NULL;
    }

    p = (char *) smExtsnEntry + sizeof(disman_script_mib_smExtsnEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smExtsnEntry((GSnmpVarBind *) vbl->data, smExtsnEntry) < 0) {
        g_warning("smExtsnEntry: invalid instance identifier");
        g_free(smExtsnEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smExtsnEntry, sizeof(oid_smExtsnEntry)/sizeof(guint32),
                   attr_smExtsnEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 128) break;
            smExtsnEntry->_smExtsnExtensionLength = vb->syntax_len / sizeof(guint32);
            smExtsnEntry->smExtsnExtension = vb->syntax.ui32;
            break;
        case 3:
            if ((vb->syntax_len > 32)) {
                g_warning("smExtsnVersion: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smExtsnVersion: value not within SnmpAdminString size constraints");
                break;
            }
            smExtsnEntry->_smExtsnVersionLength = vb->syntax_len;
            smExtsnEntry->smExtsnVersion = vb->syntax.uc;
            break;
        case 4:
            if (vb->syntax_len > 128) break;
            smExtsnEntry->_smExtsnVendorLength = vb->syntax_len / sizeof(guint32);
            smExtsnEntry->smExtsnVendor = vb->syntax.ui32;
            break;
        case 5:
            if ((vb->syntax_len > 32)) {
                g_warning("smExtsnRevision: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smExtsnRevision: value not within SnmpAdminString size constraints");
                break;
            }
            smExtsnEntry->_smExtsnRevisionLength = vb->syntax_len;
            smExtsnEntry->smExtsnRevision = vb->syntax.uc;
            break;
        case 6:
            if ((vb->syntax_len > 255)) {
                g_warning("smExtsnDescr: value not within SnmpAdminString size constraints");
                break;
            }
            smExtsnEntry->_smExtsnDescrLength = vb->syntax_len;
            smExtsnEntry->smExtsnDescr = vb->syntax.uc;
            break;
        };
    }

    return smExtsnEntry;
}

void
disman_script_mib_get_smExtsnTable(GSnmpSession *s, disman_script_mib_smExtsnEntry_t ***smExtsnEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 0};

    *smExtsnEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_smExtsnEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smExtsnEntry = (disman_script_mib_smExtsnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smExtsnEntry_t *));
        if (! *smExtsnEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smExtsnEntry)[i] = assign_smExtsnEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smExtsnEntry(GSnmpSession *s, disman_script_mib_smExtsnEntry_t **smExtsnEntry, gint32 smLangIndex, gint32 smExtsnIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smExtsnEntry, sizeof(oid_smExtsnEntry));
    len = pack_smExtsnEntry(base, smLangIndex, smExtsnIndex);
    if (len < 0) {
        g_warning("smExtsnEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smExtsnEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_smExtsnEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smExtsnEntry = assign_smExtsnEntry(out);
    }
}

void
disman_script_mib_free_smExtsnEntry(disman_script_mib_smExtsnEntry_t *smExtsnEntry)
{
    GSList *vbl;
    char *p;

    if (smExtsnEntry) {
        p = (char *) smExtsnEntry + sizeof(disman_script_mib_smExtsnEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smExtsnEntry);
    }
}

void
disman_script_mib_free_smExtsnTable(disman_script_mib_smExtsnEntry_t **smExtsnEntry)
{
    int i;

    if (smExtsnEntry) {
        for (i = 0; smExtsnEntry[i]; i++) {
            disman_script_mib_free_smExtsnEntry(smExtsnEntry[i]);
        }
        g_free(smExtsnEntry);
    }
}

disman_script_mib_smScriptEntry_t *
disman_script_mib_new_smScriptEntry()
{
    disman_script_mib_smScriptEntry_t *smScriptEntry;

    smScriptEntry = (disman_script_mib_smScriptEntry_t *) g_malloc0(sizeof(disman_script_mib_smScriptEntry_t) + sizeof(gpointer));
    return smScriptEntry;
}

static int
unpack_smScriptEntry(GSnmpVarBind *vb, disman_script_mib_smScriptEntry_t *smScriptEntry)
{
    int idx = 12;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smScriptEntry->smScriptOwner[i] = vb->id[idx++];
    }
    smScriptEntry->_smScriptOwnerLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smScriptEntry->smScriptName[i] = vb->id[idx++];
    }
    smScriptEntry->_smScriptNameLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smScriptEntry(guint32 *base, guchar *smScriptOwner, guint16 _smScriptOwnerLength, guchar *smScriptName, guint16 _smScriptNameLength)
{
    int idx = 12;
    guint16 i, len;

    len = _smScriptOwnerLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smScriptOwner[i];
        if (idx >= 128) return -1;
    }
    len = _smScriptNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smScriptName[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static disman_script_mib_smScriptEntry_t *
assign_smScriptEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smScriptEntry_t *smScriptEntry;
    guint32 idx;
    char *p;

    smScriptEntry = disman_script_mib_new_smScriptEntry();
    if (! smScriptEntry) {
        return NULL;
    }

    p = (char *) smScriptEntry + sizeof(disman_script_mib_smScriptEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smScriptEntry((GSnmpVarBind *) vbl->data, smScriptEntry) < 0) {
        g_warning("smScriptEntry: invalid instance identifier");
        g_free(smScriptEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smScriptEntry, sizeof(oid_smScriptEntry)/sizeof(guint32),
                   attr_smScriptEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if ((vb->syntax_len > 255)) {
                g_warning("smScriptDescr: value not within SnmpAdminString size constraints");
                break;
            }
            smScriptEntry->_smScriptDescrLength = vb->syntax_len;
            smScriptEntry->smScriptDescr = vb->syntax.uc;
            break;
        case 4:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smScriptLanguage: value not within range constraints");
                break;
            }
            smScriptEntry->smScriptLanguage = &(vb->syntax.i32[0]);
            break;
        case 5:
            if ((vb->syntax_len > 255)) {
                g_warning("smScriptSource: value not within DisplayString size constraints");
                break;
            }
            smScriptEntry->_smScriptSourceLength = vb->syntax_len;
            smScriptEntry->smScriptSource = vb->syntax.uc;
            break;
        case 6:
            smScriptEntry->smScriptAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 7:
            smScriptEntry->smScriptOperStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            smScriptEntry->smScriptStorageType = &(vb->syntax.i32[0]);
            break;
        case 9:
            smScriptEntry->smScriptRowStatus = &(vb->syntax.i32[0]);
            break;
        case 10:
            if ((vb->syntax_len > 255)) {
                g_warning("smScriptError: value not within SnmpAdminString size constraints");
                break;
            }
            smScriptEntry->_smScriptErrorLength = vb->syntax_len;
            smScriptEntry->smScriptError = vb->syntax.uc;
            break;
        case 11:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smScriptLastChange: value not within DateAndTime size constraints");
                break;
            }
            smScriptEntry->_smScriptLastChangeLength = vb->syntax_len;
            smScriptEntry->smScriptLastChange = vb->syntax.uc;
            break;
        };
    }

    return smScriptEntry;
}

void
disman_script_mib_get_smScriptTable(GSnmpSession *s, disman_script_mib_smScriptEntry_t ***smScriptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 0};

    *smScriptEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_smScriptEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smScriptEntry = (disman_script_mib_smScriptEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smScriptEntry_t *));
        if (! *smScriptEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smScriptEntry)[i] = assign_smScriptEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smScriptEntry(GSnmpSession *s, disman_script_mib_smScriptEntry_t **smScriptEntry, guchar *smScriptOwner, guint16 _smScriptOwnerLength, guchar *smScriptName, guint16 _smScriptNameLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smScriptEntry, sizeof(oid_smScriptEntry));
    len = pack_smScriptEntry(base, smScriptOwner, _smScriptOwnerLength, smScriptName, _smScriptNameLength);
    if (len < 0) {
        g_warning("smScriptEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smScriptEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_smScriptEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smScriptEntry = assign_smScriptEntry(out);
    }
}

void
disman_script_mib_set_smScriptEntry(GSnmpSession *s, disman_script_mib_smScriptEntry_t *smScriptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smScriptEntry, sizeof(oid_smScriptEntry));
    len = pack_smScriptEntry(base, smScriptEntry->smScriptOwner, smScriptEntry->_smScriptOwnerLength, smScriptEntry->smScriptName, smScriptEntry->_smScriptNameLength);
    if (len < 0) {
        g_warning("smScriptEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (smScriptEntry->smScriptDescr) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smScriptEntry->smScriptDescr,
                       smScriptEntry->_smScriptDescrLength);
    }
    if (smScriptEntry->smScriptLanguage) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smScriptEntry->smScriptLanguage,
                       0);
    }
    if (smScriptEntry->smScriptSource) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smScriptEntry->smScriptSource,
                       smScriptEntry->_smScriptSourceLength);
    }
    if (smScriptEntry->smScriptAdminStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smScriptEntry->smScriptAdminStatus,
                       0);
    }
    if (smScriptEntry->smScriptStorageType) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smScriptEntry->smScriptStorageType,
                       0);
    }
    if (smScriptEntry->smScriptRowStatus) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smScriptEntry->smScriptRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
disman_script_mib_free_smScriptEntry(disman_script_mib_smScriptEntry_t *smScriptEntry)
{
    GSList *vbl;
    char *p;

    if (smScriptEntry) {
        p = (char *) smScriptEntry + sizeof(disman_script_mib_smScriptEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smScriptEntry);
    }
}

void
disman_script_mib_free_smScriptTable(disman_script_mib_smScriptEntry_t **smScriptEntry)
{
    int i;

    if (smScriptEntry) {
        for (i = 0; smScriptEntry[i]; i++) {
            disman_script_mib_free_smScriptEntry(smScriptEntry[i]);
        }
        g_free(smScriptEntry);
    }
}

disman_script_mib_smCodeEntry_t *
disman_script_mib_new_smCodeEntry()
{
    disman_script_mib_smCodeEntry_t *smCodeEntry;

    smCodeEntry = (disman_script_mib_smCodeEntry_t *) g_malloc0(sizeof(disman_script_mib_smCodeEntry_t) + sizeof(gpointer));
    return smCodeEntry;
}

static int
unpack_smCodeEntry(GSnmpVarBind *vb, disman_script_mib_smCodeEntry_t *smCodeEntry)
{
    int idx = 12;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smCodeEntry->smScriptOwner[i] = vb->id[idx++];
    }
    smCodeEntry->_smScriptOwnerLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smCodeEntry->smScriptName[i] = vb->id[idx++];
    }
    smCodeEntry->_smScriptNameLength = len;
    if (vb->id_len < idx) return -1;
    smCodeEntry->smCodeIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smCodeEntry(guint32 *base, guchar *smScriptOwner, guint16 _smScriptOwnerLength, guchar *smScriptName, guint16 _smScriptNameLength, guint32 smCodeIndex)
{
    int idx = 12;
    guint16 i, len;

    len = _smScriptOwnerLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smScriptOwner[i];
        if (idx >= 128) return -1;
    }
    len = _smScriptNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smScriptName[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = smCodeIndex;
    return idx;
}

static disman_script_mib_smCodeEntry_t *
assign_smCodeEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smCodeEntry_t *smCodeEntry;
    guint32 idx;
    char *p;

    smCodeEntry = disman_script_mib_new_smCodeEntry();
    if (! smCodeEntry) {
        return NULL;
    }

    p = (char *) smCodeEntry + sizeof(disman_script_mib_smCodeEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smCodeEntry((GSnmpVarBind *) vbl->data, smCodeEntry) < 0) {
        g_warning("smCodeEntry: invalid instance identifier");
        g_free(smCodeEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smCodeEntry, sizeof(oid_smCodeEntry)/sizeof(guint32),
                   attr_smCodeEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if ((vb->syntax_len < 1 || vb->syntax_len > 1024)) {
                g_warning("smCodeText: value not within size constraints");
                break;
            }
            smCodeEntry->_smCodeTextLength = vb->syntax_len;
            smCodeEntry->smCodeText = vb->syntax.uc;
            break;
        case 3:
            smCodeEntry->smCodeRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return smCodeEntry;
}

void
disman_script_mib_get_smCodeTable(GSnmpSession *s, disman_script_mib_smCodeEntry_t ***smCodeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 0};

    *smCodeEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_smCodeEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smCodeEntry = (disman_script_mib_smCodeEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smCodeEntry_t *));
        if (! *smCodeEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smCodeEntry)[i] = assign_smCodeEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smCodeEntry(GSnmpSession *s, disman_script_mib_smCodeEntry_t **smCodeEntry, guchar *smScriptOwner, guint16 _smScriptOwnerLength, guchar *smScriptName, guint16 _smScriptNameLength, guint32 smCodeIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smCodeEntry, sizeof(oid_smCodeEntry));
    len = pack_smCodeEntry(base, smScriptOwner, _smScriptOwnerLength, smScriptName, _smScriptNameLength, smCodeIndex);
    if (len < 0) {
        g_warning("smCodeEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smCodeEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_smCodeEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smCodeEntry = assign_smCodeEntry(out);
    }
}

void
disman_script_mib_set_smCodeEntry(GSnmpSession *s, disman_script_mib_smCodeEntry_t *smCodeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smCodeEntry, sizeof(oid_smCodeEntry));
    len = pack_smCodeEntry(base, smCodeEntry->smScriptOwner, smCodeEntry->_smScriptOwnerLength, smCodeEntry->smScriptName, smCodeEntry->_smScriptNameLength, smCodeEntry->smCodeIndex);
    if (len < 0) {
        g_warning("smCodeEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (smCodeEntry->smCodeText) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smCodeEntry->smCodeText,
                       smCodeEntry->_smCodeTextLength);
    }
    if (smCodeEntry->smCodeRowStatus) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smCodeEntry->smCodeRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
disman_script_mib_free_smCodeEntry(disman_script_mib_smCodeEntry_t *smCodeEntry)
{
    GSList *vbl;
    char *p;

    if (smCodeEntry) {
        p = (char *) smCodeEntry + sizeof(disman_script_mib_smCodeEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smCodeEntry);
    }
}

void
disman_script_mib_free_smCodeTable(disman_script_mib_smCodeEntry_t **smCodeEntry)
{
    int i;

    if (smCodeEntry) {
        for (i = 0; smCodeEntry[i]; i++) {
            disman_script_mib_free_smCodeEntry(smCodeEntry[i]);
        }
        g_free(smCodeEntry);
    }
}

disman_script_mib_smLaunchEntry_t *
disman_script_mib_new_smLaunchEntry()
{
    disman_script_mib_smLaunchEntry_t *smLaunchEntry;

    smLaunchEntry = (disman_script_mib_smLaunchEntry_t *) g_malloc0(sizeof(disman_script_mib_smLaunchEntry_t) + sizeof(gpointer));
    return smLaunchEntry;
}

static int
unpack_smLaunchEntry(GSnmpVarBind *vb, disman_script_mib_smLaunchEntry_t *smLaunchEntry)
{
    int idx = 12;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smLaunchEntry->smLaunchOwner[i] = vb->id[idx++];
    }
    smLaunchEntry->_smLaunchOwnerLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smLaunchEntry->smLaunchName[i] = vb->id[idx++];
    }
    smLaunchEntry->_smLaunchNameLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smLaunchEntry(guint32 *base, guchar *smLaunchOwner, guint16 _smLaunchOwnerLength, guchar *smLaunchName, guint16 _smLaunchNameLength)
{
    int idx = 12;
    guint16 i, len;

    len = _smLaunchOwnerLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smLaunchOwner[i];
        if (idx >= 128) return -1;
    }
    len = _smLaunchNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smLaunchName[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static disman_script_mib_smLaunchEntry_t *
assign_smLaunchEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smLaunchEntry_t *smLaunchEntry;
    guint32 idx;
    char *p;

    smLaunchEntry = disman_script_mib_new_smLaunchEntry();
    if (! smLaunchEntry) {
        return NULL;
    }

    p = (char *) smLaunchEntry + sizeof(disman_script_mib_smLaunchEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smLaunchEntry((GSnmpVarBind *) vbl->data, smLaunchEntry) < 0) {
        g_warning("smLaunchEntry: invalid instance identifier");
        g_free(smLaunchEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smLaunchEntry, sizeof(oid_smLaunchEntry)/sizeof(guint32),
                   attr_smLaunchEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if ((vb->syntax_len > 32)) {
                g_warning("smLaunchScriptOwner: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smLaunchScriptOwner: value not within SnmpAdminString size constraints");
                break;
            }
            smLaunchEntry->_smLaunchScriptOwnerLength = vb->syntax_len;
            smLaunchEntry->smLaunchScriptOwner = vb->syntax.uc;
            break;
        case 4:
            if ((vb->syntax_len > 32)) {
                g_warning("smLaunchScriptName: value not within size constraints");
                break;
            }
            if ((vb->syntax_len > 255)) {
                g_warning("smLaunchScriptName: value not within SnmpAdminString size constraints");
                break;
            }
            smLaunchEntry->_smLaunchScriptNameLength = vb->syntax_len;
            smLaunchEntry->smLaunchScriptName = vb->syntax.uc;
            break;
        case 5:
            smLaunchEntry->_smLaunchArgumentLength = vb->syntax_len;
            smLaunchEntry->smLaunchArgument = vb->syntax.uc;
            break;
        case 6:
            if ((vb->syntax.ui32[0] < 1)) {
                g_warning("smLaunchMaxRunning: value not within range constraints");
                break;
            }
            smLaunchEntry->smLaunchMaxRunning = &(vb->syntax.ui32[0]);
            break;
        case 7:
            if ((vb->syntax.ui32[0] < 1)) {
                g_warning("smLaunchMaxCompleted: value not within range constraints");
                break;
            }
            smLaunchEntry->smLaunchMaxCompleted = &(vb->syntax.ui32[0]);
            break;
        case 8:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smLaunchLifeTime: value not within TimeInterval range constraints");
                break;
            }
            smLaunchEntry->smLaunchLifeTime = &(vb->syntax.i32[0]);
            break;
        case 9:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smLaunchExpireTime: value not within TimeInterval range constraints");
                break;
            }
            smLaunchEntry->smLaunchExpireTime = &(vb->syntax.i32[0]);
            break;
        case 10:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smLaunchStart: value not within range constraints");
                break;
            }
            smLaunchEntry->smLaunchStart = &(vb->syntax.i32[0]);
            break;
        case 11:
            smLaunchEntry->smLaunchControl = &(vb->syntax.i32[0]);
            break;
        case 12:
            smLaunchEntry->smLaunchAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 13:
            smLaunchEntry->smLaunchOperStatus = &(vb->syntax.i32[0]);
            break;
        case 14:
            if ((vb->syntax.i32[0] < 1)) {
                g_warning("smLaunchRunIndexNext: value not within range constraints");
                break;
            }
            smLaunchEntry->smLaunchRunIndexNext = &(vb->syntax.i32[0]);
            break;
        case 15:
            smLaunchEntry->smLaunchStorageType = &(vb->syntax.i32[0]);
            break;
        case 16:
            smLaunchEntry->smLaunchRowStatus = &(vb->syntax.i32[0]);
            break;
        case 17:
            if ((vb->syntax_len > 255)) {
                g_warning("smLaunchError: value not within SnmpAdminString size constraints");
                break;
            }
            smLaunchEntry->_smLaunchErrorLength = vb->syntax_len;
            smLaunchEntry->smLaunchError = vb->syntax.uc;
            break;
        case 18:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smLaunchLastChange: value not within DateAndTime size constraints");
                break;
            }
            smLaunchEntry->_smLaunchLastChangeLength = vb->syntax_len;
            smLaunchEntry->smLaunchLastChange = vb->syntax.uc;
            break;
        case 19:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smLaunchRowExpireTime: value not within TimeInterval range constraints");
                break;
            }
            smLaunchEntry->smLaunchRowExpireTime = &(vb->syntax.i32[0]);
            break;
        };
    }

    return smLaunchEntry;
}

void
disman_script_mib_get_smLaunchTable(GSnmpSession *s, disman_script_mib_smLaunchEntry_t ***smLaunchEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 0};

    *smLaunchEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_smLaunchEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smLaunchEntry = (disman_script_mib_smLaunchEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smLaunchEntry_t *));
        if (! *smLaunchEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smLaunchEntry)[i] = assign_smLaunchEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smLaunchEntry(GSnmpSession *s, disman_script_mib_smLaunchEntry_t **smLaunchEntry, guchar *smLaunchOwner, guint16 _smLaunchOwnerLength, guchar *smLaunchName, guint16 _smLaunchNameLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smLaunchEntry, sizeof(oid_smLaunchEntry));
    len = pack_smLaunchEntry(base, smLaunchOwner, _smLaunchOwnerLength, smLaunchName, _smLaunchNameLength);
    if (len < 0) {
        g_warning("smLaunchEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smLaunchEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_smLaunchEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smLaunchEntry = assign_smLaunchEntry(out);
    }
}

void
disman_script_mib_set_smLaunchEntry(GSnmpSession *s, disman_script_mib_smLaunchEntry_t *smLaunchEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smLaunchEntry, sizeof(oid_smLaunchEntry));
    len = pack_smLaunchEntry(base, smLaunchEntry->smLaunchOwner, smLaunchEntry->_smLaunchOwnerLength, smLaunchEntry->smLaunchName, smLaunchEntry->_smLaunchNameLength);
    if (len < 0) {
        g_warning("smLaunchEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (smLaunchEntry->smLaunchScriptOwner) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smLaunchEntry->smLaunchScriptOwner,
                       smLaunchEntry->_smLaunchScriptOwnerLength);
    }
    if (smLaunchEntry->smLaunchScriptName) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smLaunchEntry->smLaunchScriptName,
                       smLaunchEntry->_smLaunchScriptNameLength);
    }
    if (smLaunchEntry->smLaunchArgument) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       smLaunchEntry->smLaunchArgument,
                       smLaunchEntry->_smLaunchArgumentLength);
    }
    if (smLaunchEntry->smLaunchMaxRunning) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_UNSIGNED32,
                       smLaunchEntry->smLaunchMaxRunning,
                       0);
    }
    if (smLaunchEntry->smLaunchMaxCompleted) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_UNSIGNED32,
                       smLaunchEntry->smLaunchMaxCompleted,
                       0);
    }
    if (smLaunchEntry->smLaunchLifeTime) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchLifeTime,
                       0);
    }
    if (smLaunchEntry->smLaunchExpireTime) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchExpireTime,
                       0);
    }
    if (smLaunchEntry->smLaunchStart) {
        base[11] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchStart,
                       0);
    }
    if (smLaunchEntry->smLaunchControl) {
        base[11] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchControl,
                       0);
    }
    if (smLaunchEntry->smLaunchAdminStatus) {
        base[11] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchAdminStatus,
                       0);
    }
    if (smLaunchEntry->smLaunchStorageType) {
        base[11] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchStorageType,
                       0);
    }
    if (smLaunchEntry->smLaunchRowStatus) {
        base[11] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchRowStatus,
                       0);
    }
    if (smLaunchEntry->smLaunchRowExpireTime) {
        base[11] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smLaunchEntry->smLaunchRowExpireTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
disman_script_mib_free_smLaunchEntry(disman_script_mib_smLaunchEntry_t *smLaunchEntry)
{
    GSList *vbl;
    char *p;

    if (smLaunchEntry) {
        p = (char *) smLaunchEntry + sizeof(disman_script_mib_smLaunchEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smLaunchEntry);
    }
}

void
disman_script_mib_free_smLaunchTable(disman_script_mib_smLaunchEntry_t **smLaunchEntry)
{
    int i;

    if (smLaunchEntry) {
        for (i = 0; smLaunchEntry[i]; i++) {
            disman_script_mib_free_smLaunchEntry(smLaunchEntry[i]);
        }
        g_free(smLaunchEntry);
    }
}

disman_script_mib_smRunEntry_t *
disman_script_mib_new_smRunEntry()
{
    disman_script_mib_smRunEntry_t *smRunEntry;

    smRunEntry = (disman_script_mib_smRunEntry_t *) g_malloc0(sizeof(disman_script_mib_smRunEntry_t) + sizeof(gpointer));
    return smRunEntry;
}

static int
unpack_smRunEntry(GSnmpVarBind *vb, disman_script_mib_smRunEntry_t *smRunEntry)
{
    int idx = 12;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smRunEntry->smLaunchOwner[i] = vb->id[idx++];
    }
    smRunEntry->_smLaunchOwnerLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        smRunEntry->smLaunchName[i] = vb->id[idx++];
    }
    smRunEntry->_smLaunchNameLength = len;
    if (vb->id_len < idx) return -1;
    smRunEntry->smRunIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_smRunEntry(guint32 *base, guchar *smLaunchOwner, guint16 _smLaunchOwnerLength, guchar *smLaunchName, guint16 _smLaunchNameLength, gint32 smRunIndex)
{
    int idx = 12;
    guint16 i, len;

    len = _smLaunchOwnerLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smLaunchOwner[i];
        if (idx >= 128) return -1;
    }
    len = _smLaunchNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = smLaunchName[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = smRunIndex;
    return idx;
}

static disman_script_mib_smRunEntry_t *
assign_smRunEntry(GSList *vbl)
{
    GSList *elem;
    disman_script_mib_smRunEntry_t *smRunEntry;
    guint32 idx;
    char *p;

    smRunEntry = disman_script_mib_new_smRunEntry();
    if (! smRunEntry) {
        return NULL;
    }

    p = (char *) smRunEntry + sizeof(disman_script_mib_smRunEntry_t);
    * (GSList **) p = vbl;

    if (unpack_smRunEntry((GSnmpVarBind *) vbl->data, smRunEntry) < 0) {
        g_warning("smRunEntry: invalid instance identifier");
        g_free(smRunEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_smRunEntry, sizeof(oid_smRunEntry)/sizeof(guint32),
                   attr_smRunEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            smRunEntry->_smRunArgumentLength = vb->syntax_len;
            smRunEntry->smRunArgument = vb->syntax.uc;
            break;
        case 3:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smRunStartTime: value not within DateAndTime size constraints");
                break;
            }
            smRunEntry->_smRunStartTimeLength = vb->syntax_len;
            smRunEntry->smRunStartTime = vb->syntax.uc;
            break;
        case 4:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smRunEndTime: value not within DateAndTime size constraints");
                break;
            }
            smRunEntry->_smRunEndTimeLength = vb->syntax_len;
            smRunEntry->smRunEndTime = vb->syntax.uc;
            break;
        case 5:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smRunLifeTime: value not within TimeInterval range constraints");
                break;
            }
            smRunEntry->smRunLifeTime = &(vb->syntax.i32[0]);
            break;
        case 6:
            if ((vb->syntax.i32[0] < 0)) {
                g_warning("smRunExpireTime: value not within TimeInterval range constraints");
                break;
            }
            smRunEntry->smRunExpireTime = &(vb->syntax.i32[0]);
            break;
        case 7:
            smRunEntry->smRunExitCode = &(vb->syntax.i32[0]);
            break;
        case 8:
            smRunEntry->_smRunResultLength = vb->syntax_len;
            smRunEntry->smRunResult = vb->syntax.uc;
            break;
        case 9:
            smRunEntry->smRunControl = &(vb->syntax.i32[0]);
            break;
        case 10:
            smRunEntry->smRunState = &(vb->syntax.i32[0]);
            break;
        case 11:
            if ((vb->syntax_len > 255)) {
                g_warning("smRunError: value not within SnmpAdminString size constraints");
                break;
            }
            smRunEntry->_smRunErrorLength = vb->syntax_len;
            smRunEntry->smRunError = vb->syntax.uc;
            break;
        case 12:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smRunResultTime: value not within DateAndTime size constraints");
                break;
            }
            smRunEntry->_smRunResultTimeLength = vb->syntax_len;
            smRunEntry->smRunResultTime = vb->syntax.uc;
            break;
        case 13:
            if ((vb->syntax_len != 8)
                && (vb->syntax_len != 11)) {
                g_warning("smRunErrorTime: value not within DateAndTime size constraints");
                break;
            }
            smRunEntry->_smRunErrorTimeLength = vb->syntax_len;
            smRunEntry->smRunErrorTime = vb->syntax.uc;
            break;
        };
    }

    return smRunEntry;
}

void
disman_script_mib_get_smRunTable(GSnmpSession *s, disman_script_mib_smRunEntry_t ***smRunEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 0};

    *smRunEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_smRunEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *smRunEntry = (disman_script_mib_smRunEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(disman_script_mib_smRunEntry_t *));
        if (! *smRunEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*smRunEntry)[i] = assign_smRunEntry(row->data);
        }
    }
}

void
disman_script_mib_get_smRunEntry(GSnmpSession *s, disman_script_mib_smRunEntry_t **smRunEntry, guchar *smLaunchOwner, guint16 _smLaunchOwnerLength, guchar *smLaunchName, guint16 _smLaunchNameLength, gint32 smRunIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smRunEntry, sizeof(oid_smRunEntry));
    len = pack_smRunEntry(base, smLaunchOwner, _smLaunchOwnerLength, smLaunchName, _smLaunchNameLength, smRunIndex);
    if (len < 0) {
        g_warning("smRunEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *smRunEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_smRunEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *smRunEntry = assign_smRunEntry(out);
    }
}

void
disman_script_mib_set_smRunEntry(GSnmpSession *s, disman_script_mib_smRunEntry_t *smRunEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_smRunEntry, sizeof(oid_smRunEntry));
    len = pack_smRunEntry(base, smRunEntry->smLaunchOwner, smRunEntry->_smLaunchOwnerLength, smRunEntry->smLaunchName, smRunEntry->_smLaunchNameLength, smRunEntry->smRunIndex);
    if (len < 0) {
        g_warning("smRunEntry: invalid index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (smRunEntry->smRunLifeTime) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smRunEntry->smRunLifeTime,
                       0);
    }
    if (smRunEntry->smRunExpireTime) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smRunEntry->smRunExpireTime,
                       0);
    }
    if (smRunEntry->smRunControl) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       smRunEntry->smRunControl,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
disman_script_mib_free_smRunEntry(disman_script_mib_smRunEntry_t *smRunEntry)
{
    GSList *vbl;
    char *p;

    if (smRunEntry) {
        p = (char *) smRunEntry + sizeof(disman_script_mib_smRunEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(smRunEntry);
    }
}

void
disman_script_mib_free_smRunTable(disman_script_mib_smRunEntry_t **smRunEntry)
{
    int i;

    if (smRunEntry) {
        for (i = 0; smRunEntry[i]; i++) {
            disman_script_mib_free_smRunEntry(smRunEntry[i]);
        }
        g_free(smRunEntry);
    }
}


