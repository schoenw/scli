/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Options:
 *   --scli-include='version|extEntry|prEntry|laEntry'
 *
 * Derived from UCD-SNMP-MIB:
 *   This file defines the private UCD SNMP MIB extensions.
 *
 * Revision 2001-01-17 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 2002-01-04 00:00:
 *   Introduced LongDisplayString which is needed for allow
 *   for long configuration settings. Rewrote some definitions
 *   to make them more precise.
 *
 * Revision 2001-01-17 00:00:
 *   Added raw CPU and IO counters.
 *
 * Revision 1999-12-09 00:00:
 *   SMIv2 version converted from older MIB definitions.
 *
 * $Id$
 */

#include "ucd-snmp-mib.h"

GSnmpEnum const ucd_snmp_mib_enums_prErrorFlag[] = {
    { UCD_SNMP_MIB_PRERRORFLAG_OK,    "ok" },
    { UCD_SNMP_MIB_PRERRORFLAG_ERROR, "error" },
    { 0, NULL }
};

GSnmpEnum const ucd_snmp_mib_enums_versionDoDebugging[] = {
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_DISABLED, "disabled" },
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_ENABLED,  "enabled" },
    { 0, NULL }
};


static guint16 prNames_constraints[] = {0, 255, 0, 0};
static guint16 prErrMessage_constraints[] = {0, 255, 0, 0};
static guint16 prErrFixCmd_constraints[] = {0, 255, 0, 0};
static guint16 extNames_constraints[] = {0, 255, 0, 0};
static guint16 extCommand_constraints[] = {0, 255, 0, 0};
static guint16 extOutput_constraints[] = {0, 255, 0, 0};
static guint16 extErrFixCmd_constraints[] = {0, 255, 0, 0};
static guint16 laNames_constraints[] = {0, 255, 0, 0};
static guint16 laLoad_constraints[] = {0, 255, 0, 0};
static guint16 laConfig_constraints[] = {0, 255, 0, 0};
static guint16 laLoadFloat_constraints[] = {7, 7, 0, 0};
static guint16 laErrMessage_constraints[] = {0, 255, 0, 0};
static guint16 versionTag_constraints[] = {0, 255, 0, 0};
static guint16 versionDate_constraints[] = {0, 255, 0, 0};
static guint16 versionCDate_constraints[] = {0, 255, 0, 0};
static guint16 versionIdent_constraints[] = {0, 255, 0, 0};
static guint16 versionConfigureOptions_constraints[] = {0, 1023, 0, 0};


static guint32 const prEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1};

static GSnmpAttribute prEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRNAMES, "prNames",
       prNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prNamesLength),
      0 },
    { 3, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRMIN, "prMin",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMin),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRMAX, "prMax",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMax),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRCOUNT, "prCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prCount),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRERRORFLAG, "prErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRERRMESSAGE, "prErrMessage",
       prErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrMessageLength),
      0 },
    { 102, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRERRFIX, "prErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRERRFIXCMD, "prErrFixCmd",
       prErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const extEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1};

static GSnmpAttribute extEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTNAMES, "extNames",
       extNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extNamesLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTCOMMAND, "extCommand",
       extCommand_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extCommand),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extCommandLength),
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_EXTRESULT, "extResult",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extResult),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTOUTPUT, "extOutput",
       extOutput_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extOutput),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extOutputLength),
      0 },
    { 102, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_EXTERRFIX, "extErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTERRFIXCMD, "extErrFixCmd",
       extErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const laEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1};

static GSnmpAttribute laEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LANAMES, "laNames",
       laNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laNamesLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LALOAD, "laLoad",
       laLoad_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoad),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laLoadLength),
      0 },
    { 4, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LACONFIG, "laConfig",
       laConfig_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laConfig),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laConfigLength),
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_LALOADINT, "laLoadInt",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadInt),
      0,
      0 },
    { 6, G_SNMP_OPAQUE,
      UCD_SNMP_MIB_LALOADFLOAT, "laLoadFloat",
       laLoadFloat_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadFloat),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_LAERRORFLAG, "laErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LAERRMESSAGE, "laErrMessage",
       laErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laErrMessageLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const version_oid[] = {1, 3, 6, 1, 4, 1, 2021, 100};

static GSnmpAttribute version_attr[] = {
    { 1, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONINDEX, "versionIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIndex),
      0,
      0 },
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONTAG, "versionTag",
       versionTag_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionTag),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionTagLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONDATE, "versionDate",
       versionDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionDateLength),
      0 },
    { 4, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCDATE, "versionCDate",
       versionCDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionCDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionCDateLength),
      0 },
    { 5, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONIDENT, "versionIdent",
       versionIdent_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIdent),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionIdentLength),
      0 },
    { 6, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCONFIGUREOPTIONS, "versionConfigureOptions",
       versionConfigureOptions_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionConfigureOptions),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionConfigureOptionsLength),
      0 },
    { 10, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONCLEARCACHE, "versionClearCache",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionClearCache),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONUPDATECONFIG, "versionUpdateConfig",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionUpdateConfig),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONRESTARTAGENT, "versionRestartAgent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionRestartAgent),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 20, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONDODEBUGGING, "versionDoDebugging",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDoDebugging),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


ucd_snmp_mib_prEntry_t *
ucd_snmp_mib_new_prEntry()
{
    ucd_snmp_mib_prEntry_t *prEntry;

    prEntry = (ucd_snmp_mib_prEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_prEntry_t) + sizeof(gpointer));
    return prEntry;
}

static inline int
unpack_prEntry(GSnmpVarBind *vb, ucd_snmp_mib_prEntry_t *prEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    prEntry->prIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static inline gint8
pack_prEntry(guint32 *base, gint32 prIndex)
{
    guint8 idx = 10;

    base[idx++] = prIndex;
    return idx;
}

static inline ucd_snmp_mib_prEntry_t *
assign_prEntry(GSList *vbl)
{
    ucd_snmp_mib_prEntry_t *prEntry;
    char *p;

    prEntry = ucd_snmp_mib_new_prEntry();
    if (! prEntry) {
        return NULL;
    }

    p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prEntry((GSnmpVarBind *) vbl->data, prEntry) < 0) {
        g_warning("%s: invalid instance identifier", "prEntry");
        g_free(prEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, prEntry_oid, sizeof(prEntry_oid)/sizeof(guint32),
                      prEntry_attr, prEntry);

    return prEntry;
}

void
ucd_snmp_mib_get_prTable(GSnmpSession *s, ucd_snmp_mib_prEntry_t ***prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1, 0};

    *prEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, prEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prEntry = (ucd_snmp_mib_prEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_prEntry_t *));
        if (! *prEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prEntry)[i] = assign_prEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t **prEntry, gint32 prIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, prEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prEntry = assign_prEntry(out);
    }
}

void
ucd_snmp_mib_set_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t *prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prEntry->prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, prEntry_attr, mask, prEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_prEntry(ucd_snmp_mib_prEntry_t *prEntry)
{
    GSList *vbl;
    char *p;

    if (prEntry) {
        p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_free_prTable(ucd_snmp_mib_prEntry_t **prEntry)
{
    int i;

    if (prEntry) {
        for (i = 0; prEntry[i]; i++) {
            ucd_snmp_mib_free_prEntry(prEntry[i]);
        }
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_set_prErrFix(GSnmpSession *s, gint32 prIndex, gint32 prErrFix)
{
    ucd_snmp_mib_prEntry_t *prEntry;

    ucd_snmp_mib_get_prEntry(s, &prEntry, prIndex, UCD_SNMP_MIB_PRERRFIX);
    if (s->error_status || !prEntry) return;
    prEntry->prErrFix = &prErrFix;
    ucd_snmp_mib_set_prEntry(s, prEntry, UCD_SNMP_MIB_PRERRFIX);
    ucd_snmp_mib_free_prEntry(prEntry);
}

ucd_snmp_mib_extEntry_t *
ucd_snmp_mib_new_extEntry()
{
    ucd_snmp_mib_extEntry_t *extEntry;

    extEntry = (ucd_snmp_mib_extEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_extEntry_t) + sizeof(gpointer));
    return extEntry;
}

static inline int
unpack_extEntry(GSnmpVarBind *vb, ucd_snmp_mib_extEntry_t *extEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    extEntry->extIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static inline gint8
pack_extEntry(guint32 *base, gint32 extIndex)
{
    guint8 idx = 10;

    base[idx++] = extIndex;
    return idx;
}

static inline ucd_snmp_mib_extEntry_t *
assign_extEntry(GSList *vbl)
{
    ucd_snmp_mib_extEntry_t *extEntry;
    char *p;

    extEntry = ucd_snmp_mib_new_extEntry();
    if (! extEntry) {
        return NULL;
    }

    p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
    * (GSList **) p = vbl;

    if (unpack_extEntry((GSnmpVarBind *) vbl->data, extEntry) < 0) {
        g_warning("%s: invalid instance identifier", "extEntry");
        g_free(extEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, extEntry_oid, sizeof(extEntry_oid)/sizeof(guint32),
                      extEntry_attr, extEntry);

    return extEntry;
}

void
ucd_snmp_mib_get_extTable(GSnmpSession *s, ucd_snmp_mib_extEntry_t ***extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1, 0};

    *extEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, extEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *extEntry = (ucd_snmp_mib_extEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_extEntry_t *));
        if (! *extEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*extEntry)[i] = assign_extEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t **extEntry, gint32 extIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *extEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, extEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *extEntry = assign_extEntry(out);
    }
}

void
ucd_snmp_mib_set_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t *extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extEntry->extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, extEntry_attr, mask, extEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_extEntry(ucd_snmp_mib_extEntry_t *extEntry)
{
    GSList *vbl;
    char *p;

    if (extEntry) {
        p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_free_extTable(ucd_snmp_mib_extEntry_t **extEntry)
{
    int i;

    if (extEntry) {
        for (i = 0; extEntry[i]; i++) {
            ucd_snmp_mib_free_extEntry(extEntry[i]);
        }
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_set_extErrFix(GSnmpSession *s, gint32 extIndex, gint32 extErrFix)
{
    ucd_snmp_mib_extEntry_t *extEntry;

    ucd_snmp_mib_get_extEntry(s, &extEntry, extIndex, UCD_SNMP_MIB_EXTERRFIX);
    if (s->error_status || !extEntry) return;
    extEntry->extErrFix = &extErrFix;
    ucd_snmp_mib_set_extEntry(s, extEntry, UCD_SNMP_MIB_EXTERRFIX);
    ucd_snmp_mib_free_extEntry(extEntry);
}

ucd_snmp_mib_laEntry_t *
ucd_snmp_mib_new_laEntry()
{
    ucd_snmp_mib_laEntry_t *laEntry;

    laEntry = (ucd_snmp_mib_laEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_laEntry_t) + sizeof(gpointer));
    return laEntry;
}

static inline int
unpack_laEntry(GSnmpVarBind *vb, ucd_snmp_mib_laEntry_t *laEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    laEntry->laIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static inline gint8
pack_laEntry(guint32 *base, gint32 laIndex)
{
    guint8 idx = 10;

    base[idx++] = laIndex;
    return idx;
}

static inline ucd_snmp_mib_laEntry_t *
assign_laEntry(GSList *vbl)
{
    ucd_snmp_mib_laEntry_t *laEntry;
    char *p;

    laEntry = ucd_snmp_mib_new_laEntry();
    if (! laEntry) {
        return NULL;
    }

    p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
    * (GSList **) p = vbl;

    if (unpack_laEntry((GSnmpVarBind *) vbl->data, laEntry) < 0) {
        g_warning("%s: invalid instance identifier", "laEntry");
        g_free(laEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, laEntry_oid, sizeof(laEntry_oid)/sizeof(guint32),
                      laEntry_attr, laEntry);

    return laEntry;
}

void
ucd_snmp_mib_get_laTable(GSnmpSession *s, ucd_snmp_mib_laEntry_t ***laEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1, 0};

    *laEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, laEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *laEntry = (ucd_snmp_mib_laEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_laEntry_t *));
        if (! *laEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*laEntry)[i] = assign_laEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_laEntry(GSnmpSession *s, ucd_snmp_mib_laEntry_t **laEntry, gint32 laIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, laEntry_oid, sizeof(laEntry_oid));
    len = pack_laEntry(base, laIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "laEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *laEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, laEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *laEntry = assign_laEntry(out);
    }
}

void
ucd_snmp_mib_free_laEntry(ucd_snmp_mib_laEntry_t *laEntry)
{
    GSList *vbl;
    char *p;

    if (laEntry) {
        p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(laEntry);
    }
}

void
ucd_snmp_mib_free_laTable(ucd_snmp_mib_laEntry_t **laEntry)
{
    int i;

    if (laEntry) {
        for (i = 0; laEntry[i]; i++) {
            ucd_snmp_mib_free_laEntry(laEntry[i]);
        }
        g_free(laEntry);
    }
}

ucd_snmp_mib_version_t *
ucd_snmp_mib_new_version()
{
    ucd_snmp_mib_version_t *version;

    version = (ucd_snmp_mib_version_t *) g_malloc0(sizeof(ucd_snmp_mib_version_t) + sizeof(gpointer));
    return version;
}

static inline ucd_snmp_mib_version_t *
assign_version(GSList *vbl)
{
    ucd_snmp_mib_version_t *version;
    char *p;

    version = ucd_snmp_mib_new_version();
    if (! version) {
        return NULL;
    }

    p = (char *) version + sizeof(ucd_snmp_mib_version_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, version_oid, sizeof(version_oid)/sizeof(guint32),
                      version_attr, version);

    return version;
}

void
ucd_snmp_mib_get_version(GSnmpSession *s, ucd_snmp_mib_version_t **version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0};

    *version = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, version_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *version = assign_version(out);
    }
}

void
ucd_snmp_mib_set_version(GSnmpSession *s, ucd_snmp_mib_version_t *version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0, 0};

    gsnmp_attr_set(s, &in, base, 10, 8, version_attr, mask, version);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_version(ucd_snmp_mib_version_t *version)
{
    GSList *vbl;
    char *p;

    if (version) {
        p = (char *) version + sizeof(ucd_snmp_mib_version_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(version);
    }
}

void
ucd_snmp_mib_set_versionClearCache(GSnmpSession *s, gint32 versionClearCache)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONCLEARCACHE);
    if (s->error_status || !version) return;
    version->versionClearCache = &versionClearCache;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONCLEARCACHE);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionUpdateConfig(GSnmpSession *s, gint32 versionUpdateConfig)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONUPDATECONFIG);
    if (s->error_status || !version) return;
    version->versionUpdateConfig = &versionUpdateConfig;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONUPDATECONFIG);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionRestartAgent(GSnmpSession *s, gint32 versionRestartAgent)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONRESTARTAGENT);
    if (s->error_status || !version) return;
    version->versionRestartAgent = &versionRestartAgent;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONRESTARTAGENT);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionDoDebugging(GSnmpSession *s, gint32 versionDoDebugging)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONDODEBUGGING);
    if (s->error_status || !version) return;
    version->versionDoDebugging = &versionDoDebugging;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONDODEBUGGING);
    ucd_snmp_mib_free_version(version);
}


