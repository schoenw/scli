/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from UCD-SNMP-MIB:
 *   This file defines the private UCD SNMP MIB extensions.
 *
 * Revision 2001-01-17 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 2002-01-04 00:00:
 *   Introduced LongDisplayString which is needed for allow
 *   for long configuration settings. Rewrote some definitions
 *   to make them more precise.
 *
 * Revision 2001-01-17 00:00:
 *   Added raw CPU and IO counters.
 *
 * Revision 1999-12-09 00:00:
 *   SMIv2 version converted from older MIB definitions.
 *
 * $Id$
 */

#include "ucd-snmp-mib.h"

GSnmpEnum const ucd_snmp_mib_enums_prErrorFlag[] = {
    { UCD_SNMP_MIB_PRERRORFLAG_OK,	"ok" },
    { UCD_SNMP_MIB_PRERRORFLAG_ERROR,	"error" },
    { 0, NULL }
};

GSnmpEnum const ucd_snmp_mib_enums_fileErrorFlag[] = {
    { UCD_SNMP_MIB_FILEERRORFLAG_TRUE,	"true" },
    { UCD_SNMP_MIB_FILEERRORFLAG_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ucd_snmp_mib_enums_versionDoDebugging[] = {
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_DISABLED,	"disabled" },
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_ENABLED,	"enabled" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_prEntry[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1};

static attribute_t attr_prEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_PRNAMES, "prNames" },
    { 3, G_SNMP_INTEGER32, UCD_SNMP_MIB_PRMIN, "prMin" },
    { 4, G_SNMP_INTEGER32, UCD_SNMP_MIB_PRMAX, "prMax" },
    { 5, G_SNMP_INTEGER32, UCD_SNMP_MIB_PRCOUNT, "prCount" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_PRERRORFLAG, "prErrorFlag" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_PRERRMESSAGE, "prErrMessage" },
    { 102, G_SNMP_INTEGER32, UCD_SNMP_MIB_PRERRFIX, "prErrFix" },
    { 103, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_PRERRFIXCMD, "prErrFixCmd" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_memory[] = {1, 3, 6, 1, 4, 1, 2021, 4};

static attribute_t attr_memory[] = {
    { 1, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMINDEX, "memIndex" },
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_MEMERRORNAME, "memErrorName" },
    { 3, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMTOTALSWAP, "memTotalSwap" },
    { 4, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMAVAILSWAP, "memAvailSwap" },
    { 5, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMTOTALREAL, "memTotalReal" },
    { 6, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMAVAILREAL, "memAvailReal" },
    { 7, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMTOTALSWAPTXT, "memTotalSwapTXT" },
    { 8, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMAVAILSWAPTXT, "memAvailSwapTXT" },
    { 9, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMTOTALREALTXT, "memTotalRealTXT" },
    { 10, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMAVAILREALTXT, "memAvailRealTXT" },
    { 11, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMTOTALFREE, "memTotalFree" },
    { 12, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMMINIMUMSWAP, "memMinimumSwap" },
    { 13, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMSHARED, "memShared" },
    { 14, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMBUFFER, "memBuffer" },
    { 15, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMCACHED, "memCached" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_MEMSWAPERROR, "memSwapError" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_MEMSWAPERRORMSG, "memSwapErrorMsg" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_extEntry[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1};

static attribute_t attr_extEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_EXTNAMES, "extNames" },
    { 3, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_EXTCOMMAND, "extCommand" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_EXTRESULT, "extResult" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_EXTOUTPUT, "extOutput" },
    { 102, G_SNMP_INTEGER32, UCD_SNMP_MIB_EXTERRFIX, "extErrFix" },
    { 103, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_EXTERRFIXCMD, "extErrFixCmd" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_dskEntry[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1};

static attribute_t attr_dskEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_DSKPATH, "dskPath" },
    { 3, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_DSKDEVICE, "dskDevice" },
    { 4, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKMINIMUM, "dskMinimum" },
    { 5, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKMINPERCENT, "dskMinPercent" },
    { 6, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKTOTAL, "dskTotal" },
    { 7, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKAVAIL, "dskAvail" },
    { 8, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKUSED, "dskUsed" },
    { 9, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKPERCENT, "dskPercent" },
    { 10, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKPERCENTNODE, "dskPercentNode" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_DSKERRORFLAG, "dskErrorFlag" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_DSKERRORMSG, "dskErrorMsg" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_laEntry[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1};

static attribute_t attr_laEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_LANAMES, "laNames" },
    { 3, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_LALOAD, "laLoad" },
    { 4, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_LACONFIG, "laConfig" },
    { 5, G_SNMP_INTEGER32, UCD_SNMP_MIB_LALOADINT, "laLoadInt" },
    { 6, G_SNMP_OPAQUE, UCD_SNMP_MIB_LALOADFLOAT, "laLoadFloat" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_LAERRORFLAG, "laErrorFlag" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_LAERRMESSAGE, "laErrMessage" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_systemStats[] = {1, 3, 6, 1, 4, 1, 2021, 11};

static attribute_t attr_systemStats[] = {
    { 1, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSINDEX, "ssIndex" },
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_SSERRORNAME, "ssErrorName" },
    { 3, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSSWAPIN, "ssSwapIn" },
    { 4, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSSWAPOUT, "ssSwapOut" },
    { 5, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSIOSENT, "ssIOSent" },
    { 6, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSIORECEIVE, "ssIOReceive" },
    { 7, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSSYSINTERRUPTS, "ssSysInterrupts" },
    { 8, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSSYSCONTEXT, "ssSysContext" },
    { 9, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSCPUUSER, "ssCpuUser" },
    { 10, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSCPUSYSTEM, "ssCpuSystem" },
    { 11, G_SNMP_INTEGER32, UCD_SNMP_MIB_SSCPUIDLE, "ssCpuIdle" },
    { 50, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWUSER, "ssCpuRawUser" },
    { 51, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWNICE, "ssCpuRawNice" },
    { 52, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWSYSTEM, "ssCpuRawSystem" },
    { 53, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWIDLE, "ssCpuRawIdle" },
    { 54, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWWAIT, "ssCpuRawWait" },
    { 55, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWKERNEL, "ssCpuRawKernel" },
    { 56, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSCPURAWINTERRUPT, "ssCpuRawInterrupt" },
    { 57, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSIORAWSENT, "ssIORawSent" },
    { 58, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSIORAWRECEIVED, "ssIORawReceived" },
    { 59, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSRAWINTERRUPTS, "ssRawInterrupts" },
    { 60, G_SNMP_COUNTER32, UCD_SNMP_MIB_SSRAWCONTEXTS, "ssRawContexts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_fileEntry[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1};

static attribute_t attr_fileEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_FILENAME, "fileName" },
    { 3, G_SNMP_INTEGER32, UCD_SNMP_MIB_FILESIZE, "fileSize" },
    { 4, G_SNMP_INTEGER32, UCD_SNMP_MIB_FILEMAX, "fileMax" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_FILEERRORFLAG, "fileErrorFlag" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_FILEERRORMSG, "fileErrorMsg" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_version[] = {1, 3, 6, 1, 4, 1, 2021, 100};

static attribute_t attr_version[] = {
    { 1, G_SNMP_INTEGER32, UCD_SNMP_MIB_VERSIONINDEX, "versionIndex" },
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_VERSIONTAG, "versionTag" },
    { 3, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_VERSIONDATE, "versionDate" },
    { 4, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_VERSIONCDATE, "versionCDate" },
    { 5, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_VERSIONIDENT, "versionIdent" },
    { 6, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_VERSIONCONFIGUREOPTIONS, "versionConfigureOptions" },
    { 10, G_SNMP_INTEGER32, UCD_SNMP_MIB_VERSIONCLEARCACHE, "versionClearCache" },
    { 11, G_SNMP_INTEGER32, UCD_SNMP_MIB_VERSIONUPDATECONFIG, "versionUpdateConfig" },
    { 12, G_SNMP_INTEGER32, UCD_SNMP_MIB_VERSIONRESTARTAGENT, "versionRestartAgent" },
    { 20, G_SNMP_INTEGER32, UCD_SNMP_MIB_VERSIONDODEBUGGING, "versionDoDebugging" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_snmperrs[] = {1, 3, 6, 1, 4, 1, 2021, 101};

static attribute_t attr_snmperrs[] = {
    { 1, G_SNMP_INTEGER32, UCD_SNMP_MIB_SNMPERRINDEX, "snmperrIndex" },
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_SNMPERRNAMES, "snmperrNames" },
    { 100, G_SNMP_INTEGER32, UCD_SNMP_MIB_SNMPERRERRORFLAG, "snmperrErrorFlag" },
    { 101, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_SNMPERRERRMESSAGE, "snmperrErrMessage" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_mrEntry[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1};

static attribute_t attr_mrEntry[] = {
    { 2, G_SNMP_OCTETSTRING, UCD_SNMP_MIB_MRMODULENAME, "mrModuleName" },
    { 0, 0, 0, NULL }
};


ucd_snmp_mib_prEntry_t *
ucd_snmp_mib_new_prEntry()
{
    ucd_snmp_mib_prEntry_t *prEntry;

    prEntry = (ucd_snmp_mib_prEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_prEntry_t) + sizeof(gpointer));
    return prEntry;
}

static int
unpack_prEntry(GSnmpVarBind *vb, ucd_snmp_mib_prEntry_t *prEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    prEntry->prIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prEntry(guint32 *base, gint32 prIndex)
{
    int idx = 10;

    base[idx++] = prIndex;
    return idx;
}

static ucd_snmp_mib_prEntry_t *
assign_prEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_prEntry_t *prEntry;
    guint32 idx;
    char *p;

    prEntry = ucd_snmp_mib_new_prEntry();
    if (! prEntry) {
        return NULL;
    }

    p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prEntry((GSnmpVarBind *) vbl->data, prEntry) < 0) {
        g_warning("illegal prEntry instance identifier");
        g_free(prEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prEntry, sizeof(oid_prEntry)/sizeof(guint32),
                   attr_prEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            prEntry->_prNamesLength = vb->syntax_len;
            prEntry->prNames = vb->syntax.uc;
            break;
        case 3:
            prEntry->prMin = &(vb->syntax.i32[0]);
            break;
        case 4:
            prEntry->prMax = &(vb->syntax.i32[0]);
            break;
        case 5:
            prEntry->prCount = &(vb->syntax.i32[0]);
            break;
        case 100:
            prEntry->prErrorFlag = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            prEntry->_prErrMessageLength = vb->syntax_len;
            prEntry->prErrMessage = vb->syntax.uc;
            break;
        case 102:
            prEntry->prErrFix = &(vb->syntax.i32[0]);
            break;
        case 103:
            if (vb->syntax_len > 255) break;
            prEntry->_prErrFixCmdLength = vb->syntax_len;
            prEntry->prErrFixCmd = vb->syntax.uc;
            break;
        };
    }

    return prEntry;
}

void
ucd_snmp_mib_get_prTable(GSnmpSession *s, ucd_snmp_mib_prEntry_t ***prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1, 0};

    *prEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_prEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prEntry = (ucd_snmp_mib_prEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_prEntry_t *));
        if (! *prEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prEntry)[i] = assign_prEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t **prEntry, gint32 prIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prEntry, sizeof(oid_prEntry));
    len = pack_prEntry(base, prIndex);
    if (len < 0) {
        g_warning("illegal prEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_prEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prEntry = assign_prEntry(out);
    }
}

void
ucd_snmp_mib_set_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t *prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prEntry, sizeof(oid_prEntry));
    len = pack_prEntry(base, prEntry->prIndex);
    if (len < 0) {
        g_warning("illegal prEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prEntry->prErrFix) {
        base[9] = 102;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prEntry->prErrFix,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_prEntry(ucd_snmp_mib_prEntry_t *prEntry)
{
    GSList *vbl;
    char *p;

    if (prEntry) {
        p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_free_prTable(ucd_snmp_mib_prEntry_t **prEntry)
{
    int i;

    if (prEntry) {
        for (i = 0; prEntry[i]; i++) {
            ucd_snmp_mib_free_prEntry(prEntry[i]);
        }
        g_free(prEntry);
    }
}

ucd_snmp_mib_memory_t *
ucd_snmp_mib_new_memory()
{
    ucd_snmp_mib_memory_t *memory;

    memory = (ucd_snmp_mib_memory_t *) g_malloc0(sizeof(ucd_snmp_mib_memory_t) + sizeof(gpointer));
    return memory;
}

static ucd_snmp_mib_memory_t *
assign_memory(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_memory_t *memory;
    guint32 idx;
    char *p;

    memory = ucd_snmp_mib_new_memory();
    if (! memory) {
        return NULL;
    }

    p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_memory, sizeof(oid_memory)/sizeof(guint32),
                   attr_memory, &idx) < 0) continue;

        switch (idx) {
        case 1:
            memory->memIndex = &(vb->syntax.i32[0]);
            break;
        case 2:
            if (vb->syntax_len > 255) break;
            memory->_memErrorNameLength = vb->syntax_len;
            memory->memErrorName = vb->syntax.uc;
            break;
        case 3:
            memory->memTotalSwap = &(vb->syntax.i32[0]);
            break;
        case 4:
            memory->memAvailSwap = &(vb->syntax.i32[0]);
            break;
        case 5:
            memory->memTotalReal = &(vb->syntax.i32[0]);
            break;
        case 6:
            memory->memAvailReal = &(vb->syntax.i32[0]);
            break;
        case 7:
            memory->memTotalSwapTXT = &(vb->syntax.i32[0]);
            break;
        case 8:
            memory->memAvailSwapTXT = &(vb->syntax.i32[0]);
            break;
        case 9:
            memory->memTotalRealTXT = &(vb->syntax.i32[0]);
            break;
        case 10:
            memory->memAvailRealTXT = &(vb->syntax.i32[0]);
            break;
        case 11:
            memory->memTotalFree = &(vb->syntax.i32[0]);
            break;
        case 12:
            memory->memMinimumSwap = &(vb->syntax.i32[0]);
            break;
        case 13:
            memory->memShared = &(vb->syntax.i32[0]);
            break;
        case 14:
            memory->memBuffer = &(vb->syntax.i32[0]);
            break;
        case 15:
            memory->memCached = &(vb->syntax.i32[0]);
            break;
        case 100:
            memory->memSwapError = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            memory->_memSwapErrorMsgLength = vb->syntax_len;
            memory->memSwapErrorMsg = vb->syntax.uc;
            break;
        };
    }

    return memory;
}

void
ucd_snmp_mib_get_memory(GSnmpSession *s, ucd_snmp_mib_memory_t **memory, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 4, 0};

    *memory = NULL;

    add_attributes(s, &in, base, 9, 8, attr_memory, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *memory = assign_memory(out);
    }
}

void
ucd_snmp_mib_free_memory(ucd_snmp_mib_memory_t *memory)
{
    GSList *vbl;
    char *p;

    if (memory) {
        p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(memory);
    }
}

ucd_snmp_mib_extEntry_t *
ucd_snmp_mib_new_extEntry()
{
    ucd_snmp_mib_extEntry_t *extEntry;

    extEntry = (ucd_snmp_mib_extEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_extEntry_t) + sizeof(gpointer));
    return extEntry;
}

static int
unpack_extEntry(GSnmpVarBind *vb, ucd_snmp_mib_extEntry_t *extEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    extEntry->extIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_extEntry(guint32 *base, gint32 extIndex)
{
    int idx = 10;

    base[idx++] = extIndex;
    return idx;
}

static ucd_snmp_mib_extEntry_t *
assign_extEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_extEntry_t *extEntry;
    guint32 idx;
    char *p;

    extEntry = ucd_snmp_mib_new_extEntry();
    if (! extEntry) {
        return NULL;
    }

    p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
    * (GSList **) p = vbl;

    if (unpack_extEntry((GSnmpVarBind *) vbl->data, extEntry) < 0) {
        g_warning("illegal extEntry instance identifier");
        g_free(extEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_extEntry, sizeof(oid_extEntry)/sizeof(guint32),
                   attr_extEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            extEntry->_extNamesLength = vb->syntax_len;
            extEntry->extNames = vb->syntax.uc;
            break;
        case 3:
            if (vb->syntax_len > 255) break;
            extEntry->_extCommandLength = vb->syntax_len;
            extEntry->extCommand = vb->syntax.uc;
            break;
        case 100:
            extEntry->extResult = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            extEntry->_extOutputLength = vb->syntax_len;
            extEntry->extOutput = vb->syntax.uc;
            break;
        case 102:
            extEntry->extErrFix = &(vb->syntax.i32[0]);
            break;
        case 103:
            if (vb->syntax_len > 255) break;
            extEntry->_extErrFixCmdLength = vb->syntax_len;
            extEntry->extErrFixCmd = vb->syntax.uc;
            break;
        };
    }

    return extEntry;
}

void
ucd_snmp_mib_get_extTable(GSnmpSession *s, ucd_snmp_mib_extEntry_t ***extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1, 0};

    *extEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_extEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *extEntry = (ucd_snmp_mib_extEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_extEntry_t *));
        if (! *extEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*extEntry)[i] = assign_extEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t **extEntry, gint32 extIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_extEntry, sizeof(oid_extEntry));
    len = pack_extEntry(base, extIndex);
    if (len < 0) {
        g_warning("illegal extEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *extEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_extEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *extEntry = assign_extEntry(out);
    }
}

void
ucd_snmp_mib_set_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t *extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_extEntry, sizeof(oid_extEntry));
    len = pack_extEntry(base, extEntry->extIndex);
    if (len < 0) {
        g_warning("illegal extEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (extEntry->extErrFix) {
        base[9] = 102;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       extEntry->extErrFix,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_extEntry(ucd_snmp_mib_extEntry_t *extEntry)
{
    GSList *vbl;
    char *p;

    if (extEntry) {
        p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_free_extTable(ucd_snmp_mib_extEntry_t **extEntry)
{
    int i;

    if (extEntry) {
        for (i = 0; extEntry[i]; i++) {
            ucd_snmp_mib_free_extEntry(extEntry[i]);
        }
        g_free(extEntry);
    }
}

ucd_snmp_mib_dskEntry_t *
ucd_snmp_mib_new_dskEntry()
{
    ucd_snmp_mib_dskEntry_t *dskEntry;

    dskEntry = (ucd_snmp_mib_dskEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_dskEntry_t) + sizeof(gpointer));
    return dskEntry;
}

static int
unpack_dskEntry(GSnmpVarBind *vb, ucd_snmp_mib_dskEntry_t *dskEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    dskEntry->dskIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_dskEntry(guint32 *base, gint32 dskIndex)
{
    int idx = 10;

    base[idx++] = dskIndex;
    return idx;
}

static ucd_snmp_mib_dskEntry_t *
assign_dskEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_dskEntry_t *dskEntry;
    guint32 idx;
    char *p;

    dskEntry = ucd_snmp_mib_new_dskEntry();
    if (! dskEntry) {
        return NULL;
    }

    p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
    * (GSList **) p = vbl;

    if (unpack_dskEntry((GSnmpVarBind *) vbl->data, dskEntry) < 0) {
        g_warning("illegal dskEntry instance identifier");
        g_free(dskEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_dskEntry, sizeof(oid_dskEntry)/sizeof(guint32),
                   attr_dskEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            dskEntry->_dskPathLength = vb->syntax_len;
            dskEntry->dskPath = vb->syntax.uc;
            break;
        case 3:
            if (vb->syntax_len > 255) break;
            dskEntry->_dskDeviceLength = vb->syntax_len;
            dskEntry->dskDevice = vb->syntax.uc;
            break;
        case 4:
            dskEntry->dskMinimum = &(vb->syntax.i32[0]);
            break;
        case 5:
            dskEntry->dskMinPercent = &(vb->syntax.i32[0]);
            break;
        case 6:
            dskEntry->dskTotal = &(vb->syntax.i32[0]);
            break;
        case 7:
            dskEntry->dskAvail = &(vb->syntax.i32[0]);
            break;
        case 8:
            dskEntry->dskUsed = &(vb->syntax.i32[0]);
            break;
        case 9:
            dskEntry->dskPercent = &(vb->syntax.i32[0]);
            break;
        case 10:
            dskEntry->dskPercentNode = &(vb->syntax.i32[0]);
            break;
        case 100:
            dskEntry->dskErrorFlag = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            dskEntry->_dskErrorMsgLength = vb->syntax_len;
            dskEntry->dskErrorMsg = vb->syntax.uc;
            break;
        };
    }

    return dskEntry;
}

void
ucd_snmp_mib_get_dskTable(GSnmpSession *s, ucd_snmp_mib_dskEntry_t ***dskEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1, 0};

    *dskEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_dskEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *dskEntry = (ucd_snmp_mib_dskEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_dskEntry_t *));
        if (! *dskEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*dskEntry)[i] = assign_dskEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_dskEntry(GSnmpSession *s, ucd_snmp_mib_dskEntry_t **dskEntry, gint32 dskIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_dskEntry, sizeof(oid_dskEntry));
    len = pack_dskEntry(base, dskIndex);
    if (len < 0) {
        g_warning("illegal dskEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *dskEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_dskEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *dskEntry = assign_dskEntry(out);
    }
}

void
ucd_snmp_mib_free_dskEntry(ucd_snmp_mib_dskEntry_t *dskEntry)
{
    GSList *vbl;
    char *p;

    if (dskEntry) {
        p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(dskEntry);
    }
}

void
ucd_snmp_mib_free_dskTable(ucd_snmp_mib_dskEntry_t **dskEntry)
{
    int i;

    if (dskEntry) {
        for (i = 0; dskEntry[i]; i++) {
            ucd_snmp_mib_free_dskEntry(dskEntry[i]);
        }
        g_free(dskEntry);
    }
}

ucd_snmp_mib_laEntry_t *
ucd_snmp_mib_new_laEntry()
{
    ucd_snmp_mib_laEntry_t *laEntry;

    laEntry = (ucd_snmp_mib_laEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_laEntry_t) + sizeof(gpointer));
    return laEntry;
}

static int
unpack_laEntry(GSnmpVarBind *vb, ucd_snmp_mib_laEntry_t *laEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    laEntry->laIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_laEntry(guint32 *base, gint32 laIndex)
{
    int idx = 10;

    base[idx++] = laIndex;
    return idx;
}

static ucd_snmp_mib_laEntry_t *
assign_laEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_laEntry_t *laEntry;
    guint32 idx;
    char *p;

    laEntry = ucd_snmp_mib_new_laEntry();
    if (! laEntry) {
        return NULL;
    }

    p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
    * (GSList **) p = vbl;

    if (unpack_laEntry((GSnmpVarBind *) vbl->data, laEntry) < 0) {
        g_warning("illegal laEntry instance identifier");
        g_free(laEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_laEntry, sizeof(oid_laEntry)/sizeof(guint32),
                   attr_laEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            laEntry->_laNamesLength = vb->syntax_len;
            laEntry->laNames = vb->syntax.uc;
            break;
        case 3:
            if (vb->syntax_len > 255) break;
            laEntry->_laLoadLength = vb->syntax_len;
            laEntry->laLoad = vb->syntax.uc;
            break;
        case 4:
            if (vb->syntax_len > 255) break;
            laEntry->_laConfigLength = vb->syntax_len;
            laEntry->laConfig = vb->syntax.uc;
            break;
        case 5:
            laEntry->laLoadInt = &(vb->syntax.i32[0]);
            break;
        case 6:
            if (vb->syntax_len != 7) break;
            laEntry->laLoadFloat = vb->syntax.uc;
            break;
        case 100:
            laEntry->laErrorFlag = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            laEntry->_laErrMessageLength = vb->syntax_len;
            laEntry->laErrMessage = vb->syntax.uc;
            break;
        };
    }

    return laEntry;
}

void
ucd_snmp_mib_get_laTable(GSnmpSession *s, ucd_snmp_mib_laEntry_t ***laEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1, 0};

    *laEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_laEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *laEntry = (ucd_snmp_mib_laEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_laEntry_t *));
        if (! *laEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*laEntry)[i] = assign_laEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_laEntry(GSnmpSession *s, ucd_snmp_mib_laEntry_t **laEntry, gint32 laIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_laEntry, sizeof(oid_laEntry));
    len = pack_laEntry(base, laIndex);
    if (len < 0) {
        g_warning("illegal laEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *laEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_laEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *laEntry = assign_laEntry(out);
    }
}

void
ucd_snmp_mib_free_laEntry(ucd_snmp_mib_laEntry_t *laEntry)
{
    GSList *vbl;
    char *p;

    if (laEntry) {
        p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(laEntry);
    }
}

void
ucd_snmp_mib_free_laTable(ucd_snmp_mib_laEntry_t **laEntry)
{
    int i;

    if (laEntry) {
        for (i = 0; laEntry[i]; i++) {
            ucd_snmp_mib_free_laEntry(laEntry[i]);
        }
        g_free(laEntry);
    }
}

ucd_snmp_mib_systemStats_t *
ucd_snmp_mib_new_systemStats()
{
    ucd_snmp_mib_systemStats_t *systemStats;

    systemStats = (ucd_snmp_mib_systemStats_t *) g_malloc0(sizeof(ucd_snmp_mib_systemStats_t) + sizeof(gpointer));
    return systemStats;
}

static ucd_snmp_mib_systemStats_t *
assign_systemStats(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_systemStats_t *systemStats;
    guint32 idx;
    char *p;

    systemStats = ucd_snmp_mib_new_systemStats();
    if (! systemStats) {
        return NULL;
    }

    p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_systemStats, sizeof(oid_systemStats)/sizeof(guint32),
                   attr_systemStats, &idx) < 0) continue;

        switch (idx) {
        case 1:
            systemStats->ssIndex = &(vb->syntax.i32[0]);
            break;
        case 2:
            if (vb->syntax_len > 255) break;
            systemStats->_ssErrorNameLength = vb->syntax_len;
            systemStats->ssErrorName = vb->syntax.uc;
            break;
        case 3:
            systemStats->ssSwapIn = &(vb->syntax.i32[0]);
            break;
        case 4:
            systemStats->ssSwapOut = &(vb->syntax.i32[0]);
            break;
        case 5:
            systemStats->ssIOSent = &(vb->syntax.i32[0]);
            break;
        case 6:
            systemStats->ssIOReceive = &(vb->syntax.i32[0]);
            break;
        case 7:
            systemStats->ssSysInterrupts = &(vb->syntax.i32[0]);
            break;
        case 8:
            systemStats->ssSysContext = &(vb->syntax.i32[0]);
            break;
        case 9:
            systemStats->ssCpuUser = &(vb->syntax.i32[0]);
            break;
        case 10:
            systemStats->ssCpuSystem = &(vb->syntax.i32[0]);
            break;
        case 11:
            systemStats->ssCpuIdle = &(vb->syntax.i32[0]);
            break;
        case 50:
            systemStats->ssCpuRawUser = &(vb->syntax.ui32[0]);
            break;
        case 51:
            systemStats->ssCpuRawNice = &(vb->syntax.ui32[0]);
            break;
        case 52:
            systemStats->ssCpuRawSystem = &(vb->syntax.ui32[0]);
            break;
        case 53:
            systemStats->ssCpuRawIdle = &(vb->syntax.ui32[0]);
            break;
        case 54:
            systemStats->ssCpuRawWait = &(vb->syntax.ui32[0]);
            break;
        case 55:
            systemStats->ssCpuRawKernel = &(vb->syntax.ui32[0]);
            break;
        case 56:
            systemStats->ssCpuRawInterrupt = &(vb->syntax.ui32[0]);
            break;
        case 57:
            systemStats->ssIORawSent = &(vb->syntax.ui32[0]);
            break;
        case 58:
            systemStats->ssIORawReceived = &(vb->syntax.ui32[0]);
            break;
        case 59:
            systemStats->ssRawInterrupts = &(vb->syntax.ui32[0]);
            break;
        case 60:
            systemStats->ssRawContexts = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return systemStats;
}

void
ucd_snmp_mib_get_systemStats(GSnmpSession *s, ucd_snmp_mib_systemStats_t **systemStats, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 11, 0};

    *systemStats = NULL;

    add_attributes(s, &in, base, 9, 8, attr_systemStats, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *systemStats = assign_systemStats(out);
    }
}

void
ucd_snmp_mib_free_systemStats(ucd_snmp_mib_systemStats_t *systemStats)
{
    GSList *vbl;
    char *p;

    if (systemStats) {
        p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(systemStats);
    }
}

ucd_snmp_mib_fileEntry_t *
ucd_snmp_mib_new_fileEntry()
{
    ucd_snmp_mib_fileEntry_t *fileEntry;

    fileEntry = (ucd_snmp_mib_fileEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_fileEntry_t) + sizeof(gpointer));
    return fileEntry;
}

static int
unpack_fileEntry(GSnmpVarBind *vb, ucd_snmp_mib_fileEntry_t *fileEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    fileEntry->fileIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_fileEntry(guint32 *base, gint32 fileIndex)
{
    int idx = 10;

    base[idx++] = fileIndex;
    return idx;
}

static ucd_snmp_mib_fileEntry_t *
assign_fileEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_fileEntry_t *fileEntry;
    guint32 idx;
    char *p;

    fileEntry = ucd_snmp_mib_new_fileEntry();
    if (! fileEntry) {
        return NULL;
    }

    p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
    * (GSList **) p = vbl;

    if (unpack_fileEntry((GSnmpVarBind *) vbl->data, fileEntry) < 0) {
        g_warning("illegal fileEntry instance identifier");
        g_free(fileEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_fileEntry, sizeof(oid_fileEntry)/sizeof(guint32),
                   attr_fileEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            fileEntry->_fileNameLength = vb->syntax_len;
            fileEntry->fileName = vb->syntax.uc;
            break;
        case 3:
            fileEntry->fileSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            fileEntry->fileMax = &(vb->syntax.i32[0]);
            break;
        case 100:
            fileEntry->fileErrorFlag = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            fileEntry->_fileErrorMsgLength = vb->syntax_len;
            fileEntry->fileErrorMsg = vb->syntax.uc;
            break;
        };
    }

    return fileEntry;
}

void
ucd_snmp_mib_get_fileTable(GSnmpSession *s, ucd_snmp_mib_fileEntry_t ***fileEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1, 0};

    *fileEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_fileEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *fileEntry = (ucd_snmp_mib_fileEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_fileEntry_t *));
        if (! *fileEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*fileEntry)[i] = assign_fileEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_fileEntry(GSnmpSession *s, ucd_snmp_mib_fileEntry_t **fileEntry, gint32 fileIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_fileEntry, sizeof(oid_fileEntry));
    len = pack_fileEntry(base, fileIndex);
    if (len < 0) {
        g_warning("illegal fileEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *fileEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_fileEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *fileEntry = assign_fileEntry(out);
    }
}

void
ucd_snmp_mib_free_fileEntry(ucd_snmp_mib_fileEntry_t *fileEntry)
{
    GSList *vbl;
    char *p;

    if (fileEntry) {
        p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(fileEntry);
    }
}

void
ucd_snmp_mib_free_fileTable(ucd_snmp_mib_fileEntry_t **fileEntry)
{
    int i;

    if (fileEntry) {
        for (i = 0; fileEntry[i]; i++) {
            ucd_snmp_mib_free_fileEntry(fileEntry[i]);
        }
        g_free(fileEntry);
    }
}

ucd_snmp_mib_version_t *
ucd_snmp_mib_new_version()
{
    ucd_snmp_mib_version_t *version;

    version = (ucd_snmp_mib_version_t *) g_malloc0(sizeof(ucd_snmp_mib_version_t) + sizeof(gpointer));
    return version;
}

static ucd_snmp_mib_version_t *
assign_version(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_version_t *version;
    guint32 idx;
    char *p;

    version = ucd_snmp_mib_new_version();
    if (! version) {
        return NULL;
    }

    p = (char *) version + sizeof(ucd_snmp_mib_version_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_version, sizeof(oid_version)/sizeof(guint32),
                   attr_version, &idx) < 0) continue;

        switch (idx) {
        case 1:
            version->versionIndex = &(vb->syntax.i32[0]);
            break;
        case 2:
            if (vb->syntax_len > 255) break;
            version->_versionTagLength = vb->syntax_len;
            version->versionTag = vb->syntax.uc;
            break;
        case 3:
            if (vb->syntax_len > 255) break;
            version->_versionDateLength = vb->syntax_len;
            version->versionDate = vb->syntax.uc;
            break;
        case 4:
            if (vb->syntax_len > 255) break;
            version->_versionCDateLength = vb->syntax_len;
            version->versionCDate = vb->syntax.uc;
            break;
        case 5:
            if (vb->syntax_len > 255) break;
            version->_versionIdentLength = vb->syntax_len;
            version->versionIdent = vb->syntax.uc;
            break;
        case 6:
            if (vb->syntax_len > 1023) break;
            version->_versionConfigureOptionsLength = vb->syntax_len;
            version->versionConfigureOptions = vb->syntax.uc;
            break;
        case 10:
            version->versionClearCache = &(vb->syntax.i32[0]);
            break;
        case 11:
            version->versionUpdateConfig = &(vb->syntax.i32[0]);
            break;
        case 12:
            version->versionRestartAgent = &(vb->syntax.i32[0]);
            break;
        case 20:
            version->versionDoDebugging = &(vb->syntax.i32[0]);
            break;
        };
    }

    return version;
}

void
ucd_snmp_mib_get_version(GSnmpSession *s, ucd_snmp_mib_version_t **version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0};

    *version = NULL;

    add_attributes(s, &in, base, 9, 8, attr_version, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *version = assign_version(out);
    }
}

void
ucd_snmp_mib_set_version(GSnmpSession *s, ucd_snmp_mib_version_t *version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0, 0};

    if (version->versionClearCache) {
        base[8] = 10;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       version->versionClearCache,
                       0);
    }
    if (version->versionUpdateConfig) {
        base[8] = 11;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       version->versionUpdateConfig,
                       0);
    }
    if (version->versionRestartAgent) {
        base[8] = 12;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       version->versionRestartAgent,
                       0);
    }
    if (version->versionDoDebugging) {
        base[8] = 20;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       version->versionDoDebugging,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_version(ucd_snmp_mib_version_t *version)
{
    GSList *vbl;
    char *p;

    if (version) {
        p = (char *) version + sizeof(ucd_snmp_mib_version_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(version);
    }
}

ucd_snmp_mib_snmperrs_t *
ucd_snmp_mib_new_snmperrs()
{
    ucd_snmp_mib_snmperrs_t *snmperrs;

    snmperrs = (ucd_snmp_mib_snmperrs_t *) g_malloc0(sizeof(ucd_snmp_mib_snmperrs_t) + sizeof(gpointer));
    return snmperrs;
}

static ucd_snmp_mib_snmperrs_t *
assign_snmperrs(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_snmperrs_t *snmperrs;
    guint32 idx;
    char *p;

    snmperrs = ucd_snmp_mib_new_snmperrs();
    if (! snmperrs) {
        return NULL;
    }

    p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_snmperrs, sizeof(oid_snmperrs)/sizeof(guint32),
                   attr_snmperrs, &idx) < 0) continue;

        switch (idx) {
        case 1:
            snmperrs->snmperrIndex = &(vb->syntax.i32[0]);
            break;
        case 2:
            if (vb->syntax_len > 255) break;
            snmperrs->_snmperrNamesLength = vb->syntax_len;
            snmperrs->snmperrNames = vb->syntax.uc;
            break;
        case 100:
            snmperrs->snmperrErrorFlag = &(vb->syntax.i32[0]);
            break;
        case 101:
            if (vb->syntax_len > 255) break;
            snmperrs->_snmperrErrMessageLength = vb->syntax_len;
            snmperrs->snmperrErrMessage = vb->syntax.uc;
            break;
        };
    }

    return snmperrs;
}

void
ucd_snmp_mib_get_snmperrs(GSnmpSession *s, ucd_snmp_mib_snmperrs_t **snmperrs, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 101, 0};

    *snmperrs = NULL;

    add_attributes(s, &in, base, 9, 8, attr_snmperrs, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *snmperrs = assign_snmperrs(out);
    }
}

void
ucd_snmp_mib_free_snmperrs(ucd_snmp_mib_snmperrs_t *snmperrs)
{
    GSList *vbl;
    char *p;

    if (snmperrs) {
        p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmperrs);
    }
}

ucd_snmp_mib_mrEntry_t *
ucd_snmp_mib_new_mrEntry()
{
    ucd_snmp_mib_mrEntry_t *mrEntry;

    mrEntry = (ucd_snmp_mib_mrEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_mrEntry_t) + sizeof(gpointer));
    return mrEntry;
}

static int
unpack_mrEntry(GSnmpVarBind *vb, ucd_snmp_mib_mrEntry_t *mrEntry)
{
    int idx = 10;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id_len - idx;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        mrEntry->mrIndex[i] = vb->id[idx++];
    }
    mrEntry->_mrIndexLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_mrEntry(guint32 *base, guint32 *mrIndex, guint16 _mrIndexLength)
{
    int idx = 10;
    guint16 i, len;

    len = _mrIndexLength;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = mrIndex[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ucd_snmp_mib_mrEntry_t *
assign_mrEntry(GSList *vbl)
{
    GSList *elem;
    ucd_snmp_mib_mrEntry_t *mrEntry;
    guint32 idx;
    char *p;

    mrEntry = ucd_snmp_mib_new_mrEntry();
    if (! mrEntry) {
        return NULL;
    }

    p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_mrEntry((GSnmpVarBind *) vbl->data, mrEntry) < 0) {
        g_warning("illegal mrEntry instance identifier");
        g_free(mrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_mrEntry, sizeof(oid_mrEntry)/sizeof(guint32),
                   attr_mrEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            mrEntry->_mrModuleNameLength = vb->syntax_len;
            mrEntry->mrModuleName = vb->syntax.uc;
            break;
        };
    }

    return mrEntry;
}

void
ucd_snmp_mib_get_mrTable(GSnmpSession *s, ucd_snmp_mib_mrEntry_t ***mrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1, 0};

    *mrEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_mrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *mrEntry = (ucd_snmp_mib_mrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_mrEntry_t *));
        if (! *mrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*mrEntry)[i] = assign_mrEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_mrEntry(GSnmpSession *s, ucd_snmp_mib_mrEntry_t **mrEntry, guint32 *mrIndex, guint16 _mrIndexLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_mrEntry, sizeof(oid_mrEntry));
    len = pack_mrEntry(base, mrIndex, _mrIndexLength);
    if (len < 0) {
        g_warning("illegal mrEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *mrEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_mrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *mrEntry = assign_mrEntry(out);
    }
}

void
ucd_snmp_mib_free_mrEntry(ucd_snmp_mib_mrEntry_t *mrEntry)
{
    GSList *vbl;
    char *p;

    if (mrEntry) {
        p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(mrEntry);
    }
}

void
ucd_snmp_mib_free_mrTable(ucd_snmp_mib_mrEntry_t **mrEntry)
{
    int i;

    if (mrEntry) {
        for (i = 0; mrEntry[i]; i++) {
            ucd_snmp_mib_free_mrEntry(mrEntry[i]);
        }
        g_free(mrEntry);
    }
}


