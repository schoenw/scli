/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from UCD-SNMP-MIB:
 *   This file defines the private UCD SNMP MIB extensions.
 *
 * Revision 2001-01-17 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 2002-01-04 00:00:
 *   Introduced LongDisplayString which is needed for allow
 *   for long configuration settings. Rewrote some definitions
 *   to make them more precise.
 *
 * Revision 2001-01-17 00:00:
 *   Added raw CPU and IO counters.
 *
 * Revision 1999-12-09 00:00:
 *   SMIv2 version converted from older MIB definitions.
 *
 * $Id$
 */

#include "ucd-snmp-mib.h"

GSnmpEnum const ucd_snmp_mib_enums_prErrorFlag[] = {
    { UCD_SNMP_MIB_PRERRORFLAG_OK,    "ok" },
    { UCD_SNMP_MIB_PRERRORFLAG_ERROR, "error" },
    { 0, NULL }
};

GSnmpEnum const ucd_snmp_mib_enums_fileErrorFlag[] = {
    { UCD_SNMP_MIB_FILEERRORFLAG_TRUE,  "true" },
    { UCD_SNMP_MIB_FILEERRORFLAG_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ucd_snmp_mib_enums_versionDoDebugging[] = {
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_DISABLED, "disabled" },
    { UCD_SNMP_MIB_VERSIONDODEBUGGING_ENABLED,  "enabled" },
    { 0, NULL }
};


static guint16 prNames_constraints[] = {0, 255, 0, 0};
static guint16 prErrMessage_constraints[] = {0, 255, 0, 0};
static guint16 prErrFixCmd_constraints[] = {0, 255, 0, 0};
static guint16 memErrorName_constraints[] = {0, 255, 0, 0};
static guint16 memSwapErrorMsg_constraints[] = {0, 255, 0, 0};
static guint16 extNames_constraints[] = {0, 255, 0, 0};
static guint16 extCommand_constraints[] = {0, 255, 0, 0};
static guint16 extOutput_constraints[] = {0, 255, 0, 0};
static guint16 extErrFixCmd_constraints[] = {0, 255, 0, 0};
static guint16 dskPath_constraints[] = {0, 255, 0, 0};
static guint16 dskDevice_constraints[] = {0, 255, 0, 0};
static guint16 dskErrorMsg_constraints[] = {0, 255, 0, 0};
static guint16 laNames_constraints[] = {0, 255, 0, 0};
static guint16 laLoad_constraints[] = {0, 255, 0, 0};
static guint16 laConfig_constraints[] = {0, 255, 0, 0};
static guint16 laLoadFloat_constraints[] = {7, 7, 0, 0};
static guint16 laErrMessage_constraints[] = {0, 255, 0, 0};
static guint16 ssErrorName_constraints[] = {0, 255, 0, 0};
static guint16 fileName_constraints[] = {0, 255, 0, 0};
static guint16 fileErrorMsg_constraints[] = {0, 255, 0, 0};
static guint16 versionTag_constraints[] = {0, 255, 0, 0};
static guint16 versionDate_constraints[] = {0, 255, 0, 0};
static guint16 versionCDate_constraints[] = {0, 255, 0, 0};
static guint16 versionIdent_constraints[] = {0, 255, 0, 0};
static guint16 versionConfigureOptions_constraints[] = {0, 1023, 0, 0};
static guint16 snmperrNames_constraints[] = {0, 255, 0, 0};
static guint16 snmperrErrMessage_constraints[] = {0, 255, 0, 0};
static guint16 mrModuleName_constraints[] = {0, 255, 0, 0};


static guint32 const prEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1};

static GSnmpAttribute prEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRNAMES, "prNames",
       prNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prNamesLength),
      0 },
    { 3, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRMIN, "prMin",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMin),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRMAX, "prMax",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMax),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRCOUNT, "prCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prCount),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRERRORFLAG, "prErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRERRMESSAGE, "prErrMessage",
       prErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrMessageLength),
      0 },
    { 102, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_PRERRFIX, "prErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_PRERRFIXCMD, "prErrFixCmd",
       prErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const memory_oid[] = {1, 3, 6, 1, 4, 1, 2021, 4};

static GSnmpAttribute memory_attr[] = {
    { 1, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMINDEX, "memIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memIndex),
      0,
      0 },
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_MEMERRORNAME, "memErrorName",
       memErrorName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memErrorName),
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, _memErrorNameLength),
      0 },
    { 3, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALSWAP, "memTotalSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalSwap),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILSWAP, "memAvailSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailSwap),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALREAL, "memTotalReal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalReal),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILREAL, "memAvailReal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailReal),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALSWAPTXT, "memTotalSwapTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalSwapTXT),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILSWAPTXT, "memAvailSwapTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailSwapTXT),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALREALTXT, "memTotalRealTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalRealTXT),
      0,
      0 },
    { 10, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILREALTXT, "memAvailRealTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailRealTXT),
      0,
      0 },
    { 11, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALFREE, "memTotalFree",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalFree),
      0,
      0 },
    { 12, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMMINIMUMSWAP, "memMinimumSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memMinimumSwap),
      0,
      0 },
    { 13, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMSHARED, "memShared",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memShared),
      0,
      0 },
    { 14, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMBUFFER, "memBuffer",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memBuffer),
      0,
      0 },
    { 15, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMCACHED, "memCached",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memCached),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_MEMSWAPERROR, "memSwapError",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memSwapError),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_MEMSWAPERRORMSG, "memSwapErrorMsg",
       memSwapErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memSwapErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, _memSwapErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const extEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1};

static GSnmpAttribute extEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTNAMES, "extNames",
       extNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extNamesLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTCOMMAND, "extCommand",
       extCommand_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extCommand),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extCommandLength),
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_EXTRESULT, "extResult",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extResult),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTOUTPUT, "extOutput",
       extOutput_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extOutput),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extOutputLength),
      0 },
    { 102, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_EXTERRFIX, "extErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_EXTERRFIXCMD, "extErrFixCmd",
       extErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const dskEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1};

static GSnmpAttribute dskEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_DSKPATH, "dskPath",
       dskPath_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPath),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskPathLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_DSKDEVICE, "dskDevice",
       dskDevice_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskDevice),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskDeviceLength),
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKMINIMUM, "dskMinimum",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskMinimum),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKMINPERCENT, "dskMinPercent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskMinPercent),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKTOTAL, "dskTotal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskTotal),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKAVAIL, "dskAvail",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskAvail),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKUSED, "dskUsed",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskUsed),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKPERCENT, "dskPercent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPercent),
      0,
      0 },
    { 10, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKPERCENTNODE, "dskPercentNode",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPercentNode),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_DSKERRORFLAG, "dskErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_DSKERRORMSG, "dskErrorMsg",
       dskErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const laEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1};

static GSnmpAttribute laEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LANAMES, "laNames",
       laNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laNamesLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LALOAD, "laLoad",
       laLoad_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoad),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laLoadLength),
      0 },
    { 4, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LACONFIG, "laConfig",
       laConfig_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laConfig),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laConfigLength),
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_LALOADINT, "laLoadInt",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadInt),
      0,
      0 },
    { 6, G_SNMP_OPAQUE,
      UCD_SNMP_MIB_LALOADFLOAT, "laLoadFloat",
       laLoadFloat_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadFloat),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_LAERRORFLAG, "laErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_LAERRMESSAGE, "laErrMessage",
       laErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laErrMessageLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const systemStats_oid[] = {1, 3, 6, 1, 4, 1, 2021, 11};

static GSnmpAttribute systemStats_attr[] = {
    { 1, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSINDEX, "ssIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIndex),
      0,
      0 },
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_SSERRORNAME, "ssErrorName",
       ssErrorName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssErrorName),
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, _ssErrorNameLength),
      0 },
    { 3, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSSWAPIN, "ssSwapIn",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSwapIn),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSSWAPOUT, "ssSwapOut",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSwapOut),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSIOSENT, "ssIOSent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIOSent),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSIORECEIVE, "ssIOReceive",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIOReceive),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSSYSINTERRUPTS, "ssSysInterrupts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSysInterrupts),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSSYSCONTEXT, "ssSysContext",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSysContext),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSCPUUSER, "ssCpuUser",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuUser),
      0,
      0 },
    { 10, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSCPUSYSTEM, "ssCpuSystem",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuSystem),
      0,
      0 },
    { 11, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SSCPUIDLE, "ssCpuIdle",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuIdle),
      0,
      0 },
    { 50, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWUSER, "ssCpuRawUser",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawUser),
      0,
      0 },
    { 51, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWNICE, "ssCpuRawNice",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawNice),
      0,
      0 },
    { 52, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWSYSTEM, "ssCpuRawSystem",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawSystem),
      0,
      0 },
    { 53, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWIDLE, "ssCpuRawIdle",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawIdle),
      0,
      0 },
    { 54, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWWAIT, "ssCpuRawWait",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawWait),
      0,
      0 },
    { 55, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWKERNEL, "ssCpuRawKernel",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawKernel),
      0,
      0 },
    { 56, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWINTERRUPT, "ssCpuRawInterrupt",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawInterrupt),
      0,
      0 },
    { 57, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSIORAWSENT, "ssIORawSent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIORawSent),
      0,
      0 },
    { 58, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSIORAWRECEIVED, "ssIORawReceived",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIORawReceived),
      0,
      0 },
    { 59, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSRAWINTERRUPTS, "ssRawInterrupts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssRawInterrupts),
      0,
      0 },
    { 60, G_SNMP_COUNTER32,
      UCD_SNMP_MIB_SSRAWCONTEXTS, "ssRawContexts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssRawContexts),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const fileEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1};

static GSnmpAttribute fileEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_FILENAME, "fileName",
       fileName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileName),
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, _fileNameLength),
      0 },
    { 3, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_FILESIZE, "fileSize",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileSize),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_FILEMAX, "fileMax",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileMax),
      0,
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_FILEERRORFLAG, "fileErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_FILEERRORMSG, "fileErrorMsg",
       fileErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, _fileErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const version_oid[] = {1, 3, 6, 1, 4, 1, 2021, 100};

static GSnmpAttribute version_attr[] = {
    { 1, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONINDEX, "versionIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIndex),
      0,
      0 },
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONTAG, "versionTag",
       versionTag_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionTag),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionTagLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONDATE, "versionDate",
       versionDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionDateLength),
      0 },
    { 4, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCDATE, "versionCDate",
       versionCDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionCDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionCDateLength),
      0 },
    { 5, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONIDENT, "versionIdent",
       versionIdent_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIdent),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionIdentLength),
      0 },
    { 6, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCONFIGUREOPTIONS, "versionConfigureOptions",
       versionConfigureOptions_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionConfigureOptions),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionConfigureOptionsLength),
      0 },
    { 10, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONCLEARCACHE, "versionClearCache",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionClearCache),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONUPDATECONFIG, "versionUpdateConfig",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionUpdateConfig),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONRESTARTAGENT, "versionRestartAgent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionRestartAgent),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 20, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_VERSIONDODEBUGGING, "versionDoDebugging",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDoDebugging),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const snmperrs_oid[] = {1, 3, 6, 1, 4, 1, 2021, 101};

static GSnmpAttribute snmperrs_attr[] = {
    { 1, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SNMPERRINDEX, "snmperrIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrIndex),
      0,
      0 },
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_SNMPERRNAMES, "snmperrNames",
       snmperrNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, _snmperrNamesLength),
      0 },
    { 100, G_SNMP_INTEGER32,
      UCD_SNMP_MIB_SNMPERRERRORFLAG, "snmperrErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrErrorFlag),
      0,
      0 },
    { 101, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_SNMPERRERRMESSAGE, "snmperrErrMessage",
       snmperrErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, _snmperrErrMessageLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const mrEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1};

static GSnmpAttribute mrEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      UCD_SNMP_MIB_MRMODULENAME, "mrModuleName",
       mrModuleName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_mrEntry_t, mrModuleName),
      G_STRUCT_OFFSET(ucd_snmp_mib_mrEntry_t, _mrModuleNameLength),
      0 },
    { 0, 0, 0, NULL }
};


ucd_snmp_mib_prEntry_t *
ucd_snmp_mib_new_prEntry()
{
    ucd_snmp_mib_prEntry_t *prEntry;

    prEntry = (ucd_snmp_mib_prEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_prEntry_t) + sizeof(gpointer));
    return prEntry;
}

static int
unpack_prEntry(GSnmpVarBind *vb, ucd_snmp_mib_prEntry_t *prEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    prEntry->prIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prEntry(guint32 *base, gint32 prIndex)
{
    guint8 idx = 10;

    base[idx++] = prIndex;
    return idx;
}

static ucd_snmp_mib_prEntry_t *
assign_prEntry(GSList *vbl)
{
    ucd_snmp_mib_prEntry_t *prEntry;
    char *p;

    prEntry = ucd_snmp_mib_new_prEntry();
    if (! prEntry) {
        return NULL;
    }

    p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prEntry((GSnmpVarBind *) vbl->data, prEntry) < 0) {
        g_warning("%s: invalid instance identifier", "prEntry");
        g_free(prEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, prEntry_oid, sizeof(prEntry_oid)/sizeof(guint32),
                      prEntry_attr, prEntry);

    return prEntry;
}

void
ucd_snmp_mib_get_prTable(GSnmpSession *s, ucd_snmp_mib_prEntry_t ***prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1, 0};

    *prEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, prEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prEntry = (ucd_snmp_mib_prEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_prEntry_t *));
        if (! *prEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prEntry)[i] = assign_prEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t **prEntry, gint32 prIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, prEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prEntry = assign_prEntry(out);
    }
}

void
ucd_snmp_mib_set_prEntry(GSnmpSession *s, ucd_snmp_mib_prEntry_t *prEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prEntry->prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, prEntry_attr, mask, prEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_prEntry(ucd_snmp_mib_prEntry_t *prEntry)
{
    GSList *vbl;
    char *p;

    if (prEntry) {
        p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_free_prTable(ucd_snmp_mib_prEntry_t **prEntry)
{
    int i;

    if (prEntry) {
        for (i = 0; prEntry[i]; i++) {
            ucd_snmp_mib_free_prEntry(prEntry[i]);
        }
        g_free(prEntry);
    }
}

ucd_snmp_mib_memory_t *
ucd_snmp_mib_new_memory()
{
    ucd_snmp_mib_memory_t *memory;

    memory = (ucd_snmp_mib_memory_t *) g_malloc0(sizeof(ucd_snmp_mib_memory_t) + sizeof(gpointer));
    return memory;
}

static ucd_snmp_mib_memory_t *
assign_memory(GSList *vbl)
{
    ucd_snmp_mib_memory_t *memory;
    char *p;

    memory = ucd_snmp_mib_new_memory();
    if (! memory) {
        return NULL;
    }

    p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, memory_oid, sizeof(memory_oid)/sizeof(guint32),
                      memory_attr, memory);

    return memory;
}

void
ucd_snmp_mib_get_memory(GSnmpSession *s, ucd_snmp_mib_memory_t **memory, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 4, 0};

    *memory = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, memory_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *memory = assign_memory(out);
    }
}

void
ucd_snmp_mib_free_memory(ucd_snmp_mib_memory_t *memory)
{
    GSList *vbl;
    char *p;

    if (memory) {
        p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(memory);
    }
}

ucd_snmp_mib_extEntry_t *
ucd_snmp_mib_new_extEntry()
{
    ucd_snmp_mib_extEntry_t *extEntry;

    extEntry = (ucd_snmp_mib_extEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_extEntry_t) + sizeof(gpointer));
    return extEntry;
}

static int
unpack_extEntry(GSnmpVarBind *vb, ucd_snmp_mib_extEntry_t *extEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    extEntry->extIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_extEntry(guint32 *base, gint32 extIndex)
{
    guint8 idx = 10;

    base[idx++] = extIndex;
    return idx;
}

static ucd_snmp_mib_extEntry_t *
assign_extEntry(GSList *vbl)
{
    ucd_snmp_mib_extEntry_t *extEntry;
    char *p;

    extEntry = ucd_snmp_mib_new_extEntry();
    if (! extEntry) {
        return NULL;
    }

    p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
    * (GSList **) p = vbl;

    if (unpack_extEntry((GSnmpVarBind *) vbl->data, extEntry) < 0) {
        g_warning("%s: invalid instance identifier", "extEntry");
        g_free(extEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, extEntry_oid, sizeof(extEntry_oid)/sizeof(guint32),
                      extEntry_attr, extEntry);

    return extEntry;
}

void
ucd_snmp_mib_get_extTable(GSnmpSession *s, ucd_snmp_mib_extEntry_t ***extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1, 0};

    *extEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, extEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *extEntry = (ucd_snmp_mib_extEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_extEntry_t *));
        if (! *extEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*extEntry)[i] = assign_extEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t **extEntry, gint32 extIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *extEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, extEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *extEntry = assign_extEntry(out);
    }
}

void
ucd_snmp_mib_set_extEntry(GSnmpSession *s, ucd_snmp_mib_extEntry_t *extEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extEntry->extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, extEntry_attr, mask, extEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_extEntry(ucd_snmp_mib_extEntry_t *extEntry)
{
    GSList *vbl;
    char *p;

    if (extEntry) {
        p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_free_extTable(ucd_snmp_mib_extEntry_t **extEntry)
{
    int i;

    if (extEntry) {
        for (i = 0; extEntry[i]; i++) {
            ucd_snmp_mib_free_extEntry(extEntry[i]);
        }
        g_free(extEntry);
    }
}

ucd_snmp_mib_dskEntry_t *
ucd_snmp_mib_new_dskEntry()
{
    ucd_snmp_mib_dskEntry_t *dskEntry;

    dskEntry = (ucd_snmp_mib_dskEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_dskEntry_t) + sizeof(gpointer));
    return dskEntry;
}

static int
unpack_dskEntry(GSnmpVarBind *vb, ucd_snmp_mib_dskEntry_t *dskEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    dskEntry->dskIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_dskEntry(guint32 *base, gint32 dskIndex)
{
    guint8 idx = 10;

    base[idx++] = dskIndex;
    return idx;
}

static ucd_snmp_mib_dskEntry_t *
assign_dskEntry(GSList *vbl)
{
    ucd_snmp_mib_dskEntry_t *dskEntry;
    char *p;

    dskEntry = ucd_snmp_mib_new_dskEntry();
    if (! dskEntry) {
        return NULL;
    }

    p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
    * (GSList **) p = vbl;

    if (unpack_dskEntry((GSnmpVarBind *) vbl->data, dskEntry) < 0) {
        g_warning("%s: invalid instance identifier", "dskEntry");
        g_free(dskEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, dskEntry_oid, sizeof(dskEntry_oid)/sizeof(guint32),
                      dskEntry_attr, dskEntry);

    return dskEntry;
}

void
ucd_snmp_mib_get_dskTable(GSnmpSession *s, ucd_snmp_mib_dskEntry_t ***dskEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1, 0};

    *dskEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, dskEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *dskEntry = (ucd_snmp_mib_dskEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_dskEntry_t *));
        if (! *dskEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*dskEntry)[i] = assign_dskEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_dskEntry(GSnmpSession *s, ucd_snmp_mib_dskEntry_t **dskEntry, gint32 dskIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, dskEntry_oid, sizeof(dskEntry_oid));
    len = pack_dskEntry(base, dskIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "dskEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *dskEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, dskEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *dskEntry = assign_dskEntry(out);
    }
}

void
ucd_snmp_mib_free_dskEntry(ucd_snmp_mib_dskEntry_t *dskEntry)
{
    GSList *vbl;
    char *p;

    if (dskEntry) {
        p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(dskEntry);
    }
}

void
ucd_snmp_mib_free_dskTable(ucd_snmp_mib_dskEntry_t **dskEntry)
{
    int i;

    if (dskEntry) {
        for (i = 0; dskEntry[i]; i++) {
            ucd_snmp_mib_free_dskEntry(dskEntry[i]);
        }
        g_free(dskEntry);
    }
}

ucd_snmp_mib_laEntry_t *
ucd_snmp_mib_new_laEntry()
{
    ucd_snmp_mib_laEntry_t *laEntry;

    laEntry = (ucd_snmp_mib_laEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_laEntry_t) + sizeof(gpointer));
    return laEntry;
}

static int
unpack_laEntry(GSnmpVarBind *vb, ucd_snmp_mib_laEntry_t *laEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    laEntry->laIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_laEntry(guint32 *base, gint32 laIndex)
{
    guint8 idx = 10;

    base[idx++] = laIndex;
    return idx;
}

static ucd_snmp_mib_laEntry_t *
assign_laEntry(GSList *vbl)
{
    ucd_snmp_mib_laEntry_t *laEntry;
    char *p;

    laEntry = ucd_snmp_mib_new_laEntry();
    if (! laEntry) {
        return NULL;
    }

    p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
    * (GSList **) p = vbl;

    if (unpack_laEntry((GSnmpVarBind *) vbl->data, laEntry) < 0) {
        g_warning("%s: invalid instance identifier", "laEntry");
        g_free(laEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, laEntry_oid, sizeof(laEntry_oid)/sizeof(guint32),
                      laEntry_attr, laEntry);

    return laEntry;
}

void
ucd_snmp_mib_get_laTable(GSnmpSession *s, ucd_snmp_mib_laEntry_t ***laEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1, 0};

    *laEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, laEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *laEntry = (ucd_snmp_mib_laEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_laEntry_t *));
        if (! *laEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*laEntry)[i] = assign_laEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_laEntry(GSnmpSession *s, ucd_snmp_mib_laEntry_t **laEntry, gint32 laIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, laEntry_oid, sizeof(laEntry_oid));
    len = pack_laEntry(base, laIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "laEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *laEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, laEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *laEntry = assign_laEntry(out);
    }
}

void
ucd_snmp_mib_free_laEntry(ucd_snmp_mib_laEntry_t *laEntry)
{
    GSList *vbl;
    char *p;

    if (laEntry) {
        p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(laEntry);
    }
}

void
ucd_snmp_mib_free_laTable(ucd_snmp_mib_laEntry_t **laEntry)
{
    int i;

    if (laEntry) {
        for (i = 0; laEntry[i]; i++) {
            ucd_snmp_mib_free_laEntry(laEntry[i]);
        }
        g_free(laEntry);
    }
}

ucd_snmp_mib_systemStats_t *
ucd_snmp_mib_new_systemStats()
{
    ucd_snmp_mib_systemStats_t *systemStats;

    systemStats = (ucd_snmp_mib_systemStats_t *) g_malloc0(sizeof(ucd_snmp_mib_systemStats_t) + sizeof(gpointer));
    return systemStats;
}

static ucd_snmp_mib_systemStats_t *
assign_systemStats(GSList *vbl)
{
    ucd_snmp_mib_systemStats_t *systemStats;
    char *p;

    systemStats = ucd_snmp_mib_new_systemStats();
    if (! systemStats) {
        return NULL;
    }

    p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, systemStats_oid, sizeof(systemStats_oid)/sizeof(guint32),
                      systemStats_attr, systemStats);

    return systemStats;
}

void
ucd_snmp_mib_get_systemStats(GSnmpSession *s, ucd_snmp_mib_systemStats_t **systemStats, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 11, 0};

    *systemStats = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, systemStats_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *systemStats = assign_systemStats(out);
    }
}

void
ucd_snmp_mib_free_systemStats(ucd_snmp_mib_systemStats_t *systemStats)
{
    GSList *vbl;
    char *p;

    if (systemStats) {
        p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(systemStats);
    }
}

ucd_snmp_mib_fileEntry_t *
ucd_snmp_mib_new_fileEntry()
{
    ucd_snmp_mib_fileEntry_t *fileEntry;

    fileEntry = (ucd_snmp_mib_fileEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_fileEntry_t) + sizeof(gpointer));
    return fileEntry;
}

static int
unpack_fileEntry(GSnmpVarBind *vb, ucd_snmp_mib_fileEntry_t *fileEntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    fileEntry->fileIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_fileEntry(guint32 *base, gint32 fileIndex)
{
    guint8 idx = 10;

    base[idx++] = fileIndex;
    return idx;
}

static ucd_snmp_mib_fileEntry_t *
assign_fileEntry(GSList *vbl)
{
    ucd_snmp_mib_fileEntry_t *fileEntry;
    char *p;

    fileEntry = ucd_snmp_mib_new_fileEntry();
    if (! fileEntry) {
        return NULL;
    }

    p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
    * (GSList **) p = vbl;

    if (unpack_fileEntry((GSnmpVarBind *) vbl->data, fileEntry) < 0) {
        g_warning("%s: invalid instance identifier", "fileEntry");
        g_free(fileEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, fileEntry_oid, sizeof(fileEntry_oid)/sizeof(guint32),
                      fileEntry_attr, fileEntry);

    return fileEntry;
}

void
ucd_snmp_mib_get_fileTable(GSnmpSession *s, ucd_snmp_mib_fileEntry_t ***fileEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1, 0};

    *fileEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, fileEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *fileEntry = (ucd_snmp_mib_fileEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_fileEntry_t *));
        if (! *fileEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*fileEntry)[i] = assign_fileEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_fileEntry(GSnmpSession *s, ucd_snmp_mib_fileEntry_t **fileEntry, gint32 fileIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, fileEntry_oid, sizeof(fileEntry_oid));
    len = pack_fileEntry(base, fileIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "fileEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *fileEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, fileEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *fileEntry = assign_fileEntry(out);
    }
}

void
ucd_snmp_mib_free_fileEntry(ucd_snmp_mib_fileEntry_t *fileEntry)
{
    GSList *vbl;
    char *p;

    if (fileEntry) {
        p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(fileEntry);
    }
}

void
ucd_snmp_mib_free_fileTable(ucd_snmp_mib_fileEntry_t **fileEntry)
{
    int i;

    if (fileEntry) {
        for (i = 0; fileEntry[i]; i++) {
            ucd_snmp_mib_free_fileEntry(fileEntry[i]);
        }
        g_free(fileEntry);
    }
}

ucd_snmp_mib_version_t *
ucd_snmp_mib_new_version()
{
    ucd_snmp_mib_version_t *version;

    version = (ucd_snmp_mib_version_t *) g_malloc0(sizeof(ucd_snmp_mib_version_t) + sizeof(gpointer));
    return version;
}

static ucd_snmp_mib_version_t *
assign_version(GSList *vbl)
{
    ucd_snmp_mib_version_t *version;
    char *p;

    version = ucd_snmp_mib_new_version();
    if (! version) {
        return NULL;
    }

    p = (char *) version + sizeof(ucd_snmp_mib_version_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, version_oid, sizeof(version_oid)/sizeof(guint32),
                      version_attr, version);

    return version;
}

void
ucd_snmp_mib_get_version(GSnmpSession *s, ucd_snmp_mib_version_t **version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0};

    *version = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, version_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *version = assign_version(out);
    }
}

void
ucd_snmp_mib_set_version(GSnmpSession *s, ucd_snmp_mib_version_t *version, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0, 0};

    gsnmp_attr_set(s, &in, base, 10, 8, version_attr, mask, version);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ucd_snmp_mib_free_version(ucd_snmp_mib_version_t *version)
{
    GSList *vbl;
    char *p;

    if (version) {
        p = (char *) version + sizeof(ucd_snmp_mib_version_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(version);
    }
}

ucd_snmp_mib_snmperrs_t *
ucd_snmp_mib_new_snmperrs()
{
    ucd_snmp_mib_snmperrs_t *snmperrs;

    snmperrs = (ucd_snmp_mib_snmperrs_t *) g_malloc0(sizeof(ucd_snmp_mib_snmperrs_t) + sizeof(gpointer));
    return snmperrs;
}

static ucd_snmp_mib_snmperrs_t *
assign_snmperrs(GSList *vbl)
{
    ucd_snmp_mib_snmperrs_t *snmperrs;
    char *p;

    snmperrs = ucd_snmp_mib_new_snmperrs();
    if (! snmperrs) {
        return NULL;
    }

    p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, snmperrs_oid, sizeof(snmperrs_oid)/sizeof(guint32),
                      snmperrs_attr, snmperrs);

    return snmperrs;
}

void
ucd_snmp_mib_get_snmperrs(GSnmpSession *s, ucd_snmp_mib_snmperrs_t **snmperrs, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 101, 0};

    *snmperrs = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, snmperrs_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *snmperrs = assign_snmperrs(out);
    }
}

void
ucd_snmp_mib_free_snmperrs(ucd_snmp_mib_snmperrs_t *snmperrs)
{
    GSList *vbl;
    char *p;

    if (snmperrs) {
        p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmperrs);
    }
}

ucd_snmp_mib_mrEntry_t *
ucd_snmp_mib_new_mrEntry()
{
    ucd_snmp_mib_mrEntry_t *mrEntry;

    mrEntry = (ucd_snmp_mib_mrEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_mrEntry_t) + sizeof(gpointer));
    return mrEntry;
}

static int
unpack_mrEntry(GSnmpVarBind *vb, ucd_snmp_mib_mrEntry_t *mrEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id_len - idx;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        mrEntry->mrIndex[i] = vb->id[idx++];
    }
    mrEntry->_mrIndexLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_mrEntry(guint32 *base, guint32 *mrIndex, guint16 _mrIndexLength)
{
    guint8 idx = 10;
    guint16 i, len;

    len = _mrIndexLength;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = mrIndex[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ucd_snmp_mib_mrEntry_t *
assign_mrEntry(GSList *vbl)
{
    ucd_snmp_mib_mrEntry_t *mrEntry;
    char *p;

    mrEntry = ucd_snmp_mib_new_mrEntry();
    if (! mrEntry) {
        return NULL;
    }

    p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_mrEntry((GSnmpVarBind *) vbl->data, mrEntry) < 0) {
        g_warning("%s: invalid instance identifier", "mrEntry");
        g_free(mrEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, mrEntry_oid, sizeof(mrEntry_oid)/sizeof(guint32),
                      mrEntry_attr, mrEntry);

    return mrEntry;
}

void
ucd_snmp_mib_get_mrTable(GSnmpSession *s, ucd_snmp_mib_mrEntry_t ***mrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1, 0};

    *mrEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, mrEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *mrEntry = (ucd_snmp_mib_mrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ucd_snmp_mib_mrEntry_t *));
        if (! *mrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*mrEntry)[i] = assign_mrEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_mrEntry(GSnmpSession *s, ucd_snmp_mib_mrEntry_t **mrEntry, guint32 *mrIndex, guint16 _mrIndexLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, mrEntry_oid, sizeof(mrEntry_oid));
    len = pack_mrEntry(base, mrIndex, _mrIndexLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "mrEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *mrEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, mrEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *mrEntry = assign_mrEntry(out);
    }
}

void
ucd_snmp_mib_free_mrEntry(ucd_snmp_mib_mrEntry_t *mrEntry)
{
    GSList *vbl;
    char *p;

    if (mrEntry) {
        p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(mrEntry);
    }
}

void
ucd_snmp_mib_free_mrTable(ucd_snmp_mib_mrEntry_t **mrEntry)
{
    int i;

    if (mrEntry) {
        for (i = 0; mrEntry[i]; i++) {
            ucd_snmp_mib_free_mrEntry(mrEntry[i]);
        }
        g_free(mrEntry);
    }
}


