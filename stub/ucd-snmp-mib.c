/*							-- DO NOT EDIT --
 * Generated by smidump version 0.4.3-pre1:
 *   smidump -f scli --scli-set UCD-SNMP-MIB
 *
 * Derived from UCD-SNMP-MIB:
 *   Deprecate the non-raw objects.
 *
 * Revision 2002-09-05 00:00:
 *   This file defines the private UCD SNMP MIB extensions.
 *
 * Revision 2001-01-17 00:00:
 *   Added raw CPU and IO counters.
 *
 * Revision 1999-12-09 00:00:
 *   SMIv2 version converted from older MIB definitions.
 *
 * $Id$
 */

#include "ucd-snmp-mib.h"

static guint16 prNames_constraints[] = {0U, 255U, 0, 0};
static guint16 prErrMessage_constraints[] = {0U, 255U, 0, 0};
static guint16 prErrFixCmd_constraints[] = {0U, 255U, 0, 0};
static guint16 memErrorName_constraints[] = {0U, 255U, 0, 0};
static guint16 memSwapErrorMsg_constraints[] = {0U, 255U, 0, 0};
static guint16 extNames_constraints[] = {0U, 255U, 0, 0};
static guint16 extCommand_constraints[] = {0U, 255U, 0, 0};
static guint16 extOutput_constraints[] = {0U, 255U, 0, 0};
static guint16 extErrFixCmd_constraints[] = {0U, 255U, 0, 0};
static guint16 dskPath_constraints[] = {0U, 255U, 0, 0};
static guint16 dskDevice_constraints[] = {0U, 255U, 0, 0};
static guint16 dskErrorMsg_constraints[] = {0U, 255U, 0, 0};
static guint16 laNames_constraints[] = {0U, 255U, 0, 0};
static guint16 laLoad_constraints[] = {0U, 255U, 0, 0};
static guint16 laConfig_constraints[] = {0U, 255U, 0, 0};
static guint16 laLoadFloat_constraints[] = {7U, 7U, 0, 0};
static guint16 laErrMessage_constraints[] = {0U, 255U, 0, 0};
static guint16 ssErrorName_constraints[] = {0U, 255U, 0, 0};
static guint16 fileName_constraints[] = {0U, 255U, 0, 0};
static guint16 fileErrorMsg_constraints[] = {0U, 255U, 0, 0};
static guint16 logMatchName_constraints[] = {0U, 255U, 0, 0};
static guint16 logMatchFilename_constraints[] = {0U, 255U, 0, 0};
static guint16 logMatchRegEx_constraints[] = {0U, 255U, 0, 0};
static guint16 logMatchRegExCompilation_constraints[] = {0U, 255U, 0, 0};
static guint16 versionTag_constraints[] = {0U, 255U, 0, 0};
static guint16 versionDate_constraints[] = {0U, 255U, 0, 0};
static guint16 versionCDate_constraints[] = {0U, 255U, 0, 0};
static guint16 versionIdent_constraints[] = {0U, 255U, 0, 0};
static guint16 versionConfigureOptions_constraints[] = {0U, 255U, 0, 0};
static guint16 snmperrNames_constraints[] = {0U, 255U, 0, 0};
static guint16 snmperrErrMessage_constraints[] = {0U, 255U, 0, 0};
static guint16 mrModuleName_constraints[] = {0U, 255U, 0, 0};


static guint32 const prEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1};

static GNetSnmpAttribute prEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_PRNAMES, "prNames",
       prNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prNamesLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_PRMIN, "prMin",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMin),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_PRMAX, "prMax",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prMax),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_PRCOUNT, "prCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prCount),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_PRERRORFLAG, "prErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_PRERRMESSAGE, "prErrMessage",
       prErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrMessageLength),
      0 },
    { 102, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_PRERRFIX, "prErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_PRERRFIXCMD, "prErrFixCmd",
       prErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, prErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_prEntry_t, _prErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const memory_oid[] = {1, 3, 6, 1, 4, 1, 2021, 4};

static GNetSnmpAttribute memory_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMINDEX, "memIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memIndex),
      0,
      0 },
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_MEMERRORNAME, "memErrorName",
       memErrorName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memErrorName),
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, _memErrorNameLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALSWAP, "memTotalSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalSwap),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILSWAP, "memAvailSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailSwap),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALREAL, "memTotalReal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalReal),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILREAL, "memAvailReal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailReal),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALSWAPTXT, "memTotalSwapTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalSwapTXT),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILSWAPTXT, "memAvailSwapTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailSwapTXT),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALREALTXT, "memTotalRealTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalRealTXT),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMAVAILREALTXT, "memAvailRealTXT",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memAvailRealTXT),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMTOTALFREE, "memTotalFree",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memTotalFree),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMMINIMUMSWAP, "memMinimumSwap",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memMinimumSwap),
      0,
      0 },
    { 13, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMSHARED, "memShared",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memShared),
      0,
      0 },
    { 14, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMBUFFER, "memBuffer",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memBuffer),
      0,
      0 },
    { 15, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMCACHED, "memCached",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memCached),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_MEMSWAPERROR, "memSwapError",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memSwapError),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_MEMSWAPERRORMSG, "memSwapErrorMsg",
       memSwapErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, memSwapErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_memory_t, _memSwapErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const extEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1};

static GNetSnmpAttribute extEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_EXTNAMES, "extNames",
       extNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extNamesLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_EXTCOMMAND, "extCommand",
       extCommand_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extCommand),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extCommandLength),
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_EXTRESULT, "extResult",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extResult),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_EXTOUTPUT, "extOutput",
       extOutput_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extOutput),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extOutputLength),
      0 },
    { 102, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_EXTERRFIX, "extErrFix",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFix),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 103, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_EXTERRFIXCMD, "extErrFixCmd",
       extErrFixCmd_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, extErrFixCmd),
      G_STRUCT_OFFSET(ucd_snmp_mib_extEntry_t, _extErrFixCmdLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const dskEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1};

static GNetSnmpAttribute dskEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_DSKPATH, "dskPath",
       dskPath_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPath),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskPathLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_DSKDEVICE, "dskDevice",
       dskDevice_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskDevice),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskDeviceLength),
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKMINIMUM, "dskMinimum",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskMinimum),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKMINPERCENT, "dskMinPercent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskMinPercent),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKTOTAL, "dskTotal",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskTotal),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKAVAIL, "dskAvail",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskAvail),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKUSED, "dskUsed",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskUsed),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKPERCENT, "dskPercent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPercent),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKPERCENTNODE, "dskPercentNode",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskPercentNode),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_DSKERRORFLAG, "dskErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_DSKERRORMSG, "dskErrorMsg",
       dskErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, dskErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_dskEntry_t, _dskErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const laEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1};

static GNetSnmpAttribute laEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LANAMES, "laNames",
       laNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laNamesLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LALOAD, "laLoad",
       laLoad_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoad),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laLoadLength),
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LACONFIG, "laConfig",
       laConfig_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laConfig),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laConfigLength),
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LALOADINT, "laLoadInt",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadInt),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_OPAQUE,
      UCD_SNMP_MIB_LALOADFLOAT, "laLoadFloat",
       laLoadFloat_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laLoadFloat),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LAERRORFLAG, "laErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LAERRMESSAGE, "laErrMessage",
       laErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, laErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_laEntry_t, _laErrMessageLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const systemStats_oid[] = {1, 3, 6, 1, 4, 1, 2021, 11};

static GNetSnmpAttribute systemStats_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSINDEX, "ssIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIndex),
      0,
      0 },
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_SSERRORNAME, "ssErrorName",
       ssErrorName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssErrorName),
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, _ssErrorNameLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSSWAPIN, "ssSwapIn",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSwapIn),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSSWAPOUT, "ssSwapOut",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSwapOut),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSIOSENT, "ssIOSent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIOSent),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSIORECEIVE, "ssIOReceive",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIOReceive),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSSYSINTERRUPTS, "ssSysInterrupts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSysInterrupts),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSSYSCONTEXT, "ssSysContext",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssSysContext),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSCPUUSER, "ssCpuUser",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuUser),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSCPUSYSTEM, "ssCpuSystem",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuSystem),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SSCPUIDLE, "ssCpuIdle",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuIdle),
      0,
      0 },
    { 50, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWUSER, "ssCpuRawUser",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawUser),
      0,
      0 },
    { 51, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWNICE, "ssCpuRawNice",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawNice),
      0,
      0 },
    { 52, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWSYSTEM, "ssCpuRawSystem",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawSystem),
      0,
      0 },
    { 53, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWIDLE, "ssCpuRawIdle",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawIdle),
      0,
      0 },
    { 54, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWWAIT, "ssCpuRawWait",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawWait),
      0,
      0 },
    { 55, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWKERNEL, "ssCpuRawKernel",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawKernel),
      0,
      0 },
    { 56, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSCPURAWINTERRUPT, "ssCpuRawInterrupt",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssCpuRawInterrupt),
      0,
      0 },
    { 57, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSIORAWSENT, "ssIORawSent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIORawSent),
      0,
      0 },
    { 58, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSIORAWRECEIVED, "ssIORawReceived",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssIORawReceived),
      0,
      0 },
    { 59, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSRAWINTERRUPTS, "ssRawInterrupts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssRawInterrupts),
      0,
      0 },
    { 60, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_SSRAWCONTEXTS, "ssRawContexts",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_systemStats_t, ssRawContexts),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const fileEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1};

static GNetSnmpAttribute fileEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_FILENAME, "fileName",
       fileName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileName),
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, _fileNameLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_FILESIZE, "fileSize",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileSize),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_FILEMAX, "fileMax",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileMax),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_FILEERRORFLAG, "fileErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_FILEERRORMSG, "fileErrorMsg",
       fileErrorMsg_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, fileErrorMsg),
      G_STRUCT_OFFSET(ucd_snmp_mib_fileEntry_t, _fileErrorMsgLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const logMatch_oid[] = {1, 3, 6, 1, 4, 1, 2021, 16};

static GNetSnmpAttribute logMatch_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHMAXENTRIES, "logMatchMaxEntries",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatch_t, logMatchMaxEntries),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const logMatchEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 16, 2, 1};

static GNetSnmpAttribute logMatchEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LOGMATCHNAME, "logMatchName",
       logMatchName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchName),
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, _logMatchNameLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LOGMATCHFILENAME, "logMatchFilename",
       logMatchFilename_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchFilename),
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, _logMatchFilenameLength),
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LOGMATCHREGEX, "logMatchRegEx",
       logMatchRegEx_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchRegEx),
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, _logMatchRegExLength),
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_LOGMATCHGLOBALCOUNTER, "logMatchGlobalCounter",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchGlobalCounter),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHGLOBALCOUNT, "logMatchGlobalCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchGlobalCount),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_LOGMATCHCURRENTCOUNTER, "logMatchCurrentCounter",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchCurrentCounter),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHCURRENTCOUNT, "logMatchCurrentCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchCurrentCount),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      UCD_SNMP_MIB_LOGMATCHCOUNTER, "logMatchCounter",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchCounter),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHCOUNT, "logMatchCount",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchCount),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHCYCLE, "logMatchCycle",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchCycle),
      0,
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_LOGMATCHERRORFLAG, "logMatchErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_LOGMATCHREGEXCOMPILATION, "logMatchRegExCompilation",
       logMatchRegExCompilation_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, logMatchRegExCompilation),
      G_STRUCT_OFFSET(ucd_snmp_mib_logMatchEntry_t, _logMatchRegExCompilationLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const version_oid[] = {1, 3, 6, 1, 4, 1, 2021, 100};

static GNetSnmpAttribute version_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONINDEX, "versionIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIndex),
      0,
      0 },
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONTAG, "versionTag",
       versionTag_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionTag),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionTagLength),
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONDATE, "versionDate",
       versionDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionDateLength),
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCDATE, "versionCDate",
       versionCDate_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionCDate),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionCDateLength),
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONIDENT, "versionIdent",
       versionIdent_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionIdent),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionIdentLength),
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_VERSIONCONFIGUREOPTIONS, "versionConfigureOptions",
       versionConfigureOptions_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionConfigureOptions),
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, _versionConfigureOptionsLength),
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONCLEARCACHE, "versionClearCache",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionClearCache),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONUPDATECONFIG, "versionUpdateConfig",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionUpdateConfig),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONRESTARTAGENT, "versionRestartAgent",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionRestartAgent),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 13, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONSAVEPERSISTENTDATA, "versionSavePersistentData",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionSavePersistentData),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 20, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_VERSIONDODEBUGGING, "versionDoDebugging",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_version_t, versionDoDebugging),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const snmperrs_oid[] = {1, 3, 6, 1, 4, 1, 2021, 101};

static GNetSnmpAttribute snmperrs_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SNMPERRINDEX, "snmperrIndex",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrIndex),
      0,
      0 },
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_SNMPERRNAMES, "snmperrNames",
       snmperrNames_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrNames),
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, _snmperrNamesLength),
      0 },
    { 100, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      UCD_SNMP_MIB_SNMPERRERRORFLAG, "snmperrErrorFlag",
       NULL,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrErrorFlag),
      0,
      0 },
    { 101, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_SNMPERRERRMESSAGE, "snmperrErrMessage",
       snmperrErrMessage_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, snmperrErrMessage),
      G_STRUCT_OFFSET(ucd_snmp_mib_snmperrs_t, _snmperrErrMessageLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const mrEntry_oid[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1};

static GNetSnmpAttribute mrEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      UCD_SNMP_MIB_MRMODULENAME, "mrModuleName",
       mrModuleName_constraints,
      G_STRUCT_OFFSET(ucd_snmp_mib_mrEntry_t, mrModuleName),
      G_STRUCT_OFFSET(ucd_snmp_mib_mrEntry_t, _mrModuleNameLength),
      0 },
    { 0, 0, 0, NULL }
};


ucd_snmp_mib_prEntry_t *
ucd_snmp_mib_new_prEntry()
{
    ucd_snmp_mib_prEntry_t *prEntry;

    prEntry = (ucd_snmp_mib_prEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_prEntry_t) + sizeof(gpointer));
    return prEntry;
}

static inline int
unpack_prEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_prEntry_t *prEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    prEntry->prIndex = vb->oid[idx++];
    if ((prEntry->prIndex < 0 || prEntry->prIndex > 65535)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_prEntry(guint32 *base, gint32 prIndex)
{
    guint8 idx = 10;

    base[idx++] = prIndex;
    return idx;
}

static inline ucd_snmp_mib_prEntry_t *
assign_prEntry(GList *vbl)
{
    ucd_snmp_mib_prEntry_t *prEntry;
    char *p;

    prEntry = ucd_snmp_mib_new_prEntry();
    p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
    * (GList **) p = vbl;

    if (unpack_prEntry((GNetSnmpVarBind *) vbl->data, prEntry) < 0) {
        g_warning("%s: invalid instance identifier", "prEntry");
        g_free(prEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, prEntry_oid, G_N_ELEMENTS(prEntry_oid),
                      prEntry_attr, prEntry);

    return prEntry;
}

void
ucd_snmp_mib_get_prTable(GNetSnmp *s, ucd_snmp_mib_prEntry_t ***prEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 2, 1, 0};

    *prEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, prEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *prEntry = (ucd_snmp_mib_prEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_prEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*prEntry)[i] = assign_prEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_prEntry(GNetSnmp *s, ucd_snmp_mib_prEntry_t **prEntry, gint32 prIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *prEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, prEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *prEntry = assign_prEntry(out);
    }
}

void
ucd_snmp_mib_set_prEntry(GNetSnmp *s, ucd_snmp_mib_prEntry_t *prEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, prEntry_oid, sizeof(prEntry_oid));
    len = pack_prEntry(base, prEntry->prIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "prEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, prEntry_attr, mask, prEntry);

    out = gnet_snmp_sync_set(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(out);
    }
}

void
ucd_snmp_mib_free_prEntry(ucd_snmp_mib_prEntry_t *prEntry)
{
    GList *vbl;
    char *p;

    if (prEntry) {
        p = (char *) prEntry + sizeof(ucd_snmp_mib_prEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_free_prTable(ucd_snmp_mib_prEntry_t **prEntry)
{
    int i;

    if (prEntry) {
        for (i = 0; prEntry[i]; i++) {
            ucd_snmp_mib_free_prEntry(prEntry[i]);
        }
        g_free(prEntry);
    }
}

void
ucd_snmp_mib_set_prErrFix(GNetSnmp *s, gint32 prIndex, gint32 prErrFix)
{
    ucd_snmp_mib_prEntry_t *prEntry;

    ucd_snmp_mib_get_prEntry(s, &prEntry, prIndex, UCD_SNMP_MIB_PRERRFIX);
    if (s->error_status || !prEntry) return;
    prEntry->prErrFix = &prErrFix;
    ucd_snmp_mib_set_prEntry(s, prEntry, UCD_SNMP_MIB_PRERRFIX);
    ucd_snmp_mib_free_prEntry(prEntry);
}

ucd_snmp_mib_memory_t *
ucd_snmp_mib_new_memory()
{
    ucd_snmp_mib_memory_t *memory;

    memory = (ucd_snmp_mib_memory_t *) g_malloc0(sizeof(ucd_snmp_mib_memory_t) + sizeof(gpointer));
    return memory;
}

static inline ucd_snmp_mib_memory_t *
assign_memory(GList *vbl)
{
    ucd_snmp_mib_memory_t *memory;
    char *p;

    memory = ucd_snmp_mib_new_memory();
    p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, memory_oid, G_N_ELEMENTS(memory_oid),
                      memory_attr, memory);

    return memory;
}

void
ucd_snmp_mib_get_memory(GNetSnmp *s, ucd_snmp_mib_memory_t **memory, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 4, 0};

    *memory = NULL;

    gnet_snmp_attr_get(s, &in, base, 9, 8, memory_attr, mask);

    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *memory = assign_memory(out);
    }
}

void
ucd_snmp_mib_free_memory(ucd_snmp_mib_memory_t *memory)
{
    GList *vbl;
    char *p;

    if (memory) {
        p = (char *) memory + sizeof(ucd_snmp_mib_memory_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(memory);
    }
}

ucd_snmp_mib_extEntry_t *
ucd_snmp_mib_new_extEntry()
{
    ucd_snmp_mib_extEntry_t *extEntry;

    extEntry = (ucd_snmp_mib_extEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_extEntry_t) + sizeof(gpointer));
    return extEntry;
}

static inline int
unpack_extEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_extEntry_t *extEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    extEntry->extIndex = vb->oid[idx++];
    if ((extEntry->extIndex < 0 || extEntry->extIndex > 65535)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_extEntry(guint32 *base, gint32 extIndex)
{
    guint8 idx = 10;

    base[idx++] = extIndex;
    return idx;
}

static inline ucd_snmp_mib_extEntry_t *
assign_extEntry(GList *vbl)
{
    ucd_snmp_mib_extEntry_t *extEntry;
    char *p;

    extEntry = ucd_snmp_mib_new_extEntry();
    p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
    * (GList **) p = vbl;

    if (unpack_extEntry((GNetSnmpVarBind *) vbl->data, extEntry) < 0) {
        g_warning("%s: invalid instance identifier", "extEntry");
        g_free(extEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, extEntry_oid, G_N_ELEMENTS(extEntry_oid),
                      extEntry_attr, extEntry);

    return extEntry;
}

void
ucd_snmp_mib_get_extTable(GNetSnmp *s, ucd_snmp_mib_extEntry_t ***extEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 8, 1, 0};

    *extEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, extEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *extEntry = (ucd_snmp_mib_extEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_extEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*extEntry)[i] = assign_extEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_extEntry(GNetSnmp *s, ucd_snmp_mib_extEntry_t **extEntry, gint32 extIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *extEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, extEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *extEntry = assign_extEntry(out);
    }
}

void
ucd_snmp_mib_set_extEntry(GNetSnmp *s, ucd_snmp_mib_extEntry_t *extEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, extEntry_oid, sizeof(extEntry_oid));
    len = pack_extEntry(base, extEntry->extIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "extEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, extEntry_attr, mask, extEntry);

    out = gnet_snmp_sync_set(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(out);
    }
}

void
ucd_snmp_mib_free_extEntry(ucd_snmp_mib_extEntry_t *extEntry)
{
    GList *vbl;
    char *p;

    if (extEntry) {
        p = (char *) extEntry + sizeof(ucd_snmp_mib_extEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_free_extTable(ucd_snmp_mib_extEntry_t **extEntry)
{
    int i;

    if (extEntry) {
        for (i = 0; extEntry[i]; i++) {
            ucd_snmp_mib_free_extEntry(extEntry[i]);
        }
        g_free(extEntry);
    }
}

void
ucd_snmp_mib_set_extErrFix(GNetSnmp *s, gint32 extIndex, gint32 extErrFix)
{
    ucd_snmp_mib_extEntry_t *extEntry;

    ucd_snmp_mib_get_extEntry(s, &extEntry, extIndex, UCD_SNMP_MIB_EXTERRFIX);
    if (s->error_status || !extEntry) return;
    extEntry->extErrFix = &extErrFix;
    ucd_snmp_mib_set_extEntry(s, extEntry, UCD_SNMP_MIB_EXTERRFIX);
    ucd_snmp_mib_free_extEntry(extEntry);
}

ucd_snmp_mib_dskEntry_t *
ucd_snmp_mib_new_dskEntry()
{
    ucd_snmp_mib_dskEntry_t *dskEntry;

    dskEntry = (ucd_snmp_mib_dskEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_dskEntry_t) + sizeof(gpointer));
    return dskEntry;
}

static inline int
unpack_dskEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_dskEntry_t *dskEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    dskEntry->dskIndex = vb->oid[idx++];
    if ((dskEntry->dskIndex < 0 || dskEntry->dskIndex > 65535)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_dskEntry(guint32 *base, gint32 dskIndex)
{
    guint8 idx = 10;

    base[idx++] = dskIndex;
    return idx;
}

static inline ucd_snmp_mib_dskEntry_t *
assign_dskEntry(GList *vbl)
{
    ucd_snmp_mib_dskEntry_t *dskEntry;
    char *p;

    dskEntry = ucd_snmp_mib_new_dskEntry();
    p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
    * (GList **) p = vbl;

    if (unpack_dskEntry((GNetSnmpVarBind *) vbl->data, dskEntry) < 0) {
        g_warning("%s: invalid instance identifier", "dskEntry");
        g_free(dskEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, dskEntry_oid, G_N_ELEMENTS(dskEntry_oid),
                      dskEntry_attr, dskEntry);

    return dskEntry;
}

void
ucd_snmp_mib_get_dskTable(GNetSnmp *s, ucd_snmp_mib_dskEntry_t ***dskEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 9, 1, 0};

    *dskEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, dskEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *dskEntry = (ucd_snmp_mib_dskEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_dskEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*dskEntry)[i] = assign_dskEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_dskEntry(GNetSnmp *s, ucd_snmp_mib_dskEntry_t **dskEntry, gint32 dskIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, dskEntry_oid, sizeof(dskEntry_oid));
    len = pack_dskEntry(base, dskIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "dskEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *dskEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, dskEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *dskEntry = assign_dskEntry(out);
    }
}

void
ucd_snmp_mib_free_dskEntry(ucd_snmp_mib_dskEntry_t *dskEntry)
{
    GList *vbl;
    char *p;

    if (dskEntry) {
        p = (char *) dskEntry + sizeof(ucd_snmp_mib_dskEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(dskEntry);
    }
}

void
ucd_snmp_mib_free_dskTable(ucd_snmp_mib_dskEntry_t **dskEntry)
{
    int i;

    if (dskEntry) {
        for (i = 0; dskEntry[i]; i++) {
            ucd_snmp_mib_free_dskEntry(dskEntry[i]);
        }
        g_free(dskEntry);
    }
}

ucd_snmp_mib_laEntry_t *
ucd_snmp_mib_new_laEntry()
{
    ucd_snmp_mib_laEntry_t *laEntry;

    laEntry = (ucd_snmp_mib_laEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_laEntry_t) + sizeof(gpointer));
    return laEntry;
}

static inline int
unpack_laEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_laEntry_t *laEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    laEntry->laIndex = vb->oid[idx++];
    if ((laEntry->laIndex < 0 || laEntry->laIndex > 3)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_laEntry(guint32 *base, gint32 laIndex)
{
    guint8 idx = 10;

    base[idx++] = laIndex;
    return idx;
}

static inline ucd_snmp_mib_laEntry_t *
assign_laEntry(GList *vbl)
{
    ucd_snmp_mib_laEntry_t *laEntry;
    char *p;

    laEntry = ucd_snmp_mib_new_laEntry();
    p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
    * (GList **) p = vbl;

    if (unpack_laEntry((GNetSnmpVarBind *) vbl->data, laEntry) < 0) {
        g_warning("%s: invalid instance identifier", "laEntry");
        g_free(laEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, laEntry_oid, G_N_ELEMENTS(laEntry_oid),
                      laEntry_attr, laEntry);

    return laEntry;
}

void
ucd_snmp_mib_get_laTable(GNetSnmp *s, ucd_snmp_mib_laEntry_t ***laEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 10, 1, 0};

    *laEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, laEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *laEntry = (ucd_snmp_mib_laEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_laEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*laEntry)[i] = assign_laEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_laEntry(GNetSnmp *s, ucd_snmp_mib_laEntry_t **laEntry, gint32 laIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, laEntry_oid, sizeof(laEntry_oid));
    len = pack_laEntry(base, laIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "laEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *laEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, laEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *laEntry = assign_laEntry(out);
    }
}

void
ucd_snmp_mib_free_laEntry(ucd_snmp_mib_laEntry_t *laEntry)
{
    GList *vbl;
    char *p;

    if (laEntry) {
        p = (char *) laEntry + sizeof(ucd_snmp_mib_laEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(laEntry);
    }
}

void
ucd_snmp_mib_free_laTable(ucd_snmp_mib_laEntry_t **laEntry)
{
    int i;

    if (laEntry) {
        for (i = 0; laEntry[i]; i++) {
            ucd_snmp_mib_free_laEntry(laEntry[i]);
        }
        g_free(laEntry);
    }
}

ucd_snmp_mib_systemStats_t *
ucd_snmp_mib_new_systemStats()
{
    ucd_snmp_mib_systemStats_t *systemStats;

    systemStats = (ucd_snmp_mib_systemStats_t *) g_malloc0(sizeof(ucd_snmp_mib_systemStats_t) + sizeof(gpointer));
    return systemStats;
}

static inline ucd_snmp_mib_systemStats_t *
assign_systemStats(GList *vbl)
{
    ucd_snmp_mib_systemStats_t *systemStats;
    char *p;

    systemStats = ucd_snmp_mib_new_systemStats();
    p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, systemStats_oid, G_N_ELEMENTS(systemStats_oid),
                      systemStats_attr, systemStats);

    return systemStats;
}

void
ucd_snmp_mib_get_systemStats(GNetSnmp *s, ucd_snmp_mib_systemStats_t **systemStats, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 11, 0};

    *systemStats = NULL;

    gnet_snmp_attr_get(s, &in, base, 9, 8, systemStats_attr, mask);

    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *systemStats = assign_systemStats(out);
    }
}

void
ucd_snmp_mib_free_systemStats(ucd_snmp_mib_systemStats_t *systemStats)
{
    GList *vbl;
    char *p;

    if (systemStats) {
        p = (char *) systemStats + sizeof(ucd_snmp_mib_systemStats_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(systemStats);
    }
}

ucd_snmp_mib_fileEntry_t *
ucd_snmp_mib_new_fileEntry()
{
    ucd_snmp_mib_fileEntry_t *fileEntry;

    fileEntry = (ucd_snmp_mib_fileEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_fileEntry_t) + sizeof(gpointer));
    return fileEntry;
}

static inline int
unpack_fileEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_fileEntry_t *fileEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    fileEntry->fileIndex = vb->oid[idx++];
    if ((fileEntry->fileIndex < 0)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_fileEntry(guint32 *base, gint32 fileIndex)
{
    guint8 idx = 10;

    base[idx++] = fileIndex;
    return idx;
}

static inline ucd_snmp_mib_fileEntry_t *
assign_fileEntry(GList *vbl)
{
    ucd_snmp_mib_fileEntry_t *fileEntry;
    char *p;

    fileEntry = ucd_snmp_mib_new_fileEntry();
    p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
    * (GList **) p = vbl;

    if (unpack_fileEntry((GNetSnmpVarBind *) vbl->data, fileEntry) < 0) {
        g_warning("%s: invalid instance identifier", "fileEntry");
        g_free(fileEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, fileEntry_oid, G_N_ELEMENTS(fileEntry_oid),
                      fileEntry_attr, fileEntry);

    return fileEntry;
}

void
ucd_snmp_mib_get_fileTable(GNetSnmp *s, ucd_snmp_mib_fileEntry_t ***fileEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 15, 1, 0};

    *fileEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, fileEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *fileEntry = (ucd_snmp_mib_fileEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_fileEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*fileEntry)[i] = assign_fileEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_fileEntry(GNetSnmp *s, ucd_snmp_mib_fileEntry_t **fileEntry, gint32 fileIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, fileEntry_oid, sizeof(fileEntry_oid));
    len = pack_fileEntry(base, fileIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "fileEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *fileEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, fileEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *fileEntry = assign_fileEntry(out);
    }
}

void
ucd_snmp_mib_free_fileEntry(ucd_snmp_mib_fileEntry_t *fileEntry)
{
    GList *vbl;
    char *p;

    if (fileEntry) {
        p = (char *) fileEntry + sizeof(ucd_snmp_mib_fileEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(fileEntry);
    }
}

void
ucd_snmp_mib_free_fileTable(ucd_snmp_mib_fileEntry_t **fileEntry)
{
    int i;

    if (fileEntry) {
        for (i = 0; fileEntry[i]; i++) {
            ucd_snmp_mib_free_fileEntry(fileEntry[i]);
        }
        g_free(fileEntry);
    }
}

ucd_snmp_mib_logMatch_t *
ucd_snmp_mib_new_logMatch()
{
    ucd_snmp_mib_logMatch_t *logMatch;

    logMatch = (ucd_snmp_mib_logMatch_t *) g_malloc0(sizeof(ucd_snmp_mib_logMatch_t) + sizeof(gpointer));
    return logMatch;
}

static inline ucd_snmp_mib_logMatch_t *
assign_logMatch(GList *vbl)
{
    ucd_snmp_mib_logMatch_t *logMatch;
    char *p;

    logMatch = ucd_snmp_mib_new_logMatch();
    p = (char *) logMatch + sizeof(ucd_snmp_mib_logMatch_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, logMatch_oid, G_N_ELEMENTS(logMatch_oid),
                      logMatch_attr, logMatch);

    return logMatch;
}

void
ucd_snmp_mib_get_logMatch(GNetSnmp *s, ucd_snmp_mib_logMatch_t **logMatch, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 16, 0};

    *logMatch = NULL;

    gnet_snmp_attr_get(s, &in, base, 9, 8, logMatch_attr, mask);

    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *logMatch = assign_logMatch(out);
    }
}

void
ucd_snmp_mib_free_logMatch(ucd_snmp_mib_logMatch_t *logMatch)
{
    GList *vbl;
    char *p;

    if (logMatch) {
        p = (char *) logMatch + sizeof(ucd_snmp_mib_logMatch_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(logMatch);
    }
}

ucd_snmp_mib_logMatchEntry_t *
ucd_snmp_mib_new_logMatchEntry()
{
    ucd_snmp_mib_logMatchEntry_t *logMatchEntry;

    logMatchEntry = (ucd_snmp_mib_logMatchEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_logMatchEntry_t) + sizeof(gpointer));
    return logMatchEntry;
}

static inline int
unpack_logMatchEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_logMatchEntry_t *logMatchEntry)
{
    guint8 idx = 11;

    if (vb->oid_len < idx) return -1;
    logMatchEntry->logMatchIndex = vb->oid[idx++];
    if ((logMatchEntry->logMatchIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_logMatchEntry(guint32 *base, gint32 logMatchIndex)
{
    guint8 idx = 11;

    base[idx++] = logMatchIndex;
    return idx;
}

static inline ucd_snmp_mib_logMatchEntry_t *
assign_logMatchEntry(GList *vbl)
{
    ucd_snmp_mib_logMatchEntry_t *logMatchEntry;
    char *p;

    logMatchEntry = ucd_snmp_mib_new_logMatchEntry();
    p = (char *) logMatchEntry + sizeof(ucd_snmp_mib_logMatchEntry_t);
    * (GList **) p = vbl;

    if (unpack_logMatchEntry((GNetSnmpVarBind *) vbl->data, logMatchEntry) < 0) {
        g_warning("%s: invalid instance identifier", "logMatchEntry");
        g_free(logMatchEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, logMatchEntry_oid, G_N_ELEMENTS(logMatchEntry_oid),
                      logMatchEntry_attr, logMatchEntry);

    return logMatchEntry;
}

void
ucd_snmp_mib_get_logMatchTable(GNetSnmp *s, ucd_snmp_mib_logMatchEntry_t ***logMatchEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 16, 2, 1, 0};

    *logMatchEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 11, 10, logMatchEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *logMatchEntry = (ucd_snmp_mib_logMatchEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_logMatchEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*logMatchEntry)[i] = assign_logMatchEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_logMatchEntry(GNetSnmp *s, ucd_snmp_mib_logMatchEntry_t **logMatchEntry, gint32 logMatchIndex, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, logMatchEntry_oid, sizeof(logMatchEntry_oid));
    len = pack_logMatchEntry(base, logMatchIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "logMatchEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *logMatchEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 10, logMatchEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *logMatchEntry = assign_logMatchEntry(out);
    }
}

void
ucd_snmp_mib_free_logMatchEntry(ucd_snmp_mib_logMatchEntry_t *logMatchEntry)
{
    GList *vbl;
    char *p;

    if (logMatchEntry) {
        p = (char *) logMatchEntry + sizeof(ucd_snmp_mib_logMatchEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(logMatchEntry);
    }
}

void
ucd_snmp_mib_free_logMatchTable(ucd_snmp_mib_logMatchEntry_t **logMatchEntry)
{
    int i;

    if (logMatchEntry) {
        for (i = 0; logMatchEntry[i]; i++) {
            ucd_snmp_mib_free_logMatchEntry(logMatchEntry[i]);
        }
        g_free(logMatchEntry);
    }
}

ucd_snmp_mib_version_t *
ucd_snmp_mib_new_version()
{
    ucd_snmp_mib_version_t *version;

    version = (ucd_snmp_mib_version_t *) g_malloc0(sizeof(ucd_snmp_mib_version_t) + sizeof(gpointer));
    return version;
}

static inline ucd_snmp_mib_version_t *
assign_version(GList *vbl)
{
    ucd_snmp_mib_version_t *version;
    char *p;

    version = ucd_snmp_mib_new_version();
    p = (char *) version + sizeof(ucd_snmp_mib_version_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, version_oid, G_N_ELEMENTS(version_oid),
                      version_attr, version);

    return version;
}

void
ucd_snmp_mib_get_version(GNetSnmp *s, ucd_snmp_mib_version_t **version, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0};

    *version = NULL;

    gnet_snmp_attr_get(s, &in, base, 9, 8, version_attr, mask);

    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *version = assign_version(out);
    }
}

void
ucd_snmp_mib_set_version(GNetSnmp *s, ucd_snmp_mib_version_t *version, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 100, 0, 0};

    gnet_snmp_attr_set(s, &in, base, 10, 8, version_attr, mask, version);

    out = gnet_snmp_sync_set(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(out);
    }
}

void
ucd_snmp_mib_free_version(ucd_snmp_mib_version_t *version)
{
    GList *vbl;
    char *p;

    if (version) {
        p = (char *) version + sizeof(ucd_snmp_mib_version_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(version);
    }
}

void
ucd_snmp_mib_set_versionClearCache(GNetSnmp *s, gint32 versionClearCache)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONCLEARCACHE);
    if (s->error_status || !version) return;
    version->versionClearCache = &versionClearCache;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONCLEARCACHE);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionUpdateConfig(GNetSnmp *s, gint32 versionUpdateConfig)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONUPDATECONFIG);
    if (s->error_status || !version) return;
    version->versionUpdateConfig = &versionUpdateConfig;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONUPDATECONFIG);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionRestartAgent(GNetSnmp *s, gint32 versionRestartAgent)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONRESTARTAGENT);
    if (s->error_status || !version) return;
    version->versionRestartAgent = &versionRestartAgent;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONRESTARTAGENT);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionSavePersistentData(GNetSnmp *s, gint32 versionSavePersistentData)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONSAVEPERSISTENTDATA);
    if (s->error_status || !version) return;
    version->versionSavePersistentData = &versionSavePersistentData;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONSAVEPERSISTENTDATA);
    ucd_snmp_mib_free_version(version);
}

void
ucd_snmp_mib_set_versionDoDebugging(GNetSnmp *s, gint32 versionDoDebugging)
{
    ucd_snmp_mib_version_t *version;

    ucd_snmp_mib_get_version(s, &version, UCD_SNMP_MIB_VERSIONDODEBUGGING);
    if (s->error_status || !version) return;
    version->versionDoDebugging = &versionDoDebugging;
    ucd_snmp_mib_set_version(s, version, UCD_SNMP_MIB_VERSIONDODEBUGGING);
    ucd_snmp_mib_free_version(version);
}

ucd_snmp_mib_snmperrs_t *
ucd_snmp_mib_new_snmperrs()
{
    ucd_snmp_mib_snmperrs_t *snmperrs;

    snmperrs = (ucd_snmp_mib_snmperrs_t *) g_malloc0(sizeof(ucd_snmp_mib_snmperrs_t) + sizeof(gpointer));
    return snmperrs;
}

static inline ucd_snmp_mib_snmperrs_t *
assign_snmperrs(GList *vbl)
{
    ucd_snmp_mib_snmperrs_t *snmperrs;
    char *p;

    snmperrs = ucd_snmp_mib_new_snmperrs();
    p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, snmperrs_oid, G_N_ELEMENTS(snmperrs_oid),
                      snmperrs_attr, snmperrs);

    return snmperrs;
}

void
ucd_snmp_mib_get_snmperrs(GNetSnmp *s, ucd_snmp_mib_snmperrs_t **snmperrs, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 101, 0};

    *snmperrs = NULL;

    gnet_snmp_attr_get(s, &in, base, 9, 8, snmperrs_attr, mask);

    out = gnet_snmp_sync_getnext(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *snmperrs = assign_snmperrs(out);
    }
}

void
ucd_snmp_mib_free_snmperrs(ucd_snmp_mib_snmperrs_t *snmperrs)
{
    GList *vbl;
    char *p;

    if (snmperrs) {
        p = (char *) snmperrs + sizeof(ucd_snmp_mib_snmperrs_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(snmperrs);
    }
}

ucd_snmp_mib_mrEntry_t *
ucd_snmp_mib_new_mrEntry()
{
    ucd_snmp_mib_mrEntry_t *mrEntry;

    mrEntry = (ucd_snmp_mib_mrEntry_t *) g_malloc0(sizeof(ucd_snmp_mib_mrEntry_t) + sizeof(gpointer));
    return mrEntry;
}

static inline int
unpack_mrEntry(GNetSnmpVarBind *vb, ucd_snmp_mib_mrEntry_t *mrEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    len = vb->oid_len - idx;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        mrEntry->mrIndex[i] = vb->oid[idx++];
    }
    mrEntry->_mrIndexLength = len;
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_mrEntry(guint32 *base, guint32 *mrIndex, guint16 _mrIndexLength)
{
    guint8 idx = 10;
    guint16 i, len;

    len = _mrIndexLength;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = mrIndex[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ucd_snmp_mib_mrEntry_t *
assign_mrEntry(GList *vbl)
{
    ucd_snmp_mib_mrEntry_t *mrEntry;
    char *p;

    mrEntry = ucd_snmp_mib_new_mrEntry();
    p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
    * (GList **) p = vbl;

    if (unpack_mrEntry((GNetSnmpVarBind *) vbl->data, mrEntry) < 0) {
        g_warning("%s: invalid instance identifier", "mrEntry");
        g_free(mrEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, mrEntry_oid, G_N_ELEMENTS(mrEntry_oid),
                      mrEntry_attr, mrEntry);

    return mrEntry;
}

void
ucd_snmp_mib_get_mrTable(GNetSnmp *s, ucd_snmp_mib_mrEntry_t ***mrEntry, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2021, 102, 1, 0};

    *mrEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, 10, 9, mrEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *mrEntry = (ucd_snmp_mib_mrEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ucd_snmp_mib_mrEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*mrEntry)[i] = assign_mrEntry(row->data);
        }
    }
}

void
ucd_snmp_mib_get_mrEntry(GNetSnmp *s, ucd_snmp_mib_mrEntry_t **mrEntry, guint32 *mrIndex, guint16 _mrIndexLength, gint64 mask)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, mrEntry_oid, sizeof(mrEntry_oid));
    len = pack_mrEntry(base, mrIndex, _mrIndexLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "mrEntry");
        s->error_status = GNET_SNMP_ERR_INTERNAL;
        return;
    }

    *mrEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, mrEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_free, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_free, NULL);
            g_list_free(out);
            return;
        }
        *mrEntry = assign_mrEntry(out);
    }
}

void
ucd_snmp_mib_free_mrEntry(ucd_snmp_mib_mrEntry_t *mrEntry)
{
    GList *vbl;
    char *p;

    if (mrEntry) {
        p = (char *) mrEntry + sizeof(ucd_snmp_mib_mrEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_free, NULL);
        g_list_free(vbl);
        g_free(mrEntry);
    }
}

void
ucd_snmp_mib_free_mrTable(ucd_snmp_mib_mrEntry_t **mrEntry)
{
    int i;

    if (mrEntry) {
        for (i = 0; mrEntry[i]; i++) {
            ucd_snmp_mib_free_mrEntry(mrEntry[i]);
        }
        g_free(mrEntry);
    }
}


