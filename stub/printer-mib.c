/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from Printer-MIB:
 *   The MIB module for management of printers.
 *
 * Revision 2001-08-30 00:00:
 *   Printer MIB v2.
 *   Five new OBJECT-GROUPs: prtAuxilliarySheetGroup,
 *      prtInputSwitchingGroup, prtGeneralV2Group,
 *      prtAlertTableV2Group, prtChannelV2Group.
 *   Nine new objects added to those groups:
 *      prtAuxiliarySheetStartupPage, prtAuxiliarySheetBannerPage,
 *      prtGeneralPrinterName, prtGeneralSerialNumber,
 *      prtAlertCriticalEvents, prtAlertAllEvents,
 *      prtInputMediaLoadTimeout, prtInputNextIndex,
 *      prtChannelInformation.
 *   One new NOTIFICATION-GROUP: prtAlertTrapGroup which contains
 *      printerV2Alert.
 *   In MODULE-COMPLIANCE prtMIBCompliance, new OBJECT-GROUPs and
 *      the NOTIFICATION_GROUP, all in GROUP (not MANDATORY-GROUP)
 *      clauses.  The nine new objects are optional, i.e., this draft
 *      is backward compatible with RFC 1759.
 *
 * Revision 1994-11-25 00:00:
 *   The original version of this MIB, published as RFC1759.
 *
 * $Id$
 */

#include "printer-mib.h"

GSnmpEnum const printer_mib_enums_prtGeneralReset[] = {
    { PRINTER_MIB_PRTGENERALRESET_NOTRESETTING,	"notResetting" },
    { PRINTER_MIB_PRTGENERALRESET_POWERCYCLERESET,	"powerCycleReset" },
    { PRINTER_MIB_PRTGENERALRESET_RESETTONVRAM,	"resetToNVRAM" },
    { PRINTER_MIB_PRTGENERALRESET_RESETTOFACTORYDEFAULTS,	"resetToFactoryDefaults" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtConsoleDisable[] = {
    { PRINTER_MIB_PRTCONSOLEDISABLE_OPERATORCONSOLEENABLED,	"operatorConsoleEnabled" },
    { PRINTER_MIB_PRTCONSOLEDISABLE_OPERATORCONSOLEDISABLED,	"operatorConsoleDisabled" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAuxiliarySheetStartupPage[] = {
    { PRINTER_MIB_PRTAUXILIARYSHEETSTARTUPPAGE_OTHER,	"other" },
    { PRINTER_MIB_PRTAUXILIARYSHEETSTARTUPPAGE_ON,	"on" },
    { PRINTER_MIB_PRTAUXILIARYSHEETSTARTUPPAGE_OFF,	"off" },
    { PRINTER_MIB_PRTAUXILIARYSHEETSTARTUPPAGE_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAuxiliarySheetBannerPage[] = {
    { PRINTER_MIB_PRTAUXILIARYSHEETBANNERPAGE_OTHER,	"other" },
    { PRINTER_MIB_PRTAUXILIARYSHEETBANNERPAGE_ON,	"on" },
    { PRINTER_MIB_PRTAUXILIARYSHEETBANNERPAGE_OFF,	"off" },
    { PRINTER_MIB_PRTAUXILIARYSHEETBANNERPAGE_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtCoverStatus[] = {
    { PRINTER_MIB_PRTCOVERSTATUS_OTHER,	"other" },
    { PRINTER_MIB_PRTCOVERSTATUS_COVEROPEN,	"coverOpen" },
    { PRINTER_MIB_PRTCOVERSTATUS_COVERCLOSED,	"coverClosed" },
    { PRINTER_MIB_PRTCOVERSTATUS_INTERLOCKOPEN,	"interlockOpen" },
    { PRINTER_MIB_PRTCOVERSTATUS_INTERLOCKCLOSED,	"interlockClosed" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtLocalizationCharacterSet[] = {
    { PRINTER_MIB_PRTLOCALIZATIONCHARACTERSET_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInputType[] = {
    { PRINTER_MIB_PRTINPUTTYPE_OTHER,	"other" },
    { PRINTER_MIB_PRTINPUTTYPE_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTINPUTTYPE_SHEETFEEDAUTOREMOVABLETRAY,	"sheetFeedAutoRemovableTray" },
    { PRINTER_MIB_PRTINPUTTYPE_SHEETFEEDAUTONONREMOVABLETRAY,	"sheetFeedAutoNonRemovableTray" },
    { PRINTER_MIB_PRTINPUTTYPE_SHEETFEEDMANUAL,	"sheetFeedManual" },
    { PRINTER_MIB_PRTINPUTTYPE_CONTINUOUSROLL,	"continuousRoll" },
    { PRINTER_MIB_PRTINPUTTYPE_CONTINUOUSFANFOLD,	"continuousFanFold" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInputDimUnit[] = {
    { PRINTER_MIB_PRTINPUTDIMUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTINPUTDIMUNIT_MICROMETERS,	"micrometers" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInputCapacityUnit[] = {
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_OTHER,	"other" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_MICROMETERS,	"micrometers" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_SHEETS,	"sheets" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_FEET,	"feet" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_METERS,	"meters" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_ITEMS,	"items" },
    { PRINTER_MIB_PRTINPUTCAPACITYUNIT_PERCENT,	"percent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInputSecurity[] = {
    { PRINTER_MIB_PRTINPUTSECURITY_OTHER,	"other" },
    { PRINTER_MIB_PRTINPUTSECURITY_ON,	"on" },
    { PRINTER_MIB_PRTINPUTSECURITY_OFF,	"off" },
    { PRINTER_MIB_PRTINPUTSECURITY_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputType[] = {
    { PRINTER_MIB_PRTOUTPUTTYPE_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTTYPE_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTOUTPUTTYPE_REMOVABLEBIN,	"removableBin" },
    { PRINTER_MIB_PRTOUTPUTTYPE_UNREMOVABLEBIN,	"unRemovableBin" },
    { PRINTER_MIB_PRTOUTPUTTYPE_CONTINUOUSROLLDEVICE,	"continuousRollDevice" },
    { PRINTER_MIB_PRTOUTPUTTYPE_MAILBOX,	"mailBox" },
    { PRINTER_MIB_PRTOUTPUTTYPE_CONTINUOUSFANFOLD,	"continuousFanFold" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputCapacityUnit[] = {
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_MICROMETERS,	"micrometers" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_SHEETS,	"sheets" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_FEET,	"feet" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_METERS,	"meters" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_ITEMS,	"items" },
    { PRINTER_MIB_PRTOUTPUTCAPACITYUNIT_PERCENT,	"percent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputSecurity[] = {
    { PRINTER_MIB_PRTOUTPUTSECURITY_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTSECURITY_ON,	"on" },
    { PRINTER_MIB_PRTOUTPUTSECURITY_OFF,	"off" },
    { PRINTER_MIB_PRTOUTPUTSECURITY_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputDimUnit[] = {
    { PRINTER_MIB_PRTOUTPUTDIMUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTOUTPUTDIMUNIT_MICROMETERS,	"micrometers" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputStackingOrder[] = {
    { PRINTER_MIB_PRTOUTPUTSTACKINGORDER_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTOUTPUTSTACKINGORDER_FIRSTTOLAST,	"firstToLast" },
    { PRINTER_MIB_PRTOUTPUTSTACKINGORDER_LASTTOFIRST,	"lastToFirst" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputPageDeliveryOrientation[] = {
    { PRINTER_MIB_PRTOUTPUTPAGEDELIVERYORIENTATION_FACEUP,	"faceUp" },
    { PRINTER_MIB_PRTOUTPUTPAGEDELIVERYORIENTATION_FACEDOWN,	"faceDown" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputBursting[] = {
    { PRINTER_MIB_PRTOUTPUTBURSTING_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTBURSTING_ON,	"on" },
    { PRINTER_MIB_PRTOUTPUTBURSTING_OFF,	"off" },
    { PRINTER_MIB_PRTOUTPUTBURSTING_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputDecollating[] = {
    { PRINTER_MIB_PRTOUTPUTDECOLLATING_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTDECOLLATING_ON,	"on" },
    { PRINTER_MIB_PRTOUTPUTDECOLLATING_OFF,	"off" },
    { PRINTER_MIB_PRTOUTPUTDECOLLATING_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputPageCollated[] = {
    { PRINTER_MIB_PRTOUTPUTPAGECOLLATED_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTPAGECOLLATED_ON,	"on" },
    { PRINTER_MIB_PRTOUTPUTPAGECOLLATED_OFF,	"off" },
    { PRINTER_MIB_PRTOUTPUTPAGECOLLATED_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtOutputOffsetStacking[] = {
    { PRINTER_MIB_PRTOUTPUTOFFSETSTACKING_OTHER,	"other" },
    { PRINTER_MIB_PRTOUTPUTOFFSETSTACKING_ON,	"on" },
    { PRINTER_MIB_PRTOUTPUTOFFSETSTACKING_OFF,	"off" },
    { PRINTER_MIB_PRTOUTPUTOFFSETSTACKING_NOTPRESENT,	"notPresent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerMarkTech[] = {
    { PRINTER_MIB_PRTMARKERMARKTECH_OTHER,	"other" },
    { PRINTER_MIB_PRTMARKERMARKTECH_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTMARKERMARKTECH_ELECTROPHOTOGRAPHICLED,	"electrophotographicLED" },
    { PRINTER_MIB_PRTMARKERMARKTECH_ELECTROPHOTOGRAPHICLASER,	"electrophotographicLaser" },
    { PRINTER_MIB_PRTMARKERMARKTECH_ELECTROPHOTOGRAPHICOTHER,	"electrophotographicOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTMOVINGHEADDOTMATRIX9PIN,	"impactMovingHeadDotMatrix9pin" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTMOVINGHEADDOTMATRIX24PIN,	"impactMovingHeadDotMatrix24pin" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTMOVINGHEADDOTMATRIXOTHER,	"impactMovingHeadDotMatrixOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTMOVINGHEADFULLYFORMED,	"impactMovingHeadFullyFormed" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTBAND,	"impactBand" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IMPACTOTHER,	"impactOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_INKJETAQUEOUS,	"inkjetAqueous" },
    { PRINTER_MIB_PRTMARKERMARKTECH_INKJETSOLID,	"inkjetSolid" },
    { PRINTER_MIB_PRTMARKERMARKTECH_INKJETOTHER,	"inkjetOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_PEN,	"pen" },
    { PRINTER_MIB_PRTMARKERMARKTECH_THERMALTRANSFER,	"thermalTransfer" },
    { PRINTER_MIB_PRTMARKERMARKTECH_THERMALSENSITIVE,	"thermalSensitive" },
    { PRINTER_MIB_PRTMARKERMARKTECH_THERMALDIFFUSION,	"thermalDiffusion" },
    { PRINTER_MIB_PRTMARKERMARKTECH_THERMALOTHER,	"thermalOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_ELECTROEROSION,	"electroerosion" },
    { PRINTER_MIB_PRTMARKERMARKTECH_ELECTROSTATIC,	"electrostatic" },
    { PRINTER_MIB_PRTMARKERMARKTECH_PHOTOGRAPHICMICROFICHE,	"photographicMicrofiche" },
    { PRINTER_MIB_PRTMARKERMARKTECH_PHOTOGRAPHICIMAGESETTER,	"photographicImagesetter" },
    { PRINTER_MIB_PRTMARKERMARKTECH_PHOTOGRAPHICOTHER,	"photographicOther" },
    { PRINTER_MIB_PRTMARKERMARKTECH_IONDEPOSITION,	"ionDeposition" },
    { PRINTER_MIB_PRTMARKERMARKTECH_EBEAM,	"eBeam" },
    { PRINTER_MIB_PRTMARKERMARKTECH_TYPESETTER,	"typesetter" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerCounterUnit[] = {
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_MICROMETERS,	"micrometers" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_CHARACTERS,	"characters" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_LINES,	"lines" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_IMPRESSIONS,	"impressions" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_SHEETS,	"sheets" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_DOTROW,	"dotRow" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_HOURS,	"hours" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_FEET,	"feet" },
    { PRINTER_MIB_PRTMARKERCOUNTERUNIT_METERS,	"meters" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerAddressabilityUnit[] = {
    { PRINTER_MIB_PRTMARKERADDRESSABILITYUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTMARKERADDRESSABILITYUNIT_MICROMETERS,	"micrometers" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerSuppliesClass[] = {
    { PRINTER_MIB_PRTMARKERSUPPLIESCLASS_OTHER,	"other" },
    { PRINTER_MIB_PRTMARKERSUPPLIESCLASS_SUPPLYTHATISCONSUMED,	"supplyThatIsConsumed" },
    { PRINTER_MIB_PRTMARKERSUPPLIESCLASS_RECEPTACLETHATISFILLED,	"receptacleThatIsFilled" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerSuppliesType[] = {
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_OTHER,	"other" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_TONER,	"toner" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WASTETONER,	"wasteToner" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_INK,	"ink" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_INKCARTRIDGE,	"inkCartridge" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_INKRIBBON,	"inkRibbon" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WASTEINK,	"wasteInk" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_OPC,	"opc" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_DEVELOPER,	"developer" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_FUSEROIL,	"fuserOil" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_SOLIDWAX,	"solidWax" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_RIBBONWAX,	"ribbonWax" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WASTEWAX,	"wasteWax" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_FUSER,	"fuser" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_CORONAWIRE,	"coronaWire" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_FUSEROILWICK,	"fuserOilWick" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_CLEANERUNIT,	"cleanerUnit" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_FUSERCLEANINGPAD,	"fuserCleaningPad" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_TRANSFERUNIT,	"transferUnit" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_TONERCARTRIDGE,	"tonerCartridge" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_FUSEROILER,	"fuserOiler" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WATER,	"water" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WASTEWATER,	"wasteWater" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_GLUEWATERADDITIVE,	"glueWaterAdditive" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_WASTEPAPER,	"wastePaper" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_BINDINGSUPPLY,	"bindingSupply" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_BANDINGSUPPLY,	"bandingSupply" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_STITCHINGWIRE,	"stitchingWire" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_SHRINKWRAP,	"shrinkWrap" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_PAPERWRAP,	"paperWrap" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_STAPLES,	"staples" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_INSERTS,	"inserts" },
    { PRINTER_MIB_PRTMARKERSUPPLIESTYPE_COVERS,	"covers" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerSuppliesSupplyUnit[] = {
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_OTHER,	"other" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_MICROMETERS,	"micrometers" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_IMPRESSIONS,	"impressions" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_SHEETS,	"sheets" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_HOURS,	"hours" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_THOUSANDTHSOFOUNCES,	"thousandthsOfOunces" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_TENTHSOFGRAMS,	"tenthsOfGrams" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_HUNDRETHSOFFLUIDOUNCES,	"hundrethsOfFluidOunces" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_TENTHSOFMILLILITERS,	"tenthsOfMilliliters" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_FEET,	"feet" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_METERS,	"meters" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_ITEMS,	"items" },
    { PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT_PERCENT,	"percent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMarkerColorantRole[] = {
    { PRINTER_MIB_PRTMARKERCOLORANTROLE_OTHER,	"other" },
    { PRINTER_MIB_PRTMARKERCOLORANTROLE_PROCESS,	"process" },
    { PRINTER_MIB_PRTMARKERCOLORANTROLE_SPOT,	"spot" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMediaPathMaxSpeedPrintUnit[] = {
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_TENTHOUSANDTHSOFINCHESPERHOUR,	"tenThousandthsOfInchesPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_MICROMETERSPERHOUR,	"micrometersPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_CHARACTERSPERHOUR,	"charactersPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_LINESPERHOUR,	"linesPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_IMPRESSIONSPERHOUR,	"impressionsPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_SHEETSPERHOUR,	"sheetsPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_DOTROWPERHOUR,	"dotRowPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_FEETPERHOUR,	"feetPerHour" },
    { PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT_METERSPERHOUR,	"metersPerHour" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMediaPathMediaSizeUnit[] = {
    { PRINTER_MIB_PRTMEDIAPATHMEDIASIZEUNIT_TENTHOUSANDTHSOFINCHES,	"tenThousandthsOfInches" },
    { PRINTER_MIB_PRTMEDIAPATHMEDIASIZEUNIT_MICROMETERS,	"micrometers" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtMediaPathType[] = {
    { PRINTER_MIB_PRTMEDIAPATHTYPE_OTHER,	"other" },
    { PRINTER_MIB_PRTMEDIAPATHTYPE_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTMEDIAPATHTYPE_LONGEDGEBINDINGDUPLEX,	"longEdgeBindingDuplex" },
    { PRINTER_MIB_PRTMEDIAPATHTYPE_SHORTEDGEBINDINGDUPLEX,	"shortEdgeBindingDuplex" },
    { PRINTER_MIB_PRTMEDIAPATHTYPE_SIMPLEX,	"simplex" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtChannelType[] = {
    { PRINTER_MIB_PRTCHANNELTYPE_OTHER,	"other" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHSERIALPORT,	"chSerialPort" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPARALLELPORT,	"chParallelPort" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIEEE1284PORT,	"chIEEE1284Port" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHSCSIPORT,	"chSCSIPort" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHAPPLETALKPAP,	"chAppleTalkPAP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHLPDSERVER,	"chLPDServer" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHNETWARERPRINTER,	"chNetwareRPrinter" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHNETWAREPSERVER,	"chNetwarePServer" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPORT9100,	"chPort9100" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHAPPSOCKET,	"chAppSocket" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHFTP,	"chFTP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHTFTP,	"chTFTP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHDLCLLCPORT,	"chDLCLLCPort" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIBM3270,	"chIBM3270" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIBM5250,	"chIBM5250" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHFAX,	"chFax" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIEEE1394,	"chIEEE1394" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHTRANSPORT1,	"chTransport1" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHCPAP,	"chCPAP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHDCEREMOTEPROCCALL,	"chDCERemoteProcCall" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHONCREMOTEPROCCALL,	"chONCRemoteProcCall" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHOLE,	"chOLE" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHNAMEDPIPE,	"chNamedPipe" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPCPRINT,	"chPCPrint" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHSERVERMESSAGEBLOCK,	"chServerMessageBlock" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPSM,	"chPSM" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHDLLAPI,	"chDLLAPI" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHVXDAPI,	"chVxDAPI" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHSYSTEMOBJECTMANAGER,	"chSystemObjectManager" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHDECLAT,	"chDECLAT" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHNPAP,	"chNPAP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHUSB,	"chUSB" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIRDA,	"chIRDA" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPRINTXCHANGE,	"chPrintXChange" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPORTTCP,	"chPortTCP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHBIDIRPORTTCP,	"chBidirPortTCP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHUNPP,	"chUNPP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHAPPLETALKADSP,	"chAppleTalkADSP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPORTSPX,	"chPortSPX" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHPORTHTTP,	"chPortHTTP" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHNDPS,	"chNDPS" },
    { PRINTER_MIB_PRTCHANNELTYPE_CHIPP,	"chIPP" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtChannelState[] = {
    { PRINTER_MIB_PRTCHANNELSTATE_OTHER,	"other" },
    { PRINTER_MIB_PRTCHANNELSTATE_PRINTDATAACCEPTED,	"printDataAccepted" },
    { PRINTER_MIB_PRTCHANNELSTATE_NODATAACCEPTED,	"noDataAccepted" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInterpreterLangFamily[] = {
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_OTHER,	"other" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPCL,	"langPCL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGHPGL,	"langHPGL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPJL,	"langPJL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPS,	"langPS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGIPDS,	"langIPDS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPPDS,	"langPPDS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGESCAPEP,	"langEscapeP" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGEPSON,	"langEpson" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGDDIF,	"langDDIF" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGINTERPRESS,	"langInterpress" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGISO6429,	"langISO6429" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGLINEDATA,	"langLineData" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGMODCA,	"langMODCA" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGREGIS,	"langREGIS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGSCS,	"langSCS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGSPDL,	"langSPDL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGTEK4014,	"langTEK4014" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPDS,	"langPDS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGIGP,	"langIGP" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGCODEV,	"langCodeV" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGDSCDSE,	"langDSCDSE" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGWPS,	"langWPS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGLN03,	"langLN03" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGCCITT,	"langCCITT" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGQUIC,	"langQUIC" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGCPAP,	"langCPAP" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGDECPPL,	"langDecPPL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGSIMPLETEXT,	"langSimpleText" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGNPAP,	"langNPAP" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGDOC,	"langDOC" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGIMPRESS,	"langimPress" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPINWRITER,	"langPinwriter" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGNPDL,	"langNPDL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGNEC201PL,	"langNEC201PL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGAUTOMATIC,	"langAutomatic" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPAGES,	"langPages" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGLIPS,	"langLIPS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGTIFF,	"langTIFF" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGDIAGNOSTIC,	"langDiagnostic" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPSPRINTER,	"langPSPrinter" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGCAPSL,	"langCaPSL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGEXCL,	"langEXCL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGLCDS,	"langLCDS" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGXES,	"langXES" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPCLXL,	"langPCLXL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGART,	"langART" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGTIPSI,	"langTIPSI" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPRESCRIBE,	"langPrescribe" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGLINEPRINTER,	"langLinePrinter" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGIDP,	"langIDP" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGXJCL,	"langXJCL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGPDF,	"langPDF" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGRPDL,	"langRPDL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGINTERMECIPL,	"langIntermecIPL" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGUBIFINGERPRINT,	"langUBIFingerprint" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGUBIDIRECTPROTOCOL,	"langUBIDirectProtocol" },
    { PRINTER_MIB_PRTINTERPRETERLANGFAMILY_LANGFUJITSU,	"langFujitsu" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInterpreterDefaultOrientation[] = {
    { PRINTER_MIB_PRTINTERPRETERDEFAULTORIENTATION_OTHER,	"other" },
    { PRINTER_MIB_PRTINTERPRETERDEFAULTORIENTATION_PORTRAIT,	"portrait" },
    { PRINTER_MIB_PRTINTERPRETERDEFAULTORIENTATION_LANDSCAPE,	"landscape" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInterpreterDefaultCharSetIn[] = {
    { PRINTER_MIB_PRTINTERPRETERDEFAULTCHARSETIN_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInterpreterDefaultCharSetOut[] = {
    { PRINTER_MIB_PRTINTERPRETERDEFAULTCHARSETOUT_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtInterpreterTwoWay[] = {
    { PRINTER_MIB_PRTINTERPRETERTWOWAY_YES,	"yes" },
    { PRINTER_MIB_PRTINTERPRETERTWOWAY_NO,	"no" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtConsoleColor[] = {
    { PRINTER_MIB_PRTCONSOLECOLOR_OTHER,	"other" },
    { PRINTER_MIB_PRTCONSOLECOLOR_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTCONSOLECOLOR_WHITE,	"white" },
    { PRINTER_MIB_PRTCONSOLECOLOR_RED,	"red" },
    { PRINTER_MIB_PRTCONSOLECOLOR_GREEN,	"green" },
    { PRINTER_MIB_PRTCONSOLECOLOR_BLUE,	"blue" },
    { PRINTER_MIB_PRTCONSOLECOLOR_CYAN,	"cyan" },
    { PRINTER_MIB_PRTCONSOLECOLOR_MAGENTA,	"magenta" },
    { PRINTER_MIB_PRTCONSOLECOLOR_YELLOW,	"yellow" },
    { PRINTER_MIB_PRTCONSOLECOLOR_ORANGE,	"orange" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAlertSeverityLevel[] = {
    { PRINTER_MIB_PRTALERTSEVERITYLEVEL_OTHER,	"other" },
    { PRINTER_MIB_PRTALERTSEVERITYLEVEL_CRITICAL,	"critical" },
    { PRINTER_MIB_PRTALERTSEVERITYLEVEL_WARNING,	"warning" },
    { PRINTER_MIB_PRTALERTSEVERITYLEVEL_WARNINGBINARYCHANGEEVENT,	"warningBinaryChangeEvent" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAlertTrainingLevel[] = {
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_OTHER,	"other" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_UNTRAINED,	"untrained" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_TRAINED,	"trained" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_FIELDSERVICE,	"fieldService" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_MANAGEMENT,	"management" },
    { PRINTER_MIB_PRTALERTTRAININGLEVEL_NOINTERVENTIONREQUIRED,	"noInterventionRequired" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAlertGroup[] = {
    { PRINTER_MIB_PRTALERTGROUP_OTHER,	"other" },
    { PRINTER_MIB_PRTALERTGROUP_HOSTRESOURCESMIBSTORAGETABLE,	"hostResourcesMIBStorageTable" },
    { PRINTER_MIB_PRTALERTGROUP_HOSTRESOURCESMIBDEVICETABLE,	"hostResourcesMIBDeviceTable" },
    { PRINTER_MIB_PRTALERTGROUP_GENERALPRINTER,	"generalPrinter" },
    { PRINTER_MIB_PRTALERTGROUP_COVER,	"cover" },
    { PRINTER_MIB_PRTALERTGROUP_LOCALIZATION,	"localization" },
    { PRINTER_MIB_PRTALERTGROUP_INPUT,	"input" },
    { PRINTER_MIB_PRTALERTGROUP_OUTPUT,	"output" },
    { PRINTER_MIB_PRTALERTGROUP_MARKER,	"marker" },
    { PRINTER_MIB_PRTALERTGROUP_MARKERSUPPLIES,	"markerSupplies" },
    { PRINTER_MIB_PRTALERTGROUP_MARKERCOLORANT,	"markerColorant" },
    { PRINTER_MIB_PRTALERTGROUP_MEDIAPATH,	"mediaPath" },
    { PRINTER_MIB_PRTALERTGROUP_CHANNEL,	"channel" },
    { PRINTER_MIB_PRTALERTGROUP_INTERPRETER,	"interpreter" },
    { PRINTER_MIB_PRTALERTGROUP_CONSOLEDISPLAYBUFFER,	"consoleDisplayBuffer" },
    { PRINTER_MIB_PRTALERTGROUP_CONSOLELIGHTS,	"consoleLights" },
    { PRINTER_MIB_PRTALERTGROUP_ALERT,	"alert" },
    { PRINTER_MIB_PRTALERTGROUP_FINDEVICE,	"finDevice" },
    { PRINTER_MIB_PRTALERTGROUP_FINSUPPLY,	"finSupply" },
    { PRINTER_MIB_PRTALERTGROUP_FINSUPPLYMEDIAINPUT,	"finSupplyMediaInput" },
    { PRINTER_MIB_PRTALERTGROUP_FINATTRIBUTETABLE,	"finAttributeTable" },
    { 0, NULL }
};

GSnmpEnum const printer_mib_enums_prtAlertCode[] = {
    { PRINTER_MIB_PRTALERTCODE_OTHER,	"other" },
    { PRINTER_MIB_PRTALERTCODE_UNKNOWN,	"unknown" },
    { PRINTER_MIB_PRTALERTCODE_COVEROPEN,	"coverOpen" },
    { PRINTER_MIB_PRTALERTCODE_COVERCLOSED,	"coverClosed" },
    { PRINTER_MIB_PRTALERTCODE_INTERLOCKOPEN,	"interlockOpen" },
    { PRINTER_MIB_PRTALERTCODE_INTERLOCKCLOSED,	"interlockClosed" },
    { PRINTER_MIB_PRTALERTCODE_CONFIGURATIONCHANGE,	"configurationChange" },
    { PRINTER_MIB_PRTALERTCODE_JAM,	"jam" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITMISSING,	"subunitMissing" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITLIFEALMOSTOVER,	"subunitLifeAlmostOver" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITLIFEOVER,	"subunitLifeOver" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITALMOSTEMPTY,	"subunitAlmostEmpty" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITEMPTY,	"subunitEmpty" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITALMOSTFULL,	"subunitAlmostFull" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITFULL,	"subunitFull" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITNEARLIMIT,	"subunitNearLimit" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITATLIMIT,	"subunitAtLimit" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITOPENED,	"subunitOpened" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITCLOSED,	"subunitClosed" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITTURNEDON,	"subunitTurnedOn" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITTURNEDOFF,	"subunitTurnedOff" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITOFFLINE,	"subunitOffline" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITPOWERSAVER,	"subunitPowerSaver" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITWARMINGUP,	"subunitWarmingUp" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITADDED,	"subunitAdded" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITREMOVED,	"subunitRemoved" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITRESOURCEADDED,	"subunitResourceAdded" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITRESOURCEREMOVED,	"subunitResourceRemoved" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITRECOVERABLEFAILURE,	"subunitRecoverableFailure" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITUNRECOVERABLEFAILURE,	"subunitUnrecoverableFailure" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITRECOVERABLESTORAGEERROR,	"subunitRecoverableStorageError" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITUNRECOVERABLESTORAGEERROR,	"subunitUnrecoverableStorageError" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITMOTORFAILURE,	"subunitMotorFailure" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITMEMORYEXHAUSTED,	"subunitMemoryExhausted" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITUNDERTEMPERATURE,	"subunitUnderTemperature" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITOVERTEMPERATURE,	"subunitOverTemperature" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITTIMINGFAILURE,	"subunitTimingFailure" },
    { PRINTER_MIB_PRTALERTCODE_SUBUNITTHERMISTORFAILURE,	"subunitThermistorFailure" },
    { PRINTER_MIB_PRTALERTCODE_DOOROPEN,	"doorOpen" },
    { PRINTER_MIB_PRTALERTCODE_DOORCLOSED,	"doorClosed" },
    { PRINTER_MIB_PRTALERTCODE_POWERUP,	"powerUp" },
    { PRINTER_MIB_PRTALERTCODE_POWERDOWN,	"powerDown" },
    { PRINTER_MIB_PRTALERTCODE_PRINTERNMSRESET,	"printerNMSReset" },
    { PRINTER_MIB_PRTALERTCODE_PRINTERMANUALRESET,	"printerManualReset" },
    { PRINTER_MIB_PRTALERTCODE_PRINTERREADYTOPRINT,	"printerReadyToPrint" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIATRAYMISSING,	"inputMediaTrayMissing" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIASIZECHANGE,	"inputMediaSizeChange" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIAWEIGHTCHANGE,	"inputMediaWeightChange" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIATYPECHANGE,	"inputMediaTypeChange" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIACOLORCHANGE,	"inputMediaColorChange" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIAFORMPARTSCHANGE,	"inputMediaFormPartsChange" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIASUPPLYLOW,	"inputMediaSupplyLow" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIASUPPLYEMPTY,	"inputMediaSupplyEmpty" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMEDIACHANGEREQUEST,	"inputMediaChangeRequest" },
    { PRINTER_MIB_PRTALERTCODE_INPUTMANUALINPUTREQUEST,	"inputManualInputRequest" },
    { PRINTER_MIB_PRTALERTCODE_INPUTTRAYPOSITIONFAILURE,	"inputTrayPositionFailure" },
    { PRINTER_MIB_PRTALERTCODE_INPUTTRAYELEVATIONFAILURE,	"inputTrayElevationFailure" },
    { PRINTER_MIB_PRTALERTCODE_INPUTCANNOTFEEDSIZESELECTED,	"inputCannotFeedSizeSelected" },
    { PRINTER_MIB_PRTALERTCODE_OUTPUTMEDIATRAYMISSING,	"outputMediaTrayMissing" },
    { PRINTER_MIB_PRTALERTCODE_OUTPUTMEDIATRAYALMOSTFULL,	"outputMediaTrayAlmostFull" },
    { PRINTER_MIB_PRTALERTCODE_OUTPUTMEDIATRAYFULL,	"outputMediaTrayFull" },
    { PRINTER_MIB_PRTALERTCODE_OUTPUTMAILBOXSELECTFAILURE,	"outputMailboxSelectFailure" },
    { PRINTER_MIB_PRTALERTCODE_MARKERFUSERUNDERTEMPERATURE,	"markerFuserUnderTemperature" },
    { PRINTER_MIB_PRTALERTCODE_MARKERFUSEROVERTEMPERATURE,	"markerFuserOverTemperature" },
    { PRINTER_MIB_PRTALERTCODE_MARKERFUSERTIMINGFAILURE,	"markerFuserTimingFailure" },
    { PRINTER_MIB_PRTALERTCODE_MARKERFUSERTHERMISTORFAILURE,	"markerFuserThermistorFailure" },
    { PRINTER_MIB_PRTALERTCODE_MARKERADJUSTINGPRINTQUALITY,	"markerAdjustingPrintQuality" },
    { PRINTER_MIB_PRTALERTCODE_MARKERTONEREMPTY,	"markerTonerEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERINKEMPTY,	"markerInkEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERPRINTRIBBONEMPTY,	"markerPrintRibbonEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERTONERALMOSTEMPTY,	"markerTonerAlmostEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERINKALMOSTEMPTY,	"markerInkAlmostEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERPRINTRIBBONALMOSTEMPTY,	"markerPrintRibbonAlmostEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERWASTETONERRECEPTACLEALMOSTFULL,	"markerWasteTonerReceptacleAlmostFull" },
    { PRINTER_MIB_PRTALERTCODE_MARKERWASTEINKRECEPTACLEALMOSTFULL,	"markerWasteInkReceptacleAlmostFull" },
    { PRINTER_MIB_PRTALERTCODE_MARKERWASTETONERRECEPTACLEFULL,	"markerWasteTonerReceptacleFull" },
    { PRINTER_MIB_PRTALERTCODE_MARKERWASTEINKRECEPTACLEFULL,	"markerWasteInkReceptacleFull" },
    { PRINTER_MIB_PRTALERTCODE_MARKEROPCLIFEALMOSTOVER,	"markerOpcLifeAlmostOver" },
    { PRINTER_MIB_PRTALERTCODE_MARKEROPCLIFEOVER,	"markerOpcLifeOver" },
    { PRINTER_MIB_PRTALERTCODE_MARKERDEVELOPERALMOSTEMPTY,	"markerDeveloperAlmostEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERDEVELOPEREMPTY,	"markerDeveloperEmpty" },
    { PRINTER_MIB_PRTALERTCODE_MARKERTONERCARTRIDGEMISSING,	"markerTonerCartridgeMissing" },
    { PRINTER_MIB_PRTALERTCODE_MEDIAPATHMEDIATRAYMISSING,	"mediaPathMediaTrayMissing" },
    { PRINTER_MIB_PRTALERTCODE_MEDIAPATHMEDIATRAYALMOSTFULL,	"mediaPathMediaTrayAlmostFull" },
    { PRINTER_MIB_PRTALERTCODE_MEDIAPATHMEDIATRAYFULL,	"mediaPathMediaTrayFull" },
    { PRINTER_MIB_PRTALERTCODE_MEDIAPATHCANNOTDUPLEXMEDIASELECTED,	"mediaPathcannotDuplexMediaSelected" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERMEMORYINCREASE,	"interpreterMemoryIncrease" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERMEMORYDECREASE,	"interpreterMemoryDecrease" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERCARTRIDGEADDED,	"interpreterCartridgeAdded" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERCARTRIDGEDELETED,	"interpreterCartridgeDeleted" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERRESOURCEADDED,	"interpreterResourceAdded" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERRESOURCEDELETED,	"interpreterResourceDeleted" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERRESOURCEUNAVAILABLE,	"interpreterResourceUnavailable" },
    { PRINTER_MIB_PRTALERTCODE_INTERPRETERCOMPLEXPAGEENCOUNTERED,	"interpreterComplexPageEncountered" },
    { PRINTER_MIB_PRTALERTCODE_ALERTREMOVALOFBINARYCHANGEENTRY,	"alertRemovalOfBinaryChangeEntry" },
    { 0, NULL }
};


static guint32 const printerV1Alert[]
	= { PRINTER_MIB_PRINTERV1ALERT };

GSnmpIdentity const printer_mib_identities[] = {
    { printerV1Alert,
      sizeof(printerV1Alert)/sizeof(guint32),
      "printerV1Alert" },
    { 0, 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_prtGeneralEntry[] = {1, 3, 6, 1, 2, 1, 43, 5, 1, 1};

static attribute_t attr_prtGeneralEntry[] = {
    { 1, G_SNMP_COUNTER32, PRINTER_MIB_PRTGENERALCONFIGCHANGES, "prtGeneralConfigChanges" },
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTGENERALCURRENTLOCALIZATION, "prtGeneralCurrentLocalization" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTGENERALRESET, "prtGeneralReset" },
    { 4, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTGENERALCURRENTOPERATOR, "prtGeneralCurrentOperator" },
    { 5, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTGENERALSERVICEPERSON, "prtGeneralServicePerson" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTDEFAULTINDEX, "prtInputDefaultIndex" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTDEFAULTINDEX, "prtOutputDefaultIndex" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERDEFAULTINDEX, "prtMarkerDefaultIndex" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHDEFAULTINDEX, "prtMediaPathDefaultIndex" },
    { 10, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLELOCALIZATION, "prtConsoleLocalization" },
    { 11, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLENUMBEROFDISPLAYLINES, "prtConsoleNumberOfDisplayLines" },
    { 12, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLENUMBEROFDISPLAYCHARS, "prtConsoleNumberOfDisplayChars" },
    { 13, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLEDISABLE, "prtConsoleDisable" },
    { 14, G_SNMP_INTEGER32, PRINTER_MIB_PRTAUXILIARYSHEETSTARTUPPAGE, "prtAuxiliarySheetStartupPage" },
    { 15, G_SNMP_INTEGER32, PRINTER_MIB_PRTAUXILIARYSHEETBANNERPAGE, "prtAuxiliarySheetBannerPage" },
    { 16, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTGENERALPRINTERNAME, "prtGeneralPrinterName" },
    { 17, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTGENERALSERIALNUMBER, "prtGeneralSerialNumber" },
    { 18, G_SNMP_COUNTER32, PRINTER_MIB_PRTALERTCRITICALEVENTS, "prtAlertCriticalEvents" },
    { 19, G_SNMP_COUNTER32, PRINTER_MIB_PRTALERTALLEVENTS, "prtAlertAllEvents" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtStorageRefEntry[] = {1, 3, 6, 1, 2, 1, 43, 5, 2, 1};

static attribute_t attr_prtStorageRefEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTSTORAGEREFINDEX, "prtStorageRefIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtDeviceRefEntry[] = {1, 3, 6, 1, 2, 1, 43, 5, 3, 1};

static attribute_t attr_prtDeviceRefEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTDEVICEREFINDEX, "prtDeviceRefIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtCoverEntry[] = {1, 3, 6, 1, 2, 1, 43, 6, 1, 1};

static attribute_t attr_prtCoverEntry[] = {
    { 2, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTCOVERDESCRIPTION, "prtCoverDescription" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTCOVERSTATUS, "prtCoverStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtLocalizationEntry[] = {1, 3, 6, 1, 2, 1, 43, 7, 1, 1};

static attribute_t attr_prtLocalizationEntry[] = {
    { 2, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTLOCALIZATIONLANGUAGE, "prtLocalizationLanguage" },
    { 3, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTLOCALIZATIONCOUNTRY, "prtLocalizationCountry" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTLOCALIZATIONCHARACTERSET, "prtLocalizationCharacterSet" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtInputEntry[] = {1, 3, 6, 1, 2, 1, 43, 8, 2, 1};

static attribute_t attr_prtInputEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTTYPE, "prtInputType" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTDIMUNIT, "prtInputDimUnit" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIADIMFEEDDIRDECLARED, "prtInputMediaDimFeedDirDeclared" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIADIMXFEEDDIRDECLARED, "prtInputMediaDimXFeedDirDeclared" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIADIMFEEDDIRCHOSEN, "prtInputMediaDimFeedDirChosen" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIADIMXFEEDDIRCHOSEN, "prtInputMediaDimXFeedDirChosen" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTCAPACITYUNIT, "prtInputCapacityUnit" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMAXCAPACITY, "prtInputMaxCapacity" },
    { 10, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTCURRENTLEVEL, "prtInputCurrentLevel" },
    { 11, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTSTATUS, "prtInputStatus" },
    { 12, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTMEDIANAME, "prtInputMediaName" },
    { 13, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTNAME, "prtInputName" },
    { 14, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTVENDORNAME, "prtInputVendorName" },
    { 15, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTMODEL, "prtInputModel" },
    { 16, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTVERSION, "prtInputVersion" },
    { 17, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTSERIALNUMBER, "prtInputSerialNumber" },
    { 18, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTDESCRIPTION, "prtInputDescription" },
    { 19, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTSECURITY, "prtInputSecurity" },
    { 20, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIAWEIGHT, "prtInputMediaWeight" },
    { 21, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTMEDIATYPE, "prtInputMediaType" },
    { 22, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINPUTMEDIACOLOR, "prtInputMediaColor" },
    { 23, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIAFORMPARTS, "prtInputMediaFormParts" },
    { 24, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTMEDIALOADTIMEOUT, "prtInputMediaLoadTimeout" },
    { 25, G_SNMP_INTEGER32, PRINTER_MIB_PRTINPUTNEXTINDEX, "prtInputNextIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtOutputEntry[] = {1, 3, 6, 1, 2, 1, 43, 9, 2, 1};

static attribute_t attr_prtOutputEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTTYPE, "prtOutputType" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTCAPACITYUNIT, "prtOutputCapacityUnit" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTMAXCAPACITY, "prtOutputMaxCapacity" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTREMAININGCAPACITY, "prtOutputRemainingCapacity" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTSTATUS, "prtOutputStatus" },
    { 7, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTNAME, "prtOutputName" },
    { 8, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTVENDORNAME, "prtOutputVendorName" },
    { 9, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTMODEL, "prtOutputModel" },
    { 10, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTVERSION, "prtOutputVersion" },
    { 11, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTSERIALNUMBER, "prtOutputSerialNumber" },
    { 12, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTOUTPUTDESCRIPTION, "prtOutputDescription" },
    { 13, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTSECURITY, "prtOutputSecurity" },
    { 14, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTDIMUNIT, "prtOutputDimUnit" },
    { 15, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTMAXDIMFEEDDIR, "prtOutputMaxDimFeedDir" },
    { 16, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTMAXDIMXFEEDDIR, "prtOutputMaxDimXFeedDir" },
    { 17, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTMINDIMFEEDDIR, "prtOutputMinDimFeedDir" },
    { 18, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTMINDIMXFEEDDIR, "prtOutputMinDimXFeedDir" },
    { 19, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTSTACKINGORDER, "prtOutputStackingOrder" },
    { 20, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTPAGEDELIVERYORIENTATION, "prtOutputPageDeliveryOrientation" },
    { 21, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTBURSTING, "prtOutputBursting" },
    { 22, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTDECOLLATING, "prtOutputDecollating" },
    { 23, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTPAGECOLLATED, "prtOutputPageCollated" },
    { 24, G_SNMP_INTEGER32, PRINTER_MIB_PRTOUTPUTOFFSETSTACKING, "prtOutputOffsetStacking" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtMarkerEntry[] = {1, 3, 6, 1, 2, 1, 43, 10, 2, 1};

static attribute_t attr_prtMarkerEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERMARKTECH, "prtMarkerMarkTech" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERCOUNTERUNIT, "prtMarkerCounterUnit" },
    { 4, G_SNMP_COUNTER32, PRINTER_MIB_PRTMARKERLIFECOUNT, "prtMarkerLifeCount" },
    { 5, G_SNMP_COUNTER32, PRINTER_MIB_PRTMARKERPOWERONCOUNT, "prtMarkerPowerOnCount" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERPROCESSCOLORANTS, "prtMarkerProcessColorants" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSPOTCOLORANTS, "prtMarkerSpotColorants" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERADDRESSABILITYUNIT, "prtMarkerAddressabilityUnit" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERADDRESSABILITYFEEDDIR, "prtMarkerAddressabilityFeedDir" },
    { 10, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERADDRESSABILITYXFEEDDIR, "prtMarkerAddressabilityXFeedDir" },
    { 11, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERNORTHMARGIN, "prtMarkerNorthMargin" },
    { 12, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSOUTHMARGIN, "prtMarkerSouthMargin" },
    { 13, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERWESTMARGIN, "prtMarkerWestMargin" },
    { 14, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKEREASTMARGIN, "prtMarkerEastMargin" },
    { 15, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSTATUS, "prtMarkerStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtMarkerSuppliesEntry[] = {1, 3, 6, 1, 2, 1, 43, 11, 1, 1};

static attribute_t attr_prtMarkerSuppliesEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESMARKERINDEX, "prtMarkerSuppliesMarkerIndex" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESCOLORANTINDEX, "prtMarkerSuppliesColorantIndex" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESCLASS, "prtMarkerSuppliesClass" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESTYPE, "prtMarkerSuppliesType" },
    { 6, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTMARKERSUPPLIESDESCRIPTION, "prtMarkerSuppliesDescription" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESSUPPLYUNIT, "prtMarkerSuppliesSupplyUnit" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESMAXCAPACITY, "prtMarkerSuppliesMaxCapacity" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERSUPPLIESLEVEL, "prtMarkerSuppliesLevel" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtMarkerColorantEntry[] = {1, 3, 6, 1, 2, 1, 43, 12, 1, 1};

static attribute_t attr_prtMarkerColorantEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERCOLORANTMARKERINDEX, "prtMarkerColorantMarkerIndex" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERCOLORANTROLE, "prtMarkerColorantRole" },
    { 4, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTMARKERCOLORANTVALUE, "prtMarkerColorantValue" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTMARKERCOLORANTTONALITY, "prtMarkerColorantTonality" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtMediaPathEntry[] = {1, 3, 6, 1, 2, 1, 43, 13, 4, 1};

static attribute_t attr_prtMediaPathEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMAXSPEEDPRINTUNIT, "prtMediaPathMaxSpeedPrintUnit" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMEDIASIZEUNIT, "prtMediaPathMediaSizeUnit" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMAXSPEED, "prtMediaPathMaxSpeed" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMAXMEDIAFEEDDIR, "prtMediaPathMaxMediaFeedDir" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMAXMEDIAXFEEDDIR, "prtMediaPathMaxMediaXFeedDir" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMINMEDIAFEEDDIR, "prtMediaPathMinMediaFeedDir" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHMINMEDIAXFEEDDIR, "prtMediaPathMinMediaXFeedDir" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHTYPE, "prtMediaPathType" },
    { 10, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTMEDIAPATHDESCRIPTION, "prtMediaPathDescription" },
    { 11, G_SNMP_INTEGER32, PRINTER_MIB_PRTMEDIAPATHSTATUS, "prtMediaPathStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtChannelEntry[] = {1, 3, 6, 1, 2, 1, 43, 14, 1, 1};

static attribute_t attr_prtChannelEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELTYPE, "prtChannelType" },
    { 3, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTCHANNELPROTOCOLVERSION, "prtChannelProtocolVersion" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELCURRENTJOBCNTLLANGINDEX, "prtChannelCurrentJobCntlLangIndex" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELDEFAULTPAGEDESCLANGINDEX, "prtChannelDefaultPageDescLangIndex" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELSTATE, "prtChannelState" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELIFINDEX, "prtChannelIfIndex" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTCHANNELSTATUS, "prtChannelStatus" },
    { 9, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTCHANNELINFORMATION, "prtChannelInformation" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtInterpreterEntry[] = {1, 3, 6, 1, 2, 1, 43, 15, 1, 1};

static attribute_t attr_prtInterpreterEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERLANGFAMILY, "prtInterpreterLangFamily" },
    { 3, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINTERPRETERLANGLEVEL, "prtInterpreterLangLevel" },
    { 4, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINTERPRETERLANGVERSION, "prtInterpreterLangVersion" },
    { 5, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINTERPRETERDESCRIPTION, "prtInterpreterDescription" },
    { 6, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTINTERPRETERVERSION, "prtInterpreterVersion" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERDEFAULTORIENTATION, "prtInterpreterDefaultOrientation" },
    { 8, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERFEEDADDRESSABILITY, "prtInterpreterFeedAddressability" },
    { 9, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERXFEEDADDRESSABILITY, "prtInterpreterXFeedAddressability" },
    { 10, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERDEFAULTCHARSETIN, "prtInterpreterDefaultCharSetIn" },
    { 11, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERDEFAULTCHARSETOUT, "prtInterpreterDefaultCharSetOut" },
    { 12, G_SNMP_INTEGER32, PRINTER_MIB_PRTINTERPRETERTWOWAY, "prtInterpreterTwoWay" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtConsoleDisplayBufferEntry[] = {1, 3, 6, 1, 2, 1, 43, 16, 5, 1};

static attribute_t attr_prtConsoleDisplayBufferEntry[] = {
    { 2, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTCONSOLEDISPLAYBUFFERTEXT, "prtConsoleDisplayBufferText" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtConsoleLightEntry[] = {1, 3, 6, 1, 2, 1, 43, 17, 6, 1};

static attribute_t attr_prtConsoleLightEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLEONTIME, "prtConsoleOnTime" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLEOFFTIME, "prtConsoleOffTime" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTCONSOLECOLOR, "prtConsoleColor" },
    { 5, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTCONSOLEDESCRIPTION, "prtConsoleDescription" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_prtAlertEntry[] = {1, 3, 6, 1, 2, 1, 43, 18, 1, 1};

static attribute_t attr_prtAlertEntry[] = {
    { 2, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTSEVERITYLEVEL, "prtAlertSeverityLevel" },
    { 3, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTTRAININGLEVEL, "prtAlertTrainingLevel" },
    { 4, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTGROUP, "prtAlertGroup" },
    { 5, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTGROUPINDEX, "prtAlertGroupIndex" },
    { 6, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTLOCATION, "prtAlertLocation" },
    { 7, G_SNMP_INTEGER32, PRINTER_MIB_PRTALERTCODE, "prtAlertCode" },
    { 8, G_SNMP_OCTETSTRING, PRINTER_MIB_PRTALERTDESCRIPTION, "prtAlertDescription" },
    { 9, G_SNMP_TIMETICKS, PRINTER_MIB_PRTALERTTIME, "prtAlertTime" },
    { 0, 0, 0, NULL }
};


printer_mib_prtGeneralEntry_t *
printer_mib_new_prtGeneralEntry()
{
    printer_mib_prtGeneralEntry_t *prtGeneralEntry;

    prtGeneralEntry = (printer_mib_prtGeneralEntry_t *) g_malloc0(sizeof(printer_mib_prtGeneralEntry_t) + sizeof(gpointer));
    return prtGeneralEntry;
}

static int
unpack_prtGeneralEntry(GSnmpVarBind *vb, printer_mib_prtGeneralEntry_t *prtGeneralEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtGeneralEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtGeneralEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static printer_mib_prtGeneralEntry_t *
assign_prtGeneralEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtGeneralEntry_t *prtGeneralEntry;
    guint32 idx;
    char *p;

    prtGeneralEntry = printer_mib_new_prtGeneralEntry();
    if (! prtGeneralEntry) {
        return NULL;
    }

    p = (char *) prtGeneralEntry + sizeof(printer_mib_prtGeneralEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtGeneralEntry((GSnmpVarBind *) vbl->data, prtGeneralEntry) < 0) {
        g_warning("illegal prtGeneralEntry instance identifier");
        g_free(prtGeneralEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtGeneralEntry, sizeof(oid_prtGeneralEntry)/sizeof(guint32),
                   attr_prtGeneralEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            prtGeneralEntry->prtGeneralConfigChanges = &(vb->syntax.ui32[0]);
            break;
        case 2:
            prtGeneralEntry->prtGeneralCurrentLocalization = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtGeneralEntry->prtGeneralReset = &(vb->syntax.i32[0]);
            break;
        case 4:
            if (vb->syntax_len > 127) break;
            prtGeneralEntry->_prtGeneralCurrentOperatorLength = vb->syntax_len;
            prtGeneralEntry->prtGeneralCurrentOperator = vb->syntax.uc;
            break;
        case 5:
            if (vb->syntax_len > 127) break;
            prtGeneralEntry->_prtGeneralServicePersonLength = vb->syntax_len;
            prtGeneralEntry->prtGeneralServicePerson = vb->syntax.uc;
            break;
        case 6:
            prtGeneralEntry->prtInputDefaultIndex = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtGeneralEntry->prtOutputDefaultIndex = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtGeneralEntry->prtMarkerDefaultIndex = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtGeneralEntry->prtMediaPathDefaultIndex = &(vb->syntax.i32[0]);
            break;
        case 10:
            prtGeneralEntry->prtConsoleLocalization = &(vb->syntax.i32[0]);
            break;
        case 11:
            prtGeneralEntry->prtConsoleNumberOfDisplayLines = &(vb->syntax.i32[0]);
            break;
        case 12:
            prtGeneralEntry->prtConsoleNumberOfDisplayChars = &(vb->syntax.i32[0]);
            break;
        case 13:
            prtGeneralEntry->prtConsoleDisable = &(vb->syntax.i32[0]);
            break;
        case 14:
            prtGeneralEntry->prtAuxiliarySheetStartupPage = &(vb->syntax.i32[0]);
            break;
        case 15:
            prtGeneralEntry->prtAuxiliarySheetBannerPage = &(vb->syntax.i32[0]);
            break;
        case 16:
            if (vb->syntax_len > 127) break;
            prtGeneralEntry->_prtGeneralPrinterNameLength = vb->syntax_len;
            prtGeneralEntry->prtGeneralPrinterName = vb->syntax.uc;
            break;
        case 17:
            if (vb->syntax_len > 255) break;
            prtGeneralEntry->_prtGeneralSerialNumberLength = vb->syntax_len;
            prtGeneralEntry->prtGeneralSerialNumber = vb->syntax.uc;
            break;
        case 18:
            prtGeneralEntry->prtAlertCriticalEvents = &(vb->syntax.ui32[0]);
            break;
        case 19:
            prtGeneralEntry->prtAlertAllEvents = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return prtGeneralEntry;
}

void
printer_mib_get_prtGeneralTable(GSnmpSession *s, printer_mib_prtGeneralEntry_t ***prtGeneralEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 5, 1, 1, 0};

    *prtGeneralEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtGeneralEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtGeneralEntry = (printer_mib_prtGeneralEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtGeneralEntry_t *));
        if (! *prtGeneralEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtGeneralEntry)[i] = assign_prtGeneralEntry(row->data);
        }
    }
}

void
printer_mib_get_prtGeneralEntry(GSnmpSession *s, printer_mib_prtGeneralEntry_t **prtGeneralEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtGeneralEntry, sizeof(oid_prtGeneralEntry));
    len = pack_prtGeneralEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal prtGeneralEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtGeneralEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtGeneralEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtGeneralEntry = assign_prtGeneralEntry(out);
    }
}

void
printer_mib_set_prtGeneralEntry(GSnmpSession *s, printer_mib_prtGeneralEntry_t *prtGeneralEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtGeneralEntry, sizeof(oid_prtGeneralEntry));
    len = pack_prtGeneralEntry(base, prtGeneralEntry->hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal prtGeneralEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtGeneralEntry->prtGeneralCurrentLocalization) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtGeneralCurrentLocalization,
                       0);
    }
    if (prtGeneralEntry->prtGeneralReset) {
        base[10] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtGeneralReset,
                       0);
    }
    if (prtGeneralEntry->prtGeneralCurrentOperator) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtGeneralEntry->prtGeneralCurrentOperator,
                       prtGeneralEntry->_prtGeneralCurrentOperatorLength);
    }
    if (prtGeneralEntry->prtGeneralServicePerson) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtGeneralEntry->prtGeneralServicePerson,
                       prtGeneralEntry->_prtGeneralServicePersonLength);
    }
    if (prtGeneralEntry->prtInputDefaultIndex) {
        base[10] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtInputDefaultIndex,
                       0);
    }
    if (prtGeneralEntry->prtOutputDefaultIndex) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtOutputDefaultIndex,
                       0);
    }
    if (prtGeneralEntry->prtMarkerDefaultIndex) {
        base[10] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtMarkerDefaultIndex,
                       0);
    }
    if (prtGeneralEntry->prtMediaPathDefaultIndex) {
        base[10] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtMediaPathDefaultIndex,
                       0);
    }
    if (prtGeneralEntry->prtConsoleLocalization) {
        base[10] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtConsoleLocalization,
                       0);
    }
    if (prtGeneralEntry->prtConsoleDisable) {
        base[10] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtConsoleDisable,
                       0);
    }
    if (prtGeneralEntry->prtAuxiliarySheetStartupPage) {
        base[10] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtAuxiliarySheetStartupPage,
                       0);
    }
    if (prtGeneralEntry->prtAuxiliarySheetBannerPage) {
        base[10] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtGeneralEntry->prtAuxiliarySheetBannerPage,
                       0);
    }
    if (prtGeneralEntry->prtGeneralPrinterName) {
        base[10] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtGeneralEntry->prtGeneralPrinterName,
                       prtGeneralEntry->_prtGeneralPrinterNameLength);
    }
    if (prtGeneralEntry->prtGeneralSerialNumber) {
        base[10] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtGeneralEntry->prtGeneralSerialNumber,
                       prtGeneralEntry->_prtGeneralSerialNumberLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtGeneralEntry(printer_mib_prtGeneralEntry_t *prtGeneralEntry)
{
    GSList *vbl;
    char *p;

    if (prtGeneralEntry) {
        p = (char *) prtGeneralEntry + sizeof(printer_mib_prtGeneralEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtGeneralEntry);
    }
}

void
printer_mib_free_prtGeneralTable(printer_mib_prtGeneralEntry_t **prtGeneralEntry)
{
    int i;

    if (prtGeneralEntry) {
        for (i = 0; prtGeneralEntry[i]; i++) {
            printer_mib_free_prtGeneralEntry(prtGeneralEntry[i]);
        }
        g_free(prtGeneralEntry);
    }
}

printer_mib_prtStorageRefEntry_t *
printer_mib_new_prtStorageRefEntry()
{
    printer_mib_prtStorageRefEntry_t *prtStorageRefEntry;

    prtStorageRefEntry = (printer_mib_prtStorageRefEntry_t *) g_malloc0(sizeof(printer_mib_prtStorageRefEntry_t) + sizeof(gpointer));
    return prtStorageRefEntry;
}

static int
unpack_prtStorageRefEntry(GSnmpVarBind *vb, printer_mib_prtStorageRefEntry_t *prtStorageRefEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtStorageRefEntry->hrStorageIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtStorageRefEntry->prtStorageRefSeqNumber = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtStorageRefEntry(guint32 *base, gint32 hrStorageIndex, gint32 prtStorageRefSeqNumber)
{
    int idx = 11;

    base[idx++] = hrStorageIndex;
    base[idx++] = prtStorageRefSeqNumber;
    return idx;
}

static printer_mib_prtStorageRefEntry_t *
assign_prtStorageRefEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtStorageRefEntry_t *prtStorageRefEntry;
    guint32 idx;
    char *p;

    prtStorageRefEntry = printer_mib_new_prtStorageRefEntry();
    if (! prtStorageRefEntry) {
        return NULL;
    }

    p = (char *) prtStorageRefEntry + sizeof(printer_mib_prtStorageRefEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtStorageRefEntry((GSnmpVarBind *) vbl->data, prtStorageRefEntry) < 0) {
        g_warning("illegal prtStorageRefEntry instance identifier");
        g_free(prtStorageRefEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtStorageRefEntry, sizeof(oid_prtStorageRefEntry)/sizeof(guint32),
                   attr_prtStorageRefEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtStorageRefEntry->prtStorageRefIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtStorageRefEntry;
}

void
printer_mib_get_prtStorageRefTable(GSnmpSession *s, printer_mib_prtStorageRefEntry_t ***prtStorageRefEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 5, 2, 1, 0};

    *prtStorageRefEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtStorageRefEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtStorageRefEntry = (printer_mib_prtStorageRefEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtStorageRefEntry_t *));
        if (! *prtStorageRefEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtStorageRefEntry)[i] = assign_prtStorageRefEntry(row->data);
        }
    }
}

void
printer_mib_get_prtStorageRefEntry(GSnmpSession *s, printer_mib_prtStorageRefEntry_t **prtStorageRefEntry, gint32 hrStorageIndex, gint32 prtStorageRefSeqNumber, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtStorageRefEntry, sizeof(oid_prtStorageRefEntry));
    len = pack_prtStorageRefEntry(base, hrStorageIndex, prtStorageRefSeqNumber);
    if (len < 0) {
        g_warning("illegal prtStorageRefEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtStorageRefEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtStorageRefEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtStorageRefEntry = assign_prtStorageRefEntry(out);
    }
}

void
printer_mib_free_prtStorageRefEntry(printer_mib_prtStorageRefEntry_t *prtStorageRefEntry)
{
    GSList *vbl;
    char *p;

    if (prtStorageRefEntry) {
        p = (char *) prtStorageRefEntry + sizeof(printer_mib_prtStorageRefEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtStorageRefEntry);
    }
}

void
printer_mib_free_prtStorageRefTable(printer_mib_prtStorageRefEntry_t **prtStorageRefEntry)
{
    int i;

    if (prtStorageRefEntry) {
        for (i = 0; prtStorageRefEntry[i]; i++) {
            printer_mib_free_prtStorageRefEntry(prtStorageRefEntry[i]);
        }
        g_free(prtStorageRefEntry);
    }
}

printer_mib_prtDeviceRefEntry_t *
printer_mib_new_prtDeviceRefEntry()
{
    printer_mib_prtDeviceRefEntry_t *prtDeviceRefEntry;

    prtDeviceRefEntry = (printer_mib_prtDeviceRefEntry_t *) g_malloc0(sizeof(printer_mib_prtDeviceRefEntry_t) + sizeof(gpointer));
    return prtDeviceRefEntry;
}

static int
unpack_prtDeviceRefEntry(GSnmpVarBind *vb, printer_mib_prtDeviceRefEntry_t *prtDeviceRefEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtDeviceRefEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtDeviceRefEntry->prtDeviceRefSeqNumber = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtDeviceRefEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtDeviceRefSeqNumber)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtDeviceRefSeqNumber;
    return idx;
}

static printer_mib_prtDeviceRefEntry_t *
assign_prtDeviceRefEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtDeviceRefEntry_t *prtDeviceRefEntry;
    guint32 idx;
    char *p;

    prtDeviceRefEntry = printer_mib_new_prtDeviceRefEntry();
    if (! prtDeviceRefEntry) {
        return NULL;
    }

    p = (char *) prtDeviceRefEntry + sizeof(printer_mib_prtDeviceRefEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtDeviceRefEntry((GSnmpVarBind *) vbl->data, prtDeviceRefEntry) < 0) {
        g_warning("illegal prtDeviceRefEntry instance identifier");
        g_free(prtDeviceRefEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtDeviceRefEntry, sizeof(oid_prtDeviceRefEntry)/sizeof(guint32),
                   attr_prtDeviceRefEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtDeviceRefEntry->prtDeviceRefIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtDeviceRefEntry;
}

void
printer_mib_get_prtDeviceRefTable(GSnmpSession *s, printer_mib_prtDeviceRefEntry_t ***prtDeviceRefEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 5, 3, 1, 0};

    *prtDeviceRefEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtDeviceRefEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtDeviceRefEntry = (printer_mib_prtDeviceRefEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtDeviceRefEntry_t *));
        if (! *prtDeviceRefEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtDeviceRefEntry)[i] = assign_prtDeviceRefEntry(row->data);
        }
    }
}

void
printer_mib_get_prtDeviceRefEntry(GSnmpSession *s, printer_mib_prtDeviceRefEntry_t **prtDeviceRefEntry, gint32 hrDeviceIndex, gint32 prtDeviceRefSeqNumber, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtDeviceRefEntry, sizeof(oid_prtDeviceRefEntry));
    len = pack_prtDeviceRefEntry(base, hrDeviceIndex, prtDeviceRefSeqNumber);
    if (len < 0) {
        g_warning("illegal prtDeviceRefEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtDeviceRefEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtDeviceRefEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtDeviceRefEntry = assign_prtDeviceRefEntry(out);
    }
}

void
printer_mib_free_prtDeviceRefEntry(printer_mib_prtDeviceRefEntry_t *prtDeviceRefEntry)
{
    GSList *vbl;
    char *p;

    if (prtDeviceRefEntry) {
        p = (char *) prtDeviceRefEntry + sizeof(printer_mib_prtDeviceRefEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtDeviceRefEntry);
    }
}

void
printer_mib_free_prtDeviceRefTable(printer_mib_prtDeviceRefEntry_t **prtDeviceRefEntry)
{
    int i;

    if (prtDeviceRefEntry) {
        for (i = 0; prtDeviceRefEntry[i]; i++) {
            printer_mib_free_prtDeviceRefEntry(prtDeviceRefEntry[i]);
        }
        g_free(prtDeviceRefEntry);
    }
}

printer_mib_prtCoverEntry_t *
printer_mib_new_prtCoverEntry()
{
    printer_mib_prtCoverEntry_t *prtCoverEntry;

    prtCoverEntry = (printer_mib_prtCoverEntry_t *) g_malloc0(sizeof(printer_mib_prtCoverEntry_t) + sizeof(gpointer));
    return prtCoverEntry;
}

static int
unpack_prtCoverEntry(GSnmpVarBind *vb, printer_mib_prtCoverEntry_t *prtCoverEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtCoverEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtCoverEntry->prtCoverIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtCoverEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtCoverIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtCoverIndex;
    return idx;
}

static printer_mib_prtCoverEntry_t *
assign_prtCoverEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtCoverEntry_t *prtCoverEntry;
    guint32 idx;
    char *p;

    prtCoverEntry = printer_mib_new_prtCoverEntry();
    if (! prtCoverEntry) {
        return NULL;
    }

    p = (char *) prtCoverEntry + sizeof(printer_mib_prtCoverEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtCoverEntry((GSnmpVarBind *) vbl->data, prtCoverEntry) < 0) {
        g_warning("illegal prtCoverEntry instance identifier");
        g_free(prtCoverEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtCoverEntry, sizeof(oid_prtCoverEntry)/sizeof(guint32),
                   attr_prtCoverEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            prtCoverEntry->_prtCoverDescriptionLength = vb->syntax_len;
            prtCoverEntry->prtCoverDescription = vb->syntax.uc;
            break;
        case 3:
            prtCoverEntry->prtCoverStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtCoverEntry;
}

void
printer_mib_get_prtCoverTable(GSnmpSession *s, printer_mib_prtCoverEntry_t ***prtCoverEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 6, 1, 1, 0};

    *prtCoverEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtCoverEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtCoverEntry = (printer_mib_prtCoverEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtCoverEntry_t *));
        if (! *prtCoverEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtCoverEntry)[i] = assign_prtCoverEntry(row->data);
        }
    }
}

void
printer_mib_get_prtCoverEntry(GSnmpSession *s, printer_mib_prtCoverEntry_t **prtCoverEntry, gint32 hrDeviceIndex, gint32 prtCoverIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtCoverEntry, sizeof(oid_prtCoverEntry));
    len = pack_prtCoverEntry(base, hrDeviceIndex, prtCoverIndex);
    if (len < 0) {
        g_warning("illegal prtCoverEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtCoverEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtCoverEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtCoverEntry = assign_prtCoverEntry(out);
    }
}

void
printer_mib_free_prtCoverEntry(printer_mib_prtCoverEntry_t *prtCoverEntry)
{
    GSList *vbl;
    char *p;

    if (prtCoverEntry) {
        p = (char *) prtCoverEntry + sizeof(printer_mib_prtCoverEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtCoverEntry);
    }
}

void
printer_mib_free_prtCoverTable(printer_mib_prtCoverEntry_t **prtCoverEntry)
{
    int i;

    if (prtCoverEntry) {
        for (i = 0; prtCoverEntry[i]; i++) {
            printer_mib_free_prtCoverEntry(prtCoverEntry[i]);
        }
        g_free(prtCoverEntry);
    }
}

printer_mib_prtLocalizationEntry_t *
printer_mib_new_prtLocalizationEntry()
{
    printer_mib_prtLocalizationEntry_t *prtLocalizationEntry;

    prtLocalizationEntry = (printer_mib_prtLocalizationEntry_t *) g_malloc0(sizeof(printer_mib_prtLocalizationEntry_t) + sizeof(gpointer));
    return prtLocalizationEntry;
}

static int
unpack_prtLocalizationEntry(GSnmpVarBind *vb, printer_mib_prtLocalizationEntry_t *prtLocalizationEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtLocalizationEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtLocalizationEntry->prtLocalizationIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtLocalizationEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtLocalizationIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtLocalizationIndex;
    return idx;
}

static printer_mib_prtLocalizationEntry_t *
assign_prtLocalizationEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtLocalizationEntry_t *prtLocalizationEntry;
    guint32 idx;
    char *p;

    prtLocalizationEntry = printer_mib_new_prtLocalizationEntry();
    if (! prtLocalizationEntry) {
        return NULL;
    }

    p = (char *) prtLocalizationEntry + sizeof(printer_mib_prtLocalizationEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtLocalizationEntry((GSnmpVarBind *) vbl->data, prtLocalizationEntry) < 0) {
        g_warning("illegal prtLocalizationEntry instance identifier");
        g_free(prtLocalizationEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtLocalizationEntry, sizeof(oid_prtLocalizationEntry)/sizeof(guint32),
                   attr_prtLocalizationEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 2) break;
            prtLocalizationEntry->_prtLocalizationLanguageLength = vb->syntax_len;
            prtLocalizationEntry->prtLocalizationLanguage = vb->syntax.uc;
            break;
        case 3:
            if (vb->syntax_len > 2) break;
            prtLocalizationEntry->_prtLocalizationCountryLength = vb->syntax_len;
            prtLocalizationEntry->prtLocalizationCountry = vb->syntax.uc;
            break;
        case 4:
            prtLocalizationEntry->prtLocalizationCharacterSet = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtLocalizationEntry;
}

void
printer_mib_get_prtLocalizationTable(GSnmpSession *s, printer_mib_prtLocalizationEntry_t ***prtLocalizationEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 7, 1, 1, 0};

    *prtLocalizationEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtLocalizationEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtLocalizationEntry = (printer_mib_prtLocalizationEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtLocalizationEntry_t *));
        if (! *prtLocalizationEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtLocalizationEntry)[i] = assign_prtLocalizationEntry(row->data);
        }
    }
}

void
printer_mib_get_prtLocalizationEntry(GSnmpSession *s, printer_mib_prtLocalizationEntry_t **prtLocalizationEntry, gint32 hrDeviceIndex, gint32 prtLocalizationIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtLocalizationEntry, sizeof(oid_prtLocalizationEntry));
    len = pack_prtLocalizationEntry(base, hrDeviceIndex, prtLocalizationIndex);
    if (len < 0) {
        g_warning("illegal prtLocalizationEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtLocalizationEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtLocalizationEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtLocalizationEntry = assign_prtLocalizationEntry(out);
    }
}

void
printer_mib_free_prtLocalizationEntry(printer_mib_prtLocalizationEntry_t *prtLocalizationEntry)
{
    GSList *vbl;
    char *p;

    if (prtLocalizationEntry) {
        p = (char *) prtLocalizationEntry + sizeof(printer_mib_prtLocalizationEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtLocalizationEntry);
    }
}

void
printer_mib_free_prtLocalizationTable(printer_mib_prtLocalizationEntry_t **prtLocalizationEntry)
{
    int i;

    if (prtLocalizationEntry) {
        for (i = 0; prtLocalizationEntry[i]; i++) {
            printer_mib_free_prtLocalizationEntry(prtLocalizationEntry[i]);
        }
        g_free(prtLocalizationEntry);
    }
}

printer_mib_prtInputEntry_t *
printer_mib_new_prtInputEntry()
{
    printer_mib_prtInputEntry_t *prtInputEntry;

    prtInputEntry = (printer_mib_prtInputEntry_t *) g_malloc0(sizeof(printer_mib_prtInputEntry_t) + sizeof(gpointer));
    return prtInputEntry;
}

static int
unpack_prtInputEntry(GSnmpVarBind *vb, printer_mib_prtInputEntry_t *prtInputEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtInputEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtInputEntry->prtInputIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtInputEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtInputIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtInputIndex;
    return idx;
}

static printer_mib_prtInputEntry_t *
assign_prtInputEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtInputEntry_t *prtInputEntry;
    guint32 idx;
    char *p;

    prtInputEntry = printer_mib_new_prtInputEntry();
    if (! prtInputEntry) {
        return NULL;
    }

    p = (char *) prtInputEntry + sizeof(printer_mib_prtInputEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtInputEntry((GSnmpVarBind *) vbl->data, prtInputEntry) < 0) {
        g_warning("illegal prtInputEntry instance identifier");
        g_free(prtInputEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtInputEntry, sizeof(oid_prtInputEntry)/sizeof(guint32),
                   attr_prtInputEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtInputEntry->prtInputType = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtInputEntry->prtInputDimUnit = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtInputEntry->prtInputMediaDimFeedDirDeclared = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtInputEntry->prtInputMediaDimXFeedDirDeclared = &(vb->syntax.i32[0]);
            break;
        case 6:
            prtInputEntry->prtInputMediaDimFeedDirChosen = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtInputEntry->prtInputMediaDimXFeedDirChosen = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtInputEntry->prtInputCapacityUnit = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtInputEntry->prtInputMaxCapacity = &(vb->syntax.i32[0]);
            break;
        case 10:
            prtInputEntry->prtInputCurrentLevel = &(vb->syntax.i32[0]);
            break;
        case 11:
            prtInputEntry->prtInputStatus = &(vb->syntax.i32[0]);
            break;
        case 12:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputMediaNameLength = vb->syntax_len;
            prtInputEntry->prtInputMediaName = vb->syntax.uc;
            break;
        case 13:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputNameLength = vb->syntax_len;
            prtInputEntry->prtInputName = vb->syntax.uc;
            break;
        case 14:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputVendorNameLength = vb->syntax_len;
            prtInputEntry->prtInputVendorName = vb->syntax.uc;
            break;
        case 15:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputModelLength = vb->syntax_len;
            prtInputEntry->prtInputModel = vb->syntax.uc;
            break;
        case 16:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputVersionLength = vb->syntax_len;
            prtInputEntry->prtInputVersion = vb->syntax.uc;
            break;
        case 17:
            if (vb->syntax_len > 32) break;
            prtInputEntry->_prtInputSerialNumberLength = vb->syntax_len;
            prtInputEntry->prtInputSerialNumber = vb->syntax.uc;
            break;
        case 18:
            if (vb->syntax_len > 255) break;
            prtInputEntry->_prtInputDescriptionLength = vb->syntax_len;
            prtInputEntry->prtInputDescription = vb->syntax.uc;
            break;
        case 19:
            prtInputEntry->prtInputSecurity = &(vb->syntax.i32[0]);
            break;
        case 20:
            prtInputEntry->prtInputMediaWeight = &(vb->syntax.i32[0]);
            break;
        case 21:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputMediaTypeLength = vb->syntax_len;
            prtInputEntry->prtInputMediaType = vb->syntax.uc;
            break;
        case 22:
            if (vb->syntax_len > 63) break;
            prtInputEntry->_prtInputMediaColorLength = vb->syntax_len;
            prtInputEntry->prtInputMediaColor = vb->syntax.uc;
            break;
        case 23:
            prtInputEntry->prtInputMediaFormParts = &(vb->syntax.i32[0]);
            break;
        case 24:
            prtInputEntry->prtInputMediaLoadTimeout = &(vb->syntax.i32[0]);
            break;
        case 25:
            prtInputEntry->prtInputNextIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtInputEntry;
}

void
printer_mib_get_prtInputTable(GSnmpSession *s, printer_mib_prtInputEntry_t ***prtInputEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 8, 2, 1, 0};

    *prtInputEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtInputEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtInputEntry = (printer_mib_prtInputEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtInputEntry_t *));
        if (! *prtInputEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtInputEntry)[i] = assign_prtInputEntry(row->data);
        }
    }
}

void
printer_mib_get_prtInputEntry(GSnmpSession *s, printer_mib_prtInputEntry_t **prtInputEntry, gint32 hrDeviceIndex, gint32 prtInputIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtInputEntry, sizeof(oid_prtInputEntry));
    len = pack_prtInputEntry(base, hrDeviceIndex, prtInputIndex);
    if (len < 0) {
        g_warning("illegal prtInputEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtInputEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtInputEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtInputEntry = assign_prtInputEntry(out);
    }
}

void
printer_mib_set_prtInputEntry(GSnmpSession *s, printer_mib_prtInputEntry_t *prtInputEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtInputEntry, sizeof(oid_prtInputEntry));
    len = pack_prtInputEntry(base, prtInputEntry->hrDeviceIndex, prtInputEntry->prtInputIndex);
    if (len < 0) {
        g_warning("illegal prtInputEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtInputEntry->prtInputMediaDimFeedDirDeclared) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMediaDimFeedDirDeclared,
                       0);
    }
    if (prtInputEntry->prtInputMediaDimXFeedDirDeclared) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMediaDimXFeedDirDeclared,
                       0);
    }
    if (prtInputEntry->prtInputMaxCapacity) {
        base[10] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMaxCapacity,
                       0);
    }
    if (prtInputEntry->prtInputCurrentLevel) {
        base[10] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputCurrentLevel,
                       0);
    }
    if (prtInputEntry->prtInputMediaName) {
        base[10] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtInputEntry->prtInputMediaName,
                       prtInputEntry->_prtInputMediaNameLength);
    }
    if (prtInputEntry->prtInputName) {
        base[10] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtInputEntry->prtInputName,
                       prtInputEntry->_prtInputNameLength);
    }
    if (prtInputEntry->prtInputSecurity) {
        base[10] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputSecurity,
                       0);
    }
    if (prtInputEntry->prtInputMediaWeight) {
        base[10] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMediaWeight,
                       0);
    }
    if (prtInputEntry->prtInputMediaType) {
        base[10] = 21;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtInputEntry->prtInputMediaType,
                       prtInputEntry->_prtInputMediaTypeLength);
    }
    if (prtInputEntry->prtInputMediaColor) {
        base[10] = 22;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtInputEntry->prtInputMediaColor,
                       prtInputEntry->_prtInputMediaColorLength);
    }
    if (prtInputEntry->prtInputMediaFormParts) {
        base[10] = 23;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMediaFormParts,
                       0);
    }
    if (prtInputEntry->prtInputMediaLoadTimeout) {
        base[10] = 24;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputMediaLoadTimeout,
                       0);
    }
    if (prtInputEntry->prtInputNextIndex) {
        base[10] = 25;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInputEntry->prtInputNextIndex,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtInputEntry(printer_mib_prtInputEntry_t *prtInputEntry)
{
    GSList *vbl;
    char *p;

    if (prtInputEntry) {
        p = (char *) prtInputEntry + sizeof(printer_mib_prtInputEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtInputEntry);
    }
}

void
printer_mib_free_prtInputTable(printer_mib_prtInputEntry_t **prtInputEntry)
{
    int i;

    if (prtInputEntry) {
        for (i = 0; prtInputEntry[i]; i++) {
            printer_mib_free_prtInputEntry(prtInputEntry[i]);
        }
        g_free(prtInputEntry);
    }
}

printer_mib_prtOutputEntry_t *
printer_mib_new_prtOutputEntry()
{
    printer_mib_prtOutputEntry_t *prtOutputEntry;

    prtOutputEntry = (printer_mib_prtOutputEntry_t *) g_malloc0(sizeof(printer_mib_prtOutputEntry_t) + sizeof(gpointer));
    return prtOutputEntry;
}

static int
unpack_prtOutputEntry(GSnmpVarBind *vb, printer_mib_prtOutputEntry_t *prtOutputEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtOutputEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtOutputEntry->prtOutputIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtOutputEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtOutputIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtOutputIndex;
    return idx;
}

static printer_mib_prtOutputEntry_t *
assign_prtOutputEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtOutputEntry_t *prtOutputEntry;
    guint32 idx;
    char *p;

    prtOutputEntry = printer_mib_new_prtOutputEntry();
    if (! prtOutputEntry) {
        return NULL;
    }

    p = (char *) prtOutputEntry + sizeof(printer_mib_prtOutputEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtOutputEntry((GSnmpVarBind *) vbl->data, prtOutputEntry) < 0) {
        g_warning("illegal prtOutputEntry instance identifier");
        g_free(prtOutputEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtOutputEntry, sizeof(oid_prtOutputEntry)/sizeof(guint32),
                   attr_prtOutputEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtOutputEntry->prtOutputType = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtOutputEntry->prtOutputCapacityUnit = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtOutputEntry->prtOutputMaxCapacity = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtOutputEntry->prtOutputRemainingCapacity = &(vb->syntax.i32[0]);
            break;
        case 6:
            prtOutputEntry->prtOutputStatus = &(vb->syntax.i32[0]);
            break;
        case 7:
            if (vb->syntax_len > 63) break;
            prtOutputEntry->_prtOutputNameLength = vb->syntax_len;
            prtOutputEntry->prtOutputName = vb->syntax.uc;
            break;
        case 8:
            if (vb->syntax_len > 63) break;
            prtOutputEntry->_prtOutputVendorNameLength = vb->syntax_len;
            prtOutputEntry->prtOutputVendorName = vb->syntax.uc;
            break;
        case 9:
            if (vb->syntax_len > 63) break;
            prtOutputEntry->_prtOutputModelLength = vb->syntax_len;
            prtOutputEntry->prtOutputModel = vb->syntax.uc;
            break;
        case 10:
            if (vb->syntax_len > 63) break;
            prtOutputEntry->_prtOutputVersionLength = vb->syntax_len;
            prtOutputEntry->prtOutputVersion = vb->syntax.uc;
            break;
        case 11:
            if (vb->syntax_len > 63) break;
            prtOutputEntry->_prtOutputSerialNumberLength = vb->syntax_len;
            prtOutputEntry->prtOutputSerialNumber = vb->syntax.uc;
            break;
        case 12:
            if (vb->syntax_len > 255) break;
            prtOutputEntry->_prtOutputDescriptionLength = vb->syntax_len;
            prtOutputEntry->prtOutputDescription = vb->syntax.uc;
            break;
        case 13:
            prtOutputEntry->prtOutputSecurity = &(vb->syntax.i32[0]);
            break;
        case 14:
            prtOutputEntry->prtOutputDimUnit = &(vb->syntax.i32[0]);
            break;
        case 15:
            prtOutputEntry->prtOutputMaxDimFeedDir = &(vb->syntax.i32[0]);
            break;
        case 16:
            prtOutputEntry->prtOutputMaxDimXFeedDir = &(vb->syntax.i32[0]);
            break;
        case 17:
            prtOutputEntry->prtOutputMinDimFeedDir = &(vb->syntax.i32[0]);
            break;
        case 18:
            prtOutputEntry->prtOutputMinDimXFeedDir = &(vb->syntax.i32[0]);
            break;
        case 19:
            prtOutputEntry->prtOutputStackingOrder = &(vb->syntax.i32[0]);
            break;
        case 20:
            prtOutputEntry->prtOutputPageDeliveryOrientation = &(vb->syntax.i32[0]);
            break;
        case 21:
            prtOutputEntry->prtOutputBursting = &(vb->syntax.i32[0]);
            break;
        case 22:
            prtOutputEntry->prtOutputDecollating = &(vb->syntax.i32[0]);
            break;
        case 23:
            prtOutputEntry->prtOutputPageCollated = &(vb->syntax.i32[0]);
            break;
        case 24:
            prtOutputEntry->prtOutputOffsetStacking = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtOutputEntry;
}

void
printer_mib_get_prtOutputTable(GSnmpSession *s, printer_mib_prtOutputEntry_t ***prtOutputEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 9, 2, 1, 0};

    *prtOutputEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtOutputEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtOutputEntry = (printer_mib_prtOutputEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtOutputEntry_t *));
        if (! *prtOutputEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtOutputEntry)[i] = assign_prtOutputEntry(row->data);
        }
    }
}

void
printer_mib_get_prtOutputEntry(GSnmpSession *s, printer_mib_prtOutputEntry_t **prtOutputEntry, gint32 hrDeviceIndex, gint32 prtOutputIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtOutputEntry, sizeof(oid_prtOutputEntry));
    len = pack_prtOutputEntry(base, hrDeviceIndex, prtOutputIndex);
    if (len < 0) {
        g_warning("illegal prtOutputEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtOutputEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtOutputEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtOutputEntry = assign_prtOutputEntry(out);
    }
}

void
printer_mib_set_prtOutputEntry(GSnmpSession *s, printer_mib_prtOutputEntry_t *prtOutputEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtOutputEntry, sizeof(oid_prtOutputEntry));
    len = pack_prtOutputEntry(base, prtOutputEntry->hrDeviceIndex, prtOutputEntry->prtOutputIndex);
    if (len < 0) {
        g_warning("illegal prtOutputEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtOutputEntry->prtOutputMaxCapacity) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputMaxCapacity,
                       0);
    }
    if (prtOutputEntry->prtOutputRemainingCapacity) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputRemainingCapacity,
                       0);
    }
    if (prtOutputEntry->prtOutputName) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtOutputEntry->prtOutputName,
                       prtOutputEntry->_prtOutputNameLength);
    }
    if (prtOutputEntry->prtOutputSecurity) {
        base[10] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputSecurity,
                       0);
    }
    if (prtOutputEntry->prtOutputMaxDimFeedDir) {
        base[10] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputMaxDimFeedDir,
                       0);
    }
    if (prtOutputEntry->prtOutputMaxDimXFeedDir) {
        base[10] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputMaxDimXFeedDir,
                       0);
    }
    if (prtOutputEntry->prtOutputMinDimFeedDir) {
        base[10] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputMinDimFeedDir,
                       0);
    }
    if (prtOutputEntry->prtOutputMinDimXFeedDir) {
        base[10] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputMinDimXFeedDir,
                       0);
    }
    if (prtOutputEntry->prtOutputStackingOrder) {
        base[10] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputStackingOrder,
                       0);
    }
    if (prtOutputEntry->prtOutputPageDeliveryOrientation) {
        base[10] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputPageDeliveryOrientation,
                       0);
    }
    if (prtOutputEntry->prtOutputBursting) {
        base[10] = 21;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputBursting,
                       0);
    }
    if (prtOutputEntry->prtOutputDecollating) {
        base[10] = 22;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputDecollating,
                       0);
    }
    if (prtOutputEntry->prtOutputPageCollated) {
        base[10] = 23;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputPageCollated,
                       0);
    }
    if (prtOutputEntry->prtOutputOffsetStacking) {
        base[10] = 24;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtOutputEntry->prtOutputOffsetStacking,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtOutputEntry(printer_mib_prtOutputEntry_t *prtOutputEntry)
{
    GSList *vbl;
    char *p;

    if (prtOutputEntry) {
        p = (char *) prtOutputEntry + sizeof(printer_mib_prtOutputEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtOutputEntry);
    }
}

void
printer_mib_free_prtOutputTable(printer_mib_prtOutputEntry_t **prtOutputEntry)
{
    int i;

    if (prtOutputEntry) {
        for (i = 0; prtOutputEntry[i]; i++) {
            printer_mib_free_prtOutputEntry(prtOutputEntry[i]);
        }
        g_free(prtOutputEntry);
    }
}

printer_mib_prtMarkerEntry_t *
printer_mib_new_prtMarkerEntry()
{
    printer_mib_prtMarkerEntry_t *prtMarkerEntry;

    prtMarkerEntry = (printer_mib_prtMarkerEntry_t *) g_malloc0(sizeof(printer_mib_prtMarkerEntry_t) + sizeof(gpointer));
    return prtMarkerEntry;
}

static int
unpack_prtMarkerEntry(GSnmpVarBind *vb, printer_mib_prtMarkerEntry_t *prtMarkerEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtMarkerEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtMarkerEntry->prtMarkerIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtMarkerEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtMarkerIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtMarkerIndex;
    return idx;
}

static printer_mib_prtMarkerEntry_t *
assign_prtMarkerEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtMarkerEntry_t *prtMarkerEntry;
    guint32 idx;
    char *p;

    prtMarkerEntry = printer_mib_new_prtMarkerEntry();
    if (! prtMarkerEntry) {
        return NULL;
    }

    p = (char *) prtMarkerEntry + sizeof(printer_mib_prtMarkerEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtMarkerEntry((GSnmpVarBind *) vbl->data, prtMarkerEntry) < 0) {
        g_warning("illegal prtMarkerEntry instance identifier");
        g_free(prtMarkerEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtMarkerEntry, sizeof(oid_prtMarkerEntry)/sizeof(guint32),
                   attr_prtMarkerEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtMarkerEntry->prtMarkerMarkTech = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtMarkerEntry->prtMarkerCounterUnit = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtMarkerEntry->prtMarkerLifeCount = &(vb->syntax.ui32[0]);
            break;
        case 5:
            prtMarkerEntry->prtMarkerPowerOnCount = &(vb->syntax.ui32[0]);
            break;
        case 6:
            prtMarkerEntry->prtMarkerProcessColorants = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtMarkerEntry->prtMarkerSpotColorants = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtMarkerEntry->prtMarkerAddressabilityUnit = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtMarkerEntry->prtMarkerAddressabilityFeedDir = &(vb->syntax.i32[0]);
            break;
        case 10:
            prtMarkerEntry->prtMarkerAddressabilityXFeedDir = &(vb->syntax.i32[0]);
            break;
        case 11:
            prtMarkerEntry->prtMarkerNorthMargin = &(vb->syntax.i32[0]);
            break;
        case 12:
            prtMarkerEntry->prtMarkerSouthMargin = &(vb->syntax.i32[0]);
            break;
        case 13:
            prtMarkerEntry->prtMarkerWestMargin = &(vb->syntax.i32[0]);
            break;
        case 14:
            prtMarkerEntry->prtMarkerEastMargin = &(vb->syntax.i32[0]);
            break;
        case 15:
            prtMarkerEntry->prtMarkerStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtMarkerEntry;
}

void
printer_mib_get_prtMarkerTable(GSnmpSession *s, printer_mib_prtMarkerEntry_t ***prtMarkerEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 10, 2, 1, 0};

    *prtMarkerEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtMarkerEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtMarkerEntry = (printer_mib_prtMarkerEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtMarkerEntry_t *));
        if (! *prtMarkerEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtMarkerEntry)[i] = assign_prtMarkerEntry(row->data);
        }
    }
}

void
printer_mib_get_prtMarkerEntry(GSnmpSession *s, printer_mib_prtMarkerEntry_t **prtMarkerEntry, gint32 hrDeviceIndex, gint32 prtMarkerIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtMarkerEntry, sizeof(oid_prtMarkerEntry));
    len = pack_prtMarkerEntry(base, hrDeviceIndex, prtMarkerIndex);
    if (len < 0) {
        g_warning("illegal prtMarkerEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtMarkerEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtMarkerEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtMarkerEntry = assign_prtMarkerEntry(out);
    }
}

void
printer_mib_free_prtMarkerEntry(printer_mib_prtMarkerEntry_t *prtMarkerEntry)
{
    GSList *vbl;
    char *p;

    if (prtMarkerEntry) {
        p = (char *) prtMarkerEntry + sizeof(printer_mib_prtMarkerEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtMarkerEntry);
    }
}

void
printer_mib_free_prtMarkerTable(printer_mib_prtMarkerEntry_t **prtMarkerEntry)
{
    int i;

    if (prtMarkerEntry) {
        for (i = 0; prtMarkerEntry[i]; i++) {
            printer_mib_free_prtMarkerEntry(prtMarkerEntry[i]);
        }
        g_free(prtMarkerEntry);
    }
}

printer_mib_prtMarkerSuppliesEntry_t *
printer_mib_new_prtMarkerSuppliesEntry()
{
    printer_mib_prtMarkerSuppliesEntry_t *prtMarkerSuppliesEntry;

    prtMarkerSuppliesEntry = (printer_mib_prtMarkerSuppliesEntry_t *) g_malloc0(sizeof(printer_mib_prtMarkerSuppliesEntry_t) + sizeof(gpointer));
    return prtMarkerSuppliesEntry;
}

static int
unpack_prtMarkerSuppliesEntry(GSnmpVarBind *vb, printer_mib_prtMarkerSuppliesEntry_t *prtMarkerSuppliesEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtMarkerSuppliesEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtMarkerSuppliesEntry->prtMarkerSuppliesIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtMarkerSuppliesEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtMarkerSuppliesIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtMarkerSuppliesIndex;
    return idx;
}

static printer_mib_prtMarkerSuppliesEntry_t *
assign_prtMarkerSuppliesEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtMarkerSuppliesEntry_t *prtMarkerSuppliesEntry;
    guint32 idx;
    char *p;

    prtMarkerSuppliesEntry = printer_mib_new_prtMarkerSuppliesEntry();
    if (! prtMarkerSuppliesEntry) {
        return NULL;
    }

    p = (char *) prtMarkerSuppliesEntry + sizeof(printer_mib_prtMarkerSuppliesEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtMarkerSuppliesEntry((GSnmpVarBind *) vbl->data, prtMarkerSuppliesEntry) < 0) {
        g_warning("illegal prtMarkerSuppliesEntry instance identifier");
        g_free(prtMarkerSuppliesEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtMarkerSuppliesEntry, sizeof(oid_prtMarkerSuppliesEntry)/sizeof(guint32),
                   attr_prtMarkerSuppliesEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtMarkerSuppliesEntry->prtMarkerSuppliesMarkerIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtMarkerSuppliesEntry->prtMarkerSuppliesColorantIndex = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtMarkerSuppliesEntry->prtMarkerSuppliesClass = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtMarkerSuppliesEntry->prtMarkerSuppliesType = &(vb->syntax.i32[0]);
            break;
        case 6:
            if (vb->syntax_len > 255) break;
            prtMarkerSuppliesEntry->_prtMarkerSuppliesDescriptionLength = vb->syntax_len;
            prtMarkerSuppliesEntry->prtMarkerSuppliesDescription = vb->syntax.uc;
            break;
        case 7:
            prtMarkerSuppliesEntry->prtMarkerSuppliesSupplyUnit = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtMarkerSuppliesEntry->prtMarkerSuppliesMaxCapacity = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtMarkerSuppliesEntry->prtMarkerSuppliesLevel = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtMarkerSuppliesEntry;
}

void
printer_mib_get_prtMarkerSuppliesTable(GSnmpSession *s, printer_mib_prtMarkerSuppliesEntry_t ***prtMarkerSuppliesEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 11, 1, 1, 0};

    *prtMarkerSuppliesEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtMarkerSuppliesEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtMarkerSuppliesEntry = (printer_mib_prtMarkerSuppliesEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtMarkerSuppliesEntry_t *));
        if (! *prtMarkerSuppliesEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtMarkerSuppliesEntry)[i] = assign_prtMarkerSuppliesEntry(row->data);
        }
    }
}

void
printer_mib_get_prtMarkerSuppliesEntry(GSnmpSession *s, printer_mib_prtMarkerSuppliesEntry_t **prtMarkerSuppliesEntry, gint32 hrDeviceIndex, gint32 prtMarkerSuppliesIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtMarkerSuppliesEntry, sizeof(oid_prtMarkerSuppliesEntry));
    len = pack_prtMarkerSuppliesEntry(base, hrDeviceIndex, prtMarkerSuppliesIndex);
    if (len < 0) {
        g_warning("illegal prtMarkerSuppliesEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtMarkerSuppliesEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtMarkerSuppliesEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtMarkerSuppliesEntry = assign_prtMarkerSuppliesEntry(out);
    }
}

void
printer_mib_set_prtMarkerSuppliesEntry(GSnmpSession *s, printer_mib_prtMarkerSuppliesEntry_t *prtMarkerSuppliesEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtMarkerSuppliesEntry, sizeof(oid_prtMarkerSuppliesEntry));
    len = pack_prtMarkerSuppliesEntry(base, prtMarkerSuppliesEntry->hrDeviceIndex, prtMarkerSuppliesEntry->prtMarkerSuppliesIndex);
    if (len < 0) {
        g_warning("illegal prtMarkerSuppliesEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtMarkerSuppliesEntry->prtMarkerSuppliesMaxCapacity) {
        base[10] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtMarkerSuppliesEntry->prtMarkerSuppliesMaxCapacity,
                       0);
    }
    if (prtMarkerSuppliesEntry->prtMarkerSuppliesLevel) {
        base[10] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtMarkerSuppliesEntry->prtMarkerSuppliesLevel,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtMarkerSuppliesEntry(printer_mib_prtMarkerSuppliesEntry_t *prtMarkerSuppliesEntry)
{
    GSList *vbl;
    char *p;

    if (prtMarkerSuppliesEntry) {
        p = (char *) prtMarkerSuppliesEntry + sizeof(printer_mib_prtMarkerSuppliesEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtMarkerSuppliesEntry);
    }
}

void
printer_mib_free_prtMarkerSuppliesTable(printer_mib_prtMarkerSuppliesEntry_t **prtMarkerSuppliesEntry)
{
    int i;

    if (prtMarkerSuppliesEntry) {
        for (i = 0; prtMarkerSuppliesEntry[i]; i++) {
            printer_mib_free_prtMarkerSuppliesEntry(prtMarkerSuppliesEntry[i]);
        }
        g_free(prtMarkerSuppliesEntry);
    }
}

printer_mib_prtMarkerColorantEntry_t *
printer_mib_new_prtMarkerColorantEntry()
{
    printer_mib_prtMarkerColorantEntry_t *prtMarkerColorantEntry;

    prtMarkerColorantEntry = (printer_mib_prtMarkerColorantEntry_t *) g_malloc0(sizeof(printer_mib_prtMarkerColorantEntry_t) + sizeof(gpointer));
    return prtMarkerColorantEntry;
}

static int
unpack_prtMarkerColorantEntry(GSnmpVarBind *vb, printer_mib_prtMarkerColorantEntry_t *prtMarkerColorantEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtMarkerColorantEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtMarkerColorantEntry->prtMarkerColorantIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtMarkerColorantEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtMarkerColorantIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtMarkerColorantIndex;
    return idx;
}

static printer_mib_prtMarkerColorantEntry_t *
assign_prtMarkerColorantEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtMarkerColorantEntry_t *prtMarkerColorantEntry;
    guint32 idx;
    char *p;

    prtMarkerColorantEntry = printer_mib_new_prtMarkerColorantEntry();
    if (! prtMarkerColorantEntry) {
        return NULL;
    }

    p = (char *) prtMarkerColorantEntry + sizeof(printer_mib_prtMarkerColorantEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtMarkerColorantEntry((GSnmpVarBind *) vbl->data, prtMarkerColorantEntry) < 0) {
        g_warning("illegal prtMarkerColorantEntry instance identifier");
        g_free(prtMarkerColorantEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtMarkerColorantEntry, sizeof(oid_prtMarkerColorantEntry)/sizeof(guint32),
                   attr_prtMarkerColorantEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtMarkerColorantEntry->prtMarkerColorantMarkerIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtMarkerColorantEntry->prtMarkerColorantRole = &(vb->syntax.i32[0]);
            break;
        case 4:
            if (vb->syntax_len > 255) break;
            prtMarkerColorantEntry->_prtMarkerColorantValueLength = vb->syntax_len;
            prtMarkerColorantEntry->prtMarkerColorantValue = vb->syntax.uc;
            break;
        case 5:
            prtMarkerColorantEntry->prtMarkerColorantTonality = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtMarkerColorantEntry;
}

void
printer_mib_get_prtMarkerColorantTable(GSnmpSession *s, printer_mib_prtMarkerColorantEntry_t ***prtMarkerColorantEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 12, 1, 1, 0};

    *prtMarkerColorantEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtMarkerColorantEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtMarkerColorantEntry = (printer_mib_prtMarkerColorantEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtMarkerColorantEntry_t *));
        if (! *prtMarkerColorantEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtMarkerColorantEntry)[i] = assign_prtMarkerColorantEntry(row->data);
        }
    }
}

void
printer_mib_get_prtMarkerColorantEntry(GSnmpSession *s, printer_mib_prtMarkerColorantEntry_t **prtMarkerColorantEntry, gint32 hrDeviceIndex, gint32 prtMarkerColorantIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtMarkerColorantEntry, sizeof(oid_prtMarkerColorantEntry));
    len = pack_prtMarkerColorantEntry(base, hrDeviceIndex, prtMarkerColorantIndex);
    if (len < 0) {
        g_warning("illegal prtMarkerColorantEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtMarkerColorantEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtMarkerColorantEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtMarkerColorantEntry = assign_prtMarkerColorantEntry(out);
    }
}

void
printer_mib_free_prtMarkerColorantEntry(printer_mib_prtMarkerColorantEntry_t *prtMarkerColorantEntry)
{
    GSList *vbl;
    char *p;

    if (prtMarkerColorantEntry) {
        p = (char *) prtMarkerColorantEntry + sizeof(printer_mib_prtMarkerColorantEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtMarkerColorantEntry);
    }
}

void
printer_mib_free_prtMarkerColorantTable(printer_mib_prtMarkerColorantEntry_t **prtMarkerColorantEntry)
{
    int i;

    if (prtMarkerColorantEntry) {
        for (i = 0; prtMarkerColorantEntry[i]; i++) {
            printer_mib_free_prtMarkerColorantEntry(prtMarkerColorantEntry[i]);
        }
        g_free(prtMarkerColorantEntry);
    }
}

printer_mib_prtMediaPathEntry_t *
printer_mib_new_prtMediaPathEntry()
{
    printer_mib_prtMediaPathEntry_t *prtMediaPathEntry;

    prtMediaPathEntry = (printer_mib_prtMediaPathEntry_t *) g_malloc0(sizeof(printer_mib_prtMediaPathEntry_t) + sizeof(gpointer));
    return prtMediaPathEntry;
}

static int
unpack_prtMediaPathEntry(GSnmpVarBind *vb, printer_mib_prtMediaPathEntry_t *prtMediaPathEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtMediaPathEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtMediaPathEntry->prtMediaPathIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtMediaPathEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtMediaPathIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtMediaPathIndex;
    return idx;
}

static printer_mib_prtMediaPathEntry_t *
assign_prtMediaPathEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtMediaPathEntry_t *prtMediaPathEntry;
    guint32 idx;
    char *p;

    prtMediaPathEntry = printer_mib_new_prtMediaPathEntry();
    if (! prtMediaPathEntry) {
        return NULL;
    }

    p = (char *) prtMediaPathEntry + sizeof(printer_mib_prtMediaPathEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtMediaPathEntry((GSnmpVarBind *) vbl->data, prtMediaPathEntry) < 0) {
        g_warning("illegal prtMediaPathEntry instance identifier");
        g_free(prtMediaPathEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtMediaPathEntry, sizeof(oid_prtMediaPathEntry)/sizeof(guint32),
                   attr_prtMediaPathEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtMediaPathEntry->prtMediaPathMaxSpeedPrintUnit = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtMediaPathEntry->prtMediaPathMediaSizeUnit = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtMediaPathEntry->prtMediaPathMaxSpeed = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtMediaPathEntry->prtMediaPathMaxMediaFeedDir = &(vb->syntax.i32[0]);
            break;
        case 6:
            prtMediaPathEntry->prtMediaPathMaxMediaXFeedDir = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtMediaPathEntry->prtMediaPathMinMediaFeedDir = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtMediaPathEntry->prtMediaPathMinMediaXFeedDir = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtMediaPathEntry->prtMediaPathType = &(vb->syntax.i32[0]);
            break;
        case 10:
            if (vb->syntax_len > 255) break;
            prtMediaPathEntry->_prtMediaPathDescriptionLength = vb->syntax_len;
            prtMediaPathEntry->prtMediaPathDescription = vb->syntax.uc;
            break;
        case 11:
            prtMediaPathEntry->prtMediaPathStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtMediaPathEntry;
}

void
printer_mib_get_prtMediaPathTable(GSnmpSession *s, printer_mib_prtMediaPathEntry_t ***prtMediaPathEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 13, 4, 1, 0};

    *prtMediaPathEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtMediaPathEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtMediaPathEntry = (printer_mib_prtMediaPathEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtMediaPathEntry_t *));
        if (! *prtMediaPathEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtMediaPathEntry)[i] = assign_prtMediaPathEntry(row->data);
        }
    }
}

void
printer_mib_get_prtMediaPathEntry(GSnmpSession *s, printer_mib_prtMediaPathEntry_t **prtMediaPathEntry, gint32 hrDeviceIndex, gint32 prtMediaPathIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtMediaPathEntry, sizeof(oid_prtMediaPathEntry));
    len = pack_prtMediaPathEntry(base, hrDeviceIndex, prtMediaPathIndex);
    if (len < 0) {
        g_warning("illegal prtMediaPathEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtMediaPathEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtMediaPathEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtMediaPathEntry = assign_prtMediaPathEntry(out);
    }
}

void
printer_mib_free_prtMediaPathEntry(printer_mib_prtMediaPathEntry_t *prtMediaPathEntry)
{
    GSList *vbl;
    char *p;

    if (prtMediaPathEntry) {
        p = (char *) prtMediaPathEntry + sizeof(printer_mib_prtMediaPathEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtMediaPathEntry);
    }
}

void
printer_mib_free_prtMediaPathTable(printer_mib_prtMediaPathEntry_t **prtMediaPathEntry)
{
    int i;

    if (prtMediaPathEntry) {
        for (i = 0; prtMediaPathEntry[i]; i++) {
            printer_mib_free_prtMediaPathEntry(prtMediaPathEntry[i]);
        }
        g_free(prtMediaPathEntry);
    }
}

printer_mib_prtChannelEntry_t *
printer_mib_new_prtChannelEntry()
{
    printer_mib_prtChannelEntry_t *prtChannelEntry;

    prtChannelEntry = (printer_mib_prtChannelEntry_t *) g_malloc0(sizeof(printer_mib_prtChannelEntry_t) + sizeof(gpointer));
    return prtChannelEntry;
}

static int
unpack_prtChannelEntry(GSnmpVarBind *vb, printer_mib_prtChannelEntry_t *prtChannelEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtChannelEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtChannelEntry->prtChannelIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtChannelEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtChannelIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtChannelIndex;
    return idx;
}

static printer_mib_prtChannelEntry_t *
assign_prtChannelEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtChannelEntry_t *prtChannelEntry;
    guint32 idx;
    char *p;

    prtChannelEntry = printer_mib_new_prtChannelEntry();
    if (! prtChannelEntry) {
        return NULL;
    }

    p = (char *) prtChannelEntry + sizeof(printer_mib_prtChannelEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtChannelEntry((GSnmpVarBind *) vbl->data, prtChannelEntry) < 0) {
        g_warning("illegal prtChannelEntry instance identifier");
        g_free(prtChannelEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtChannelEntry, sizeof(oid_prtChannelEntry)/sizeof(guint32),
                   attr_prtChannelEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtChannelEntry->prtChannelType = &(vb->syntax.i32[0]);
            break;
        case 3:
            if (vb->syntax_len > 63) break;
            prtChannelEntry->_prtChannelProtocolVersionLength = vb->syntax_len;
            prtChannelEntry->prtChannelProtocolVersion = vb->syntax.uc;
            break;
        case 4:
            prtChannelEntry->prtChannelCurrentJobCntlLangIndex = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtChannelEntry->prtChannelDefaultPageDescLangIndex = &(vb->syntax.i32[0]);
            break;
        case 6:
            prtChannelEntry->prtChannelState = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtChannelEntry->prtChannelIfIndex = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtChannelEntry->prtChannelStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            if (vb->syntax_len > 255) break;
            prtChannelEntry->_prtChannelInformationLength = vb->syntax_len;
            prtChannelEntry->prtChannelInformation = vb->syntax.uc;
            break;
        };
    }

    return prtChannelEntry;
}

void
printer_mib_get_prtChannelTable(GSnmpSession *s, printer_mib_prtChannelEntry_t ***prtChannelEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 14, 1, 1, 0};

    *prtChannelEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtChannelEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtChannelEntry = (printer_mib_prtChannelEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtChannelEntry_t *));
        if (! *prtChannelEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtChannelEntry)[i] = assign_prtChannelEntry(row->data);
        }
    }
}

void
printer_mib_get_prtChannelEntry(GSnmpSession *s, printer_mib_prtChannelEntry_t **prtChannelEntry, gint32 hrDeviceIndex, gint32 prtChannelIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtChannelEntry, sizeof(oid_prtChannelEntry));
    len = pack_prtChannelEntry(base, hrDeviceIndex, prtChannelIndex);
    if (len < 0) {
        g_warning("illegal prtChannelEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtChannelEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtChannelEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtChannelEntry = assign_prtChannelEntry(out);
    }
}

void
printer_mib_set_prtChannelEntry(GSnmpSession *s, printer_mib_prtChannelEntry_t *prtChannelEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtChannelEntry, sizeof(oid_prtChannelEntry));
    len = pack_prtChannelEntry(base, prtChannelEntry->hrDeviceIndex, prtChannelEntry->prtChannelIndex);
    if (len < 0) {
        g_warning("illegal prtChannelEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtChannelEntry->prtChannelCurrentJobCntlLangIndex) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtChannelEntry->prtChannelCurrentJobCntlLangIndex,
                       0);
    }
    if (prtChannelEntry->prtChannelDefaultPageDescLangIndex) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtChannelEntry->prtChannelDefaultPageDescLangIndex,
                       0);
    }
    if (prtChannelEntry->prtChannelState) {
        base[10] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtChannelEntry->prtChannelState,
                       0);
    }
    if (prtChannelEntry->prtChannelIfIndex) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtChannelEntry->prtChannelIfIndex,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtChannelEntry(printer_mib_prtChannelEntry_t *prtChannelEntry)
{
    GSList *vbl;
    char *p;

    if (prtChannelEntry) {
        p = (char *) prtChannelEntry + sizeof(printer_mib_prtChannelEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtChannelEntry);
    }
}

void
printer_mib_free_prtChannelTable(printer_mib_prtChannelEntry_t **prtChannelEntry)
{
    int i;

    if (prtChannelEntry) {
        for (i = 0; prtChannelEntry[i]; i++) {
            printer_mib_free_prtChannelEntry(prtChannelEntry[i]);
        }
        g_free(prtChannelEntry);
    }
}

printer_mib_prtInterpreterEntry_t *
printer_mib_new_prtInterpreterEntry()
{
    printer_mib_prtInterpreterEntry_t *prtInterpreterEntry;

    prtInterpreterEntry = (printer_mib_prtInterpreterEntry_t *) g_malloc0(sizeof(printer_mib_prtInterpreterEntry_t) + sizeof(gpointer));
    return prtInterpreterEntry;
}

static int
unpack_prtInterpreterEntry(GSnmpVarBind *vb, printer_mib_prtInterpreterEntry_t *prtInterpreterEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtInterpreterEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtInterpreterEntry->prtInterpreterIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtInterpreterEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtInterpreterIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtInterpreterIndex;
    return idx;
}

static printer_mib_prtInterpreterEntry_t *
assign_prtInterpreterEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtInterpreterEntry_t *prtInterpreterEntry;
    guint32 idx;
    char *p;

    prtInterpreterEntry = printer_mib_new_prtInterpreterEntry();
    if (! prtInterpreterEntry) {
        return NULL;
    }

    p = (char *) prtInterpreterEntry + sizeof(printer_mib_prtInterpreterEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtInterpreterEntry((GSnmpVarBind *) vbl->data, prtInterpreterEntry) < 0) {
        g_warning("illegal prtInterpreterEntry instance identifier");
        g_free(prtInterpreterEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtInterpreterEntry, sizeof(oid_prtInterpreterEntry)/sizeof(guint32),
                   attr_prtInterpreterEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtInterpreterEntry->prtInterpreterLangFamily = &(vb->syntax.i32[0]);
            break;
        case 3:
            if (vb->syntax_len > 31) break;
            prtInterpreterEntry->_prtInterpreterLangLevelLength = vb->syntax_len;
            prtInterpreterEntry->prtInterpreterLangLevel = vb->syntax.uc;
            break;
        case 4:
            if (vb->syntax_len > 31) break;
            prtInterpreterEntry->_prtInterpreterLangVersionLength = vb->syntax_len;
            prtInterpreterEntry->prtInterpreterLangVersion = vb->syntax.uc;
            break;
        case 5:
            if (vb->syntax_len > 255) break;
            prtInterpreterEntry->_prtInterpreterDescriptionLength = vb->syntax_len;
            prtInterpreterEntry->prtInterpreterDescription = vb->syntax.uc;
            break;
        case 6:
            if (vb->syntax_len > 31) break;
            prtInterpreterEntry->_prtInterpreterVersionLength = vb->syntax_len;
            prtInterpreterEntry->prtInterpreterVersion = vb->syntax.uc;
            break;
        case 7:
            prtInterpreterEntry->prtInterpreterDefaultOrientation = &(vb->syntax.i32[0]);
            break;
        case 8:
            prtInterpreterEntry->prtInterpreterFeedAddressability = &(vb->syntax.i32[0]);
            break;
        case 9:
            prtInterpreterEntry->prtInterpreterXFeedAddressability = &(vb->syntax.i32[0]);
            break;
        case 10:
            prtInterpreterEntry->prtInterpreterDefaultCharSetIn = &(vb->syntax.i32[0]);
            break;
        case 11:
            prtInterpreterEntry->prtInterpreterDefaultCharSetOut = &(vb->syntax.i32[0]);
            break;
        case 12:
            prtInterpreterEntry->prtInterpreterTwoWay = &(vb->syntax.i32[0]);
            break;
        };
    }

    return prtInterpreterEntry;
}

void
printer_mib_get_prtInterpreterTable(GSnmpSession *s, printer_mib_prtInterpreterEntry_t ***prtInterpreterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 15, 1, 1, 0};

    *prtInterpreterEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtInterpreterEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtInterpreterEntry = (printer_mib_prtInterpreterEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtInterpreterEntry_t *));
        if (! *prtInterpreterEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtInterpreterEntry)[i] = assign_prtInterpreterEntry(row->data);
        }
    }
}

void
printer_mib_get_prtInterpreterEntry(GSnmpSession *s, printer_mib_prtInterpreterEntry_t **prtInterpreterEntry, gint32 hrDeviceIndex, gint32 prtInterpreterIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtInterpreterEntry, sizeof(oid_prtInterpreterEntry));
    len = pack_prtInterpreterEntry(base, hrDeviceIndex, prtInterpreterIndex);
    if (len < 0) {
        g_warning("illegal prtInterpreterEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtInterpreterEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtInterpreterEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtInterpreterEntry = assign_prtInterpreterEntry(out);
    }
}

void
printer_mib_set_prtInterpreterEntry(GSnmpSession *s, printer_mib_prtInterpreterEntry_t *prtInterpreterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtInterpreterEntry, sizeof(oid_prtInterpreterEntry));
    len = pack_prtInterpreterEntry(base, prtInterpreterEntry->hrDeviceIndex, prtInterpreterEntry->prtInterpreterIndex);
    if (len < 0) {
        g_warning("illegal prtInterpreterEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtInterpreterEntry->prtInterpreterDefaultOrientation) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInterpreterEntry->prtInterpreterDefaultOrientation,
                       0);
    }
    if (prtInterpreterEntry->prtInterpreterDefaultCharSetIn) {
        base[10] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInterpreterEntry->prtInterpreterDefaultCharSetIn,
                       0);
    }
    if (prtInterpreterEntry->prtInterpreterDefaultCharSetOut) {
        base[10] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtInterpreterEntry->prtInterpreterDefaultCharSetOut,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtInterpreterEntry(printer_mib_prtInterpreterEntry_t *prtInterpreterEntry)
{
    GSList *vbl;
    char *p;

    if (prtInterpreterEntry) {
        p = (char *) prtInterpreterEntry + sizeof(printer_mib_prtInterpreterEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtInterpreterEntry);
    }
}

void
printer_mib_free_prtInterpreterTable(printer_mib_prtInterpreterEntry_t **prtInterpreterEntry)
{
    int i;

    if (prtInterpreterEntry) {
        for (i = 0; prtInterpreterEntry[i]; i++) {
            printer_mib_free_prtInterpreterEntry(prtInterpreterEntry[i]);
        }
        g_free(prtInterpreterEntry);
    }
}

printer_mib_prtConsoleDisplayBufferEntry_t *
printer_mib_new_prtConsoleDisplayBufferEntry()
{
    printer_mib_prtConsoleDisplayBufferEntry_t *prtConsoleDisplayBufferEntry;

    prtConsoleDisplayBufferEntry = (printer_mib_prtConsoleDisplayBufferEntry_t *) g_malloc0(sizeof(printer_mib_prtConsoleDisplayBufferEntry_t) + sizeof(gpointer));
    return prtConsoleDisplayBufferEntry;
}

static int
unpack_prtConsoleDisplayBufferEntry(GSnmpVarBind *vb, printer_mib_prtConsoleDisplayBufferEntry_t *prtConsoleDisplayBufferEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtConsoleDisplayBufferEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtConsoleDisplayBufferEntry->prtConsoleDisplayBufferIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtConsoleDisplayBufferEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtConsoleDisplayBufferIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtConsoleDisplayBufferIndex;
    return idx;
}

static printer_mib_prtConsoleDisplayBufferEntry_t *
assign_prtConsoleDisplayBufferEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtConsoleDisplayBufferEntry_t *prtConsoleDisplayBufferEntry;
    guint32 idx;
    char *p;

    prtConsoleDisplayBufferEntry = printer_mib_new_prtConsoleDisplayBufferEntry();
    if (! prtConsoleDisplayBufferEntry) {
        return NULL;
    }

    p = (char *) prtConsoleDisplayBufferEntry + sizeof(printer_mib_prtConsoleDisplayBufferEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtConsoleDisplayBufferEntry((GSnmpVarBind *) vbl->data, prtConsoleDisplayBufferEntry) < 0) {
        g_warning("illegal prtConsoleDisplayBufferEntry instance identifier");
        g_free(prtConsoleDisplayBufferEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtConsoleDisplayBufferEntry, sizeof(oid_prtConsoleDisplayBufferEntry)/sizeof(guint32),
                   attr_prtConsoleDisplayBufferEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            if (vb->syntax_len > 255) break;
            prtConsoleDisplayBufferEntry->_prtConsoleDisplayBufferTextLength = vb->syntax_len;
            prtConsoleDisplayBufferEntry->prtConsoleDisplayBufferText = vb->syntax.uc;
            break;
        };
    }

    return prtConsoleDisplayBufferEntry;
}

void
printer_mib_get_prtConsoleDisplayBufferTable(GSnmpSession *s, printer_mib_prtConsoleDisplayBufferEntry_t ***prtConsoleDisplayBufferEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 16, 5, 1, 0};

    *prtConsoleDisplayBufferEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtConsoleDisplayBufferEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtConsoleDisplayBufferEntry = (printer_mib_prtConsoleDisplayBufferEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtConsoleDisplayBufferEntry_t *));
        if (! *prtConsoleDisplayBufferEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtConsoleDisplayBufferEntry)[i] = assign_prtConsoleDisplayBufferEntry(row->data);
        }
    }
}

void
printer_mib_get_prtConsoleDisplayBufferEntry(GSnmpSession *s, printer_mib_prtConsoleDisplayBufferEntry_t **prtConsoleDisplayBufferEntry, gint32 hrDeviceIndex, gint32 prtConsoleDisplayBufferIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtConsoleDisplayBufferEntry, sizeof(oid_prtConsoleDisplayBufferEntry));
    len = pack_prtConsoleDisplayBufferEntry(base, hrDeviceIndex, prtConsoleDisplayBufferIndex);
    if (len < 0) {
        g_warning("illegal prtConsoleDisplayBufferEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtConsoleDisplayBufferEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtConsoleDisplayBufferEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtConsoleDisplayBufferEntry = assign_prtConsoleDisplayBufferEntry(out);
    }
}

void
printer_mib_set_prtConsoleDisplayBufferEntry(GSnmpSession *s, printer_mib_prtConsoleDisplayBufferEntry_t *prtConsoleDisplayBufferEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtConsoleDisplayBufferEntry, sizeof(oid_prtConsoleDisplayBufferEntry));
    len = pack_prtConsoleDisplayBufferEntry(base, prtConsoleDisplayBufferEntry->hrDeviceIndex, prtConsoleDisplayBufferEntry->prtConsoleDisplayBufferIndex);
    if (len < 0) {
        g_warning("illegal prtConsoleDisplayBufferEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtConsoleDisplayBufferEntry->prtConsoleDisplayBufferText) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       prtConsoleDisplayBufferEntry->prtConsoleDisplayBufferText,
                       prtConsoleDisplayBufferEntry->_prtConsoleDisplayBufferTextLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtConsoleDisplayBufferEntry(printer_mib_prtConsoleDisplayBufferEntry_t *prtConsoleDisplayBufferEntry)
{
    GSList *vbl;
    char *p;

    if (prtConsoleDisplayBufferEntry) {
        p = (char *) prtConsoleDisplayBufferEntry + sizeof(printer_mib_prtConsoleDisplayBufferEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtConsoleDisplayBufferEntry);
    }
}

void
printer_mib_free_prtConsoleDisplayBufferTable(printer_mib_prtConsoleDisplayBufferEntry_t **prtConsoleDisplayBufferEntry)
{
    int i;

    if (prtConsoleDisplayBufferEntry) {
        for (i = 0; prtConsoleDisplayBufferEntry[i]; i++) {
            printer_mib_free_prtConsoleDisplayBufferEntry(prtConsoleDisplayBufferEntry[i]);
        }
        g_free(prtConsoleDisplayBufferEntry);
    }
}

printer_mib_prtConsoleLightEntry_t *
printer_mib_new_prtConsoleLightEntry()
{
    printer_mib_prtConsoleLightEntry_t *prtConsoleLightEntry;

    prtConsoleLightEntry = (printer_mib_prtConsoleLightEntry_t *) g_malloc0(sizeof(printer_mib_prtConsoleLightEntry_t) + sizeof(gpointer));
    return prtConsoleLightEntry;
}

static int
unpack_prtConsoleLightEntry(GSnmpVarBind *vb, printer_mib_prtConsoleLightEntry_t *prtConsoleLightEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtConsoleLightEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtConsoleLightEntry->prtConsoleLightIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtConsoleLightEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtConsoleLightIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtConsoleLightIndex;
    return idx;
}

static printer_mib_prtConsoleLightEntry_t *
assign_prtConsoleLightEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtConsoleLightEntry_t *prtConsoleLightEntry;
    guint32 idx;
    char *p;

    prtConsoleLightEntry = printer_mib_new_prtConsoleLightEntry();
    if (! prtConsoleLightEntry) {
        return NULL;
    }

    p = (char *) prtConsoleLightEntry + sizeof(printer_mib_prtConsoleLightEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtConsoleLightEntry((GSnmpVarBind *) vbl->data, prtConsoleLightEntry) < 0) {
        g_warning("illegal prtConsoleLightEntry instance identifier");
        g_free(prtConsoleLightEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtConsoleLightEntry, sizeof(oid_prtConsoleLightEntry)/sizeof(guint32),
                   attr_prtConsoleLightEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtConsoleLightEntry->prtConsoleOnTime = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtConsoleLightEntry->prtConsoleOffTime = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtConsoleLightEntry->prtConsoleColor = &(vb->syntax.i32[0]);
            break;
        case 5:
            if (vb->syntax_len > 255) break;
            prtConsoleLightEntry->_prtConsoleDescriptionLength = vb->syntax_len;
            prtConsoleLightEntry->prtConsoleDescription = vb->syntax.uc;
            break;
        };
    }

    return prtConsoleLightEntry;
}

void
printer_mib_get_prtConsoleLightTable(GSnmpSession *s, printer_mib_prtConsoleLightEntry_t ***prtConsoleLightEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 17, 6, 1, 0};

    *prtConsoleLightEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtConsoleLightEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtConsoleLightEntry = (printer_mib_prtConsoleLightEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtConsoleLightEntry_t *));
        if (! *prtConsoleLightEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtConsoleLightEntry)[i] = assign_prtConsoleLightEntry(row->data);
        }
    }
}

void
printer_mib_get_prtConsoleLightEntry(GSnmpSession *s, printer_mib_prtConsoleLightEntry_t **prtConsoleLightEntry, gint32 hrDeviceIndex, gint32 prtConsoleLightIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtConsoleLightEntry, sizeof(oid_prtConsoleLightEntry));
    len = pack_prtConsoleLightEntry(base, hrDeviceIndex, prtConsoleLightIndex);
    if (len < 0) {
        g_warning("illegal prtConsoleLightEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtConsoleLightEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtConsoleLightEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtConsoleLightEntry = assign_prtConsoleLightEntry(out);
    }
}

void
printer_mib_set_prtConsoleLightEntry(GSnmpSession *s, printer_mib_prtConsoleLightEntry_t *prtConsoleLightEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtConsoleLightEntry, sizeof(oid_prtConsoleLightEntry));
    len = pack_prtConsoleLightEntry(base, prtConsoleLightEntry->hrDeviceIndex, prtConsoleLightEntry->prtConsoleLightIndex);
    if (len < 0) {
        g_warning("illegal prtConsoleLightEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (prtConsoleLightEntry->prtConsoleOnTime) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtConsoleLightEntry->prtConsoleOnTime,
                       0);
    }
    if (prtConsoleLightEntry->prtConsoleOffTime) {
        base[10] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       prtConsoleLightEntry->prtConsoleOffTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
printer_mib_free_prtConsoleLightEntry(printer_mib_prtConsoleLightEntry_t *prtConsoleLightEntry)
{
    GSList *vbl;
    char *p;

    if (prtConsoleLightEntry) {
        p = (char *) prtConsoleLightEntry + sizeof(printer_mib_prtConsoleLightEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtConsoleLightEntry);
    }
}

void
printer_mib_free_prtConsoleLightTable(printer_mib_prtConsoleLightEntry_t **prtConsoleLightEntry)
{
    int i;

    if (prtConsoleLightEntry) {
        for (i = 0; prtConsoleLightEntry[i]; i++) {
            printer_mib_free_prtConsoleLightEntry(prtConsoleLightEntry[i]);
        }
        g_free(prtConsoleLightEntry);
    }
}

printer_mib_prtAlertEntry_t *
printer_mib_new_prtAlertEntry()
{
    printer_mib_prtAlertEntry_t *prtAlertEntry;

    prtAlertEntry = (printer_mib_prtAlertEntry_t *) g_malloc0(sizeof(printer_mib_prtAlertEntry_t) + sizeof(gpointer));
    return prtAlertEntry;
}

static int
unpack_prtAlertEntry(GSnmpVarBind *vb, printer_mib_prtAlertEntry_t *prtAlertEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    prtAlertEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    prtAlertEntry->prtAlertIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_prtAlertEntry(guint32 *base, gint32 hrDeviceIndex, gint32 prtAlertIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = prtAlertIndex;
    return idx;
}

static printer_mib_prtAlertEntry_t *
assign_prtAlertEntry(GSList *vbl)
{
    GSList *elem;
    printer_mib_prtAlertEntry_t *prtAlertEntry;
    guint32 idx;
    char *p;

    prtAlertEntry = printer_mib_new_prtAlertEntry();
    if (! prtAlertEntry) {
        return NULL;
    }

    p = (char *) prtAlertEntry + sizeof(printer_mib_prtAlertEntry_t);
    * (GSList **) p = vbl;

    if (unpack_prtAlertEntry((GSnmpVarBind *) vbl->data, prtAlertEntry) < 0) {
        g_warning("illegal prtAlertEntry instance identifier");
        g_free(prtAlertEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_prtAlertEntry, sizeof(oid_prtAlertEntry)/sizeof(guint32),
                   attr_prtAlertEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            prtAlertEntry->prtAlertSeverityLevel = &(vb->syntax.i32[0]);
            break;
        case 3:
            prtAlertEntry->prtAlertTrainingLevel = &(vb->syntax.i32[0]);
            break;
        case 4:
            prtAlertEntry->prtAlertGroup = &(vb->syntax.i32[0]);
            break;
        case 5:
            prtAlertEntry->prtAlertGroupIndex = &(vb->syntax.i32[0]);
            break;
        case 6:
            prtAlertEntry->prtAlertLocation = &(vb->syntax.i32[0]);
            break;
        case 7:
            prtAlertEntry->prtAlertCode = &(vb->syntax.i32[0]);
            break;
        case 8:
            if (vb->syntax_len > 255) break;
            prtAlertEntry->_prtAlertDescriptionLength = vb->syntax_len;
            prtAlertEntry->prtAlertDescription = vb->syntax.uc;
            break;
        case 9:
            prtAlertEntry->prtAlertTime = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return prtAlertEntry;
}

void
printer_mib_get_prtAlertTable(GSnmpSession *s, printer_mib_prtAlertEntry_t ***prtAlertEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 43, 18, 1, 1, 0};

    *prtAlertEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_prtAlertEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *prtAlertEntry = (printer_mib_prtAlertEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(printer_mib_prtAlertEntry_t *));
        if (! *prtAlertEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*prtAlertEntry)[i] = assign_prtAlertEntry(row->data);
        }
    }
}

void
printer_mib_get_prtAlertEntry(GSnmpSession *s, printer_mib_prtAlertEntry_t **prtAlertEntry, gint32 hrDeviceIndex, gint32 prtAlertIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_prtAlertEntry, sizeof(oid_prtAlertEntry));
    len = pack_prtAlertEntry(base, hrDeviceIndex, prtAlertIndex);
    if (len < 0) {
        g_warning("illegal prtAlertEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *prtAlertEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_prtAlertEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *prtAlertEntry = assign_prtAlertEntry(out);
    }
}

void
printer_mib_free_prtAlertEntry(printer_mib_prtAlertEntry_t *prtAlertEntry)
{
    GSList *vbl;
    char *p;

    if (prtAlertEntry) {
        p = (char *) prtAlertEntry + sizeof(printer_mib_prtAlertEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(prtAlertEntry);
    }
}

void
printer_mib_free_prtAlertTable(printer_mib_prtAlertEntry_t **prtAlertEntry)
{
    int i;

    if (prtAlertEntry) {
        for (i = 0; prtAlertEntry[i]; i++) {
            printer_mib_free_prtAlertEntry(prtAlertEntry[i]);
        }
        g_free(prtAlertEntry);
    }
}


