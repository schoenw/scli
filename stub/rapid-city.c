/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from RAPID-CITY:
 *   Enterprise MIB for the Accelar product family.
 *
 * Revision 1997-01-01 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "rapid-city.h"

GSnmpEnum const rapid_city_enums_rcVlanHighPriority[] = {
    { RAPID_CITY_RCVLANHIGHPRIORITY_TRUE,  "true" },
    { RAPID_CITY_RCVLANHIGHPRIORITY_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanRoutingEnable[] = {
    { RAPID_CITY_RCVLANROUTINGENABLE_TRUE,  "true" },
    { RAPID_CITY_RCVLANROUTINGENABLE_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanAction[] = {
    { RAPID_CITY_RCVLANACTION_NONE,             "none" },
    { RAPID_CITY_RCVLANACTION_FLUSHMACFDB,      "flushMacFdb" },
    { RAPID_CITY_RCVLANACTION_FLUSHARP,         "flushArp" },
    { RAPID_CITY_RCVLANACTION_FLUSHIP,          "flushIp" },
    { RAPID_CITY_RCVLANACTION_FLUSHDYNMEMB,     "flushDynMemb" },
    { RAPID_CITY_RCVLANACTION_ALL,              "all" },
    { RAPID_CITY_RCVLANACTION_FLUSHSNOOPMEMB,   "flushSnoopMemb" },
    { RAPID_CITY_RCVLANACTION_TRIGGERRIPUPDATE, "triggerRipUpdate" },
    { RAPID_CITY_RCVLANACTION_FLUSHSNOOPMRTR,   "flushSnoopMRtr" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanResult[] = {
    { RAPID_CITY_RCVLANRESULT_NONE,       "none" },
    { RAPID_CITY_RCVLANRESULT_INPROGRESS, "inProgress" },
    { RAPID_CITY_RCVLANRESULT_SUCCESS,    "success" },
    { RAPID_CITY_RCVLANRESULT_FAIL,       "fail" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanType[] = {
    { RAPID_CITY_RCVLANTYPE_BYPORT,       "byPort" },
    { RAPID_CITY_RCVLANTYPE_BYIPSUBNET,   "byIpSubnet" },
    { RAPID_CITY_RCVLANTYPE_BYPROTOCOLID, "byProtocolId" },
    { RAPID_CITY_RCVLANTYPE_BYSRCMAC,     "bySrcMac" },
    { RAPID_CITY_RCVLANTYPE_BYDSTMCAST,   "byDstMcast" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanProtocolId[] = {
    { RAPID_CITY_RCVLANPROTOCOLID_NONE,         "none" },
    { RAPID_CITY_RCVLANPROTOCOLID_IP,           "ip" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPX802DOT3,   "ipx802dot3" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPX802DOT2,   "ipx802dot2" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPXSNAP,      "ipxSnap" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPXETHERNET2, "ipxEthernet2" },
    { RAPID_CITY_RCVLANPROTOCOLID_APPLETALK,    "appleTalk" },
    { RAPID_CITY_RCVLANPROTOCOLID_DECLAT,       "decLat" },
    { RAPID_CITY_RCVLANPROTOCOLID_DECOTHER,     "decOther" },
    { RAPID_CITY_RCVLANPROTOCOLID_SNA802DOT2,   "sna802dot2" },
    { RAPID_CITY_RCVLANPROTOCOLID_SNAETHERNET2, "snaEthernet2" },
    { RAPID_CITY_RCVLANPROTOCOLID_NETBIOS,      "netBios" },
    { RAPID_CITY_RCVLANPROTOCOLID_XNS,          "xns" },
    { RAPID_CITY_RCVLANPROTOCOLID_VINES,        "vines" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPV6,         "ipV6" },
    { RAPID_CITY_RCVLANPROTOCOLID_USRDEFINED,   "usrDefined" },
    { RAPID_CITY_RCVLANPROTOCOLID_RARP,         "rarp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanRowStatus[] = {
    { RAPID_CITY_RCVLANROWSTATUS_ACTIVE,        "active" },
    { RAPID_CITY_RCVLANROWSTATUS_NOTINSERVICE,  "notInService" },
    { RAPID_CITY_RCVLANROWSTATUS_NOTREADY,      "notReady" },
    { RAPID_CITY_RCVLANROWSTATUS_CREATEANDGO,   "createAndGo" },
    { RAPID_CITY_RCVLANROWSTATUS_CREATEANDWAIT, "createAndWait" },
    { RAPID_CITY_RCVLANROWSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopEnable[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPENABLE_TRUE,  "true" },
    { RAPID_CITY_RCVLANIGMPSNOOPENABLE_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopReportProxyEnable[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE_TRUE,  "true" },
    { RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortType[] = {
    { RAPID_CITY_RCVLANPORTTYPE_ACCESS, "access" },
    { RAPID_CITY_RCVLANPORTTYPE_TRUNK,  "trunk" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortDiscardTaggedFrames[] = {
    { RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES_TRUE,  "true" },
    { RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortDiscardUntaggedFrames[] = {
    { RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES_TRUE,  "true" },
    { RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortPerformTagging[] = {
    { RAPID_CITY_RCVLANPORTPERFORMTAGGING_TRUE,  "true" },
    { RAPID_CITY_RCVLANPORTPERFORMTAGGING_FALSE, "false" },
    { 0, NULL }
};


static guint16 rcVlanName_constraints[] = {0, 20, 0, 0};
static guint32 rcVlanColor_constraints[] = {0L, 32L, 0, 0};
static guint32 rcVlanStgId_constraints[] = {0L, 128L, 0, 0};
static guint16 rcVlanPortMembers_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanActiveMembers_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanStaticMembers_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanNotAllowToJoin_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanSubnetAddr_constraints[] = {4, 4, 0, 0};
static guint16 rcVlanSubnetMask_constraints[] = {4, 4, 0, 0};
static guint32 rcVlanAgingTime_constraints[] = {10L, 1000000L, 0, 0};
static guint16 rcVlanMacAddress_constraints[] = {6, 6, 0, 0};
static guint32 rcVlanIgmpSnoopRobustness_constraints[] = {2L, 255L, 0, 0};
static guint32 rcVlanIgmpSnoopQueryInterval_constraints[] = {1L, 65535L, 0, 0};
static guint16 rcVlanIgmpSnoopMRouterPorts_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanIgmpSnoopActiveMRouterPorts_constraints[] = {32, 32, 0, 0};
static guint16 rcVlanIgmpSnoopActiveQuerier_constraints[] = {4, 4, 0, 0};
static guint16 rcVlanPortVlanIds_constraints[] = {250, 250, 0, 0};
static guint32 rcVlanPortDefaultVlanId_constraints[] = {1L, 4094L, 0, 0};


static guint32 const rcVlanEntry_oid[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1};

static GSnmpAttribute rcVlanEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANNAME, "rcVlanName",
       rcVlanName_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanName),
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, _rcVlanNameLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANCOLOR, "rcVlanColor",
       rcVlanColor_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanColor),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANHIGHPRIORITY, "rcVlanHighPriority",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanHighPriority),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANROUTINGENABLE, "rcVlanRoutingEnable",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanRoutingEnable),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIFINDEX, "rcVlanIfIndex",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIfIndex),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANACTION, "rcVlanAction",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanAction),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANRESULT, "rcVlanResult",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanResult),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANSTGID, "rcVlanStgId",
       rcVlanStgId_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanStgId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANTYPE, "rcVlanType",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANPORTMEMBERS, "rcVlanPortMembers",
       rcVlanPortMembers_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanPortMembers),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANACTIVEMEMBERS, "rcVlanActiveMembers",
       rcVlanActiveMembers_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanActiveMembers),
      0,
      0 },
    { 13, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANSTATICMEMBERS, "rcVlanStaticMembers",
       rcVlanStaticMembers_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanStaticMembers),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 14, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANNOTALLOWTOJOIN, "rcVlanNotAllowToJoin",
       rcVlanNotAllowToJoin_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanNotAllowToJoin),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 15, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPROTOCOLID, "rcVlanProtocolId",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanProtocolId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 16, G_SNMP_IPADDRESS,
      RAPID_CITY_RCVLANSUBNETADDR, "rcVlanSubnetAddr",
       rcVlanSubnetAddr_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanSubnetAddr),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 17, G_SNMP_IPADDRESS,
      RAPID_CITY_RCVLANSUBNETMASK, "rcVlanSubnetMask",
       rcVlanSubnetMask_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanSubnetMask),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 18, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANAGINGTIME, "rcVlanAgingTime",
       rcVlanAgingTime_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanAgingTime),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 19, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANMACADDRESS, "rcVlanMacAddress",
       rcVlanMacAddress_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanMacAddress),
      0,
      0 },
    { 20, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANROWSTATUS, "rcVlanRowStatus",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanRowStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 21, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPENABLE, "rcVlanIgmpSnoopEnable",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopEnable),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 22, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE, "rcVlanIgmpSnoopReportProxyEnable",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopReportProxyEnable),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 23, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPROBUSTNESS, "rcVlanIgmpSnoopRobustness",
       rcVlanIgmpSnoopRobustness_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopRobustness),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 24, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPQUERYINTERVAL, "rcVlanIgmpSnoopQueryInterval",
       rcVlanIgmpSnoopQueryInterval_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopQueryInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 25, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANIGMPSNOOPMROUTERPORTS, "rcVlanIgmpSnoopMRouterPorts",
       rcVlanIgmpSnoopMRouterPorts_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopMRouterPorts),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 26, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANUSERDEFINEDPID, "rcVlanUserDefinedPid",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanUserDefinedPid),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 27, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANIGMPSNOOPACTIVEMROUTERPORTS, "rcVlanIgmpSnoopActiveMRouterPorts",
       rcVlanIgmpSnoopActiveMRouterPorts_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopActiveMRouterPorts),
      0,
      0 },
    { 28, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPROTOCOLIDS, "rcVlanProtocolIds",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanProtocolIds),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 29, G_SNMP_IPADDRESS,
      RAPID_CITY_RCVLANIGMPSNOOPACTIVEQUERIER, "rcVlanIgmpSnoopActiveQuerier",
       rcVlanIgmpSnoopActiveQuerier_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopActiveQuerier),
      0,
      0 },
    { 30, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPMROUTEREXPIRATION, "rcVlanIgmpSnoopMRouterExpiration",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopMRouterExpiration),
      0,
      0 },
    { 31, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANIGMPSNOOPQUERIERPORT, "rcVlanIgmpSnoopQuerierPort",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanEntry_t, rcVlanIgmpSnoopQuerierPort),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const rcVlanPortEntry_oid[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1};

static GSnmpAttribute rcVlanPortEntry_attr[] = {
    { 2, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTNUMVLANIDS, "rcVlanPortNumVlanIds",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortNumVlanIds),
      0,
      0 },
    { 3, G_SNMP_OCTETSTRING,
      RAPID_CITY_RCVLANPORTVLANIDS, "rcVlanPortVlanIds",
       rcVlanPortVlanIds_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortVlanIds),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTTYPE, "rcVlanPortType",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES, "rcVlanPortDiscardTaggedFrames",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortDiscardTaggedFrames),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES, "rcVlanPortDiscardUntaggedFrames",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortDiscardUntaggedFrames),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTDEFAULTVLANID, "rcVlanPortDefaultVlanId",
       rcVlanPortDefaultVlanId_constraints,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortDefaultVlanId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, G_SNMP_INTEGER32,
      RAPID_CITY_RCVLANPORTPERFORMTAGGING, "rcVlanPortPerformTagging",
       NULL,
      G_STRUCT_OFFSET(rapid_city_rcVlanPortEntry_t, rcVlanPortPerformTagging),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


rapid_city_rcVlanEntry_t *
rapid_city_new_rcVlanEntry()
{
    rapid_city_rcVlanEntry_t *rcVlanEntry;

    rcVlanEntry = (rapid_city_rcVlanEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanEntry_t) + sizeof(gpointer));
    return rcVlanEntry;
}

static int
unpack_rcVlanEntry(GSnmpVarBind *vb, rapid_city_rcVlanEntry_t *rcVlanEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanEntry->rcVlanId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanEntry(guint32 *base, gint32 rcVlanId)
{
    guint8 idx = 12;

    base[idx++] = rcVlanId;
    return idx;
}

static rapid_city_rcVlanEntry_t *
assign_rcVlanEntry(GSList *vbl)
{
    rapid_city_rcVlanEntry_t *rcVlanEntry;
    char *p;

    rcVlanEntry = rapid_city_new_rcVlanEntry();
    if (! rcVlanEntry) {
        return NULL;
    }

    p = (char *) rcVlanEntry + sizeof(rapid_city_rcVlanEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanEntry((GSnmpVarBind *) vbl->data, rcVlanEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rcVlanEntry");
        g_free(rcVlanEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, rcVlanEntry_oid, sizeof(rcVlanEntry_oid)/sizeof(guint32),
                      rcVlanEntry_attr, rcVlanEntry);

    return rcVlanEntry;
}

void
rapid_city_get_rcVlanTable(GSnmpSession *s, rapid_city_rcVlanEntry_t ***rcVlanEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 0};

    *rcVlanEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, rcVlanEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanEntry = (rapid_city_rcVlanEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanEntry_t *));
        if (! *rcVlanEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanEntry)[i] = assign_rcVlanEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanEntry(GSnmpSession *s, rapid_city_rcVlanEntry_t **rcVlanEntry, gint32 rcVlanId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, rcVlanEntry_oid, sizeof(rcVlanEntry_oid));
    len = pack_rcVlanEntry(base, rcVlanId);
    if (len < 0) {
        g_warning("%s: invalid index values", "rcVlanEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *rcVlanEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, rcVlanEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *rcVlanEntry = assign_rcVlanEntry(out);
    }
}

void
rapid_city_set_rcVlanEntry(GSnmpSession *s, rapid_city_rcVlanEntry_t *rcVlanEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, rcVlanEntry_oid, sizeof(rcVlanEntry_oid));
    len = pack_rcVlanEntry(base, rcVlanEntry->rcVlanId);
    if (len < 0) {
        g_warning("%s: invalid index values", "rcVlanEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 11, rcVlanEntry_attr, mask, rcVlanEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanEntry(rapid_city_rcVlanEntry_t *rcVlanEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanEntry) {
        p = (char *) rcVlanEntry + sizeof(rapid_city_rcVlanEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanEntry);
    }
}

void
rapid_city_free_rcVlanTable(rapid_city_rcVlanEntry_t **rcVlanEntry)
{
    int i;

    if (rcVlanEntry) {
        for (i = 0; rcVlanEntry[i]; i++) {
            rapid_city_free_rcVlanEntry(rcVlanEntry[i]);
        }
        g_free(rcVlanEntry);
    }
}

rapid_city_rcVlanPortEntry_t *
rapid_city_new_rcVlanPortEntry()
{
    rapid_city_rcVlanPortEntry_t *rcVlanPortEntry;

    rcVlanPortEntry = (rapid_city_rcVlanPortEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanPortEntry_t) + sizeof(gpointer));
    return rcVlanPortEntry;
}

static int
unpack_rcVlanPortEntry(GSnmpVarBind *vb, rapid_city_rcVlanPortEntry_t *rcVlanPortEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanPortEntry->rcVlanPortIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanPortEntry(guint32 *base, gint32 rcVlanPortIndex)
{
    guint8 idx = 12;

    base[idx++] = rcVlanPortIndex;
    return idx;
}

static rapid_city_rcVlanPortEntry_t *
assign_rcVlanPortEntry(GSList *vbl)
{
    rapid_city_rcVlanPortEntry_t *rcVlanPortEntry;
    char *p;

    rcVlanPortEntry = rapid_city_new_rcVlanPortEntry();
    if (! rcVlanPortEntry) {
        return NULL;
    }

    p = (char *) rcVlanPortEntry + sizeof(rapid_city_rcVlanPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanPortEntry((GSnmpVarBind *) vbl->data, rcVlanPortEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rcVlanPortEntry");
        g_free(rcVlanPortEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, rcVlanPortEntry_oid, sizeof(rcVlanPortEntry_oid)/sizeof(guint32),
                      rcVlanPortEntry_attr, rcVlanPortEntry);

    return rcVlanPortEntry;
}

void
rapid_city_get_rcVlanPortTable(GSnmpSession *s, rapid_city_rcVlanPortEntry_t ***rcVlanPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 0};

    *rcVlanPortEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, rcVlanPortEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanPortEntry = (rapid_city_rcVlanPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanPortEntry_t *));
        if (! *rcVlanPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanPortEntry)[i] = assign_rcVlanPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanPortEntry(GSnmpSession *s, rapid_city_rcVlanPortEntry_t **rcVlanPortEntry, gint32 rcVlanPortIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, rcVlanPortEntry_oid, sizeof(rcVlanPortEntry_oid));
    len = pack_rcVlanPortEntry(base, rcVlanPortIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "rcVlanPortEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *rcVlanPortEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, rcVlanPortEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *rcVlanPortEntry = assign_rcVlanPortEntry(out);
    }
}

void
rapid_city_set_rcVlanPortEntry(GSnmpSession *s, rapid_city_rcVlanPortEntry_t *rcVlanPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, rcVlanPortEntry_oid, sizeof(rcVlanPortEntry_oid));
    len = pack_rcVlanPortEntry(base, rcVlanPortEntry->rcVlanPortIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "rcVlanPortEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 11, rcVlanPortEntry_attr, mask, rcVlanPortEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanPortEntry(rapid_city_rcVlanPortEntry_t *rcVlanPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanPortEntry) {
        p = (char *) rcVlanPortEntry + sizeof(rapid_city_rcVlanPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanPortEntry);
    }
}

void
rapid_city_free_rcVlanPortTable(rapid_city_rcVlanPortEntry_t **rcVlanPortEntry)
{
    int i;

    if (rcVlanPortEntry) {
        for (i = 0; rcVlanPortEntry[i]; i++) {
            rapid_city_free_rcVlanPortEntry(rcVlanPortEntry[i]);
        }
        g_free(rcVlanPortEntry);
    }
}


