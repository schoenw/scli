/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.17 for the scli package.
 *
 * Derived from RAPID-CITY:
 *   Enterprise MIB for the Accelar product family.
 *
 * Revision 1997-01-01 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "rapid-city.h"

GSnmpEnum const rapid_city_enums_rcSysAction[] = {
    { RAPID_CITY_RCSYSACTION_NONE,	"none" },
    { RAPID_CITY_RCSYSACTION_HARDRESET,	"hardReset" },
    { RAPID_CITY_RCSYSACTION_SOFTRESET,	"softReset" },
    { RAPID_CITY_RCSYSACTION_SAVETONVRAM,	"saveToNVRAM" },
    { RAPID_CITY_RCSYSACTION_RESETCOUNTERS,	"resetCounters" },
    { RAPID_CITY_RCSYSACTION_SAVETOSTANDBYNVRAM,	"saveToStandbyNVRAM" },
    { RAPID_CITY_RCSYSACTION_CPUSWITCHOVER,	"cpuSwitchOver" },
    { RAPID_CITY_RCSYSACTION_CHECKSWINFLASH,	"checkSwInFlash" },
    { RAPID_CITY_RCSYSACTION_CHECKSWINPCMCIA,	"checkSwInPcmcia" },
    { RAPID_CITY_RCSYSACTION_RESETCONSOLE,	"resetConsole" },
    { RAPID_CITY_RCSYSACTION_RESETMODEM,	"resetModem" },
    { RAPID_CITY_RCSYSACTION_FLUSHIPROUTETBL,	"flushIpRouteTbl" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysResult[] = {
    { RAPID_CITY_RCSYSRESULT_NONE,	"none" },
    { RAPID_CITY_RCSYSRESULT_INPROGRESS,	"inProgress" },
    { RAPID_CITY_RCSYSRESULT_SUCCESS,	"success" },
    { RAPID_CITY_RCSYSRESULT_FAIL,	"fail" },
    { RAPID_CITY_RCSYSRESULT_FLASHREADFAILED,	"flashReadFailed" },
    { RAPID_CITY_RCSYSRESULT_PCMCIAREADFAILED,	"pcmciaReadFailed" },
    { RAPID_CITY_RCSYSRESULT_CRCCHECKFAILED,	"crcCheckFailed" },
    { RAPID_CITY_RCSYSRESULT_NOSTANDBYCPU,	"noStandbyCpu" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysRmonEnable[] = {
    { RAPID_CITY_RCSYSRMONENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSYSRMONENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysRmonSaveConfig[] = {
    { RAPID_CITY_RCSYSRMONSAVECONFIG_TRUE,	"true" },
    { RAPID_CITY_RCSYSRMONSAVECONFIG_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysRmonTrapOption[] = {
    { RAPID_CITY_RCSYSRMONTRAPOPTION_TOOWNER,	"toOwner" },
    { RAPID_CITY_RCSYSRMONTRAPOPTION_TOALL,	"toAll" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysSupportRouting[] = {
    { RAPID_CITY_RCSYSSUPPORTROUTING_TRUE,	"true" },
    { RAPID_CITY_RCSYSSUPPORTROUTING_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysSupportWebServer[] = {
    { RAPID_CITY_RCSYSSUPPORTWEBSERVER_TRUE,	"true" },
    { RAPID_CITY_RCSYSSUPPORTWEBSERVER_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyEnable[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSYSACCESSPOLICYENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysTrapRecvVersion[] = {
    { RAPID_CITY_RCSYSTRAPRECVVERSION_V1,	"v1" },
    { RAPID_CITY_RCSYSTRAPRECVVERSION_V2C,	"v2c" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysTrapRecvRowStatus[] = {
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCSYSTRAPRECVROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyPolicyEnable[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYPOLICYENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSYSACCESSPOLICYPOLICYENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyMode[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYMODE_ALLOW,	"allow" },
    { RAPID_CITY_RCSYSACCESSPOLICYMODE_DENY,	"deny" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyService[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_TELNET,	"telnet" },
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_SNMP,	"snmp" },
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_TFTP,	"tftp" },
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_FTP,	"ftp" },
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_HTTP,	"http" },
    { RAPID_CITY_RCSYSACCESSPOLICYSERVICE_RLOGIN,	"rlogin" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyAccessLevel[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYACCESSLEVEL_READONLY,	"readOnly" },
    { RAPID_CITY_RCSYSACCESSPOLICYACCESSLEVEL_READWRITE,	"readWrite" },
    { RAPID_CITY_RCSYSACCESSPOLICYACCESSLEVEL_READWRITEALL,	"readWriteAll" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyLog[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYLOG_TRUE,	"true" },
    { RAPID_CITY_RCSYSACCESSPOLICYLOG_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSysAccessPolicyRowStatus[] = {
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcTftpAction[] = {
    { RAPID_CITY_RCTFTPACTION_NONE,	"none" },
    { RAPID_CITY_RCTFTPACTION_DOWNLOADCONFIG,	"downloadConfig" },
    { RAPID_CITY_RCTFTPACTION_UPLOADCONFIG,	"uploadConfig" },
    { RAPID_CITY_RCTFTPACTION_DOWNLOADSWTOFLASH,	"downloadSwToFlash" },
    { RAPID_CITY_RCTFTPACTION_DOWNLOADSWTOPCMCIA,	"downloadSwToPcmcia" },
    { RAPID_CITY_RCTFTPACTION_UPLOADSW,	"uploadSw" },
    { RAPID_CITY_RCTFTPACTION_DOWNLOADSWTODRAM,	"downloadSwToDram" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcTftpResult[] = {
    { RAPID_CITY_RCTFTPRESULT_NONE,	"none" },
    { RAPID_CITY_RCTFTPRESULT_INPROGRESS,	"inProgress" },
    { RAPID_CITY_RCTFTPRESULT_NORESPONSE,	"noResponse" },
    { RAPID_CITY_RCTFTPRESULT_FILEACCESSERROR,	"fileAccessError" },
    { RAPID_CITY_RCTFTPRESULT_BADFLASH,	"badFlash" },
    { RAPID_CITY_RCTFTPRESULT_FLASHERASEFAILED,	"flashEraseFailed" },
    { RAPID_CITY_RCTFTPRESULT_PCMCIAERASEFAILED,	"pcmciaEraseFailed" },
    { RAPID_CITY_RCTFTPRESULT_SUCCESS,	"success" },
    { RAPID_CITY_RCTFTPRESULT_FAIL,	"fail" },
    { RAPID_CITY_RCTFTPRESULT_WRITETONVRAMFAILED,	"writeToNvramFailed" },
    { RAPID_CITY_RCTFTPRESULT_FLASHWRITEFAILED,	"flashWriteFailed" },
    { RAPID_CITY_RCTFTPRESULT_PCMCIAWRITEFAILED,	"pcmciaWriteFailed" },
    { RAPID_CITY_RCTFTPRESULT_CONFIGFILETOOBIG,	"configFileTooBig" },
    { RAPID_CITY_RCTFTPRESULT_IMAGEFILETOOBIG,	"imageFileTooBig" },
    { RAPID_CITY_RCTFTPRESULT_NOPCMCIADETECT,	"noPcmciaDetect" },
    { RAPID_CITY_RCTFTPRESULT_PCMCIANOTSUPPORTED,	"pcmciaNotSupported" },
    { RAPID_CITY_RCTFTPRESULT_INVALIDFILE,	"invalidFile" },
    { RAPID_CITY_RCTFTPRESULT_NOMEMORY,	"noMemory" },
    { RAPID_CITY_RCTFTPRESULT_XFERERROR,	"xferError" },
    { RAPID_CITY_RCTFTPRESULT_CRCERROR,	"crcError" },
    { RAPID_CITY_RCTFTPRESULT_READNVRAMFAILED,	"readNvramFailed" },
    { RAPID_CITY_RCTFTPRESULT_PCMCIAWRITEPROTECT,	"pcmciaWriteProtect" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanHighPriority[] = {
    { RAPID_CITY_RCVLANHIGHPRIORITY_TRUE,	"true" },
    { RAPID_CITY_RCVLANHIGHPRIORITY_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanRoutingEnable[] = {
    { RAPID_CITY_RCVLANROUTINGENABLE_TRUE,	"true" },
    { RAPID_CITY_RCVLANROUTINGENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanAction[] = {
    { RAPID_CITY_RCVLANACTION_NONE,	"none" },
    { RAPID_CITY_RCVLANACTION_FLUSHMACFDB,	"flushMacFdb" },
    { RAPID_CITY_RCVLANACTION_FLUSHARP,	"flushArp" },
    { RAPID_CITY_RCVLANACTION_FLUSHIP,	"flushIp" },
    { RAPID_CITY_RCVLANACTION_FLUSHDYNMEMB,	"flushDynMemb" },
    { RAPID_CITY_RCVLANACTION_ALL,	"all" },
    { RAPID_CITY_RCVLANACTION_FLUSHSNOOPMEMB,	"flushSnoopMemb" },
    { RAPID_CITY_RCVLANACTION_TRIGGERRIPUPDATE,	"triggerRipUpdate" },
    { RAPID_CITY_RCVLANACTION_FLUSHSNOOPMRTR,	"flushSnoopMRtr" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanResult[] = {
    { RAPID_CITY_RCVLANRESULT_NONE,	"none" },
    { RAPID_CITY_RCVLANRESULT_INPROGRESS,	"inProgress" },
    { RAPID_CITY_RCVLANRESULT_SUCCESS,	"success" },
    { RAPID_CITY_RCVLANRESULT_FAIL,	"fail" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanType[] = {
    { RAPID_CITY_RCVLANTYPE_BYPORT,	"byPort" },
    { RAPID_CITY_RCVLANTYPE_BYIPSUBNET,	"byIpSubnet" },
    { RAPID_CITY_RCVLANTYPE_BYPROTOCOLID,	"byProtocolId" },
    { RAPID_CITY_RCVLANTYPE_BYSRCMAC,	"bySrcMac" },
    { RAPID_CITY_RCVLANTYPE_BYDSTMCAST,	"byDstMcast" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanProtocolId[] = {
    { RAPID_CITY_RCVLANPROTOCOLID_NONE,	"none" },
    { RAPID_CITY_RCVLANPROTOCOLID_IP,	"ip" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPX802DOT3,	"ipx802dot3" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPX802DOT2,	"ipx802dot2" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPXSNAP,	"ipxSnap" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPXETHERNET2,	"ipxEthernet2" },
    { RAPID_CITY_RCVLANPROTOCOLID_APPLETALK,	"appleTalk" },
    { RAPID_CITY_RCVLANPROTOCOLID_DECLAT,	"decLat" },
    { RAPID_CITY_RCVLANPROTOCOLID_DECOTHER,	"decOther" },
    { RAPID_CITY_RCVLANPROTOCOLID_SNA802DOT2,	"sna802dot2" },
    { RAPID_CITY_RCVLANPROTOCOLID_SNAETHERNET2,	"snaEthernet2" },
    { RAPID_CITY_RCVLANPROTOCOLID_NETBIOS,	"netBios" },
    { RAPID_CITY_RCVLANPROTOCOLID_XNS,	"xns" },
    { RAPID_CITY_RCVLANPROTOCOLID_VINES,	"vines" },
    { RAPID_CITY_RCVLANPROTOCOLID_IPV6,	"ipV6" },
    { RAPID_CITY_RCVLANPROTOCOLID_USRDEFINED,	"usrDefined" },
    { RAPID_CITY_RCVLANPROTOCOLID_RARP,	"rarp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanRowStatus[] = {
    { RAPID_CITY_RCVLANROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCVLANROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCVLANROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCVLANROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCVLANROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCVLANROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopEnable[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCVLANIGMPSNOOPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopReportProxyEnable[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE_TRUE,	"true" },
    { RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortType[] = {
    { RAPID_CITY_RCVLANPORTTYPE_ACCESS,	"access" },
    { RAPID_CITY_RCVLANPORTTYPE_TRUNK,	"trunk" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortDiscardTaggedFrames[] = {
    { RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES_TRUE,	"true" },
    { RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortDiscardUntaggedFrames[] = {
    { RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES_TRUE,	"true" },
    { RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanPortPerformTagging[] = {
    { RAPID_CITY_RCVLANPORTPERFORMTAGGING_TRUE,	"true" },
    { RAPID_CITY_RCVLANPORTPERFORMTAGGING_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanMacRowStatus[] = {
    { RAPID_CITY_RCVLANMACROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCVLANMACROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCVLANMACROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCVLANMACROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCVLANMACROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCVLANMACROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopType[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPTYPE_DYNAMIC,	"dynamic" },
    { RAPID_CITY_RCVLANIGMPSNOOPTYPE_STATIC,	"static" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopStaticRowStatus[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopAccessMode[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSMODE_DENYTX,	"denyTx" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSMODE_DENYRX,	"denyRx" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSMODE_DENYBOTH,	"denyBoth" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopAccessRowStatus[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcVlanIgmpSnoopSenderAction[] = {
    { RAPID_CITY_RCVLANIGMPSNOOPSENDERACTION_NONE,	"none" },
    { RAPID_CITY_RCVLANIGMPSNOOPSENDERACTION_FLUSHENTRY,	"flushEntry" },
    { RAPID_CITY_RCVLANIGMPSNOOPSENDERACTION_FLUSHGRP,	"flushGrp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasType[] = {
    { RAPID_CITY_RCCHASTYPE_UNKNOWN,	"unknown" },
    { RAPID_CITY_RCCHASTYPE_A1100,	"a1100" },
    { RAPID_CITY_RCCHASTYPE_A1250,	"a1250" },
    { RAPID_CITY_RCCHASTYPE_A1150,	"a1150" },
    { RAPID_CITY_RCCHASTYPE_A1200,	"a1200" },
    { RAPID_CITY_RCCHASTYPE_A1050,	"a1050" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasTestResult[] = {
    { RAPID_CITY_RCCHASTESTRESULT_OTHER,	"other" },
    { RAPID_CITY_RCCHASTESTRESULT_OK,	"ok" },
    { RAPID_CITY_RCCHASTESTRESULT_CRCEEPROM,	"crceeprom" },
    { RAPID_CITY_RCCHASTESTRESULT_TIMER,	"timer" },
    { RAPID_CITY_RCCHASTESTRESULT_PROCDRAM,	"procdram" },
    { RAPID_CITY_RCCHASTESTRESULT_LED,	"led" },
    { RAPID_CITY_RCCHASTESTRESULT_FORMACCPUACCESS,	"formaccpuaccess" },
    { RAPID_CITY_RCCHASTESTRESULT_ASICCPUACCESS,	"asiccpuaccess" },
    { RAPID_CITY_RCCHASTESTRESULT_MEMORY,	"memory" },
    { RAPID_CITY_RCCHASTESTRESULT_LOOPBACK,	"loopback" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasFanOperStatus[] = {
    { RAPID_CITY_RCCHASFANOPERSTATUS_UNKNOWN,	"unknown" },
    { RAPID_CITY_RCCHASFANOPERSTATUS_UP,	"up" },
    { RAPID_CITY_RCCHASFANOPERSTATUS_DOWN,	"down" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasPowerSupplyOperStatus[] = {
    { RAPID_CITY_RCCHASPOWERSUPPLYOPERSTATUS_UNKNOWN,	"unknown" },
    { RAPID_CITY_RCCHASPOWERSUPPLYOPERSTATUS_EMPTY,	"empty" },
    { RAPID_CITY_RCCHASPOWERSUPPLYOPERSTATUS_UP,	"up" },
    { RAPID_CITY_RCCHASPOWERSUPPLYOPERSTATUS_DOWN,	"down" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasPowerSupplyDetailType[] = {
    { RAPID_CITY_RCCHASPOWERSUPPLYDETAILTYPE_AC,	"ac" },
    { RAPID_CITY_RCCHASPOWERSUPPLYDETAILTYPE_DC,	"dc" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcCardType[] = {
    { RAPID_CITY_RCCARDTYPE_OTHER,	"other" },
    { RAPID_CITY_RCCARDTYPE_RCCPU,	"rcCPU" },
    { RAPID_CITY_RCCARDTYPE_RC8X100BASETX,	"rc8x100BaseTX" },
    { RAPID_CITY_RCCARDTYPE_RC8X100BASET2,	"rc8x100BaseT2" },
    { RAPID_CITY_RCCARDTYPE_RC8X100BASEF,	"rc8x100BaseF" },
    { RAPID_CITY_RCCARDTYPE_RC16X100BASETX,	"rc16x100BaseTX" },
    { RAPID_CITY_RCCARDTYPE_RC8X100BASETXWG,	"rc8x100BaseTXWG" },
    { RAPID_CITY_RCCARDTYPE_RC16X100BASETXWG,	"rc16x100BaseTXWG" },
    { RAPID_CITY_RCCARDTYPE_RC4X100BASEFWG,	"rc4x100BaseFWG" },
    { RAPID_CITY_RCCARDTYPE_RC12X100BASETXWG,	"rc12x100BaseTXWG" },
    { RAPID_CITY_RCCARDTYPE_RC12X100BASEFBB,	"rc12x100BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC8X100BASEFWG,	"rc8x100BaseFWG" },
    { RAPID_CITY_RCCARDTYPE_RC12X100BASETX_2X100BASEFBB,	"rc12x100BaseTX-2x100BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X155BASEFBB,	"rc2x155BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC4X155BASEFBB,	"rc4x155BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC16X100BASEFBB,	"rc16x100BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC14X100BASETX_2X100BASEFBB,	"rc14x100BaseTX-2x100BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC8X10BASEFBB,	"rc8x10BaseFBB" },
    { RAPID_CITY_RCCARDTYPE_RC4XOC3,	"rc4xOC3" },
    { RAPID_CITY_RCCARDTYPE_RC1XOC12,	"rc1xOC12" },
    { RAPID_CITY_RCCARDTYPE_RCRMON,	"rcRMON" },
    { RAPID_CITY_RCCARDTYPE_RC4X1000BASESXWG,	"rc4x1000BaseSXWG" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASESXWG,	"rc1x1000BaseSXWG" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASESXWG,	"rc2x1000BaseSXWG" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASESXRWG,	"rc1x1000BaseSXRWG" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASESXRWG,	"rc2x1000BaseSXRWG" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASELXWG,	"rc1x1000BaseLXWG" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASELXWG,	"rc2x1000BaseLXWG" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASEXDWG,	"rc2x1000BaseXDWG" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASELXRWG,	"rc1x1000BaseLXRWG" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASELXRWG,	"rc2x1000BaseLXRWG" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASESXBB,	"rc1x1000BaseSXBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASESXBB,	"rc2x1000BaseSXBB" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASESXRBB,	"rc1x1000BaseSXRBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASESXRBB,	"rc2x1000BaseSXRBB" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASELXBB,	"rc1x1000BaseLXBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASELXBB,	"rc2x1000BaseLXBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASEXDBB,	"rc2x1000BaseXDBB" },
    { RAPID_CITY_RCCARDTYPE_RC1X1000BASELXRBB,	"rc1x1000BaseLXRBB" },
    { RAPID_CITY_RCCARDTYPE_RC2X1000BASELXRBB,	"rc2x1000BaseLXRBB" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcCardAdminStatus[] = {
    { RAPID_CITY_RCCARDADMINSTATUS_UP,	"up" },
    { RAPID_CITY_RCCARDADMINSTATUS_DOWN,	"down" },
    { RAPID_CITY_RCCARDADMINSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcCardOperStatus[] = {
    { RAPID_CITY_RCCARDOPERSTATUS_UP,	"up" },
    { RAPID_CITY_RCCARDOPERSTATUS_DOWN,	"down" },
    { RAPID_CITY_RCCARDOPERSTATUS_TESTING,	"testing" },
    { RAPID_CITY_RCCARDOPERSTATUS_UNKNOWN,	"unknown" },
    { RAPID_CITY_RCCARDOPERSTATUS_DORMANT,	"dormant" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcCardPCMCIAType[] = {
    { RAPID_CITY_RCCARDPCMCIATYPE_NONE,	"none" },
    { RAPID_CITY_RCCARDPCMCIATYPE_MODEM28KBS,	"modem28kbs" },
    { RAPID_CITY_RCCARDPCMCIATYPE_FLASH2MEG,	"flash2meg" },
    { RAPID_CITY_RCCARDPCMCIATYPE_FLASH4MEG,	"flash4meg" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortType[] = {
    { RAPID_CITY_RCPORTTYPE_OTHER,	"other" },
    { RAPID_CITY_RCPORTTYPE_RC100BASETX,	"rc100BaseTX" },
    { RAPID_CITY_RCPORTTYPE_RC100BASET2,	"rc100BaseT2" },
    { RAPID_CITY_RCPORTTYPE_RC100BASEF,	"rc100BaseF" },
    { RAPID_CITY_RCPORTTYPE_RC1000BASEF,	"rc1000BaseF" },
    { RAPID_CITY_RCPORTTYPE_RC1000BASEDUALF,	"rc1000BaseDualF" },
    { RAPID_CITY_RCPORTTYPE_RC10BASEF,	"rc10BaseF" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortConnectorType[] = {
    { RAPID_CITY_RCPORTCONNECTORTYPE_NONREDUNDANT,	"nonRedundant" },
    { RAPID_CITY_RCPORTCONNECTORTYPE_REDUNDANT,	"redundant" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortPerformRouting[] = {
    { RAPID_CITY_RCPORTPERFORMROUTING_TRUE,	"true" },
    { RAPID_CITY_RCPORTPERFORMROUTING_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortHighPriority[] = {
    { RAPID_CITY_RCPORTHIGHPRIORITY_TRUE,	"true" },
    { RAPID_CITY_RCPORTHIGHPRIORITY_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAction[] = {
    { RAPID_CITY_RCPORTACTION_NONE,	"none" },
    { RAPID_CITY_RCPORTACTION_FLUSHMACFDB,	"flushMacFdb" },
    { RAPID_CITY_RCPORTACTION_FLUSHARP,	"flushArp" },
    { RAPID_CITY_RCPORTACTION_FLUSHIP,	"flushIp" },
    { RAPID_CITY_RCPORTACTION_FLUSHALL,	"flushAll" },
    { RAPID_CITY_RCPORTACTION_TRIGGERRIPUPDATE,	"triggerRipUpdate" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortResult[] = {
    { RAPID_CITY_RCPORTRESULT_NONE,	"none" },
    { RAPID_CITY_RCPORTRESULT_INPROGRESS,	"inProgress" },
    { RAPID_CITY_RCPORTRESULT_SUCCESS,	"success" },
    { RAPID_CITY_RCPORTRESULT_FAIL,	"fail" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortPrimaryConnector[] = {
    { RAPID_CITY_RCPORTPRIMARYCONNECTOR_LEFT,	"left" },
    { RAPID_CITY_RCPORTPRIMARYCONNECTOR_RIGHT,	"right" },
    { RAPID_CITY_RCPORTPRIMARYCONNECTOR_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortActiveConnector[] = {
    { RAPID_CITY_RCPORTACTIVECONNECTOR_LEFT,	"left" },
    { RAPID_CITY_RCPORTACTIVECONNECTOR_RIGHT,	"right" },
    { RAPID_CITY_RCPORTACTIVECONNECTOR_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortBackupConnectorStatus[] = {
    { RAPID_CITY_RCPORTBACKUPCONNECTORSTATUS_UP,	"up" },
    { RAPID_CITY_RCPORTBACKUPCONNECTORSTATUS_DOWN,	"down" },
    { RAPID_CITY_RCPORTBACKUPCONNECTORSTATUS_OTHER,	"other" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAutoNegotiate[] = {
    { RAPID_CITY_RCPORTAUTONEGOTIATE_TRUE,	"true" },
    { RAPID_CITY_RCPORTAUTONEGOTIATE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAdminDuplex[] = {
    { RAPID_CITY_RCPORTADMINDUPLEX_HALF,	"half" },
    { RAPID_CITY_RCPORTADMINDUPLEX_FULL,	"full" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortOperDuplex[] = {
    { RAPID_CITY_RCPORTOPERDUPLEX_HALF,	"half" },
    { RAPID_CITY_RCPORTOPERDUPLEX_FULL,	"full" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAdminSpeed[] = {
    { RAPID_CITY_RCPORTADMINSPEED_NONE,	"none" },
    { RAPID_CITY_RCPORTADMINSPEED_MBPS10,	"mbps10" },
    { RAPID_CITY_RCPORTADMINSPEED_MBPS100,	"mbps100" },
    { RAPID_CITY_RCPORTADMINSPEED_MBPS1000,	"mbps1000" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortLocked[] = {
    { RAPID_CITY_RCPORTLOCKED_TRUE,	"true" },
    { RAPID_CITY_RCPORTLOCKED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAutoNegotiationSupported[] = {
    { RAPID_CITY_RCPORTAUTONEGOTIATIONSUPPORTED_TRUE,	"true" },
    { RAPID_CITY_RCPORTAUTONEGOTIATIONSUPPORTED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortSingleRoutablePort[] = {
    { RAPID_CITY_RCPORTSINGLEROUTABLEPORT_TRUE,	"true" },
    { RAPID_CITY_RCPORTSINGLEROUTABLEPORT_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortUnknownMacDiscard[] = {
    { RAPID_CITY_RCPORTUNKNOWNMACDISCARD_TRUE,	"true" },
    { RAPID_CITY_RCPORTUNKNOWNMACDISCARD_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortLockEnable[] = {
    { RAPID_CITY_RCPORTLOCKENABLE_TRUE,	"true" },
    { RAPID_CITY_RCPORTLOCKENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasAruMode[] = {
    { RAPID_CITY_RCCHASARUMODE_ARUONE,	"aruOne" },
    { RAPID_CITY_RCCHASARUMODE_ARUTWO,	"aruTwo" },
    { RAPID_CITY_RCCHASARUMODE_ARUTHREE,	"aruThree" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasQuidMode[] = {
    { RAPID_CITY_RCCHASQUIDMODE_QUIDMIXED,	"quidMixed" },
    { RAPID_CITY_RCCHASQUIDMODE_QUIDTWO,	"quidTwo" },
    { RAPID_CITY_RCCHASQUIDMODE_QUIDTHREE,	"quidThree" },
    { RAPID_CITY_RCCHASQUIDMODE_QUIDFOUR,	"quidFour" },
    { RAPID_CITY_RCCHASQUIDMODE_QUIDFIVE,	"quidFive" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasEocModeAdminStatus[] = {
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_DEFAULT,	"default" },
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_ARU1QUID4,	"aru1Quid4" },
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_ARU2QUID4,	"aru2Quid4" },
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_ARU2QUID5,	"aru2Quid5" },
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_ARU3QUID4,	"aru3Quid4" },
    { RAPID_CITY_RCCHASEOCMODEADMINSTATUS_ARU3QUID5,	"aru3Quid5" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcChasEocModeOperStatus[] = {
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_DEFAULT,	"default" },
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_ARU1QUID4,	"aru1Quid4" },
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_ARU2QUID4,	"aru2Quid4" },
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_ARU2QUID5,	"aru2Quid5" },
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_ARU3QUID4,	"aru3Quid4" },
    { RAPID_CITY_RCCHASEOCMODEOPERSTATUS_ARU3QUID5,	"aru3Quid5" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAtmLecExtLecStatus[] = {
    { RAPID_CITY_RCPORTATMLECEXTLECSTATUS_TRUE,	"true" },
    { RAPID_CITY_RCPORTATMLECEXTLECSTATUS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAtmLecExtLecState[] = {
    { RAPID_CITY_RCPORTATMLECEXTLECSTATE_NOTACTIVE,	"notactive" },
    { RAPID_CITY_RCPORTATMLECEXTLECSTATE_OPERATIONAL,	"operational" },
    { RAPID_CITY_RCPORTATMLECEXTLECSTATE_IDLE,	"idle" },
    { RAPID_CITY_RCPORTATMLECEXTLECSTATE_ERROR,	"error" },
    { RAPID_CITY_RCPORTATMLECEXTLECSTATE_UNKNOWN,	"unknown" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAtmLecExtDesiredPhysicalPort[] = {
    { RAPID_CITY_RCPORTATMLECEXTDESIREDPHYSICALPORT_A1,	"a1" },
    { RAPID_CITY_RCPORTATMLECEXTDESIREDPHYSICALPORT_A2,	"a2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAtmLecExtActualPhysicalPort[] = {
    { RAPID_CITY_RCPORTATMLECEXTACTUALPHYSICALPORT_A1,	"a1" },
    { RAPID_CITY_RCPORTATMLECEXTACTUALPHYSICALPORT_A2,	"a2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcPortAtmLecExtFailoverEnable[] = {
    { RAPID_CITY_RCPORTATMLECEXTFAILOVERENABLE_TRUE,	"true" },
    { RAPID_CITY_RCPORTATMLECEXTFAILOVERENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMirrorSaveConfig[] = {
    { RAPID_CITY_RCMIRRORSAVECONFIG_TRUE,	"true" },
    { RAPID_CITY_RCMIRRORSAVECONFIG_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMirrorByPortEnable[] = {
    { RAPID_CITY_RCMIRRORBYPORTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCMIRRORBYPORTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMirrorByPortEnableMirroredPortOne[] = {
    { RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTONE_TRUE,	"true" },
    { RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTONE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMirrorByPortEnableMirroredPortTwo[] = {
    { RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTTWO_TRUE,	"true" },
    { RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTTWO_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIsolateUnconfigPorts[] = {
    { RAPID_CITY_RCISOLATEUNCONFIGPORTS_TRUE,	"true" },
    { RAPID_CITY_RCISOLATEUNCONFIGPORTS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcUseFactorySettings[] = {
    { RAPID_CITY_RCUSEFACTORYSETTINGS_TRUE,	"true" },
    { RAPID_CITY_RCUSEFACTORYSETTINGS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcHighPriorityMode[] = {
    { RAPID_CITY_RCHIGHPRIORITYMODE_TRUE,	"true" },
    { RAPID_CITY_RCHIGHPRIORITYMODE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfAdvertDefRte[] = {
    { RAPID_CITY_RCIPCONFADVERTDEFRTE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFADVERTDEFRTE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfAcceptDefRte[] = {
    { RAPID_CITY_RCIPCONFACCEPTDEFRTE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFACCEPTDEFRTE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfRowStatus[] = {
    { RAPID_CITY_RCIPCONFROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPCONFROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPCONFROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPCONFROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPCONFROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPCONFROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfRipEnable[] = {
    { RAPID_CITY_RCIPCONFRIPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFRIPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfEnable[] = {
    { RAPID_CITY_RCIPCONFOSPFENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFOSPFENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfIgmpEnable[] = {
    { RAPID_CITY_RCIPCONFIGMPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFIGMPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfAddrAssigned[] = {
    { RAPID_CITY_RCIPCONFADDRASSIGNED_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFADDRASSIGNED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfDhcpEnable[] = {
    { RAPID_CITY_RCIPCONFDHCPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFDHCPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfTriggeredUpdateEnable[] = {
    { RAPID_CITY_RCIPCONFTRIGGEREDUPDATEENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFTRIGGEREDUPDATEENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfRipAutoAggrerateEnable[] = {
    { RAPID_CITY_RCIPCONFRIPAUTOAGGRERATEENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFRIPAUTOAGGRERATEENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfRipGenerateDefaultRoute[] = {
    { RAPID_CITY_RCIPCONFRIPGENERATEDEFAULTROUTE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFRIPGENERATEDEFAULTROUTE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfRowStatus[] = {
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPCONFOSPFROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfAuthType[] = {
    { RAPID_CITY_RCIPCONFOSPFAUTHTYPE_NONE,	"none" },
    { RAPID_CITY_RCIPCONFOSPFAUTHTYPE_SIMPLEPASSWORD,	"simplePassword" },
    { RAPID_CITY_RCIPCONFOSPFAUTHTYPE_MD5,	"md5" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfTrapEnable[] = {
    { RAPID_CITY_RCIPCONFOSPFTRAPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFOSPFTRAPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfAutoVirtLinkEnable[] = {
    { RAPID_CITY_RCIPCONFOSPFAUTOVIRTLINKENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFOSPFAUTOVIRTLINKENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfOspfAreaImportSummary[] = {
    { RAPID_CITY_RCIPCONFOSPFAREAIMPORTSUMMARY_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFOSPFAREAIMPORTSUMMARY_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpAdEntBcastAddrFormat[] = {
    { RAPID_CITY_RCIPADENTBCASTADDRFORMAT_ZEROS,	"zeros" },
    { RAPID_CITY_RCIPADENTBCASTADDRFORMAT_ONES,	"ones" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpAdEntRowStatus[] = {
    { RAPID_CITY_RCIPADENTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPADENTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPADENTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPADENTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPADENTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPADENTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFlowProtocol[] = {
    { RAPID_CITY_RCIPFLOWPROTOCOL_IP,	"ip" },
    { RAPID_CITY_RCIPFLOWPROTOCOL_TCP,	"tcp" },
    { RAPID_CITY_RCIPFLOWPROTOCOL_UDP,	"udp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFlowRowStatus[] = {
    { RAPID_CITY_RCIPFLOWROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPFLOWROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPFLOWROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPFLOWROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPFLOWROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPFLOWROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeRipToOspfEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeRipToOspfUseExplicitMetric[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFUSEEXPLICITMETRIC_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFUSEEXPLICITMETRIC_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeRipToOspfExternalMetricType[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFEXTERNALMETRICTYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFEXTERNALMETRICTYPE_TYPE2,	"type2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeOspfToRipEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeOspfToRipUseExplicitMetric[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPUSEEXPLICITMETRIC_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPUSEEXPLICITMETRIC_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeDirectToOspfEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeDirectToOspfMethod[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFMETHOD_USEPORTSPEED,	"usePortSpeed" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFMETHOD_USEEXPLICITMETRIC,	"useExplicitMetric" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeDirectToOspfExternalMetricType[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFEXTERNALMETRICTYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFEXTERNALMETRICTYPE_TYPE2,	"type2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeStaticToOspfEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeStaticToOspfUseExplicitMetric[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFUSEEXPLICITMETRIC_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFUSEEXPLICITMETRIC_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeStaticToOspfExternalMetricType[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFEXTERNALMETRICTYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFEXTERNALMETRICTYPE_TYPE2,	"type2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeStaticToOspfAdvertDefRte[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFADVERTDEFRTE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFADVERTDEFRTE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeDirectToRipEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTORIPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTORIPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRoutingRedistributeStaticToRipEnable[] = {
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTORIPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTORIPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfIgmpVersion[] = {
    { RAPID_CITY_RCIPCONFIGMPVERSION_VERSION1,	"version1" },
    { RAPID_CITY_RCIPCONFIGMPVERSION_VERSION2,	"version2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfIgmpLeaveEnabled[] = {
    { RAPID_CITY_RCIPCONFIGMPLEAVEENABLED_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFIGMPLEAVEENABLED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfIgmpRowStatus[] = {
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPCONFIGMPROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRouteType[] = {
    { RAPID_CITY_RCIPROUTETYPE_OTHER,	"other" },
    { RAPID_CITY_RCIPROUTETYPE_DIRECT,	"direct" },
    { RAPID_CITY_RCIPROUTETYPE_INDIRECT,	"indirect" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRouteProto[] = {
    { RAPID_CITY_RCIPROUTEPROTO_OTHER,	"other" },
    { RAPID_CITY_RCIPROUTEPROTO_LOCAL,	"local" },
    { RAPID_CITY_RCIPROUTEPROTO_NETMGMT,	"netmgmt" },
    { RAPID_CITY_RCIPROUTEPROTO_ICMP,	"icmp" },
    { RAPID_CITY_RCIPROUTEPROTO_EGP,	"egp" },
    { RAPID_CITY_RCIPROUTEPROTO_GGP,	"ggp" },
    { RAPID_CITY_RCIPROUTEPROTO_HELLO,	"hello" },
    { RAPID_CITY_RCIPROUTEPROTO_RIP,	"rip" },
    { RAPID_CITY_RCIPROUTEPROTO_IS_IS,	"is-is" },
    { RAPID_CITY_RCIPROUTEPROTO_ES_IS,	"es-is" },
    { RAPID_CITY_RCIPROUTEPROTO_CISCOIGRP,	"ciscoIgrp" },
    { RAPID_CITY_RCIPROUTEPROTO_BBNSPFIGP,	"bbnSpfIgp" },
    { RAPID_CITY_RCIPROUTEPROTO_OSPF,	"ospf" },
    { RAPID_CITY_RCIPROUTEPROTO_BGP,	"bgp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpRouteRowStatus[] = {
    { RAPID_CITY_RCIPROUTEROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPROUTEROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPROUTEROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPROUTEROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPROUTEROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPROUTEROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfDhcpMode[] = {
    { RAPID_CITY_RCIPCONFDHCPMODE_NONE,	"none" },
    { RAPID_CITY_RCIPCONFDHCPMODE_BOOTP,	"bootp" },
    { RAPID_CITY_RCIPCONFDHCPMODE_DHCP,	"dhcp" },
    { RAPID_CITY_RCIPCONFDHCPMODE_BOTH,	"both" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfDhcpRowStatus[] = {
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPCONFDHCPROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfDhcpAlwaysBroadcast[] = {
    { RAPID_CITY_RCIPCONFDHCPALWAYSBROADCAST_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFDHCPALWAYSBROADCAST_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpDhcpForwardEnable[] = {
    { RAPID_CITY_RCIPDHCPFORWARDENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPDHCPFORWARDENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpDhcpForwardMode[] = {
    { RAPID_CITY_RCIPDHCPFORWARDMODE_NONE,	"none" },
    { RAPID_CITY_RCIPDHCPFORWARDMODE_BOOTP,	"bootp" },
    { RAPID_CITY_RCIPDHCPFORWARDMODE_DHCP,	"dhcp" },
    { RAPID_CITY_RCIPDHCPFORWARDMODE_BOTH,	"both" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpDhcpForwardRowStatus[] = {
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPDHCPFORWARDROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterType[] = {
    { RAPID_CITY_RCIPFILTERTYPE_GLOBAL,	"global" },
    { RAPID_CITY_RCIPFILTERTYPE_DESTINATION,	"destination" },
    { RAPID_CITY_RCIPFILTERTYPE_SOURCE,	"source" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterProtocolType[] = {
    { RAPID_CITY_RCIPFILTERPROTOCOLTYPE_IGNORE,	"ignore" },
    { RAPID_CITY_RCIPFILTERPROTOCOLTYPE_ICMP,	"icmp" },
    { RAPID_CITY_RCIPFILTERPROTOCOLTYPE_TCP,	"tcp" },
    { RAPID_CITY_RCIPFILTERPROTOCOLTYPE_UDP,	"udp" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterSrcOption[] = {
    { RAPID_CITY_RCIPFILTERSRCOPTION_EQUAL,	"equal" },
    { RAPID_CITY_RCIPFILTERSRCOPTION_NOTEQUAL,	"notEqual" },
    { RAPID_CITY_RCIPFILTERSRCOPTION_GREATER,	"greater" },
    { RAPID_CITY_RCIPFILTERSRCOPTION_LESS,	"less" },
    { RAPID_CITY_RCIPFILTERSRCOPTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterDstOption[] = {
    { RAPID_CITY_RCIPFILTERDSTOPTION_EQUAL,	"equal" },
    { RAPID_CITY_RCIPFILTERDSTOPTION_NOTEQUAL,	"notEqual" },
    { RAPID_CITY_RCIPFILTERDSTOPTION_GREATER,	"greater" },
    { RAPID_CITY_RCIPFILTERDSTOPTION_LESS,	"less" },
    { RAPID_CITY_RCIPFILTERDSTOPTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterCopyToCpu[] = {
    { RAPID_CITY_RCIPFILTERCOPYTOCPU_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERCOPYTOCPU_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterMirror[] = {
    { RAPID_CITY_RCIPFILTERMIRROR_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERMIRROR_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterHighPriority[] = {
    { RAPID_CITY_RCIPFILTERHIGHPRIORITY_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERHIGHPRIORITY_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterTcpConnect[] = {
    { RAPID_CITY_RCIPFILTERTCPCONNECT_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERTCPCONNECT_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterUsePktLimit[] = {
    { RAPID_CITY_RCIPFILTERUSEPKTLIMIT_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERUSEPKTLIMIT_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterRowStatus[] = {
    { RAPID_CITY_RCIPFILTERROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPFILTERROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPFILTERROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPFILTERROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPFILTERROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPFILTERROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterMode[] = {
    { RAPID_CITY_RCIPFILTERMODE_USEDEFAULTACTION,	"useDefaultAction" },
    { RAPID_CITY_RCIPFILTERMODE_FORWARD,	"forward" },
    { RAPID_CITY_RCIPFILTERMODE_DROP,	"drop" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterGlobalListRowStatus[] = {
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterBaseListRowStatus[] = {
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPFILTERBASELISTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterPortMode[] = {
    { RAPID_CITY_RCIPFILTERPORTMODE_PERMIT,	"permit" },
    { RAPID_CITY_RCIPFILTERPORTMODE_DENY,	"deny" },
    { RAPID_CITY_RCIPFILTERPORTMODE_NONE,	"none" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterPortEnable[] = {
    { RAPID_CITY_RCIPFILTERPORTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPFILTERPORTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterPortRowStatus[] = {
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPFILTERPORTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpFilterPortDefaultAction[] = {
    { RAPID_CITY_RCIPFILTERPORTDEFAULTACTION_FORWARD,	"forward" },
    { RAPID_CITY_RCIPFILTERPORTDEFAULTACTION_DROP,	"drop" },
    { RAPID_CITY_RCIPFILTERPORTDEFAULTACTION_NONE,	"none" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyAddrRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYADDRROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyNetRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYNETROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyAddrListRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAnnounceEnable[] = {
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAnnounceRouteSource[] = {
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE_DIRECT,	"direct" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE_STATIC,	"static" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE_RIP,	"rip" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE_OSPF,	"ospf" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE_ANY,	"any" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAnnounceAction[] = {
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEACTION_ANNOUNCE,	"announce" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEACTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAnnounceOspfRouteType[] = {
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE_TYPE2,	"type2" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE_EXTERNAL,	"external" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE_INTERNAL,	"internal" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE_ANY,	"any" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAnnounceRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAnnounceEnable[] = {
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAnnounceRouteSource[] = {
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROUTESOURCE_DIRECT,	"direct" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROUTESOURCE_STATIC,	"static" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROUTESOURCE_RIP,	"rip" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROUTESOURCE_ANY,	"any" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAnnounceAction[] = {
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEACTION_ANNOUNCE,	"announce" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEACTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAnnounceExtMetricType[] = {
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEEXTMETRICTYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEEXTMETRICTYPE_TYPE2,	"type2" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAnnounceRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAcceptEnable[] = {
    { RAPID_CITY_RCIPPOLICYRIPACCEPTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAcceptAction[] = {
    { RAPID_CITY_RCIPPOLICYRIPACCEPTACTION_ACCEPT,	"accept" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTACTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyRipAcceptRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAcceptEnable[] = {
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAcceptAction[] = {
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTACTION_ACCEPT,	"accept" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTACTION_IGNORE,	"ignore" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAcceptExtType[] = {
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTEXTTYPE_TYPE1,	"type1" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTEXTTYPE_TYPE2,	"type2" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTEXTTYPE_ANY,	"any" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyOspfAcceptRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpPolicyNetListRowStatus[] = {
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpDvmrpEnable[] = {
    { RAPID_CITY_RCIPDVMRPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPDVMRPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpConfDvmrpTableEnable[] = {
    { RAPID_CITY_RCIPCONFDVMRPTABLEENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPCONFDVMRPTABLEENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpUdpProtocolRowStatus[] = {
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpUdpPortFwdRowStatus[] = {
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPUDPPORTFWDROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpUdpPortFwdListRowStatus[] = {
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpUdpConfBroadcastIntfRowStatus[] = {
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcArpExtEntDoProxy[] = {
    { RAPID_CITY_RCARPEXTENTDOPROXY_DISABLE,	"disable" },
    { RAPID_CITY_RCARPEXTENTDOPROXY_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcArpExtEntDoResp[] = {
    { RAPID_CITY_RCARPEXTENTDORESP_DISABLE,	"disable" },
    { RAPID_CITY_RCARPEXTENTDORESP_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcRipExtOperation[] = {
    { RAPID_CITY_RCRIPEXTOPERATION_DISABLE,	"disable" },
    { RAPID_CITY_RCRIPEXTOPERATION_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcRipExtEntTalk[] = {
    { RAPID_CITY_RCRIPEXTENTTALK_DISABLE,	"disable" },
    { RAPID_CITY_RCRIPEXTENTTALK_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcRipExtEntListen[] = {
    { RAPID_CITY_RCRIPEXTENTLISTEN_DISABLE,	"disable" },
    { RAPID_CITY_RCRIPEXTENTLISTEN_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcRipExtEntPoison[] = {
    { RAPID_CITY_RCRIPEXTENTPOISON_DISABLE,	"disable" },
    { RAPID_CITY_RCRIPEXTENTPOISON_ENABLE,	"enable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgProtocolSpecification[] = {
    { RAPID_CITY_RCSTGPROTOCOLSPECIFICATION_UNKNOWN,	"unknown" },
    { RAPID_CITY_RCSTGPROTOCOLSPECIFICATION_DECLB100,	"decLb100" },
    { RAPID_CITY_RCSTGPROTOCOLSPECIFICATION_IEEE8021D,	"ieee8021d" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgEnableStp[] = {
    { RAPID_CITY_RCSTGENABLESTP_TRUE,	"true" },
    { RAPID_CITY_RCSTGENABLESTP_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgStpTrapEnable[] = {
    { RAPID_CITY_RCSTGSTPTRAPENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSTGSTPTRAPENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgRowStatus[] = {
    { RAPID_CITY_RCSTGROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCSTGROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCSTGROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCSTGROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCSTGROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCSTGROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgPortState[] = {
    { RAPID_CITY_RCSTGPORTSTATE_DISABLED,	"disabled" },
    { RAPID_CITY_RCSTGPORTSTATE_BLOCKING,	"blocking" },
    { RAPID_CITY_RCSTGPORTSTATE_LISTENING,	"listening" },
    { RAPID_CITY_RCSTGPORTSTATE_LEARNING,	"learning" },
    { RAPID_CITY_RCSTGPORTSTATE_FORWARDING,	"forwarding" },
    { RAPID_CITY_RCSTGPORTSTATE_BROKEN,	"broken" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgPortEnableStp[] = {
    { RAPID_CITY_RCSTGPORTENABLESTP_TRUE,	"true" },
    { RAPID_CITY_RCSTGPORTENABLESTP_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgPortFastStart[] = {
    { RAPID_CITY_RCSTGPORTFASTSTART_TRUE,	"true" },
    { RAPID_CITY_RCSTGPORTFASTSTART_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcStgPortRowStatus[] = {
    { RAPID_CITY_RCSTGPORTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCSTGPORTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCSTGPORTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCSTGPORTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCSTGPORTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCSTGPORTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeFdbStatus[] = {
    { RAPID_CITY_RCBRIDGEFDBSTATUS_OTHER,	"other" },
    { RAPID_CITY_RCBRIDGEFDBSTATUS_INVALID,	"invalid" },
    { RAPID_CITY_RCBRIDGEFDBSTATUS_LEARNED,	"learned" },
    { RAPID_CITY_RCBRIDGEFDBSTATUS_SELF,	"self" },
    { RAPID_CITY_RCBRIDGEFDBSTATUS_MGMT,	"mgmt" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeFdbMonitor[] = {
    { RAPID_CITY_RCBRIDGEFDBMONITOR_TRUE,	"true" },
    { RAPID_CITY_RCBRIDGEFDBMONITOR_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeFdbPriority[] = {
    { RAPID_CITY_RCBRIDGEFDBPRIORITY_LOW,	"low" },
    { RAPID_CITY_RCBRIDGEFDBPRIORITY_HIGH,	"high" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeStaticMonitor[] = {
    { RAPID_CITY_RCBRIDGESTATICMONITOR_TRUE,	"true" },
    { RAPID_CITY_RCBRIDGESTATICMONITOR_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeStaticPriority[] = {
    { RAPID_CITY_RCBRIDGESTATICPRIORITY_LOW,	"low" },
    { RAPID_CITY_RCBRIDGESTATICPRIORITY_HIGH,	"high" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeStaticStatus[] = {
    { RAPID_CITY_RCBRIDGESTATICSTATUS_OTHER,	"other" },
    { RAPID_CITY_RCBRIDGESTATICSTATUS_INVALID,	"invalid" },
    { RAPID_CITY_RCBRIDGESTATICSTATUS_PERMANENT,	"permanent" },
    { RAPID_CITY_RCBRIDGESTATICSTATUS_DELETEONRESET,	"deleteOnReset" },
    { RAPID_CITY_RCBRIDGESTATICSTATUS_DELETEONTIMEOUT,	"deleteOnTimeout" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBridgeFilterStatus[] = {
    { RAPID_CITY_RCBRIDGEFILTERSTATUS_OTHER,	"other" },
    { RAPID_CITY_RCBRIDGEFILTERSTATUS_INVALID,	"invalid" },
    { RAPID_CITY_RCBRIDGEFILTERSTATUS_PERMANENT,	"permanent" },
    { RAPID_CITY_RCBRIDGEFILTERSTATUS_DELETEONRESET,	"deleteOnReset" },
    { RAPID_CITY_RCBRIDGEFILTERSTATUS_DELETEONTIMEOUT,	"deleteOnTimeout" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBootPrimary[] = {
    { RAPID_CITY_RCBOOTPRIMARY_FLASH,	"flash" },
    { RAPID_CITY_RCBOOTPRIMARY_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCBOOTPRIMARY_NET,	"net" },
    { RAPID_CITY_RCBOOTPRIMARY_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBootSecondary[] = {
    { RAPID_CITY_RCBOOTSECONDARY_FLASH,	"flash" },
    { RAPID_CITY_RCBOOTSECONDARY_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCBOOTSECONDARY_NET,	"net" },
    { RAPID_CITY_RCBOOTSECONDARY_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcBootTertiary[] = {
    { RAPID_CITY_RCBOOTTERTIARY_FLASH,	"flash" },
    { RAPID_CITY_RCBOOTTERTIARY_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCBOOTTERTIARY_NET,	"net" },
    { RAPID_CITY_RCBOOTTERTIARY_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDevicePrimarySource[] = {
    { RAPID_CITY_RCDEVICEPRIMARYSOURCE_FLASH,	"flash" },
    { RAPID_CITY_RCDEVICEPRIMARYSOURCE_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCDEVICEPRIMARYSOURCE_NET,	"net" },
    { RAPID_CITY_RCDEVICEPRIMARYSOURCE_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceSecondarySource[] = {
    { RAPID_CITY_RCDEVICESECONDARYSOURCE_FLASH,	"flash" },
    { RAPID_CITY_RCDEVICESECONDARYSOURCE_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCDEVICESECONDARYSOURCE_NET,	"net" },
    { RAPID_CITY_RCDEVICESECONDARYSOURCE_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceTertiarySource[] = {
    { RAPID_CITY_RCDEVICETERTIARYSOURCE_FLASH,	"flash" },
    { RAPID_CITY_RCDEVICETERTIARYSOURCE_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCDEVICETERTIARYSOURCE_NET,	"net" },
    { RAPID_CITY_RCDEVICETERTIARYSOURCE_SKIP,	"skip" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceConfigSource[] = {
    { RAPID_CITY_RCDEVICECONFIGSOURCE_FLASH,	"flash" },
    { RAPID_CITY_RCDEVICECONFIGSOURCE_PCMCIA,	"pcmcia" },
    { RAPID_CITY_RCDEVICECONFIGSOURCE_NVRAM,	"nvram" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceAction[] = {
    { RAPID_CITY_RCDEVICEACTION_NONE,	"none" },
    { RAPID_CITY_RCDEVICEACTION_SQUEEZEFLASH,	"squeezeFlash" },
    { RAPID_CITY_RCDEVICEACTION_SQUEEZEPCMCIA,	"squeezePcmcia" },
    { RAPID_CITY_RCDEVICEACTION_FORMATFLASH,	"formatFlash" },
    { RAPID_CITY_RCDEVICEACTION_FORMATPCMCIA,	"formatPcmcia" },
    { RAPID_CITY_RCDEVICEACTION_RECOVERFLASH,	"recoverFlash" },
    { RAPID_CITY_RCDEVICEACTION_RECOVERPCMCIA,	"recoverPcmcia" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceResult[] = {
    { RAPID_CITY_RCDEVICERESULT_NONE,	"none" },
    { RAPID_CITY_RCDEVICERESULT_INPROGRESS,	"inProgress" },
    { RAPID_CITY_RCDEVICERESULT_SUCCESS,	"success" },
    { RAPID_CITY_RCDEVICERESULT_FAIL,	"fail" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceFlashFileType[] = {
    { RAPID_CITY_RCDEVICEFLASHFILETYPE_CONFIG,	"config" },
    { RAPID_CITY_RCDEVICEFLASHFILETYPE_LOG,	"log" },
    { RAPID_CITY_RCDEVICEFLASHFILETYPE_TRACE,	"trace" },
    { RAPID_CITY_RCDEVICEFLASHFILETYPE_EXECUTABLE,	"executable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceFlashFileMode[] = {
    { RAPID_CITY_RCDEVICEFLASHFILEMODE_COMPRESSED,	"compressed" },
    { RAPID_CITY_RCDEVICEFLASHFILEMODE_UNCOMPRESSED,	"uncompressed" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceFlashFileStatus[] = {
    { RAPID_CITY_RCDEVICEFLASHFILESTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDEVICEFLASHFILESTATUS_DELETED,	"deleted" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDeviceFlashRowStatus[] = {
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCDEVICEFLASHROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDevicePcmciaFileType[] = {
    { RAPID_CITY_RCDEVICEPCMCIAFILETYPE_CONFIG,	"config" },
    { RAPID_CITY_RCDEVICEPCMCIAFILETYPE_LOG,	"log" },
    { RAPID_CITY_RCDEVICEPCMCIAFILETYPE_TRACE,	"trace" },
    { RAPID_CITY_RCDEVICEPCMCIAFILETYPE_EXECUTABLE,	"executable" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDevicePcmciaFileMode[] = {
    { RAPID_CITY_RCDEVICEPCMCIAFILEMODE_COMPRESSED,	"compressed" },
    { RAPID_CITY_RCDEVICEPCMCIAFILEMODE_UNCOMPRESSED,	"uncompressed" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDevicePcmciaFileStatus[] = {
    { RAPID_CITY_RCDEVICEPCMCIAFILESTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDEVICEPCMCIAFILESTATUS_DELETED,	"deleted" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDevicePcmciaRowStatus[] = {
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCDEVICEPCMCIAROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMltPortType[] = {
    { RAPID_CITY_RCMLTPORTTYPE_ACCESS,	"access" },
    { RAPID_CITY_RCMLTPORTTYPE_TRUNK,	"trunk" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMltRowStatus[] = {
    { RAPID_CITY_RCMLTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCMLTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCMLTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCMLTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCMLTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCMLTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMltEnable[] = {
    { RAPID_CITY_RCMLTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCMLTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMltLoadBalance[] = {
    { RAPID_CITY_RCMLTLOADBALANCE_TRUE,	"true" },
    { RAPID_CITY_RCMLTLOADBALANCE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcMltDistributionAlgorithm[] = {
    { RAPID_CITY_RCMLTDISTRIBUTIONALGORITHM_NONE,	"none" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcWebEnableServer[] = {
    { RAPID_CITY_RCWEBENABLESERVER_TRUE,	"true" },
    { RAPID_CITY_RCWEBENABLESERVER_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcErrorReturnCode[] = {
    { RAPID_CITY_RCERRORRETURNCODE_NONE,	"none" },
    { RAPID_CITY_RCERRORRETURNCODE_RESOURCENOTAVAILABLE,	"resourceNotAvailable" },
    { RAPID_CITY_RCERRORRETURNCODE_OPERATIONNOTALLOWED,	"operationNotAllowed" },
    { RAPID_CITY_RCERRORRETURNCODE_OPERATIONINPROGRESS,	"operationInProgress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDPORTNUMBER,	"invalidPortNumber" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSUBNETADDRESS,	"invalidSubnetAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSUBNETMASK,	"invalidSubnetMask" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVLANID,	"invalidVlanId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVLANNAME,	"invalidVlanName" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVLANTYPE,	"invalidVlanType" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSTGID,	"invalidStgId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDPROTOCOLID,	"invalidProtocolId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDPORTMEMBERS,	"invalidPortMembers" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSTATICMEMBERS,	"invalidStaticMembers" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDNOTALLOWEDMEMBERS,	"invalidNotAllowedMembers" },
    { RAPID_CITY_RCERRORRETURNCODE_DESTINATIONNOTREACHABLE,	"destinationNotReachable" },
    { RAPID_CITY_RCERRORRETURNCODE_TABLEISFULL,	"tableIsFull" },
    { RAPID_CITY_RCERRORRETURNCODE_NONDUALCONNECTORGIGPORT,	"nondualConnectorGigPort" },
    { RAPID_CITY_RCERRORRETURNCODE_TESTIDNOTPRESENT,	"testIdNotPresent" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDTESTID,	"invalidTestId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSTATUSCHANGE,	"invalidStatusChange" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDCPUCARD,	"invalidCpuCard" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSRCPORTCHOICE,	"invalidSrcPortChoice" },
    { RAPID_CITY_RCERRORRETURNCODE_DSTPORTUNSPECIFIED,	"dstPortUnspecified" },
    { RAPID_CITY_RCERRORRETURNCODE_SRCPORTONEUNSPECIFIED,	"srcPortOneUnspecified" },
    { RAPID_CITY_RCERRORRETURNCODE_SRCPORTTWOUNSPECIFIED,	"srcPortTwoUnspecified" },
    { RAPID_CITY_RCERRORRETURNCODE_NOTSUPPORTED,	"notSupported" },
    { RAPID_CITY_RCERRORRETURNCODE_USERNAMEISNONUNIQUE,	"userNameIsNonUnique" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDNAME,	"invalidName" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTMODIFYTHISFIELD,	"cannotModifyThisField" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDUSERPASSWORDLENGTH,	"invalidUserPasswordLength" },
    { RAPID_CITY_RCERRORRETURNCODE_THISUSERNAMEEXISTS,	"thisUsernameExists" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPADDRESS,	"invalidIpAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDMACADDRESS,	"invalidMacAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_NOSUCHENTRY,	"nosuchEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_ANOTHERLOOPBACKTESTALREADYRUNNING,	"anotherLoopBackTestAlreadyRunning" },
    { RAPID_CITY_RCERRORRETURNCODE_PROTOCOLIDNOTROUTABLE,	"protocolIdNotRoutable" },
    { RAPID_CITY_RCERRORRETURNCODE_AUTONEGOTIATEISON,	"autoNegotiateIsOn" },
    { RAPID_CITY_RCERRORRETURNCODE_NOACTIONSPECIFIED,	"noActionSpecified" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACTIONSPECIFIED,	"invalidActionSpecified" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTMODIFYAUTONEGOTIATEISON,	"cannotModifyAutoNegotiateIsOn" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTMODIFYAUTOPORTISFIBER,	"cannotModifyAutoPortIsFiber" },
    { RAPID_CITY_RCERRORRETURNCODE_AUTONEGOTIATIONNOTSUPPORTED,	"autoNegotiationNotSupported" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTSETADMINSPEED,	"cannotSetAdminSpeed" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTSETADMINDUPLEX,	"cannotSetAdminDuplex" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFRTRDEADINTISNOTMULTOFHELLOINT,	"ospfRtrDeadIntIsnotMultOfHelloInt" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFRTRDEADINTLESSTHAN4TIMESHELLOINT,	"ospfRtrDeadIntLessThan4TimesHelloInt" },
    { RAPID_CITY_RCERRORRETURNCODE_NOTUSED1,	"notUsed1" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFBADAUTHVALUE,	"ospfBadAuthValue" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFENABLED,	"ospfEnabled" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFAREANOTFOUND,	"ospfAreaNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFBACKBONEAREA,	"ospfBackboneArea" },
    { RAPID_CITY_RCERRORRETURNCODE_NOTINTESTMODE,	"notInTestMode" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFINVALIDAREARANGEMASK,	"ospfInvalidAreaRangeMask" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFDUPLICATEENTRY,	"ospfDuplicateEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFRANGENOTALLOCATED,	"ospfRangeNotAllocated" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFAREARANGENOTFOUND,	"ospfAreaRangeNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_TESTRUNNING,	"testRunning" },
    { RAPID_CITY_RCERRORRETURNCODE_NVRAMLIMITEXCEEDED,	"nvramLimitExceeded" },
    { RAPID_CITY_RCERRORRETURNCODE_FLOWALREADYEXIST,	"flowAlreadyExist" },
    { RAPID_CITY_RCERRORRETURNCODE_FLOWNOTFOUND,	"flowNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEIPADDRESS,	"duplicateIpAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_CONFLICTINGIPADDRESS,	"conflictingIpAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDROUTECOST,	"invalidRouteCost" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDNEXTHOP,	"invalidNextHop" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEROUTE,	"duplicateRoute" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTFINDROUTE,	"cannotFindRoute" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTDELETELOCALROUTE,	"cannotDeleteLocalRoute" },
    { RAPID_CITY_RCERRORRETURNCODE_BADDHCPMINSEC,	"badDhcpMinSec" },
    { RAPID_CITY_RCERRORRETURNCODE_BADDHCPMAXHOP,	"badDhcpMaxHop" },
    { RAPID_CITY_RCERRORRETURNCODE_BADDHCPMODE,	"badDhcpMode" },
    { RAPID_CITY_RCERRORRETURNCODE_BADAGENTADDRESS,	"badAgentAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_DHCPNOTENABLED,	"dhcpNotEnabled" },
    { RAPID_CITY_RCERRORRETURNCODE_DHCPFORWARDNOTFOUND,	"dhcpForwardNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DHCPDUPLICATEFORWARD,	"dhcpDuplicateForward" },
    { RAPID_CITY_RCERRORRETURNCODE_DHCPMAXFORWARD,	"dhcpMaxForward" },
    { RAPID_CITY_RCERRORRETURNCODE_DHCPBADENABLE,	"dhcpBadEnable" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDDEVICEFILENUMBER,	"invalidDeviceFileNumber" },
    { RAPID_CITY_RCERRORRETURNCODE_NOTEXECUTABLEDEVICEFILE,	"notExecutableDeviceFile" },
    { RAPID_CITY_RCERRORRETURNCODE_DELETEDDEVICEFILE,	"deletedDeviceFile" },
    { RAPID_CITY_RCERRORRETURNCODE_PCMCIANOTPRESENT,	"pcmciaNotPresent" },
    { RAPID_CITY_RCERRORRETURNCODE_PCMCIAWRITEPROTECTED,	"pcmciaWriteProtected" },
    { RAPID_CITY_RCERRORRETURNCODE_DISCONTIGUOUSSUBNETMASK,	"discontiguousSubnetMask" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDOSPFMETRIC,	"invalidOspfMetric" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFHOSTROUTENOTFOUND,	"ospfHostRouteNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDMLTID,	"invalidMltId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDMLTNAME,	"invalidMltName" },
    { RAPID_CITY_RCERRORRETURNCODE_ONLYONEPORTINMLT,	"onlyOnePortInMlt" },
    { RAPID_CITY_RCERRORRETURNCODE_MORETHAN4PORTSINMLT,	"moreThan4PortsInMlt" },
    { RAPID_CITY_RCERRORRETURNCODE_PORTSINDIFFERENTQUID,	"portsInDifferentQuid" },
    { RAPID_CITY_RCERRORRETURNCODE_PORTALREADYINANOTHERMLT,	"portAlreadyInAnotherMlt" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVLAN,	"invalidVlan" },
    { RAPID_CITY_RCERRORRETURNCODE_NONEXISTIPMCASTADDRIESS,	"nonExistIpMcastAddriess" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPMULTICASTADDRESS,	"invalidIpMulticastAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_PORTISLOCKED,	"portIsLocked" },
    { RAPID_CITY_RCERRORRETURNCODE_ACCESSRESTRICTION,	"accessRestriction" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDDEVICEFILELENGTH,	"invalidDeviceFileLength" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEACCESSPOLICYID,	"duplicateAccessPolicyId" },
    { RAPID_CITY_RCERRORRETURNCODE_NODESIREDACCESSPOLICYITEM,	"noDesiredAccessPolicyItem" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFFILTERNONEXIST,	"ipfFilterNonExist" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFINVALIDVLANPRIORITY,	"ipfInvalidVlanPriority" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFINVALIDDESTINATIONADDRESS,	"ipfInvalidDestinationAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFINVALIDSOURCEADDRESS,	"ipfInvalidSourceAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFFILTERDUPLICATE,	"ipfFilterDuplicate" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFGLOBALLISTDUPLICATE,	"ipfGlobalListDuplicate" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFGLOBALLISTNONEXIST,	"ipfGlobalListNonExist" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFBASELISTDUPLICATE,	"ipfBaseListDuplicate" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFBASELISTNONEXIST,	"ipfBaseListNonExist" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFPORTDUPLICATE,	"ipfPortDuplicate" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFPORTNONEXIST,	"ipfPortNonExist" },
    { RAPID_CITY_RCERRORRETURNCODE_IPFLISTNONEXIST,	"ipfListNonExist" },
    { RAPID_CITY_RCERRORRETURNCODE_SNMPSNOOPDISABLED,	"snmpSnoopDisabled" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDHOSTIPADDRESS,	"invalidHostIpAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_SNOOPSTATICGROUPEXIST,	"snoopStaticGroupExist" },
    { RAPID_CITY_RCERRORRETURNCODE_RIPANNOUNCEPOLICYNOTFOUND,	"ripAnnouncePolicyNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATERIPANNOUNCEPOLICY,	"duplicateRipAnnouncePolicy" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFANNOUNCEPOLICYNOTFOUND,	"ospfAnnouncePolicyNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEOSPFANNOUNCEPOLICY,	"duplicateOspfAnnouncePolicy" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYMATCHNETENTRYNOTFOUND,	"policyMatchNetEntryNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEPOLICYNETENTRY,	"duplicatePolicyNetEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYADDRLISTENTRYNOTFOUND,	"policyAddrListEntryNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEPOLICYADDRLISTENTRY,	"duplicatePolicyAddrListEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYADDRLISTIDNOTFOUND,	"policyAddrListIdNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYEXACTNETLISTNOTFOUND,	"policyExactNetListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYRANGENETLISTNOTFOUND,	"policyRangeNetListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYRIPGATEWAYLISTNOTFOUND,	"policyRipGatewayListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYRIPINTERFACELISTNOTFOUND,	"policyRipInterfaceListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYOSPFRTRIDLISTNOTFOUND,	"policyOspfRtrIdListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYANNOUNCEINTERFACELISTNOTFOUND,	"policyAnnounceInterfaceListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYADVERTISENETLISTNOTFOUND,	"policyAdvertiseNetListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYINJECTNETLISTNOTFOUND,	"policyInjectNetListNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDPOLICYLISTIDLISTSIZE,	"invalidPolicyListIdListSize" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYADDRENTRYNOTFOUND,	"policyAddrEntryNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEPOLICYADDRENTRY,	"duplicatePolicyAddrEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_DISABLETHISPORTFIRST,	"disableThisPortFirst" },
    { RAPID_CITY_RCERRORRETURNCODE_MUTINETTINGNOTSUPPORTED,	"mutinettingNotSupported" },
    { RAPID_CITY_RCERRORRETURNCODE_ADDINGGLOBALFILTERTONONGLOBALLIST,	"addingGlobalFilterToNonGlobalList" },
    { RAPID_CITY_RCERRORRETURNCODE_ADDINGNONGLOBALFILTERTOGLOBALLIST,	"addingNonGlobalFilterToGlobalList" },
    { RAPID_CITY_RCERRORRETURNCODE_SETFILTEREDPORTMODE,	"setFilteredPortMode" },
    { RAPID_CITY_RCERRORRETURNCODE_SETFILTEREDPORTENABLEVALUE,	"setFilteredPortEnableValue" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDMODETYPE,	"invalidModeType" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATERIPACCEPTPOLICY,	"duplicateRipAcceptPolicy" },
    { RAPID_CITY_RCERRORRETURNCODE_RIPACCEPPOLICYNOTFOUND,	"ripAccepPolicyNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEOSPFACCEPTPOLICY,	"duplicateOspfAcceptPolicy" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFACCEPPOLICYNOTFOUND,	"ospfAccepPolicyNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYNAME,	"invalidAccessPolicyName" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYPOLICYENABLE,	"invalidAccessPolicyPolicyEnable" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYMODE,	"invalidAccessPolicyMode" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYSERVICE,	"invalidAccessPolicyService" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYPRECEDENCE,	"invalidAccessPolicyPrecedence" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYNETADDRESS,	"invalidAccessPolicyNetAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYTRUSTEDHOSTADDRESS,	"invalidAccessPolicyTrustedHostAddress" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYTRUSTEDHOSTUSERNAME,	"invalidAccessPolicyTrustedHostUserName" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYACCESSLEVEL,	"invalidAccessPolicyAccessLevel" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYLOGSETTING,	"invalidAccessPolicyLogSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDACCESSPOLICYPOLICYID,	"invalidAccessPolicyPolicyId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDAREAOPTIONS,	"invalidAreaOptions" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTDELETEAREAIFCOUNTISNOTZERO,	"cannotDeleteAreaIfCountIsNotZero" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFINTERFACENOTFOUND,	"ospfInterfaceNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_OSPFIFAREAIDCONFLICTSWITHCONFIGUREDAREARANGE,	"ospfIfAreaIdConflictsWithConfiguredAreaRange" },
    { RAPID_CITY_RCERRORRETURNCODE_APPLYINGDUPLICATEGLOBALFILTERTOPORT,	"applyingDuplicateGlobalFilterToPort" },
    { RAPID_CITY_RCERRORRETURNCODE_DIFFERENTMLTPORTTYPES,	"differentMltPortTypes" },
    { RAPID_CITY_RCERRORRETURNCODE_ADDPORTTOMLTFAILED,	"addPortToMltFailed" },
    { RAPID_CITY_RCERRORRETURNCODE_REMOVEPORTFROMMLTFAILED,	"removePortFromMltFailed" },
    { RAPID_CITY_RCERRORRETURNCODE_MIRRORPORTINMLT,	"mirrorPortInMlt" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDDHCPALWAYSBROADCAST,	"invalidDhcpAlwaysBroadcast" },
    { RAPID_CITY_RCERRORRETURNCODE_INTERFACEISSETTOTRANSMITRIPV1,	"interfaceIsSetToTransmitRipV1" },
    { RAPID_CITY_RCERRORRETURNCODE_RIPINTERFACEDOESNOTEXIST,	"ripInterfaceDoesnotExist" },
    { RAPID_CITY_RCERRORRETURNCODE_INTERFACEISNOTRUNNINGRIP,	"interfaceIsNotRunningRip" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTCREATEVIRTLINKSTHROUGHSTUBAREA,	"cannotCreateVirtLinksThroughStubArea" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGENABLESETTING,	"invalidSyslogEnableSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGHOSTIPADDR,	"invalidSyslogHostIpAddr" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGHOSTUDPPORT,	"invalidSyslogHostUdpPort" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGHOSTFACILITY,	"invalidSyslogHostFacility" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMODULEID,	"invalidSyslogModuleId" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGSEVERITY,	"invalidSyslogSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPINFOSEVERITY,	"invalidSyslogMapInfoSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPWARNINGSEVERITY,	"invalidSyslogMapWarningSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPERRORSEVERITY,	"invalidSyslogMapErrorSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPMFGSEVERITY,	"invalidSyslogMapMfgSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPFATALSEVERITY,	"invalidSyslogMapFatalSeverity" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPTRACEMSGSETTING,	"invalidSyslogMapTraceMsgSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAPTRAPMSGSETTING,	"invalidSyslogMapTrapMsgSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGLOGTRACEMSGSETTING,	"invalidSyslogLogTraceMsgSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGLOGTRAPMSGSETTING,	"invalidSyslogLogTrapMsgSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGENTRYENABLESETTING,	"invalidSyslogEntryEnableSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGMAXHOSTSETTING,	"invalidSyslogMaxHostSetting" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDSYSLOGHOSTID,	"invalidSyslogHostId" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATESYSLOGENTRY,	"duplicateSyslogEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_SYSLOGHOSTTABLEISFULL,	"syslogHostTableIsFull" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDHOLDDOWNTIME,	"invalidHoldDownTime" },
    { RAPID_CITY_RCERRORRETURNCODE_INCOMPATIBLEARUHARDWARE,	"incompatibleAruHardware" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVRID,	"invalidVrid" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEVRRPENTRY,	"duplicateVrrpEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_NOVRRPIPADDRESSSPECIFIED,	"noVrrpIpAddressSpecified" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVRRPCONTROLVALUE,	"invalidVrrpControlValue" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVRRPPRIORITY,	"invalidVrrpPriority" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDVRRPADVERTISEMENTINTERVAL,	"invalidVrrpAdvertisementInterval" },
    { RAPID_CITY_RCERRORRETURNCODE_MAXNUMOFVRRPSENTRIESEXCEEDED,	"maxNumOfVrrpsEntriesExceeded" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYNETLISTENTRYNOTFOUND,	"policyNetListEntryNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEPOLICYNETLISTENTRY,	"duplicatePolicyNetListEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_POLICYNETLISTIDNOTFOUND,	"policyNetListIdNotFound" },
    { RAPID_CITY_RCERRORRETURNCODE_FILTERONANENABLEDPORT,	"filterOnAnEnabledPort" },
    { RAPID_CITY_RCERRORRETURNCODE_LISTONANENABLEDPORT,	"listOnAnEnabledPort" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPFILTERSRCOPTION,	"invalidIpFilterSrcOption" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPFILTERDSTOPTION,	"invalidIpFilterDstOption" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDOSPFAREAIMPORTEXTOPTION,	"invalidOspfAreaImportextOption" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDOSPFINTERFACEMD5KEYIDLENGTH,	"invalidOspfInterfaceMd5KeyIdLength" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDOSPFINTERFACEMD5KEYLENGTH,	"invalidOspfInterfaceMd5KeyLength" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPXNETWORKNUMBER,	"invalidIPXNetworkNumber" },
    { RAPID_CITY_RCERRORRETURNCODE_IPXCIRCUITALREADYEXISTS,	"ipxCircuitAlreadyExists" },
    { RAPID_CITY_RCERRORRETURNCODE_IPXCIRCUITDOESNOTEXIST,	"ipxCircuitDoesNotExist" },
    { RAPID_CITY_RCERRORRETURNCODE_ENCAPSULATIONISNOTALLOWEDONSAMESEGMENT,	"encapsulationIsNotAllowedOnSameSegment" },
    { RAPID_CITY_RCERRORRETURNCODE_ENCAPSULATIONDOESNOTMATCHPROTOCOLBASEDVLAN,	"encapsulationDoesNotMatchProtocolBasedVLAN" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDDVMRPIFTBLENABLEVALUE,	"invalidDvmrpIfTblEnableValue" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDDVMRPIFTBLMETRICVALUE,	"invalidDvmrpIfTblMetricValue" },
    { RAPID_CITY_RCERRORRETURNCODE_IPHOSTPARTFORSUBNETADDRISNONZERO,	"ipHostPartForSubnetAddrIsNonZero" },
    { RAPID_CITY_RCERRORRETURNCODE_GLOBALMULTICASTNOTENABLED,	"globalMulticastNotEnabled" },
    { RAPID_CITY_RCERRORRETURNCODE_METRICFIELDISCREATEDBUTMODIFIED,	"metricFieldIsCreatedButModified" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDIPMROUTEINTERFACETBLTTLVALUE,	"invalidIpMRouteInterfaceTblTtlValue" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDUDPPORTNUMBER,	"invalidUdpPortNumber" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDUDPPROTOCOLNAMELENGTH,	"invalidUdpProtocolNameLength" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTMODIFYUDPPROTOCOLNAME,	"cannotModifyUdpProtocolName" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPROTOCOLENTRYDOESNOTEXISTS,	"udpProtocolEntryDoesnotexists" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEUDPPROTOCOLENTRY,	"duplicateUdpProtocolEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTDELUDPPROTOCOLENTRYFWDENTRIESEXISTS,	"cannotDelUdpProtocolEntryFwdEntriesExists" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPBROADCASTINTFENTRYDOESNOTEXISTS,	"udpBroadcastIntfEntryDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEUDPBROADCASTINTFENTRY,	"duplicateUdpBroadcastIntfEntry" },
    { RAPID_CITY_RCERRORRETURNCODE_INVALIDUDPCONFBROACASTINTERFACE,	"invalidUdpConfBroacastInterface" },
    { RAPID_CITY_RCERRORRETURNCODE_UPDCONFINTFENTRYNOTENABLEDFORUDPBCASTFORWARDING,	"updConfIntfEntryNotEnabledForUdpBcastForwarding" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPORTFWDENTRYDOESNOTEXISTS,	"udpPortFwdEntryDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEUDPPORTFWDENTRYDOESNOTEXISTS,	"duplicateUdpPortFwdEntryDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPORTFWDENTRYUDPPORTINTERFACEDOESNOTEXISTS,	"udpPortFwdEntryUdpPortInterfaceDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPORTFWDLISTENTRYDOESNOTEXISTS,	"udpPortFwdListEntryDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_DUPLICATEUDPPORTFWDLISTENTRYDOESNOTEXISTS,	"duplicateUdpPortFwdListEntryDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPORTFWDLISTENTRYPORTFWDIDDOESNOTEXISTS,	"udpPortFwdListEntryPortFwdIdDoesnotExists" },
    { RAPID_CITY_RCERRORRETURNCODE_UDPPORTFWDLISTENTRYINVALIDFWDIDLISTSIZE,	"udpPortFwdListEntryinvalidFwdIdListSize" },
    { RAPID_CITY_RCERRORRETURNCODE_CANNOTDELETEUDPPORTFWDLISTENTRYINTERFACEUSINGTHISLIST,	"cannotDeleteUdpPortFwdListEntryInterfaceUsingThisList" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcErrorSendTrap[] = {
    { RAPID_CITY_RCERRORSENDTRAP_TRUE,	"true" },
    { RAPID_CITY_RCERRORSENDTRAP_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogGlobalEnable[] = {
    { RAPID_CITY_RCSYSLOGGLOBALENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSYSLOGGLOBALENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogGlobalOperState[] = {
    { RAPID_CITY_RCSYSLOGGLOBALOPERSTATE_ACTIVE,	"active" },
    { RAPID_CITY_RCSYSLOGGLOBALOPERSTATE_INACTIVE,	"inactive" },
    { RAPID_CITY_RCSYSLOGGLOBALOPERSTATE_EMPTYHOSTTBL,	"emptyHostTbl" },
    { RAPID_CITY_RCSYSLOGGLOBALOPERSTATE_ALLHOSTDISABLED,	"allHostDisabled" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostFacility[] = {
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL0,	"local0" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL1,	"local1" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL2,	"local2" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL3,	"local3" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL4,	"local4" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL5,	"local5" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL6,	"local6" },
    { RAPID_CITY_RCSYSLOGHOSTFACILITY_LOCAL7,	"local7" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostModuleId[] = {
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_COMMON,	"common" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_SNMP,	"snmp" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_RMON,	"rmon" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_PORTMGR,	"portmgr" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_CHASMGR,	"chasmgr" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_BRIDGE,	"bridge" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_OSPF,	"ospf" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_HWIF,	"hwif" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_SIM,	"sim" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_CPP,	"cpp" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_NETDRV,	"netdrv" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_VLANMGR,	"vlanmgr" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_CLI,	"cli" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_MAIN,	"main" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_P2IP,	"p2ip" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_RCIP,	"rcip" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_ROMPAGER,	"rompager" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_ACIF,	"acif" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_GBIP,	"gbip" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_WDT,	"wdt" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_TDP,	"tdp" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_MANDIAG,	"mandiag" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_MANTEST,	"mantest" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_IGMP,	"igmp" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_IPFIL,	"ipfil" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_MLT,	"mlt" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_IPPOLICY,	"ippolicy" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_IPMC,	"ipmc" },
    { RAPID_CITY_RCSYSLOGHOSTMODULEID_SYSLOG,	"syslog" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTSEVERITY_MFG,	"mfg" },
    { RAPID_CITY_RCSYSLOGHOSTSEVERITY_FATAL,	"fatal" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapInfoSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapWarningSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapErrorSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapMfgSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapFatalSeverity[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapTraceMsg[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostMapTrapMsg[] = {
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_EMERGENCY,	"emergency" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_ALERT,	"alert" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_CRITICAL,	"critical" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_ERROR,	"error" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_WARNING,	"warning" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_NOTICE,	"notice" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_INFO,	"info" },
    { RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG_DEBUG,	"debug" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostLogTraceMsgs[] = {
    { RAPID_CITY_RCSYSLOGHOSTLOGTRACEMSGS_TRUE,	"true" },
    { RAPID_CITY_RCSYSLOGHOSTLOGTRACEMSGS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostLogTrapMsgs[] = {
    { RAPID_CITY_RCSYSLOGHOSTLOGTRAPMSGS_TRUE,	"true" },
    { RAPID_CITY_RCSYSLOGHOSTLOGTRAPMSGS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostEnable[] = {
    { RAPID_CITY_RCSYSLOGHOSTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCSYSLOGHOSTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcSyslogHostRowStatus[] = {
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCSYSLOGHOSTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagMirrorByPortMode[] = {
    { RAPID_CITY_RCDIAGMIRRORBYPORTMODE_TX,	"tx" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTMODE_RX,	"rx" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTMODE_BOTH,	"both" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagMirrorByPortEnable[] = {
    { RAPID_CITY_RCDIAGMIRRORBYPORTENABLE_TRUE,	"true" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagMirrorByPortRowStatus[] = {
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagPortConvSteeringMode[] = {
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGMODE_ONETOTWO,	"oneToTwo" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGMODE_TWOTOONE,	"twoToOne" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGMODE_BOTH,	"both" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagPortConvSteeringEnable[] = {
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGENABLE_TRUE,	"true" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagPortConvSteeringRowStatus[] = {
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagMacConvSteeringEnable[] = {
    { RAPID_CITY_RCDIAGMACCONVSTEERINGENABLE_TRUE,	"true" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagMacConvSteeringRowStatus[] = {
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcDiagSaveConfig[] = {
    { RAPID_CITY_RCDIAGSAVECONFIG_TRUE,	"true" },
    { RAPID_CITY_RCDIAGSAVECONFIG_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpxRoutingEnable[] = {
    { RAPID_CITY_RCIPXROUTINGENABLE_TRUE,	"true" },
    { RAPID_CITY_RCIPXROUTINGENABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpxAddrEncap[] = {
    { RAPID_CITY_RCIPXADDRENCAP_NONE,	"none" },
    { RAPID_CITY_RCIPXADDRENCAP_ETHERNETII,	"ethernetii" },
    { RAPID_CITY_RCIPXADDRENCAP_SNAP,	"snap" },
    { RAPID_CITY_RCIPXADDRENCAP_LLC,	"llc" },
    { RAPID_CITY_RCIPXADDRENCAP_RAW,	"raw" },
    { 0, NULL }
};

GSnmpEnum const rapid_city_enums_rcIpxAddrEntryStatus[] = {
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_ACTIVE,	"active" },
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_NOTINSERVICE,	"notInService" },
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_NOTREADY,	"notReady" },
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_CREATEANDGO,	"createAndGo" },
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_CREATEANDWAIT,	"createAndWait" },
    { RAPID_CITY_RCIPXADDRENTRYSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, gsize len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, gsize const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		g_warning("type tag 0x%02x does not match 0x%02x (%s)",
			  vb->type, attributes[i].type, attributes[i].label);
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_rcSystem[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1};

static attribute_t attr_rcSystem[] = {
    { 1, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSIPADDR, "rcSysIpAddr" },
    { 2, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSNETMASK, "rcSysNetMask" },
    { 3, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSBROADCAST, "rcSysBroadcast" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSCOMMREADWRITEALL, "rcSysCommReadWriteAll" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSCOMMREADWRITE, "rcSysCommReadWrite" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSCOMMREADONLY, "rcSysCommReadOnly" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSVERSION, "rcSysVersion" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACTION, "rcSysAction" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCSYSRESULT, "rcSysResult" },
    { 10, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTCHANGE, "rcSysLastChange" },
    { 11, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTVLANCHANGE, "rcSysLastVlanChange" },
    { 12, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTSTATISTICSRESET, "rcSysLastStatisticsReset" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCSYSBUFFERUTIL, "rcSysBufferUtil" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCSYSBUFFERUTILPEAK, "rcSysBufferUtilPeak" },
    { 15, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSBUFFERUTILPEAKTIME, "rcSysBufferUtilPeakTime" },
    { 16, G_SNMP_UNSIGNED32, RAPID_CITY_RCSYSNVRAMSIZE, "rcSysNVRamSize" },
    { 17, G_SNMP_UNSIGNED32, RAPID_CITY_RCSYSNVRAMUSED, "rcSysNVRamUsed" },
    { 18, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTSAVETONVRAM, "rcSysLastSaveToNVRam" },
    { 19, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTSAVETOSTANDBYNVRAM, "rcSysLastSaveToStandbyNVRam" },
    { 20, G_SNMP_UNSIGNED32, RAPID_CITY_RCSYSCPUUTIL, "rcSysCpuUtil" },
    { 21, G_SNMP_UNSIGNED32, RAPID_CITY_RCSYSSWITCHFABRICUTIL, "rcSysSwitchFabricUtil" },
    { 22, G_SNMP_INTEGER32, RAPID_CITY_RCSYSRMONMEMSIZE, "rcSysRmonMemSize" },
    { 23, G_SNMP_INTEGER32, RAPID_CITY_RCSYSRMONENABLE, "rcSysRmonEnable" },
    { 24, G_SNMP_INTEGER32, RAPID_CITY_RCSYSRMONSAVECONFIG, "rcSysRmonSaveConfig" },
    { 25, G_SNMP_INTEGER32, RAPID_CITY_RCSYSRMONTRAPOPTION, "rcSysRmonTrapOption" },
    { 26, G_SNMP_INTEGER32, RAPID_CITY_RCSYSSUPPORTROUTING, "rcSysSupportRouting" },
    { 27, G_SNMP_INTEGER32, RAPID_CITY_RCSYSSUPPORTWEBSERVER, "rcSysSupportWebServer" },
    { 28, G_SNMP_TIMETICKS, RAPID_CITY_RCSYSLASTIPADDRCHANGE, "rcSysLastIpAddrChange" },
    { 29, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSCOMMREADWRITELAYER3, "rcSysCommReadWriteLayer3" },
    { 30, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSCOMMREADWRITELAYER2, "rcSysCommReadWriteLayer2" },
    { 31, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYENABLE, "rcSysAccessPolicyEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcSysTrapRecvEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 60, 1};

static attribute_t attr_rcSysTrapRecvEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCSYSTRAPRECVVERSION, "rcSysTrapRecvVersion" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSTRAPRECVCOMMUNITY, "rcSysTrapRecvCommunity" },
    { 4, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSTRAPRECVSRCADDRESS, "rcSysTrapRecvSrcAddress" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCSYSTRAPRECVROWSTATUS, "rcSysTrapRecvRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcSysAccessPolicyEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 61, 1};

static attribute_t attr_rcSysAccessPolicyEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSACCESSPOLICYNAME, "rcSysAccessPolicyName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYPOLICYENABLE, "rcSysAccessPolicyPolicyEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYMODE, "rcSysAccessPolicyMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYSERVICE, "rcSysAccessPolicyService" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYPRECEDENCE, "rcSysAccessPolicyPrecedence" },
    { 7, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSACCESSPOLICYNETADDR, "rcSysAccessPolicyNetAddr" },
    { 8, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSACCESSPOLICYNETMASK, "rcSysAccessPolicyNetMask" },
    { 9, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSACCESSPOLICYTRUSTEDHOSTADDR, "rcSysAccessPolicyTrustedHostAddr" },
    { 10, G_SNMP_OCTET_STRING, RAPID_CITY_RCSYSACCESSPOLICYTRUSTEDHOSTUSERNAME, "rcSysAccessPolicyTrustedHostUserName" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYACCESSLEVEL, "rcSysAccessPolicyAccessLevel" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYLOG, "rcSysAccessPolicyLog" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSYSACCESSPOLICYUSAGE, "rcSysAccessPolicyUsage" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCSYSACCESSPOLICYROWSTATUS, "rcSysAccessPolicyRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcTftp[] = {1, 3, 6, 1, 4, 1, 2272, 1, 2};

static attribute_t attr_rcTftp[] = {
    { 1, G_SNMP_IPADDRESS, RAPID_CITY_RCTFTPHOST, "rcTftpHost" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCTFTPFILE, "rcTftpFile" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCTFTPACTION, "rcTftpAction" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCTFTPRESULT, "rcTftpResult" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlan[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3};

static attribute_t attr_rcVlan[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCVLANNUMVLANS, "rcVlanNumVlans" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPNUMGROUPS, "rcVlanIgmpSnoopNumGroups" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1};

static attribute_t attr_rcVlanEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANNAME, "rcVlanName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCVLANCOLOR, "rcVlanColor" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCVLANHIGHPRIORITY, "rcVlanHighPriority" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANROUTINGENABLE, "rcVlanRoutingEnable" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIFINDEX, "rcVlanIfIndex" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCVLANACTION, "rcVlanAction" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCVLANRESULT, "rcVlanResult" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCVLANSTGID, "rcVlanStgId" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCVLANTYPE, "rcVlanType" },
    { 11, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANPORTMEMBERS, "rcVlanPortMembers" },
    { 12, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANACTIVEMEMBERS, "rcVlanActiveMembers" },
    { 13, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANSTATICMEMBERS, "rcVlanStaticMembers" },
    { 14, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANNOTALLOWTOJOIN, "rcVlanNotAllowToJoin" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPROTOCOLID, "rcVlanProtocolId" },
    { 16, G_SNMP_IPADDRESS, RAPID_CITY_RCVLANSUBNETADDR, "rcVlanSubnetAddr" },
    { 17, G_SNMP_IPADDRESS, RAPID_CITY_RCVLANSUBNETMASK, "rcVlanSubnetMask" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCVLANAGINGTIME, "rcVlanAgingTime" },
    { 19, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANMACADDRESS, "rcVlanMacAddress" },
    { 20, G_SNMP_INTEGER32, RAPID_CITY_RCVLANROWSTATUS, "rcVlanRowStatus" },
    { 21, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPENABLE, "rcVlanIgmpSnoopEnable" },
    { 22, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPREPORTPROXYENABLE, "rcVlanIgmpSnoopReportProxyEnable" },
    { 23, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPROBUSTNESS, "rcVlanIgmpSnoopRobustness" },
    { 24, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPQUERYINTERVAL, "rcVlanIgmpSnoopQueryInterval" },
    { 25, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANIGMPSNOOPMROUTERPORTS, "rcVlanIgmpSnoopMRouterPorts" },
    { 26, G_SNMP_INTEGER32, RAPID_CITY_RCVLANUSERDEFINEDPID, "rcVlanUserDefinedPid" },
    { 27, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANIGMPSNOOPACTIVEMROUTERPORTS, "rcVlanIgmpSnoopActiveMRouterPorts" },
    { 28, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPROTOCOLIDS, "rcVlanProtocolIds" },
    { 29, G_SNMP_IPADDRESS, RAPID_CITY_RCVLANIGMPSNOOPACTIVEQUERIER, "rcVlanIgmpSnoopActiveQuerier" },
    { 30, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPMROUTEREXPIRATION, "rcVlanIgmpSnoopMRouterExpiration" },
    { 31, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPQUERIERPORT, "rcVlanIgmpSnoopQuerierPort" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanPortEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1};

static attribute_t attr_rcVlanPortEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTNUMVLANIDS, "rcVlanPortNumVlanIds" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANPORTVLANIDS, "rcVlanPortVlanIds" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTTYPE, "rcVlanPortType" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTDISCARDTAGGEDFRAMES, "rcVlanPortDiscardTaggedFrames" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTDISCARDUNTAGGEDFRAMES, "rcVlanPortDiscardUntaggedFrames" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTDEFAULTVLANID, "rcVlanPortDefaultVlanId" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCVLANPORTPERFORMTAGGING, "rcVlanPortPerformTagging" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanMacEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1};

static attribute_t attr_rcVlanMacEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCVLANMACROWSTATUS, "rcVlanMacRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanIgmpSnoopEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1};

static attribute_t attr_rcVlanIgmpSnoopEntry[] = {
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPEXPIRATION, "rcVlanIgmpSnoopExpiration" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPTYPE, "rcVlanIgmpSnoopType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanIgmpSnoopStaticEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1};

static attribute_t attr_rcVlanIgmpSnoopStaticEntry[] = {
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANIGMPSNOOPSTATICMEMBERPORTS, "rcVlanIgmpSnoopStaticMemberPorts" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPSTATICROWSTATUS, "rcVlanIgmpSnoopStaticRowStatus" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCVLANIGMPSNOOPSTATICNOTALLOWEDTOJOIN, "rcVlanIgmpSnoopStaticNotAllowedToJoin" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanIgmpSnoopAccessEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1};

static attribute_t attr_rcVlanIgmpSnoopAccessEntry[] = {
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPACCESSMODE, "rcVlanIgmpSnoopAccessMode" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPACCESSROWSTATUS, "rcVlanIgmpSnoopAccessRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcVlanIgmpSnoopSenderEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1};

static attribute_t attr_rcVlanIgmpSnoopSenderEntry[] = {
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCVLANIGMPSNOOPSENDERACTION, "rcVlanIgmpSnoopSenderAction" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcChassis[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4};

static attribute_t attr_rcChassis[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCCHASTYPE, "rcChasType" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCCHASSERIALNUMBER, "rcChasSerialNumber" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCCHASHARDWAREREVISION, "rcChasHardwareRevision" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCCHASNUMSLOTS, "rcChasNumSlots" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCCHASNUMPORTS, "rcChasNumPorts" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCCHASTESTRESULT, "rcChasTestResult" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCCHASARUMODE, "rcChasAruMode" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCCHASQUIDMODE, "rcChasQuidMode" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCCHASEOCMODEADMINSTATUS, "rcChasEocModeAdminStatus" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCCHASEOCMODEOPERSTATUS, "rcChasEocModeOperStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcChasFanEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 7, 1, 1};

static attribute_t attr_rcChasFanEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCCHASFANOPERSTATUS, "rcChasFanOperStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcChasPowerSupplyEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 8, 1, 1};

static attribute_t attr_rcChasPowerSupplyEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCCHASPOWERSUPPLYOPERSTATUS, "rcChasPowerSupplyOperStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcChasPowerSupplyDetailEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 8, 2, 1};

static attribute_t attr_rcChasPowerSupplyDetailEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCCHASPOWERSUPPLYDETAILTYPE, "rcChasPowerSupplyDetailType" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCCHASPOWERSUPPLYDETAILSERIALNUMBER, "rcChasPowerSupplyDetailSerialNumber" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCCHASPOWERSUPPLYDETAILHARDWAREREVISION, "rcChasPowerSupplyDetailHardwareRevision" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCCHASPOWERSUPPLYDETAILPARTNUMBER, "rcChasPowerSupplyDetailPartNumber" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcCardEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 9, 1, 1};

static attribute_t attr_rcCardEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCCARDTYPE, "rcCardType" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCCARDSERIALNUMBER, "rcCardSerialNumber" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCCARDHARDWAREREVISION, "rcCardHardwareRevision" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCCARDADMINSTATUS, "rcCardAdminStatus" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCCARDOPERSTATUS, "rcCardOperStatus" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCCARDPCMCIATYPE, "rcCardPCMCIAType" },
    { 8, G_SNMP_OCTET_STRING, RAPID_CITY_RCCARDPARTNUMBER, "rcCardPartNumber" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcPortEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 10, 1, 1};

static attribute_t attr_rcPortEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCPORTTYPE, "rcPortType" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCPORTCONNECTORTYPE, "rcPortConnectorType" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCPORTPERFORMROUTING, "rcPortPerformRouting" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCPORTHIGHPRIORITY, "rcPortHighPriority" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCPORTACTION, "rcPortAction" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCPORTRESULT, "rcPortResult" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCPORTPRIMARYCONNECTOR, "rcPortPrimaryConnector" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCPORTACTIVECONNECTOR, "rcPortActiveConnector" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCPORTBACKUPCONNECTORSTATUS, "rcPortBackupConnectorStatus" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCPORTAUTONEGOTIATE, "rcPortAutoNegotiate" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCPORTADMINDUPLEX, "rcPortAdminDuplex" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCPORTOPERDUPLEX, "rcPortOperDuplex" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCPORTADMINSPEED, "rcPortAdminSpeed" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCPORTOPERSPEED, "rcPortOperSpeed" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCPORTMLTID, "rcPortMltId" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCPORTLOCKED, "rcPortLocked" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCPORTAUTONEGOTIATIONSUPPORTED, "rcPortAutoNegotiationSupported" },
    { 19, G_SNMP_INTEGER32, RAPID_CITY_RCPORTSINGLEROUTABLEPORT, "rcPortSingleRoutablePort" },
    { 20, G_SNMP_INTEGER32, RAPID_CITY_RCPORTUNKNOWNMACDISCARD, "rcPortUnknownMacDiscard" },
    { 21, G_SNMP_COUNTER32, RAPID_CITY_RCPORTNUMSTATETRANSITION, "rcPortNumStateTransition" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcPortLock[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 11};

static attribute_t attr_rcPortLock[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCPORTLOCKENABLE, "rcPortLockEnable" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCPORTLOCKLOCKEDPORTS, "rcPortLockLockedPorts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcPortAtmLecExtEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 40, 1, 1};

static attribute_t attr_rcPortAtmLecExtEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTLECSTATUS, "rcPortAtmLecExtLecStatus" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTLECSTATE, "rcPortAtmLecExtLecState" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTVIRTUALPORTID, "rcPortAtmLecExtVirtualPortId" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCPORTATMLECEXTELANNAME, "rcPortAtmLecExtElanName" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTVLANID, "rcPortAtmLecExtVlanId" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTDESIREDPHYSICALPORT, "rcPortAtmLecExtDesiredPhysicalPort" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTACTUALPHYSICALPORT, "rcPortAtmLecExtActualPhysicalPort" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCPORTATMLECEXTFAILOVERENABLE, "rcPortAtmLecExtFailoverEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcMirror[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5};

static attribute_t attr_rcMirror[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORSAVECONFIG, "rcMirrorSaveConfig" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcMirrorByPort[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5, 2};

static attribute_t attr_rcMirrorByPort[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTENABLE, "rcMirrorByPortEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTMIRRORPORT, "rcMirrorByPortMirrorPort" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTONE, "rcMirrorByPortEnableMirroredPortOne" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTMIRROREDPORTONE, "rcMirrorByPortMirroredPortOne" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTENABLEMIRROREDPORTTWO, "rcMirrorByPortEnableMirroredPortTwo" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCMIRRORBYPORTMIRROREDPORTTWO, "rcMirrorByPortMirroredPortTwo" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDipSwitch[] = {1, 3, 6, 1, 4, 1, 2272, 1, 6};

static attribute_t attr_rcDipSwitch[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCISOLATEUNCONFIGPORTS, "rcIsolateUnconfigPorts" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCUSEFACTORYSETTINGS, "rcUseFactorySettings" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCHIGHPRIORITYMODE, "rcHighPriorityMode" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcTblSize[] = {1, 3, 6, 1, 4, 1, 2272, 1, 7};

static attribute_t attr_rcTblSize[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONSTATSIZE, "rcTblRmonStatSize" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONHISTORYCONTROLSIZE, "rcTblRmonHistoryControlSize" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONHISTORYENETSIZE, "rcTblRmonHistoryEnetSize" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONALARMSIZE, "rcTblRmonAlarmSize" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONEVENTSIZE, "rcTblRmonEventSize" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCTBLRMONLOGSIZE, "rcTblRmonLogSize" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARTBLSIZE, "rcTblArTblSize" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARFREE, "rcTblArFree" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARNOSPACE, "rcTblArNoSpace" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARADDED, "rcTblArAdded" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARDELETED, "rcTblArDeleted" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARMACADDED, "rcTblArMacAdded" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARMACDELETED, "rcTblArMacDeleted" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARMACMOVED, "rcTblArMacMoved" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPADDED, "rcTblArIpAdded" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPDELETED, "rcTblArIpDeleted" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARMCASTTBLSIZE, "rcTblArMcastTblSize" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARFREEMCASTGROUPS, "rcTblArFreeMcastGroups" },
    { 19, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPMCASTADDED, "rcTblArIpMcastAdded" },
    { 20, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPMCASTDELETED, "rcTblArIpMcastDeleted" },
    { 21, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYPORTADDED, "rcTblArVlanByPortAdded" },
    { 22, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYPORTDELETED, "rcTblArVlanByPortDeleted" },
    { 23, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYPROTOCOLADDED, "rcTblArVlanByProtocolAdded" },
    { 24, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYPROTOCOLDELETED, "rcTblArVlanByProtocolDeleted" },
    { 25, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYIPSUBNETADDED, "rcTblArVlanByIpSubnetAdded" },
    { 26, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARVLANBYIPSUBNETDELETED, "rcTblArVlanByIpSubnetDeleted" },
    { 27, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPSUBNETSADDED, "rcTblArIpSubnetsAdded" },
    { 28, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARIPSUBNETSDELETED, "rcTblArIpSubnetsDeleted" },
    { 29, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARRSVPSADDED, "rcTblArRsvpsAdded" },
    { 30, G_SNMP_INTEGER32, RAPID_CITY_RCTBLARRSVPSDELETED, "rcTblArRsvpsDeleted" },
    { 31, G_SNMP_INTEGER32, RAPID_CITY_RCTBLBRDGFDBSIZE, "rcTblBrdgFdbSize" },
    { 32, G_SNMP_INTEGER32, RAPID_CITY_RCTBLBRDGSTATICSIZE, "rcTblBrdgStaticSize" },
    { 33, G_SNMP_INTEGER32, RAPID_CITY_RCTBLIPADDRSIZE, "rcTblIpAddrSize" },
    { 34, G_SNMP_INTEGER32, RAPID_CITY_RCTBLIPFORWARDINGSIZE, "rcTblIpForwardingSize" },
    { 35, G_SNMP_INTEGER32, RAPID_CITY_RCTBLIPNETTOMEDIASIZE, "rcTblIpNetToMediaSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 1, 1};

static attribute_t attr_rcIpConfEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFADVERTDEFRTE, "rcIpConfAdvertDefRte" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFACCEPTDEFRTE, "rcIpConfAcceptDefRte" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFROWSTATUS, "rcIpConfRowStatus" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFRIPENABLE, "rcIpConfRipEnable" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFENABLE, "rcIpConfOspfEnable" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPENABLE, "rcIpConfIgmpEnable" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFADDRASSIGNED, "rcIpConfAddrAssigned" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPENABLE, "rcIpConfDhcpEnable" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFTRIGGEREDUPDATEENABLE, "rcIpConfTriggeredUpdateEnable" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFRIPAUTOAGGRERATEENABLE, "rcIpConfRipAutoAggrerateEnable" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFRIPGENERATEDEFAULTROUTE, "rcIpConfRipGenerateDefaultRoute" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfOspfEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 2, 1};

static attribute_t attr_rcIpConfOspfEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFRTRPRIORITY, "rcIpConfOspfRtrPriority" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFMETRIC, "rcIpConfOspfMetric" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPCONFOSPFAUTHKEY, "rcIpConfOspfAuthKey" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFROWSTATUS, "rcIpConfOspfRowStatus" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFHELLOINTERVAL, "rcIpConfOspfHelloInterval" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFRTRDEADINTERVAL, "rcIpConfOspfRtrDeadInterval" },
    { 8, G_SNMP_IPADDRESS, RAPID_CITY_RCIPCONFOSPFIFAREAID, "rcIpConfOspfIfAreaId" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFAUTHTYPE, "rcIpConfOspfAuthType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfOspfDefaultMetric[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 3};

static attribute_t attr_rcIpConfOspfDefaultMetric[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFDEFAULTMETRIC10MEGPORT, "rcIpConfOspfDefaultMetric10MegPort" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFDEFAULTMETRIC100MEGPORT, "rcIpConfOspfDefaultMetric100MegPort" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFDEFAULTMETRIC1000MEGPORT, "rcIpConfOspfDefaultMetric1000MegPort" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfOspf[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 4};

static attribute_t attr_rcIpConfOspf[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFTRAPENABLE, "rcIpConfOspfTrapEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFAUTOVIRTLINKENABLE, "rcIpConfOspfAutoVirtLinkEnable" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFSPFHOLDDOWNTIME, "rcIpConfOspfSpfHoldDownTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfGlobal[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 6};

static attribute_t attr_rcIpConfGlobal[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFGLOBALRIPHOLDDOWNTIME, "rcIpConfGlobalRipHoldDownTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfOspfAreaEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 7, 1};

static attribute_t attr_rcIpConfOspfAreaEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFAREAIMPORTSUMMARY, "rcIpConfOspfAreaImportSummary" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFOSPFAREAACTIVEIFCOUNT, "rcIpConfOspfAreaActiveIfCount" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpAddrEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 2, 1};

static attribute_t attr_rcIpAddrEntry[] = {
    { 3, G_SNMP_IPADDRESS, RAPID_CITY_RCIPADENTNETMASK, "rcIpAdEntNetMask" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPADENTBCASTADDRFORMAT, "rcIpAdEntBcastAddrFormat" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPADENTREASMMAXSIZE, "rcIpAdEntReasmMaxSize" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPADENTROWSTATUS, "rcIpAdEntRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFlowEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 3, 1};

static attribute_t attr_rcIpFlowEntry[] = {
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPFLOWROWSTATUS, "rcIpFlowRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeRipToOspf[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 1};

static attribute_t attr_rcIpRoutingRedistributeRipToOspf[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFENABLE, "rcIpRoutingRedistributeRipToOspfEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFEXPLICITMETRIC, "rcIpRoutingRedistributeRipToOspfExplicitMetric" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFUSEEXPLICITMETRIC, "rcIpRoutingRedistributeRipToOspfUseExplicitMetric" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTERIPTOOSPFEXTERNALMETRICTYPE, "rcIpRoutingRedistributeRipToOspfExternalMetricType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeOspfToRip[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 2};

static attribute_t attr_rcIpRoutingRedistributeOspfToRip[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPENABLE, "rcIpRoutingRedistributeOspfToRipEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPEXPLICITMETRIC, "rcIpRoutingRedistributeOspfToRipExplicitMetric" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEOSPFTORIPUSEEXPLICITMETRIC, "rcIpRoutingRedistributeOspfToRipUseExplicitMetric" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeDirectToOspf[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 3};

static attribute_t attr_rcIpRoutingRedistributeDirectToOspf[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFENABLE, "rcIpRoutingRedistributeDirectToOspfEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFMETHOD, "rcIpRoutingRedistributeDirectToOspfMethod" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFEXPLICITMETRIC, "rcIpRoutingRedistributeDirectToOspfExplicitMetric" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTOOSPFEXTERNALMETRICTYPE, "rcIpRoutingRedistributeDirectToOspfExternalMetricType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeStaticToOspf[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 4};

static attribute_t attr_rcIpRoutingRedistributeStaticToOspf[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFENABLE, "rcIpRoutingRedistributeStaticToOspfEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFEXPLICITMETRIC, "rcIpRoutingRedistributeStaticToOspfExplicitMetric" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFUSEEXPLICITMETRIC, "rcIpRoutingRedistributeStaticToOspfUseExplicitMetric" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFEXTERNALMETRICTYPE, "rcIpRoutingRedistributeStaticToOspfExternalMetricType" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTOOSPFADVERTDEFRTE, "rcIpRoutingRedistributeStaticToOspfAdvertDefRte" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeDirectToRip[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 5};

static attribute_t attr_rcIpRoutingRedistributeDirectToRip[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTEDIRECTTORIPENABLE, "rcIpRoutingRedistributeDirectToRipEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRoutingRedistributeStaticToRip[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 6};

static attribute_t attr_rcIpRoutingRedistributeStaticToRip[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTINGREDISTRIBUTESTATICTORIPENABLE, "rcIpRoutingRedistributeStaticToRipEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfIgmpEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 5, 1};

static attribute_t attr_rcIpConfIgmpEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPQUERYINTERVAL, "rcIpConfIgmpQueryInterval" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPVERSION, "rcIpConfIgmpVersion" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPQUERYMAXRESPONSETIME, "rcIpConfIgmpQueryMaxResponseTime" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPQUERIERPRESENTTIMEOUT, "rcIpConfIgmpQuerierPresentTimeout" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPLEAVEENABLED, "rcIpConfIgmpLeaveEnabled" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPROWSTATUS, "rcIpConfIgmpRowStatus" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPROBUSTNESS, "rcIpConfIgmpRobustness" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFIGMPLASTMEMBERQUERYINTERVAL, "rcIpConfIgmpLastMemberQueryInterval" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIgmpGroupEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 6, 1};

static attribute_t attr_rcIgmpGroupEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIGMPGROUPINPORT, "rcIgmpGroupInPort" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIGMPGROUPEXPIRATION, "rcIgmpGroupExpiration" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpRouteEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 7, 1};

static attribute_t attr_rcIpRouteEntry[] = {
    { 3, G_SNMP_IPADDRESS, RAPID_CITY_RCIPROUTENEXTHOP, "rcIpRouteNextHop" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTEMETRIC, "rcIpRouteMetric" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTEIFINDEX, "rcIpRouteIfIndex" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTETYPE, "rcIpRouteType" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTEPROTO, "rcIpRouteProto" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTEAGE, "rcIpRouteAge" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPROUTEROWSTATUS, "rcIpRouteRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfDhcpEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 8, 1};

static attribute_t attr_rcIpConfDhcpEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPMAXHOP, "rcIpConfDhcpMaxHop" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPMINSEC, "rcIpConfDhcpMinSec" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPMODE, "rcIpConfDhcpMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPROWSTATUS, "rcIpConfDhcpRowStatus" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCIPCONFDHCPNUMREQUESTS, "rcIpConfDhcpNumRequests" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCIPCONFDHCPNUMREPLIES, "rcIpConfDhcpNumReplies" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDHCPALWAYSBROADCAST, "rcIpConfDhcpAlwaysBroadcast" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpDhcpForwardEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 9, 1};

static attribute_t attr_rcIpDhcpForwardEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPDHCPFORWARDENABLE, "rcIpDhcpForwardEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPDHCPFORWARDMODE, "rcIpDhcpForwardMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPDHCPFORWARDROWSTATUS, "rcIpDhcpForwardRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFilter[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10};

static attribute_t attr_rcIpFilter[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERFILTERTABLESIZE, "rcIpFilterFilterTableSize" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERGLOBALLISTTABLESIZE, "rcIpFilterGlobalListTableSize" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERBASELISTTABLESIZE, "rcIpFilterBaseListTableSize" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTTABLESIZE, "rcIpFilterPortTableSize" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERNEXTAVAILFILTERID, "rcIpFilterNextAvailFilterId" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFilterEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 20, 1};

static attribute_t attr_rcIpFilterEntry[] = {
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERNAME, "rcIpFilterName" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPROTOCOLTYPE, "rcIpFilterProtocolType" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERSRCPORT, "rcIpFilterSrcPort" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERSRCOPTION, "rcIpFilterSrcOption" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERDSTPORT, "rcIpFilterDstPort" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERDSTOPTION, "rcIpFilterDstOption" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERCOPYTOCPU, "rcIpFilterCopyToCpu" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERMIRROR, "rcIpFilterMirror" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERHIGHPRIORITY, "rcIpFilterHighPriority" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERTCPCONNECT, "rcIpFilterTcpConnect" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERIEEEVLANPRIORITY, "rcIpFilterIeeeVlanPriority" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERUSEPKTLIMIT, "rcIpFilterUsePktLimit" },
    { 19, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPKTLIMIT, "rcIpFilterPktLimit" },
    { 20, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERROWSTATUS, "rcIpFilterRowStatus" },
    { 21, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERMODE, "rcIpFilterMode" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFilterGlobalListEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 21, 1};

static attribute_t attr_rcIpFilterGlobalListEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERGLOBALLISTNAME, "rcIpFilterGlobalListName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERGLOBALLISTFILTERIDLISTSIZE, "rcIpFilterGlobalListFilterIdListSize" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERGLOBALLISTFILTERIDLIST, "rcIpFilterGlobalListFilterIdList" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERGLOBALLISTROWSTATUS, "rcIpFilterGlobalListRowStatus" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERGLOBALLISTMEMBERPORTS, "rcIpFilterGlobalListMemberPorts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFilterBaseListEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 22, 1};

static attribute_t attr_rcIpFilterBaseListEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERBASELISTNAME, "rcIpFilterBaseListName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERBASELISTFILTERIDLISTSIZE, "rcIpFilterBaseListFilterIdListSize" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERBASELISTFILTERIDLIST, "rcIpFilterBaseListFilterIdList" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERBASELISTROWSTATUS, "rcIpFilterBaseListRowStatus" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERBASELISTMEMBERPORTS, "rcIpFilterBaseListMemberPorts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpFilterPortEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 23, 1};

static attribute_t attr_rcIpFilterPortEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTFILTERLISTSIZE, "rcIpFilterPortFilterListSize" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPFILTERPORTFILTERLIST, "rcIpFilterPortFilterList" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTMODE, "rcIpFilterPortMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTENABLE, "rcIpFilterPortEnable" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTROWSTATUS, "rcIpFilterPortRowStatus" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTDEFAULTACTION, "rcIpFilterPortDefaultAction" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTNUMGLOBALFILTERS, "rcIpFilterPortNumGlobalFilters" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPFILTERPORTNUMBASEFILTERS, "rcIpFilterPortNumBaseFilters" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicy[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11};

static attribute_t attr_rcIpPolicy[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRTABLESIZE, "rcIpPolicyAddrTableSize" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETTABLESIZE, "rcIpPolicyNetTableSize" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRLISTTABLESIZE, "rcIpPolicyAddrListTableSize" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCETABLESIZE, "rcIpPolicyRipAnnounceTableSize" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCETABLESIZE, "rcIpPolicyOspfAnnounceTableSize" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTTABLESIZE, "rcIpPolicyRipAcceptTableSize" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTTABLESIZE, "rcIpPolicyOspfAcceptTableSize" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETLISTTABLESIZE, "rcIpPolicyNetListTableSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyAddrEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 2, 1};

static attribute_t attr_rcIpPolicyAddrEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRID, "rcIpPolicyAddrId" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRADDRLISTIDLISTSIZE, "rcIpPolicyAddrAddrListIdListSize" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYADDRADDRLISTIDLIST, "rcIpPolicyAddrAddrListIdList" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRROWSTATUS, "rcIpPolicyAddrRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyNetEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 4, 1};

static attribute_t attr_rcIpPolicyNetEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETID, "rcIpPolicyNetId" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETNETLISTIDLISTSIZE, "rcIpPolicyNetNetListIdListSize" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYNETNETLISTIDLIST, "rcIpPolicyNetNetListIdList" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETROWSTATUS, "rcIpPolicyNetRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyAddrListEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 6, 1};

static attribute_t attr_rcIpPolicyAddrListEntry[] = {
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYADDRLISTNAME, "rcIpPolicyAddrListName" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRLISTIDLISTSIZE, "rcIpPolicyAddrListIdListSize" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYADDRLISTIDLIST, "rcIpPolicyAddrListIdList" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRLISTPOLICYIDLISTSIZE, "rcIpPolicyAddrListPolicyIdListSize" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYADDRLISTPOLICYIDLIST, "rcIpPolicyAddrListPolicyIdList" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYADDRLISTROWSTATUS, "rcIpPolicyAddrListRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyRipAnnounceEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 8, 1};

static attribute_t attr_rcIpPolicyRipAnnounceEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYRIPANNOUNCENAME, "rcIpPolicyRipAnnounceName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEENABLE, "rcIpPolicyRipAnnounceEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEEXACTNETLISTID, "rcIpPolicyRipAnnounceExactNetListId" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCERANGENETLISTID, "rcIpPolicyRipAnnounceRangeNetListId" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCERIPGATEWAYLISTID, "rcIpPolicyRipAnnounceRipGatewayListId" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCERIPINTERFACELISTID, "rcIpPolicyRipAnnounceRipInterfaceListId" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTERLISTID, "rcIpPolicyRipAnnounceOspfRouterListId" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEANNOUNCEINTERFACELISTID, "rcIpPolicyRipAnnounceAnnounceInterfaceListId" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEPRECEDENCE, "rcIpPolicyRipAnnouncePrecedence" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEROUTESOURCE, "rcIpPolicyRipAnnounceRouteSource" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEADVERTISENETLISTID, "rcIpPolicyRipAnnounceAdvertiseNetListId" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEACTION, "rcIpPolicyRipAnnounceAction" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEOSPFROUTETYPE, "rcIpPolicyRipAnnounceOspfRouteType" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCERIPMETRIC, "rcIpPolicyRipAnnounceRipMetric" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPANNOUNCEROWSTATUS, "rcIpPolicyRipAnnounceRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyOspfAnnounceEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 10, 1};

static attribute_t attr_rcIpPolicyOspfAnnounceEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYOSPFANNOUNCENAME, "rcIpPolicyOspfAnnounceName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEENABLE, "rcIpPolicyOspfAnnounceEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEEXACTNETLISTID, "rcIpPolicyOspfAnnounceExactNetListId" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCERANGENETLISTID, "rcIpPolicyOspfAnnounceRangeNetListId" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCERIPGATEWAYLISTID, "rcIpPolicyOspfAnnounceRipGatewayListId" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCERIPINTERFACELISTID, "rcIpPolicyOspfAnnounceRipInterfaceListId" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEPRECEDENCE, "rcIpPolicyOspfAnnouncePrecedence" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROUTESOURCE, "rcIpPolicyOspfAnnounceRouteSource" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEADVERTISENETLISTID, "rcIpPolicyOspfAnnounceAdvertiseNetListId" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEACTION, "rcIpPolicyOspfAnnounceAction" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEEXTMETRICTYPE, "rcIpPolicyOspfAnnounceExtMetricType" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEEXTMETRIC, "rcIpPolicyOspfAnnounceExtMetric" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFANNOUNCEROWSTATUS, "rcIpPolicyOspfAnnounceRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyRipAcceptEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 12, 1};

static attribute_t attr_rcIpPolicyRipAcceptEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYRIPACCEPTNAME, "rcIpPolicyRipAcceptName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTENABLE, "rcIpPolicyRipAcceptEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTEXACTNETLISTID, "rcIpPolicyRipAcceptExactNetListId" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTRANGENETLISTID, "rcIpPolicyRipAcceptRangeNetListId" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTRIPGATEWAYLISTID, "rcIpPolicyRipAcceptRipGatewayListId" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTRIPINTERFACELISTID, "rcIpPolicyRipAcceptRipInterfaceListId" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTPRECEDENCE, "rcIpPolicyRipAcceptPrecedence" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTACTION, "rcIpPolicyRipAcceptAction" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTINJECTNETLISTID, "rcIpPolicyRipAcceptInjectNetListId" },
    { 11, G_SNMP_IPADDRESS, RAPID_CITY_RCIPPOLICYRIPACCEPTAPPLYMASK, "rcIpPolicyRipAcceptApplyMask" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYRIPACCEPTROWSTATUS, "rcIpPolicyRipAcceptRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyOspfAcceptEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 14, 1};

static attribute_t attr_rcIpPolicyOspfAcceptEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYOSPFACCEPTNAME, "rcIpPolicyOspfAcceptName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTENABLE, "rcIpPolicyOspfAcceptEnable" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTEXACTNETLISTID, "rcIpPolicyOspfAcceptExactNetListId" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTRANGENETLISTID, "rcIpPolicyOspfAcceptRangeNetListId" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTPRECEDENCE, "rcIpPolicyOspfAcceptPrecedence" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTACTION, "rcIpPolicyOspfAcceptAction" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTINJECTNETLISTID, "rcIpPolicyOspfAcceptInjectNetListId" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTEXTTYPE, "rcIpPolicyOspfAcceptExtType" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYOSPFACCEPTROWSTATUS, "rcIpPolicyOspfAcceptRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpPolicyNetListEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 16, 1};

static attribute_t attr_rcIpPolicyNetListEntry[] = {
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYNETLISTNAME, "rcIpPolicyNetListName" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETLISTIDLISTSIZE, "rcIpPolicyNetListIdListSize" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYNETLISTIDLIST, "rcIpPolicyNetListIdList" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETLISTPOLICYIDLISTSIZE, "rcIpPolicyNetListPolicyIdListSize" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPPOLICYNETLISTPOLICYIDLIST, "rcIpPolicyNetListPolicyIdList" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCIPPOLICYNETLISTROWSTATUS, "rcIpPolicyNetListRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpDvmrp[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 12};

static attribute_t attr_rcIpDvmrp[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPDVMRPENABLE, "rcIpDvmrpEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpConfDvmrpTableEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 12, 10, 1};

static attribute_t attr_rcIpConfDvmrpTableEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDVMRPTABLEENABLE, "rcIpConfDvmrpTableEnable" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPCONFDVMRPTABLEMETRIC, "rcIpConfDvmrpTableMetric" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpUdp[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13};

static attribute_t attr_rcIpUdp[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPROTOCOLTABLESIZE, "rcIpUdpProtocolTableSize" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDTABLESIZE, "rcIpUdpPortFwdTableSize" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDLISTTABLESIZE, "rcIpUdpPortFwdListTableSize" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFTABLESIZE, "rcIpUdpConfBroadcastIntfTableSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpUdpProtocolEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 2, 1};

static attribute_t attr_rcIpUdpProtocolEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPUDPPROTOCOLNAME, "rcIpUdpProtocolName" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPROTOCOLROWSTATUS, "rcIpUdpProtocolRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpUdpPortFwdEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 4, 1};

static attribute_t attr_rcIpUdpPortFwdEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDID, "rcIpUdpPortFwdId" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDFWDLISTIDLISTSIZE, "rcIpUdpPortFwdFwdListIdListSize" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPUDPPORTFWDFWDLISTIDLIST, "rcIpUdpPortFwdFwdListIdList" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPPORTFWDNUMFWDPACKETS, "rcIpUdpPortFwdNumFwdPackets" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPPORTFWDNUMDROPPACKETSTTLEXPIRED, "rcIpUdpPortFwdNumDropPacketsTtlExpired" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPPORTFWDNUMDROPPACKETSDESTUNREACH, "rcIpUdpPortFwdNumDropPacketsDestUnreach" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDROWSTATUS, "rcIpUdpPortFwdRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpUdpPortFwdListEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 6, 1};

static attribute_t attr_rcIpUdpPortFwdListEntry[] = {
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPUDPPORTFWDLISTNAME, "rcIpUdpPortFwdListName" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDLISTFWDIDLISTSIZE, "rcIpUdpPortFwdListFwdIdListSize" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCIPUDPPORTFWDLISTFWDIDLIST, "rcIpUdpPortFwdListFwdIdList" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPPORTFWDLISTROWSTATUS, "rcIpUdpPortFwdListRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpUdpConfBroadcastIntfEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 8, 1};

static attribute_t attr_rcIpUdpConfBroadcastIntfEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFUDPPORTFWDLISTID, "rcIpUdpConfBroadcastIntfUdpPortFwdListId" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFMAXTTL, "rcIpUdpConfBroadcastIntfMaxTtl" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFNUMRXPKTS, "rcIpUdpConfBroadcastIntfNumRxPkts" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFNUMFWDPKTS, "rcIpUdpConfBroadcastIntfNumFwdPkts" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFNUMDROPPKTSMAXTTLEXPIRED, "rcIpUdpConfBroadcastIntfNumDropPktsMaxTtlExpired" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFNUMDROPPKTSDESTUNREACH, "rcIpUdpConfBroadcastIntfNumDropPktsDestUnreach" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFNUMDROPPKTSUNKNOWNPORT, "rcIpUdpConfBroadcastIntfNumDropPktsUnknownPort" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCIPUDPCONFBROADCASTINTFROWSTATUS, "rcIpUdpConfBroadcastIntfRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcArp[] = {1, 3, 6, 1, 4, 1, 2272, 1, 9};

static attribute_t attr_rcArp[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCARPEXTLIFETIME, "rcArpExtLifeTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcArpExtEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 9, 2, 1};

static attribute_t attr_rcArpExtEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCARPEXTENTDOPROXY, "rcArpExtEntDoProxy" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCARPEXTENTDORESP, "rcArpExtEntDoResp" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcRip[] = {1, 3, 6, 1, 4, 1, 2272, 1, 10};

static attribute_t attr_rcRip[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCRIPEXTOPERATION, "rcRipExtOperation" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCRIPEXTUPDATETIME, "rcRipExtUpdateTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcRipExtEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 10, 3, 1};

static attribute_t attr_rcRipExtEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCRIPEXTENTTALK, "rcRipExtEntTalk" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCRIPEXTENTLISTEN, "rcRipExtEntListen" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCRIPEXTENTPOISON, "rcRipExtEntPoison" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcTestEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 11, 1, 1};

static attribute_t attr_rcTestEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCTESTEXTPASSCOUNT, "rcTestExtPassCount" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCTESTEXTFAILCOUNT, "rcTestExtFailCount" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 1, 1};

static attribute_t attr_rcStatEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATFRAMETOOSHORTS, "rcStatFrameTooShorts" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEINUNICASTFRAMES, "rcStatBridgeInUnicastFrames" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEINMULTICASTFRAMES, "rcStatBridgeInMulticastFrames" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEINBROADCASTFRAMES, "rcStatBridgeInBroadcastFrames" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEINDISCARDS, "rcStatBridgeInDiscards" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEOUTUNICASTFRAMES, "rcStatBridgeOutUnicastFrames" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEOUTMULTICASTFRAMES, "rcStatBridgeOutMulticastFrames" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTATBRIDGEOUTBROADCASTFRAMES, "rcStatBridgeOutBroadcastFrames" },
    { 10, G_SNMP_COUNTER32, RAPID_CITY_RCSTATROUTEINUNICASTFRAMES, "rcStatRouteInUnicastFrames" },
    { 11, G_SNMP_COUNTER32, RAPID_CITY_RCSTATROUTEINMULTICASTFRAMES, "rcStatRouteInMulticastFrames" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTATROUTEINDISCARDS, "rcStatRouteInDiscards" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSTATROUTEOUTUNICASTFRAMES, "rcStatRouteOutUnicastFrames" },
    { 14, G_SNMP_COUNTER32, RAPID_CITY_RCSTATROUTEOUTMULTICASTFRAMES, "rcStatRouteOutMulticastFrames" },
    { 15, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGFORWARDTRANSITIONS, "rcStatStgForwardTransitions" },
    { 16, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGINCONFIGBPDUS, "rcStatStgInConfigBpdus" },
    { 17, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGINTCNBPDUS, "rcStatStgInTcnBpdus" },
    { 18, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGINBADBPDUS, "rcStatStgInBadBpdus" },
    { 19, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGOUTCONFIGBPDUS, "rcStatStgOutConfigBpdus" },
    { 20, G_SNMP_COUNTER32, RAPID_CITY_RCSTATSTGOUTTCNBPDUS, "rcStatStgOutTcnBpdus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatGigEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 2, 1};

static attribute_t attr_rcStatGigEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGLINKFAILURES, "rcStatGigLinkFailures" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGPACKETERRORS, "rcStatGigPacketErrors" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGCARRIERERRORS, "rcStatGigCarrierErrors" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGLINKINACTIVEERRORS, "rcStatGigLinkInactiveErrors" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGINFLOWCTRLPKTS, "rcStatGigInFlowCtrlPkts" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATGIGOUTFLOWCTRLPKTS, "rcStatGigOutFlowCtrlPkts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatOspf[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 3};

static attribute_t attr_rcStatOspf[] = {
    { 1, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFBUFFERSALLOCATED, "rcStatOspfBuffersAllocated" },
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFBUFFERSFREED, "rcStatOspfBuffersFreed" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFBUFFERALLOCFAILURES, "rcStatOspfBufferAllocFailures" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFBUFFERFREEFAILURES, "rcStatOspfBufferFreeFailures" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFTXPACKETS, "rcStatOspfTxPackets" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFRXPACKETS, "rcStatOspfRxPackets" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFTXDROPPACKETS, "rcStatOspfTxDropPackets" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFRXDROPPACKETS, "rcStatOspfRxDropPackets" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFRXBADPACKETS, "rcStatOspfRxBadPackets" },
    { 10, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFSPFRUNS, "rcStatOspfSpfRuns" },
    { 11, G_SNMP_TIMETICKS, RAPID_CITY_RCSTATOSPFLASTSPFRUN, "rcStatOspfLastSpfRun" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFLSDBTBLSIZE, "rcStatOspfLsdbTblSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatIgmp[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 4};

static attribute_t attr_rcStatIgmp[] = {
    { 1, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINMSGS, "rcStatIgmpInMsgs" },
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINERRORS, "rcStatIgmpInErrors" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINQUERIES, "rcStatIgmpInQueries" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINREPORTS, "rcStatIgmpInReports" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINLEAVES, "rcStatIgmpInLeaves" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPINVALID, "rcStatIgmpInvalid" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATIGMPOUTMSGS, "rcStatIgmpOutMsgs" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatOspfIfEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 5, 1};

static attribute_t attr_rcStatOspfIfEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFRXHELLOS, "rcStatOspfIfRxHellos" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFRXDBDESCRS, "rcStatOspfIfRxDBDescrs" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFRXLSUPDATES, "rcStatOspfIfRxLSUpdates" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFRXLSREQS, "rcStatOspfIfRxLSReqs" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFRXLSACKS, "rcStatOspfIfRxLSAcks" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFTXHELLOS, "rcStatOspfIfTxHellos" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFTXDBDESCRS, "rcStatOspfIfTxDBDescrs" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFTXLSUPDATES, "rcStatOspfIfTxLSUpdates" },
    { 10, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFTXLSREQS, "rcStatOspfIfTxLSReqs" },
    { 11, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFTXLSACKS, "rcStatOspfIfTxLSAcks" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFVERSIONMISMATCHES, "rcStatOspfIfVersionMismatches" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFAREAMISMATCHES, "rcStatOspfIfAreaMismatches" },
    { 14, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFAUTHTYPEMISMATCHES, "rcStatOspfIfAuthTypeMismatches" },
    { 15, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFAUTHFAILURES, "rcStatOspfIfAuthFailures" },
    { 16, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFNETMASKMISMATCHES, "rcStatOspfIfNetMaskMismatches" },
    { 17, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFHELLOINTERVALMISMATCHES, "rcStatOspfIfHelloIntervalMismatches" },
    { 18, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFDEADINTERVALMISMATCHES, "rcStatOspfIfDeadIntervalMismatches" },
    { 19, G_SNMP_COUNTER32, RAPID_CITY_RCSTATOSPFIFOPTIONMISMATCHES, "rcStatOspfIfOptionMismatches" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatMltIfExtnEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1};

static attribute_t attr_rcStatMltIfExtnEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIFEXTNIFINMULTICASTPKTS, "rcStatMltIfExtnIfInMulticastPkts" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIFEXTNIFINBROADCASTPKTS, "rcStatMltIfExtnIfInBroadcastPkts" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIFEXTNIFOUTMULTICASTPKTS, "rcStatMltIfExtnIfOutMulticastPkts" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIFEXTNIFOUTBROADCASTPKTS, "rcStatMltIfExtnIfOutBroadcastPkts" },
    { 6, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCINOCTETS, "rcStatMltIfExtnIfHCInOctets" },
    { 7, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCINUCASTPKTS, "rcStatMltIfExtnIfHCInUcastPkts" },
    { 8, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCINMULTICASTPKT, "rcStatMltIfExtnIfHCInMulticastPkt" },
    { 9, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCINBROADCASTPKT, "rcStatMltIfExtnIfHCInBroadcastPkt" },
    { 10, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCOUTOCTETS, "rcStatMltIfExtnIfHCOutOctets" },
    { 11, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCOUTUCASTPKTS, "rcStatMltIfExtnIfHCOutUcastPkts" },
    { 12, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCOUTMULTICAST, "rcStatMltIfExtnIfHCOutMulticast" },
    { 13, G_SNMP_COUNTER64, RAPID_CITY_RCSTATMLTIFEXTNIFHCOUTBROADCAST, "rcStatMltIfExtnIfHCOutBroadcast" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatMltEtherEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1};

static attribute_t attr_rcStatMltEtherEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERALIGNMENTERRORS, "rcStatMltEtherAlignmentErrors" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERFCSERRORS, "rcStatMltEtherFCSErrors" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERSINGLECOLLFRAMES, "rcStatMltEtherSingleCollFrames" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERMULTIPLECOLLFRAMES, "rcStatMltEtherMultipleCollFrames" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERSQETESTERROR, "rcStatMltEtherSQETestError" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERDEFERREDTRANSMISS, "rcStatMltEtherDeferredTransmiss" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERLATECOLLISIONS, "rcStatMltEtherLateCollisions" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHEREXCESSIVECOLLIS, "rcStatMltEtherExcessiveCollis" },
    { 10, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERIMACTRANSMITERROR, "rcStatMltEtherIMacTransmitError" },
    { 11, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERCARRIERSENSEERROR, "rcStatMltEtherCarrierSenseError" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERFRAMETOOLONG, "rcStatMltEtherFrameTooLong" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTETHERIMACRECEIVEERROR, "rcStatMltEtherIMacReceiveError" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStatMltIpEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1};

static attribute_t attr_rcStatMltIpEntry[] = {
    { 2, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINRECEIVES, "rcStatMltIpInReceives" },
    { 3, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINHDRERRORS, "rcStatMltIpInHdrErrors" },
    { 4, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINADDRERRORS, "rcStatMltIpInAddrErrors" },
    { 5, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPFORWDATAGRAMS, "rcStatMltIpForwDatagrams" },
    { 6, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINUNKNOWNPROTOS, "rcStatMltIpInUnknownProtos" },
    { 7, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINDISCARDS, "rcStatMltIpInDiscards" },
    { 8, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPINDELIVERS, "rcStatMltIpInDelivers" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPOUTREQUEST, "rcStatMltIpOutRequest" },
    { 10, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPOUTDISCARDS, "rcStatMltIpOutDiscards" },
    { 11, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPOUTNOROUTES, "rcStatMltIpOutNoRoutes" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPREASMREQDS, "rcStatMltIpReasmReqds" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPREASMOKS, "rcStatMltIpReasmOKs" },
    { 14, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPREASMFAILS, "rcStatMltIpReasmFails" },
    { 15, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPFRAGOKS, "rcStatMltIpFragOKs" },
    { 16, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPFRAGFAILS, "rcStatMltIpFragFails" },
    { 17, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPFRAGCREATES, "rcStatMltIpFragCreates" },
    { 18, G_SNMP_COUNTER32, RAPID_CITY_RCSTATMLTIPROUTINGDISCARDS, "rcStatMltIpRoutingDiscards" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStg[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13};

static attribute_t attr_rcStg[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCSTGMAXSTGS, "rcStgMaxStgs" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCSTGNUMSTGS, "rcStgNumStgs" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGUNASSIGNEDPORTS, "rcStgUnassignedPorts" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGNOTALLOWEDPORTS, "rcStgNotAllowedPorts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStgEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 4, 1};

static attribute_t attr_rcStgEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGTAGGEDBPDUADDRESS, "rcStgTaggedBpduAddress" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCSTGTAGGEDBPDUVLANID, "rcStgTaggedBpduVlanId" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGBRIDGEADDRESS, "rcStgBridgeAddress" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCSTGNUMPORTS, "rcStgNumPorts" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPROTOCOLSPECIFICATION, "rcStgProtocolSpecification" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPRIORITY, "rcStgPriority" },
    { 8, G_SNMP_TIMETICKS, RAPID_CITY_RCSTGTIMESINCETOPOLOGYCHANGE, "rcStgTimeSinceTopologyChange" },
    { 9, G_SNMP_COUNTER32, RAPID_CITY_RCSTGTOPCHANGES, "rcStgTopChanges" },
    { 10, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGDESIGNATEDROOT, "rcStgDesignatedRoot" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCSTGROOTCOST, "rcStgRootCost" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCSTGROOTPORT, "rcStgRootPort" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCSTGMAXAGE, "rcStgMaxAge" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCSTGHELLOTIME, "rcStgHelloTime" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCSTGHOLDTIME, "rcStgHoldTime" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCSTGFORWARDDELAY, "rcStgForwardDelay" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCSTGBRIDGEMAXAGE, "rcStgBridgeMaxAge" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCSTGBRIDGEHELLOTIME, "rcStgBridgeHelloTime" },
    { 19, G_SNMP_INTEGER32, RAPID_CITY_RCSTGBRIDGEFORWARDDELAY, "rcStgBridgeForwardDelay" },
    { 20, G_SNMP_INTEGER32, RAPID_CITY_RCSTGENABLESTP, "rcStgEnableStp" },
    { 21, G_SNMP_INTEGER32, RAPID_CITY_RCSTGSTPTRAPENABLE, "rcStgStpTrapEnable" },
    { 22, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGPORTMEMBERS, "rcStgPortMembers" },
    { 23, G_SNMP_INTEGER32, RAPID_CITY_RCSTGROWSTATUS, "rcStgRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcStgPortEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 5, 1};

static attribute_t attr_rcStgPortEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTPRIORITY, "rcStgPortPriority" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTSTATE, "rcStgPortState" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTENABLESTP, "rcStgPortEnableStp" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTFASTSTART, "rcStgPortFastStart" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTPATHCOST, "rcStgPortPathCost" },
    { 8, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGPORTDESIGNATEDROOT, "rcStgPortDesignatedRoot" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTDESIGNATEDCOST, "rcStgPortDesignatedCost" },
    { 10, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGPORTDESIGNATEDBRIDGE, "rcStgPortDesignatedBridge" },
    { 11, G_SNMP_OCTET_STRING, RAPID_CITY_RCSTGPORTDESIGNATEDPORT, "rcStgPortDesignatedPort" },
    { 12, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTFORWARDTRANSITIONS, "rcStgPortForwardTransitions" },
    { 13, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTINCONFIGBPDUS, "rcStgPortInConfigBpdus" },
    { 14, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTINTCNBPDUS, "rcStgPortInTcnBpdus" },
    { 15, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTINBADBPDUS, "rcStgPortInBadBpdus" },
    { 16, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTOUTCONFIGBPDUS, "rcStgPortOutConfigBpdus" },
    { 17, G_SNMP_COUNTER32, RAPID_CITY_RCSTGPORTOUTTCNBPDUS, "rcStgPortOutTcnBpdus" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCSTGPORTROWSTATUS, "rcStgPortRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcBridge[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14};

static attribute_t attr_rcBridge[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFDBTBLSIZE, "rcBridgeFdbTblSize" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGESTATICTBLSIZE, "rcBridgeStaticTblSize" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFILTERTBLSIZE, "rcBridgeFilterTblSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcBridgeFdbEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 1, 1};

static attribute_t attr_rcBridgeFdbEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFDBPORT, "rcBridgeFdbPort" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFDBMONITOR, "rcBridgeFdbMonitor" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFDBPRIORITY, "rcBridgeFdbPriority" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcBridgeStaticEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 3, 1};

static attribute_t attr_rcBridgeStaticEntry[] = {
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGESTATICMONITOR, "rcBridgeStaticMonitor" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGESTATICPRIORITY, "rcBridgeStaticPriority" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGESTATICSTATUS, "rcBridgeStaticStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcBridgeFilterEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 5, 1};

static attribute_t attr_rcBridgeFilterEntry[] = {
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCBRIDGEFILTERNOTALLOWEDFROM, "rcBridgeFilterNotAllowedFrom" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCBRIDGEFILTERSTATUS, "rcBridgeFilterStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcBoot[] = {1, 3, 6, 1, 4, 1, 2272, 1, 15};

static attribute_t attr_rcBoot[] = {
    { 1, G_SNMP_OCTET_STRING, RAPID_CITY_RCBOOTFLASHSWVERSION, "rcBootFlashSwVersion" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCBOOTPCMCIASWVERSION, "rcBootPcmciaSwVersion" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCBOOTLASTBOOTSOURCE, "rcBootLastBootSource" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCBOOTPRIMARY, "rcBootPrimary" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCBOOTSECONDARY, "rcBootSecondary" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCBOOTTERTIARY, "rcBootTertiary" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDevice[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16};

static attribute_t attr_rcDevice[] = {
    { 1, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICELASTBOOTSOURCE, "rcDeviceLastBootSource" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPRIMARYSOURCE, "rcDevicePrimarySource" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICEPRIMARYSOURCEFILENAME, "rcDevicePrimarySourceFileName" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICESECONDARYSOURCE, "rcDeviceSecondarySource" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICESECONDARYSOURCEFILENAME, "rcDeviceSecondarySourceFileName" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICETERTIARYSOURCE, "rcDeviceTertiarySource" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICETERTIARYSOURCEFILENAME, "rcDeviceTertiarySourceFileName" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICECONFIGSOURCE, "rcDeviceConfigSource" },
    { 9, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICECONFIGSOURCEFILENAME, "rcDeviceConfigSourceFileName" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHBYTESUSED, "rcDeviceFlashBytesUsed" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHBYTESFREE, "rcDeviceFlashBytesFree" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIABYTESUSED, "rcDevicePcmciaBytesUsed" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIABYTESFREE, "rcDevicePcmciaBytesFree" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEACTION, "rcDeviceAction" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICERESULT, "rcDeviceResult" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHNUMFILES, "rcDeviceFlashNumFiles" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIANUMFILES, "rcDevicePcmciaNumFiles" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDeviceFlashEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 25, 1};

static attribute_t attr_rcDeviceFlashEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICEFLASHFILENAME, "rcDeviceFlashFileName" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICEFLASHFILEVERSION, "rcDeviceFlashFileVersion" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHFILETYPE, "rcDeviceFlashFileType" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHFILEMODE, "rcDeviceFlashFileMode" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHFILESIZE, "rcDeviceFlashFileSize" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHFILECRC, "rcDeviceFlashFileCrc" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHFILESTATUS, "rcDeviceFlashFileStatus" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEFLASHROWSTATUS, "rcDeviceFlashRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDevicePcmciaEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 26, 1};

static attribute_t attr_rcDevicePcmciaEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICEPCMCIAFILENAME, "rcDevicePcmciaFileName" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCDEVICEPCMCIAFILEVERSION, "rcDevicePcmciaFileVersion" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAFILETYPE, "rcDevicePcmciaFileType" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAFILEMODE, "rcDevicePcmciaFileMode" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAFILESIZE, "rcDevicePcmciaFileSize" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAFILECRC, "rcDevicePcmciaFileCrc" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAFILESTATUS, "rcDevicePcmciaFileStatus" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCDEVICEPCMCIAROWSTATUS, "rcDevicePcmciaRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcMlt[] = {1, 3, 6, 1, 4, 1, 2272, 1, 17};

static attribute_t attr_rcMlt[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCMLTNUMMLTS, "rcMltNumMlts" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCMLTPOTENTIALMEMBERS, "rcMltPotentialMembers" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcMltEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1};

static attribute_t attr_rcMltEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCMLTNAME, "rcMltName" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCMLTPORTMEMBERS, "rcMltPortMembers" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCMLTPORTTYPE, "rcMltPortType" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCMLTNUMVLANIDS, "rcMltNumVlanIds" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCMLTVLANIDS, "rcMltVlanIds" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCMLTROWSTATUS, "rcMltRowStatus" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCMLTENABLE, "rcMltEnable" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCMLTLOADBALANCE, "rcMltLoadBalance" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCMLTDISTRIBUTIONALGORITHM, "rcMltDistributionAlgorithm" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCMLTIFINDEX, "rcMltIfIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcWeb[] = {1, 3, 6, 1, 4, 1, 2272, 1, 18};

static attribute_t attr_rcWeb[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCWEBENABLESERVER, "rcWebEnableServer" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBRWAUSERNAME, "rcWebRWAUserName" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBRWAPASSWORD, "rcWebRWAPassword" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBRWUSERNAME, "rcWebRWUserName" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBRWPASSWORD, "rcWebRWPassword" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBROUSERNAME, "rcWebROUserName" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCWEBROPASSWORD, "rcWebROPassword" },
    { 8, G_SNMP_TIMETICKS, RAPID_CITY_RCWEBLASTCHANGE, "rcWebLastChange" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMHITS, "rcWebNumHits" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMACCESSCHECKS, "rcWebNumAccessChecks" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMACCESSBLOCKS, "rcWebNumAccessBlocks" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMRXERRORS, "rcWebNumRxErrors" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMTXERRORS, "rcWebNumTxErrors" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCWEBNUMSETREQUEST, "rcWebNumSetRequest" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcCli[] = {1, 3, 6, 1, 4, 1, 2272, 1, 19};

static attribute_t attr_rcCli[] = {
    { 1, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWAUSERNAME, "rcCliRWAUserName" },
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWAPASSWORD, "rcCliRWAPassword" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWUSERNAME, "rcCliRWUserName" },
    { 4, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWPASSWORD, "rcCliRWPassword" },
    { 5, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWL3USERNAME, "rcCliRWL3UserName" },
    { 6, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWL3PASSWORD, "rcCliRWL3Password" },
    { 7, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWL2USERNAME, "rcCliRWL2UserName" },
    { 8, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIRWL2PASSWORD, "rcCliRWL2Password" },
    { 9, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIROUSERNAME, "rcCliROUserName" },
    { 10, G_SNMP_OCTET_STRING, RAPID_CITY_RCCLIROPASSWORD, "rcCliROPassword" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCCLIMAXTELNETSESSIONS, "rcCliMaxTelnetSessions" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCCLIMAXRLOGINSESSIONS, "rcCliMaxRloginSessions" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCCLITIMEOUT, "rcCliTimeout" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCCLINUMACCESSVIOLATIONS, "rcCliNumAccessViolations" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcError[] = {1, 3, 6, 1, 4, 1, 2272, 1, 20};

static attribute_t attr_rcError[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCERRORLEVEL, "rcErrorLevel" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCERRORCODE, "rcErrorCode" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCERRORTEXT, "rcErrorText" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCERRORRETURNCODE, "rcErrorReturnCode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCERRORSENDTRAP, "rcErrorSendTrap" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcSyslogGlobal[] = {1, 3, 6, 1, 4, 1, 2272, 1, 22, 1};

static attribute_t attr_rcSyslogGlobal[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGGLOBALENABLE, "rcSyslogGlobalEnable" },
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGGLOBALMAXHOSTS, "rcSyslogGlobalMaxHosts" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGGLOBALOPERSTATE, "rcSyslogGlobalOperState" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcSyslogHostEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 22, 2, 1};

static attribute_t attr_rcSyslogHostEntry[] = {
    { 2, G_SNMP_IPADDRESS, RAPID_CITY_RCSYSLOGHOSTIPADDR, "rcSyslogHostIpAddr" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTUDPPORT, "rcSyslogHostUdpPort" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTFACILITY, "rcSyslogHostFacility" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMODULEID, "rcSyslogHostModuleId" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMODULEID2, "rcSyslogHostModuleId2" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTSEVERITY, "rcSyslogHostSeverity" },
    { 8, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPINFOSEVERITY, "rcSyslogHostMapInfoSeverity" },
    { 9, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPWARNINGSEVERITY, "rcSyslogHostMapWarningSeverity" },
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPERRORSEVERITY, "rcSyslogHostMapErrorSeverity" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPMFGSEVERITY, "rcSyslogHostMapMfgSeverity" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPFATALSEVERITY, "rcSyslogHostMapFatalSeverity" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPTRACEMSG, "rcSyslogHostMapTraceMsg" },
    { 14, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTMAPTRAPMSG, "rcSyslogHostMapTrapMsg" },
    { 15, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTLOGTRACEMSGS, "rcSyslogHostLogTraceMsgs" },
    { 16, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTLOGTRAPMSGS, "rcSyslogHostLogTrapMsgs" },
    { 17, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTENABLE, "rcSyslogHostEnable" },
    { 18, G_SNMP_INTEGER32, RAPID_CITY_RCSYSLOGHOSTROWSTATUS, "rcSyslogHostRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDiag[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23};

static attribute_t attr_rcDiag[] = {
    { 10, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGSAVECONFIG, "rcDiagSaveConfig" },
    { 11, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTTBLSIZE, "rcDiagMirrorByPortTblSize" },
    { 12, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGTBLSIZE, "rcDiagPortConvSteeringTblSize" },
    { 13, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMACCONVSTEERINGTBLSIZE, "rcDiagMacConvSteeringTblSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDiagMirrorByPortEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 1, 1};

static attribute_t attr_rcDiagMirrorByPortEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTMIRROREDPORT, "rcDiagMirrorByPortMirroredPort" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTMIRRORINGPORT, "rcDiagMirrorByPortMirroringPort" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTMODE, "rcDiagMirrorByPortMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTENABLE, "rcDiagMirrorByPortEnable" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMIRRORBYPORTROWSTATUS, "rcDiagMirrorByPortRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDiagPortConvSteeringEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 2, 1};

static attribute_t attr_rcDiagPortConvSteeringEntry[] = {
    { 2, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGPORTONE, "rcDiagPortConvSteeringPortOne" },
    { 3, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGPORTTWO, "rcDiagPortConvSteeringPortTwo" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGMODE, "rcDiagPortConvSteeringMode" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGFORWARDPORT, "rcDiagPortConvSteeringForwardPort" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGENABLE, "rcDiagPortConvSteeringEnable" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGPORTCONVSTEERINGROWSTATUS, "rcDiagPortConvSteeringRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcDiagMacConvSteeringEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 3, 1};

static attribute_t attr_rcDiagMacConvSteeringEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RAPID_CITY_RCDIAGMACCONVSTEERINGSRCMAC, "rcDiagMacConvSteeringSrcMac" },
    { 3, G_SNMP_OCTET_STRING, RAPID_CITY_RCDIAGMACCONVSTEERINGDSTMAC, "rcDiagMacConvSteeringDstMac" },
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMACCONVSTEERINGINPORT, "rcDiagMacConvSteeringInPort" },
    { 5, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMACCONVSTEERINGFORWARDPORT, "rcDiagMacConvSteeringForwardPort" },
    { 6, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMACCONVSTEERINGENABLE, "rcDiagMacConvSteeringEnable" },
    { 7, G_SNMP_INTEGER32, RAPID_CITY_RCDIAGMACCONVSTEERINGROWSTATUS, "rcDiagMacConvSteeringRowStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpx[] = {1, 3, 6, 1, 4, 1, 2272, 1, 24};

static attribute_t attr_rcIpx[] = {
    { 1, G_SNMP_INTEGER32, RAPID_CITY_RCIPXROUTINGENABLE, "rcIpxRoutingEnable" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_rcIpxAddrEntry[] = {1, 3, 6, 1, 4, 1, 2272, 1, 24, 2, 1};

static attribute_t attr_rcIpxAddrEntry[] = {
    { 4, G_SNMP_INTEGER32, RAPID_CITY_RCIPXADDRENTRYSTATUS, "rcIpxAddrEntryStatus" },
    { 0, 0, 0, NULL }
};


rapid_city_rcSystem_t *
rapid_city_new_rcSystem()
{
    rapid_city_rcSystem_t *rcSystem;

    rcSystem = (rapid_city_rcSystem_t *) g_malloc0(sizeof(rapid_city_rcSystem_t) + sizeof(gpointer));
    return rcSystem;
}

static rapid_city_rcSystem_t *
assign_rcSystem(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcSystem_t *rcSystem;
    guint32 idx;
    char *p;

    rcSystem = rapid_city_new_rcSystem();
    if (! rcSystem) {
        return NULL;
    }

    p = (char *) rcSystem + sizeof(rapid_city_rcSystem_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcSystem, sizeof(oid_rcSystem)/sizeof(guint32),
                   attr_rcSystem, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcSystem->rcSysIpAddr = vb->syntax.uc;
            break;
        case 2:
            rcSystem->rcSysNetMask = vb->syntax.uc;
            break;
        case 3:
            rcSystem->rcSysBroadcast = vb->syntax.uc;
            break;
        case 4:
            rcSystem->_rcSysCommReadWriteAllLength = vb->syntax_len;
            rcSystem->rcSysCommReadWriteAll = vb->syntax.uc;
            break;
        case 5:
            rcSystem->_rcSysCommReadWriteLength = vb->syntax_len;
            rcSystem->rcSysCommReadWrite = vb->syntax.uc;
            break;
        case 6:
            rcSystem->_rcSysCommReadOnlyLength = vb->syntax_len;
            rcSystem->rcSysCommReadOnly = vb->syntax.uc;
            break;
        case 7:
            rcSystem->_rcSysVersionLength = vb->syntax_len;
            rcSystem->rcSysVersion = vb->syntax.uc;
            break;
        case 8:
            rcSystem->rcSysAction = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcSystem->rcSysResult = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcSystem->rcSysLastChange = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcSystem->rcSysLastVlanChange = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcSystem->rcSysLastStatisticsReset = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcSystem->rcSysBufferUtil = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcSystem->rcSysBufferUtilPeak = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcSystem->rcSysBufferUtilPeakTime = &(vb->syntax.ui32[0]);
            break;
        case 16:
            rcSystem->rcSysNVRamSize = &(vb->syntax.ui32[0]);
            break;
        case 17:
            rcSystem->rcSysNVRamUsed = &(vb->syntax.ui32[0]);
            break;
        case 18:
            rcSystem->rcSysLastSaveToNVRam = &(vb->syntax.ui32[0]);
            break;
        case 19:
            rcSystem->rcSysLastSaveToStandbyNVRam = &(vb->syntax.ui32[0]);
            break;
        case 20:
            rcSystem->rcSysCpuUtil = &(vb->syntax.ui32[0]);
            break;
        case 21:
            rcSystem->rcSysSwitchFabricUtil = &(vb->syntax.ui32[0]);
            break;
        case 22:
            rcSystem->rcSysRmonMemSize = &(vb->syntax.i32[0]);
            break;
        case 23:
            rcSystem->rcSysRmonEnable = &(vb->syntax.i32[0]);
            break;
        case 24:
            rcSystem->rcSysRmonSaveConfig = &(vb->syntax.i32[0]);
            break;
        case 25:
            rcSystem->rcSysRmonTrapOption = &(vb->syntax.i32[0]);
            break;
        case 26:
            rcSystem->rcSysSupportRouting = &(vb->syntax.i32[0]);
            break;
        case 27:
            rcSystem->rcSysSupportWebServer = &(vb->syntax.i32[0]);
            break;
        case 28:
            rcSystem->rcSysLastIpAddrChange = &(vb->syntax.ui32[0]);
            break;
        case 29:
            rcSystem->_rcSysCommReadWriteLayer3Length = vb->syntax_len;
            rcSystem->rcSysCommReadWriteLayer3 = vb->syntax.uc;
            break;
        case 30:
            rcSystem->_rcSysCommReadWriteLayer2Length = vb->syntax_len;
            rcSystem->rcSysCommReadWriteLayer2 = vb->syntax.uc;
            break;
        case 31:
            rcSystem->rcSysAccessPolicyEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcSystem;
}

void
rapid_city_get_rcSystem(GSnmpSession *s, rapid_city_rcSystem_t **rcSystem, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 0};

    *rcSystem = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcSystem, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcSystem = assign_rcSystem(out);
    }
}

void
rapid_city_set_rcSystem(GSnmpSession *s, rapid_city_rcSystem_t *rcSystem, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 0, 0};

    if (rcSystem->rcSysCommReadWriteAll) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcSystem->rcSysCommReadWriteAll,
                       rcSystem->_rcSysCommReadWriteAllLength);
    }
    if (rcSystem->rcSysCommReadWrite) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcSystem->rcSysCommReadWrite,
                       rcSystem->_rcSysCommReadWriteLength);
    }
    if (rcSystem->rcSysCommReadOnly) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcSystem->rcSysCommReadOnly,
                       rcSystem->_rcSysCommReadOnlyLength);
    }
    if (rcSystem->rcSysAction) {
        base[9] = 8;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysAction,
                       0);
    }
    if (rcSystem->rcSysRmonMemSize) {
        base[9] = 22;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysRmonMemSize,
                       0);
    }
    if (rcSystem->rcSysRmonEnable) {
        base[9] = 23;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysRmonEnable,
                       0);
    }
    if (rcSystem->rcSysRmonSaveConfig) {
        base[9] = 24;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysRmonSaveConfig,
                       0);
    }
    if (rcSystem->rcSysRmonTrapOption) {
        base[9] = 25;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysRmonTrapOption,
                       0);
    }
    if (rcSystem->rcSysCommReadWriteLayer3) {
        base[9] = 29;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcSystem->rcSysCommReadWriteLayer3,
                       rcSystem->_rcSysCommReadWriteLayer3Length);
    }
    if (rcSystem->rcSysCommReadWriteLayer2) {
        base[9] = 30;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcSystem->rcSysCommReadWriteLayer2,
                       rcSystem->_rcSysCommReadWriteLayer2Length);
    }
    if (rcSystem->rcSysAccessPolicyEnable) {
        base[9] = 31;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSystem->rcSysAccessPolicyEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcSystem(rapid_city_rcSystem_t *rcSystem)
{
    GSList *vbl;
    char *p;

    if (rcSystem) {
        p = (char *) rcSystem + sizeof(rapid_city_rcSystem_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcSystem);
    }
}

rapid_city_rcSysTrapRecvEntry_t *
rapid_city_new_rcSysTrapRecvEntry()
{
    rapid_city_rcSysTrapRecvEntry_t *rcSysTrapRecvEntry;

    rcSysTrapRecvEntry = (rapid_city_rcSysTrapRecvEntry_t *) g_malloc0(sizeof(rapid_city_rcSysTrapRecvEntry_t) + sizeof(gpointer));
    return rcSysTrapRecvEntry;
}

static int
unpack_rcSysTrapRecvEntry(GSnmpVarBind *vb, rapid_city_rcSysTrapRecvEntry_t *rcSysTrapRecvEntry)
{
    int i, len, idx = 12;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcSysTrapRecvEntry->rcSysTrapRecvAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcSysTrapRecvEntry(guint32 *base, guchar *rcSysTrapRecvAddress)
{
    int i, len, idx = 12;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcSysTrapRecvAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcSysTrapRecvEntry_t *
assign_rcSysTrapRecvEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcSysTrapRecvEntry_t *rcSysTrapRecvEntry;
    guint32 idx;
    char *p;

    rcSysTrapRecvEntry = rapid_city_new_rcSysTrapRecvEntry();
    if (! rcSysTrapRecvEntry) {
        return NULL;
    }

    p = (char *) rcSysTrapRecvEntry + sizeof(rapid_city_rcSysTrapRecvEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcSysTrapRecvEntry((GSnmpVarBind *) vbl->data, rcSysTrapRecvEntry) < 0) {
        g_warning("illegal rcSysTrapRecvEntry instance identifier");
        g_free(rcSysTrapRecvEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcSysTrapRecvEntry, sizeof(oid_rcSysTrapRecvEntry)/sizeof(guint32),
                   attr_rcSysTrapRecvEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcSysTrapRecvEntry->rcSysTrapRecvVersion = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcSysTrapRecvEntry->_rcSysTrapRecvCommunityLength = vb->syntax_len;
            rcSysTrapRecvEntry->rcSysTrapRecvCommunity = vb->syntax.uc;
            break;
        case 4:
            rcSysTrapRecvEntry->rcSysTrapRecvSrcAddress = vb->syntax.uc;
            break;
        case 5:
            rcSysTrapRecvEntry->rcSysTrapRecvRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcSysTrapRecvEntry;
}

void
rapid_city_get_rcSysTrapRecvTable(GSnmpSession *s, rapid_city_rcSysTrapRecvEntry_t ***rcSysTrapRecvEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 60, 1, 0};

    *rcSysTrapRecvEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcSysTrapRecvEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcSysTrapRecvEntry = (rapid_city_rcSysTrapRecvEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcSysTrapRecvEntry_t *));
        if (! *rcSysTrapRecvEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcSysTrapRecvEntry)[i] = assign_rcSysTrapRecvEntry(row->data);
        }
    }
}

void
rapid_city_get_rcSysTrapRecvEntry(GSnmpSession *s, rapid_city_rcSysTrapRecvEntry_t **rcSysTrapRecvEntry, guchar *rcSysTrapRecvAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSysTrapRecvEntry, sizeof(oid_rcSysTrapRecvEntry));
    len = pack_rcSysTrapRecvEntry(base, rcSysTrapRecvAddress);
    if (len < 0) {
        g_warning("illegal rcSysTrapRecvEntry index values");
        return;
    }

    *rcSysTrapRecvEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcSysTrapRecvEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcSysTrapRecvEntry = assign_rcSysTrapRecvEntry(out);
    }
}

void
rapid_city_set_rcSysTrapRecvEntry(GSnmpSession *s, rapid_city_rcSysTrapRecvEntry_t *rcSysTrapRecvEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSysTrapRecvEntry, sizeof(oid_rcSysTrapRecvEntry));
    len = pack_rcSysTrapRecvEntry(base, rcSysTrapRecvEntry->rcSysTrapRecvAddress);
    if (len < 0) {
        g_warning("illegal rcSysTrapRecvEntry index values");
        return;
    }

    if (rcSysTrapRecvEntry->rcSysTrapRecvVersion) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysTrapRecvEntry->rcSysTrapRecvVersion,
                       0);
    }
    if (rcSysTrapRecvEntry->rcSysTrapRecvCommunity) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcSysTrapRecvEntry->rcSysTrapRecvCommunity,
                       rcSysTrapRecvEntry->_rcSysTrapRecvCommunityLength);
    }
    if (rcSysTrapRecvEntry->rcSysTrapRecvSrcAddress) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcSysTrapRecvEntry->rcSysTrapRecvSrcAddress,
                       4);
    }
    if (rcSysTrapRecvEntry->rcSysTrapRecvRowStatus) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysTrapRecvEntry->rcSysTrapRecvRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcSysTrapRecvEntry(rapid_city_rcSysTrapRecvEntry_t *rcSysTrapRecvEntry)
{
    GSList *vbl;
    char *p;

    if (rcSysTrapRecvEntry) {
        p = (char *) rcSysTrapRecvEntry + sizeof(rapid_city_rcSysTrapRecvEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcSysTrapRecvEntry);
    }
}

void
rapid_city_free_rcSysTrapRecvTable(rapid_city_rcSysTrapRecvEntry_t **rcSysTrapRecvEntry)
{
    int i;

    if (rcSysTrapRecvEntry) {
        for (i = 0; rcSysTrapRecvEntry[i]; i++) {
            rapid_city_free_rcSysTrapRecvEntry(rcSysTrapRecvEntry[i]);
        }
        g_free(rcSysTrapRecvEntry);
    }
}

rapid_city_rcSysAccessPolicyEntry_t *
rapid_city_new_rcSysAccessPolicyEntry()
{
    rapid_city_rcSysAccessPolicyEntry_t *rcSysAccessPolicyEntry;

    rcSysAccessPolicyEntry = (rapid_city_rcSysAccessPolicyEntry_t *) g_malloc0(sizeof(rapid_city_rcSysAccessPolicyEntry_t) + sizeof(gpointer));
    return rcSysAccessPolicyEntry;
}

static int
unpack_rcSysAccessPolicyEntry(GSnmpVarBind *vb, rapid_city_rcSysAccessPolicyEntry_t *rcSysAccessPolicyEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcSysAccessPolicyEntry->rcSysAccessPolicyId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcSysAccessPolicyEntry(guint32 *base, gint32 rcSysAccessPolicyId)
{
    int idx = 12;

    base[idx++] = rcSysAccessPolicyId;
    return idx;
}

static rapid_city_rcSysAccessPolicyEntry_t *
assign_rcSysAccessPolicyEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcSysAccessPolicyEntry_t *rcSysAccessPolicyEntry;
    guint32 idx;
    char *p;

    rcSysAccessPolicyEntry = rapid_city_new_rcSysAccessPolicyEntry();
    if (! rcSysAccessPolicyEntry) {
        return NULL;
    }

    p = (char *) rcSysAccessPolicyEntry + sizeof(rapid_city_rcSysAccessPolicyEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcSysAccessPolicyEntry((GSnmpVarBind *) vbl->data, rcSysAccessPolicyEntry) < 0) {
        g_warning("illegal rcSysAccessPolicyEntry instance identifier");
        g_free(rcSysAccessPolicyEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcSysAccessPolicyEntry, sizeof(oid_rcSysAccessPolicyEntry)/sizeof(guint32),
                   attr_rcSysAccessPolicyEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcSysAccessPolicyEntry->_rcSysAccessPolicyNameLength = vb->syntax_len;
            rcSysAccessPolicyEntry->rcSysAccessPolicyName = vb->syntax.uc;
            break;
        case 3:
            rcSysAccessPolicyEntry->rcSysAccessPolicyPolicyEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcSysAccessPolicyEntry->rcSysAccessPolicyMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcSysAccessPolicyEntry->rcSysAccessPolicyService = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcSysAccessPolicyEntry->rcSysAccessPolicyPrecedence = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcSysAccessPolicyEntry->rcSysAccessPolicyNetAddr = vb->syntax.uc;
            break;
        case 8:
            rcSysAccessPolicyEntry->rcSysAccessPolicyNetMask = vb->syntax.uc;
            break;
        case 9:
            rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostAddr = vb->syntax.uc;
            break;
        case 10:
            rcSysAccessPolicyEntry->_rcSysAccessPolicyTrustedHostUserNameLength = vb->syntax_len;
            rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostUserName = vb->syntax.uc;
            break;
        case 11:
            rcSysAccessPolicyEntry->rcSysAccessPolicyAccessLevel = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcSysAccessPolicyEntry->rcSysAccessPolicyLog = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcSysAccessPolicyEntry->rcSysAccessPolicyUsage = &(vb->syntax.ui32[0]);
            break;
        case 14:
            rcSysAccessPolicyEntry->rcSysAccessPolicyRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcSysAccessPolicyEntry;
}

void
rapid_city_get_rcSysAccessPolicyTable(GSnmpSession *s, rapid_city_rcSysAccessPolicyEntry_t ***rcSysAccessPolicyEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 1, 61, 1, 0};

    *rcSysAccessPolicyEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcSysAccessPolicyEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcSysAccessPolicyEntry = (rapid_city_rcSysAccessPolicyEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcSysAccessPolicyEntry_t *));
        if (! *rcSysAccessPolicyEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcSysAccessPolicyEntry)[i] = assign_rcSysAccessPolicyEntry(row->data);
        }
    }
}

void
rapid_city_get_rcSysAccessPolicyEntry(GSnmpSession *s, rapid_city_rcSysAccessPolicyEntry_t **rcSysAccessPolicyEntry, gint32 rcSysAccessPolicyId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSysAccessPolicyEntry, sizeof(oid_rcSysAccessPolicyEntry));
    len = pack_rcSysAccessPolicyEntry(base, rcSysAccessPolicyId);
    if (len < 0) {
        g_warning("illegal rcSysAccessPolicyEntry index values");
        return;
    }

    *rcSysAccessPolicyEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcSysAccessPolicyEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcSysAccessPolicyEntry = assign_rcSysAccessPolicyEntry(out);
    }
}

void
rapid_city_set_rcSysAccessPolicyEntry(GSnmpSession *s, rapid_city_rcSysAccessPolicyEntry_t *rcSysAccessPolicyEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSysAccessPolicyEntry, sizeof(oid_rcSysAccessPolicyEntry));
    len = pack_rcSysAccessPolicyEntry(base, rcSysAccessPolicyEntry->rcSysAccessPolicyId);
    if (len < 0) {
        g_warning("illegal rcSysAccessPolicyEntry index values");
        return;
    }

    if (rcSysAccessPolicyEntry->rcSysAccessPolicyName) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyName,
                       rcSysAccessPolicyEntry->_rcSysAccessPolicyNameLength);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyPolicyEnable) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyPolicyEnable,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyMode) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyMode,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyService) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyService,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyPrecedence) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyPrecedence,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyNetAddr) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyNetAddr,
                       4);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyNetMask) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyNetMask,
                       4);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostAddr) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostAddr,
                       4);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostUserName) {
        base[11] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyTrustedHostUserName,
                       rcSysAccessPolicyEntry->_rcSysAccessPolicyTrustedHostUserNameLength);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyAccessLevel) {
        base[11] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyAccessLevel,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyLog) {
        base[11] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyLog,
                       0);
    }
    if (rcSysAccessPolicyEntry->rcSysAccessPolicyRowStatus) {
        base[11] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSysAccessPolicyEntry->rcSysAccessPolicyRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcSysAccessPolicyEntry(rapid_city_rcSysAccessPolicyEntry_t *rcSysAccessPolicyEntry)
{
    GSList *vbl;
    char *p;

    if (rcSysAccessPolicyEntry) {
        p = (char *) rcSysAccessPolicyEntry + sizeof(rapid_city_rcSysAccessPolicyEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcSysAccessPolicyEntry);
    }
}

void
rapid_city_free_rcSysAccessPolicyTable(rapid_city_rcSysAccessPolicyEntry_t **rcSysAccessPolicyEntry)
{
    int i;

    if (rcSysAccessPolicyEntry) {
        for (i = 0; rcSysAccessPolicyEntry[i]; i++) {
            rapid_city_free_rcSysAccessPolicyEntry(rcSysAccessPolicyEntry[i]);
        }
        g_free(rcSysAccessPolicyEntry);
    }
}

rapid_city_rcTftp_t *
rapid_city_new_rcTftp()
{
    rapid_city_rcTftp_t *rcTftp;

    rcTftp = (rapid_city_rcTftp_t *) g_malloc0(sizeof(rapid_city_rcTftp_t) + sizeof(gpointer));
    return rcTftp;
}

static rapid_city_rcTftp_t *
assign_rcTftp(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcTftp_t *rcTftp;
    guint32 idx;
    char *p;

    rcTftp = rapid_city_new_rcTftp();
    if (! rcTftp) {
        return NULL;
    }

    p = (char *) rcTftp + sizeof(rapid_city_rcTftp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcTftp, sizeof(oid_rcTftp)/sizeof(guint32),
                   attr_rcTftp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcTftp->rcTftpHost = vb->syntax.uc;
            break;
        case 2:
            rcTftp->_rcTftpFileLength = vb->syntax_len;
            rcTftp->rcTftpFile = vb->syntax.uc;
            break;
        case 3:
            rcTftp->rcTftpAction = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcTftp->rcTftpResult = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcTftp;
}

void
rapid_city_get_rcTftp(GSnmpSession *s, rapid_city_rcTftp_t **rcTftp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 2, 0};

    *rcTftp = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcTftp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcTftp = assign_rcTftp(out);
    }
}

void
rapid_city_set_rcTftp(GSnmpSession *s, rapid_city_rcTftp_t *rcTftp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 2, 0, 0};

    if (rcTftp->rcTftpHost) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_IPADDRESS,
                       rcTftp->rcTftpHost,
                       4);
    }
    if (rcTftp->rcTftpFile) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcTftp->rcTftpFile,
                       rcTftp->_rcTftpFileLength);
    }
    if (rcTftp->rcTftpAction) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcTftp->rcTftpAction,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcTftp(rapid_city_rcTftp_t *rcTftp)
{
    GSList *vbl;
    char *p;

    if (rcTftp) {
        p = (char *) rcTftp + sizeof(rapid_city_rcTftp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcTftp);
    }
}

rapid_city_rcVlan_t *
rapid_city_new_rcVlan()
{
    rapid_city_rcVlan_t *rcVlan;

    rcVlan = (rapid_city_rcVlan_t *) g_malloc0(sizeof(rapid_city_rcVlan_t) + sizeof(gpointer));
    return rcVlan;
}

static rapid_city_rcVlan_t *
assign_rcVlan(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlan_t *rcVlan;
    guint32 idx;
    char *p;

    rcVlan = rapid_city_new_rcVlan();
    if (! rcVlan) {
        return NULL;
    }

    p = (char *) rcVlan + sizeof(rapid_city_rcVlan_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlan, sizeof(oid_rcVlan)/sizeof(guint32),
                   attr_rcVlan, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcVlan->rcVlanNumVlans = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcVlan->rcVlanIgmpSnoopNumGroups = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlan;
}

void
rapid_city_get_rcVlan(GSnmpSession *s, rapid_city_rcVlan_t **rcVlan, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 0};

    *rcVlan = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcVlan, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlan = assign_rcVlan(out);
    }
}

void
rapid_city_free_rcVlan(rapid_city_rcVlan_t *rcVlan)
{
    GSList *vbl;
    char *p;

    if (rcVlan) {
        p = (char *) rcVlan + sizeof(rapid_city_rcVlan_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlan);
    }
}

rapid_city_rcVlanEntry_t *
rapid_city_new_rcVlanEntry()
{
    rapid_city_rcVlanEntry_t *rcVlanEntry;

    rcVlanEntry = (rapid_city_rcVlanEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanEntry_t) + sizeof(gpointer));
    return rcVlanEntry;
}

static int
unpack_rcVlanEntry(GSnmpVarBind *vb, rapid_city_rcVlanEntry_t *rcVlanEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanEntry->rcVlanId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanEntry(guint32 *base, gint32 rcVlanId)
{
    int idx = 12;

    base[idx++] = rcVlanId;
    return idx;
}

static rapid_city_rcVlanEntry_t *
assign_rcVlanEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanEntry_t *rcVlanEntry;
    guint32 idx;
    char *p;

    rcVlanEntry = rapid_city_new_rcVlanEntry();
    if (! rcVlanEntry) {
        return NULL;
    }

    p = (char *) rcVlanEntry + sizeof(rapid_city_rcVlanEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanEntry((GSnmpVarBind *) vbl->data, rcVlanEntry) < 0) {
        g_warning("illegal rcVlanEntry instance identifier");
        g_free(rcVlanEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanEntry, sizeof(oid_rcVlanEntry)/sizeof(guint32),
                   attr_rcVlanEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcVlanEntry->_rcVlanNameLength = vb->syntax_len;
            rcVlanEntry->rcVlanName = vb->syntax.uc;
            break;
        case 3:
            rcVlanEntry->rcVlanColor = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcVlanEntry->rcVlanHighPriority = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcVlanEntry->rcVlanRoutingEnable = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcVlanEntry->rcVlanIfIndex = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcVlanEntry->rcVlanAction = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcVlanEntry->rcVlanResult = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcVlanEntry->rcVlanStgId = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcVlanEntry->rcVlanType = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcVlanEntry->rcVlanPortMembers = vb->syntax.uc;
            break;
        case 12:
            rcVlanEntry->rcVlanActiveMembers = vb->syntax.uc;
            break;
        case 13:
            rcVlanEntry->rcVlanStaticMembers = vb->syntax.uc;
            break;
        case 14:
            rcVlanEntry->rcVlanNotAllowToJoin = vb->syntax.uc;
            break;
        case 15:
            rcVlanEntry->rcVlanProtocolId = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcVlanEntry->rcVlanSubnetAddr = vb->syntax.uc;
            break;
        case 17:
            rcVlanEntry->rcVlanSubnetMask = vb->syntax.uc;
            break;
        case 18:
            rcVlanEntry->rcVlanAgingTime = &(vb->syntax.i32[0]);
            break;
        case 19:
            rcVlanEntry->rcVlanMacAddress = vb->syntax.uc;
            break;
        case 20:
            rcVlanEntry->rcVlanRowStatus = &(vb->syntax.i32[0]);
            break;
        case 21:
            rcVlanEntry->rcVlanIgmpSnoopEnable = &(vb->syntax.i32[0]);
            break;
        case 22:
            rcVlanEntry->rcVlanIgmpSnoopReportProxyEnable = &(vb->syntax.i32[0]);
            break;
        case 23:
            rcVlanEntry->rcVlanIgmpSnoopRobustness = &(vb->syntax.i32[0]);
            break;
        case 24:
            rcVlanEntry->rcVlanIgmpSnoopQueryInterval = &(vb->syntax.i32[0]);
            break;
        case 25:
            rcVlanEntry->rcVlanIgmpSnoopMRouterPorts = vb->syntax.uc;
            break;
        case 26:
            rcVlanEntry->rcVlanUserDefinedPid = &(vb->syntax.i32[0]);
            break;
        case 27:
            rcVlanEntry->rcVlanIgmpSnoopActiveMRouterPorts = vb->syntax.uc;
            break;
        case 28:
            rcVlanEntry->rcVlanProtocolIds = &(vb->syntax.i32[0]);
            break;
        case 29:
            rcVlanEntry->rcVlanIgmpSnoopActiveQuerier = vb->syntax.uc;
            break;
        case 30:
            rcVlanEntry->rcVlanIgmpSnoopMRouterExpiration = &(vb->syntax.i32[0]);
            break;
        case 31:
            rcVlanEntry->rcVlanIgmpSnoopQuerierPort = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanEntry;
}

void
rapid_city_get_rcVlanTable(GSnmpSession *s, rapid_city_rcVlanEntry_t ***rcVlanEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 0};

    *rcVlanEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanEntry = (rapid_city_rcVlanEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanEntry_t *));
        if (! *rcVlanEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanEntry)[i] = assign_rcVlanEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanEntry(GSnmpSession *s, rapid_city_rcVlanEntry_t **rcVlanEntry, gint32 rcVlanId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanEntry, sizeof(oid_rcVlanEntry));
    len = pack_rcVlanEntry(base, rcVlanId);
    if (len < 0) {
        g_warning("illegal rcVlanEntry index values");
        return;
    }

    *rcVlanEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanEntry = assign_rcVlanEntry(out);
    }
}

void
rapid_city_set_rcVlanEntry(GSnmpSession *s, rapid_city_rcVlanEntry_t *rcVlanEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanEntry, sizeof(oid_rcVlanEntry));
    len = pack_rcVlanEntry(base, rcVlanEntry->rcVlanId);
    if (len < 0) {
        g_warning("illegal rcVlanEntry index values");
        return;
    }

    if (rcVlanEntry->rcVlanName) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanEntry->rcVlanName,
                       rcVlanEntry->_rcVlanNameLength);
    }
    if (rcVlanEntry->rcVlanColor) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanColor,
                       0);
    }
    if (rcVlanEntry->rcVlanHighPriority) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanHighPriority,
                       0);
    }
    if (rcVlanEntry->rcVlanRoutingEnable) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanRoutingEnable,
                       0);
    }
    if (rcVlanEntry->rcVlanAction) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanAction,
                       0);
    }
    if (rcVlanEntry->rcVlanStgId) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanStgId,
                       0);
    }
    if (rcVlanEntry->rcVlanType) {
        base[11] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanType,
                       0);
    }
    if (rcVlanEntry->rcVlanPortMembers) {
        base[11] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanEntry->rcVlanPortMembers,
                       32);
    }
    if (rcVlanEntry->rcVlanStaticMembers) {
        base[11] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanEntry->rcVlanStaticMembers,
                       32);
    }
    if (rcVlanEntry->rcVlanNotAllowToJoin) {
        base[11] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanEntry->rcVlanNotAllowToJoin,
                       32);
    }
    if (rcVlanEntry->rcVlanProtocolId) {
        base[11] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanProtocolId,
                       0);
    }
    if (rcVlanEntry->rcVlanSubnetAddr) {
        base[11] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcVlanEntry->rcVlanSubnetAddr,
                       4);
    }
    if (rcVlanEntry->rcVlanSubnetMask) {
        base[11] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcVlanEntry->rcVlanSubnetMask,
                       4);
    }
    if (rcVlanEntry->rcVlanAgingTime) {
        base[11] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanAgingTime,
                       0);
    }
    if (rcVlanEntry->rcVlanRowStatus) {
        base[11] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanRowStatus,
                       0);
    }
    if (rcVlanEntry->rcVlanIgmpSnoopEnable) {
        base[11] = 21;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanIgmpSnoopEnable,
                       0);
    }
    if (rcVlanEntry->rcVlanIgmpSnoopReportProxyEnable) {
        base[11] = 22;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanIgmpSnoopReportProxyEnable,
                       0);
    }
    if (rcVlanEntry->rcVlanIgmpSnoopRobustness) {
        base[11] = 23;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanIgmpSnoopRobustness,
                       0);
    }
    if (rcVlanEntry->rcVlanIgmpSnoopQueryInterval) {
        base[11] = 24;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanIgmpSnoopQueryInterval,
                       0);
    }
    if (rcVlanEntry->rcVlanIgmpSnoopMRouterPorts) {
        base[11] = 25;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanEntry->rcVlanIgmpSnoopMRouterPorts,
                       32);
    }
    if (rcVlanEntry->rcVlanUserDefinedPid) {
        base[11] = 26;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanUserDefinedPid,
                       0);
    }
    if (rcVlanEntry->rcVlanProtocolIds) {
        base[11] = 28;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanEntry->rcVlanProtocolIds,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanEntry(rapid_city_rcVlanEntry_t *rcVlanEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanEntry) {
        p = (char *) rcVlanEntry + sizeof(rapid_city_rcVlanEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanEntry);
    }
}

void
rapid_city_free_rcVlanTable(rapid_city_rcVlanEntry_t **rcVlanEntry)
{
    int i;

    if (rcVlanEntry) {
        for (i = 0; rcVlanEntry[i]; i++) {
            rapid_city_free_rcVlanEntry(rcVlanEntry[i]);
        }
        g_free(rcVlanEntry);
    }
}

rapid_city_rcVlanPortEntry_t *
rapid_city_new_rcVlanPortEntry()
{
    rapid_city_rcVlanPortEntry_t *rcVlanPortEntry;

    rcVlanPortEntry = (rapid_city_rcVlanPortEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanPortEntry_t) + sizeof(gpointer));
    return rcVlanPortEntry;
}

static int
unpack_rcVlanPortEntry(GSnmpVarBind *vb, rapid_city_rcVlanPortEntry_t *rcVlanPortEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanPortEntry->rcVlanPortIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanPortEntry(guint32 *base, gint32 rcVlanPortIndex)
{
    int idx = 12;

    base[idx++] = rcVlanPortIndex;
    return idx;
}

static rapid_city_rcVlanPortEntry_t *
assign_rcVlanPortEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanPortEntry_t *rcVlanPortEntry;
    guint32 idx;
    char *p;

    rcVlanPortEntry = rapid_city_new_rcVlanPortEntry();
    if (! rcVlanPortEntry) {
        return NULL;
    }

    p = (char *) rcVlanPortEntry + sizeof(rapid_city_rcVlanPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanPortEntry((GSnmpVarBind *) vbl->data, rcVlanPortEntry) < 0) {
        g_warning("illegal rcVlanPortEntry instance identifier");
        g_free(rcVlanPortEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanPortEntry, sizeof(oid_rcVlanPortEntry)/sizeof(guint32),
                   attr_rcVlanPortEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcVlanPortEntry->rcVlanPortNumVlanIds = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcVlanPortEntry->rcVlanPortVlanIds = vb->syntax.uc;
            break;
        case 4:
            rcVlanPortEntry->rcVlanPortType = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcVlanPortEntry->rcVlanPortDiscardTaggedFrames = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcVlanPortEntry->rcVlanPortDiscardUntaggedFrames = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcVlanPortEntry->rcVlanPortDefaultVlanId = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcVlanPortEntry->rcVlanPortPerformTagging = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanPortEntry;
}

void
rapid_city_get_rcVlanPortTable(GSnmpSession *s, rapid_city_rcVlanPortEntry_t ***rcVlanPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 0};

    *rcVlanPortEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanPortEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanPortEntry = (rapid_city_rcVlanPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanPortEntry_t *));
        if (! *rcVlanPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanPortEntry)[i] = assign_rcVlanPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanPortEntry(GSnmpSession *s, rapid_city_rcVlanPortEntry_t **rcVlanPortEntry, gint32 rcVlanPortIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanPortEntry, sizeof(oid_rcVlanPortEntry));
    len = pack_rcVlanPortEntry(base, rcVlanPortIndex);
    if (len < 0) {
        g_warning("illegal rcVlanPortEntry index values");
        return;
    }

    *rcVlanPortEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanPortEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanPortEntry = assign_rcVlanPortEntry(out);
    }
}

void
rapid_city_set_rcVlanPortEntry(GSnmpSession *s, rapid_city_rcVlanPortEntry_t *rcVlanPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanPortEntry, sizeof(oid_rcVlanPortEntry));
    len = pack_rcVlanPortEntry(base, rcVlanPortEntry->rcVlanPortIndex);
    if (len < 0) {
        g_warning("illegal rcVlanPortEntry index values");
        return;
    }

    if (rcVlanPortEntry->rcVlanPortVlanIds) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanPortEntry->rcVlanPortVlanIds,
                       250);
    }
    if (rcVlanPortEntry->rcVlanPortType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanPortEntry->rcVlanPortType,
                       0);
    }
    if (rcVlanPortEntry->rcVlanPortDiscardTaggedFrames) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanPortEntry->rcVlanPortDiscardTaggedFrames,
                       0);
    }
    if (rcVlanPortEntry->rcVlanPortDiscardUntaggedFrames) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanPortEntry->rcVlanPortDiscardUntaggedFrames,
                       0);
    }
    if (rcVlanPortEntry->rcVlanPortDefaultVlanId) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanPortEntry->rcVlanPortDefaultVlanId,
                       0);
    }
    if (rcVlanPortEntry->rcVlanPortPerformTagging) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanPortEntry->rcVlanPortPerformTagging,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanPortEntry(rapid_city_rcVlanPortEntry_t *rcVlanPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanPortEntry) {
        p = (char *) rcVlanPortEntry + sizeof(rapid_city_rcVlanPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanPortEntry);
    }
}

void
rapid_city_free_rcVlanPortTable(rapid_city_rcVlanPortEntry_t **rcVlanPortEntry)
{
    int i;

    if (rcVlanPortEntry) {
        for (i = 0; rcVlanPortEntry[i]; i++) {
            rapid_city_free_rcVlanPortEntry(rcVlanPortEntry[i]);
        }
        g_free(rcVlanPortEntry);
    }
}

rapid_city_rcVlanMacEntry_t *
rapid_city_new_rcVlanMacEntry()
{
    rapid_city_rcVlanMacEntry_t *rcVlanMacEntry;

    rcVlanMacEntry = (rapid_city_rcVlanMacEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanMacEntry_t) + sizeof(gpointer));
    return rcVlanMacEntry;
}

static int
unpack_rcVlanMacEntry(GSnmpVarBind *vb, rapid_city_rcVlanMacEntry_t *rcVlanMacEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanMacEntry->rcVlanMacVlanId = vb->id[idx++];
    len = 6;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanMacEntry->rcVlanMacAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanMacEntry(guint32 *base, gint32 rcVlanMacVlanId, guchar *rcVlanMacAddr)
{
    int i, len, idx = 12;

    base[idx++] = rcVlanMacVlanId;
    len = 6;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanMacAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcVlanMacEntry_t *
assign_rcVlanMacEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanMacEntry_t *rcVlanMacEntry;
    guint32 idx;
    char *p;

    rcVlanMacEntry = rapid_city_new_rcVlanMacEntry();
    if (! rcVlanMacEntry) {
        return NULL;
    }

    p = (char *) rcVlanMacEntry + sizeof(rapid_city_rcVlanMacEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanMacEntry((GSnmpVarBind *) vbl->data, rcVlanMacEntry) < 0) {
        g_warning("illegal rcVlanMacEntry instance identifier");
        g_free(rcVlanMacEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanMacEntry, sizeof(oid_rcVlanMacEntry)/sizeof(guint32),
                   attr_rcVlanMacEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcVlanMacEntry->rcVlanMacRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanMacEntry;
}

void
rapid_city_get_rcVlanMacTable(GSnmpSession *s, rapid_city_rcVlanMacEntry_t ***rcVlanMacEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1, 0};

    *rcVlanMacEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanMacEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanMacEntry = (rapid_city_rcVlanMacEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanMacEntry_t *));
        if (! *rcVlanMacEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanMacEntry)[i] = assign_rcVlanMacEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanMacEntry(GSnmpSession *s, rapid_city_rcVlanMacEntry_t **rcVlanMacEntry, gint32 rcVlanMacVlanId, guchar *rcVlanMacAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanMacEntry, sizeof(oid_rcVlanMacEntry));
    len = pack_rcVlanMacEntry(base, rcVlanMacVlanId, rcVlanMacAddr);
    if (len < 0) {
        g_warning("illegal rcVlanMacEntry index values");
        return;
    }

    *rcVlanMacEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanMacEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanMacEntry = assign_rcVlanMacEntry(out);
    }
}

void
rapid_city_set_rcVlanMacEntry(GSnmpSession *s, rapid_city_rcVlanMacEntry_t *rcVlanMacEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanMacEntry, sizeof(oid_rcVlanMacEntry));
    len = pack_rcVlanMacEntry(base, rcVlanMacEntry->rcVlanMacVlanId, rcVlanMacEntry->rcVlanMacAddr);
    if (len < 0) {
        g_warning("illegal rcVlanMacEntry index values");
        return;
    }

    if (rcVlanMacEntry->rcVlanMacRowStatus) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanMacEntry->rcVlanMacRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanMacEntry(rapid_city_rcVlanMacEntry_t *rcVlanMacEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanMacEntry) {
        p = (char *) rcVlanMacEntry + sizeof(rapid_city_rcVlanMacEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanMacEntry);
    }
}

void
rapid_city_free_rcVlanMacTable(rapid_city_rcVlanMacEntry_t **rcVlanMacEntry)
{
    int i;

    if (rcVlanMacEntry) {
        for (i = 0; rcVlanMacEntry[i]; i++) {
            rapid_city_free_rcVlanMacEntry(rcVlanMacEntry[i]);
        }
        g_free(rcVlanMacEntry);
    }
}

rapid_city_rcVlanIgmpSnoopEntry_t *
rapid_city_new_rcVlanIgmpSnoopEntry()
{
    rapid_city_rcVlanIgmpSnoopEntry_t *rcVlanIgmpSnoopEntry;

    rcVlanIgmpSnoopEntry = (rapid_city_rcVlanIgmpSnoopEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanIgmpSnoopEntry_t) + sizeof(gpointer));
    return rcVlanIgmpSnoopEntry;
}

static int
unpack_rcVlanIgmpSnoopEntry(GSnmpVarBind *vb, rapid_city_rcVlanIgmpSnoopEntry_t *rcVlanIgmpSnoopEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopVlanId = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopMember[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanIgmpSnoopEntry(guint32 *base, gint32 rcVlanIgmpSnoopVlanId, guchar *rcVlanIgmpSnoopIpAddress, gint32 rcVlanIgmpSnoopIfIndex, guchar *rcVlanIgmpSnoopMember)
{
    int i, len, idx = 12;

    base[idx++] = rcVlanIgmpSnoopVlanId;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcVlanIgmpSnoopIfIndex;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopMember[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcVlanIgmpSnoopEntry_t *
assign_rcVlanIgmpSnoopEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanIgmpSnoopEntry_t *rcVlanIgmpSnoopEntry;
    guint32 idx;
    char *p;

    rcVlanIgmpSnoopEntry = rapid_city_new_rcVlanIgmpSnoopEntry();
    if (! rcVlanIgmpSnoopEntry) {
        return NULL;
    }

    p = (char *) rcVlanIgmpSnoopEntry + sizeof(rapid_city_rcVlanIgmpSnoopEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanIgmpSnoopEntry((GSnmpVarBind *) vbl->data, rcVlanIgmpSnoopEntry) < 0) {
        g_warning("illegal rcVlanIgmpSnoopEntry instance identifier");
        g_free(rcVlanIgmpSnoopEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanIgmpSnoopEntry, sizeof(oid_rcVlanIgmpSnoopEntry)/sizeof(guint32),
                   attr_rcVlanIgmpSnoopEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopExpiration = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcVlanIgmpSnoopEntry->rcVlanIgmpSnoopType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanIgmpSnoopEntry;
}

void
rapid_city_get_rcVlanIgmpSnoopTable(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopEntry_t ***rcVlanIgmpSnoopEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 0};

    *rcVlanIgmpSnoopEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanIgmpSnoopEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanIgmpSnoopEntry = (rapid_city_rcVlanIgmpSnoopEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanIgmpSnoopEntry_t *));
        if (! *rcVlanIgmpSnoopEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanIgmpSnoopEntry)[i] = assign_rcVlanIgmpSnoopEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanIgmpSnoopEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopEntry_t **rcVlanIgmpSnoopEntry, gint32 rcVlanIgmpSnoopVlanId, guchar *rcVlanIgmpSnoopIpAddress, gint32 rcVlanIgmpSnoopIfIndex, guchar *rcVlanIgmpSnoopMember, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopEntry, sizeof(oid_rcVlanIgmpSnoopEntry));
    len = pack_rcVlanIgmpSnoopEntry(base, rcVlanIgmpSnoopVlanId, rcVlanIgmpSnoopIpAddress, rcVlanIgmpSnoopIfIndex, rcVlanIgmpSnoopMember);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopEntry index values");
        return;
    }

    *rcVlanIgmpSnoopEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanIgmpSnoopEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanIgmpSnoopEntry = assign_rcVlanIgmpSnoopEntry(out);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopEntry(rapid_city_rcVlanIgmpSnoopEntry_t *rcVlanIgmpSnoopEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanIgmpSnoopEntry) {
        p = (char *) rcVlanIgmpSnoopEntry + sizeof(rapid_city_rcVlanIgmpSnoopEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanIgmpSnoopEntry);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopTable(rapid_city_rcVlanIgmpSnoopEntry_t **rcVlanIgmpSnoopEntry)
{
    int i;

    if (rcVlanIgmpSnoopEntry) {
        for (i = 0; rcVlanIgmpSnoopEntry[i]; i++) {
            rapid_city_free_rcVlanIgmpSnoopEntry(rcVlanIgmpSnoopEntry[i]);
        }
        g_free(rcVlanIgmpSnoopEntry);
    }
}

rapid_city_rcVlanIgmpSnoopStaticEntry_t *
rapid_city_new_rcVlanIgmpSnoopStaticEntry()
{
    rapid_city_rcVlanIgmpSnoopStaticEntry_t *rcVlanIgmpSnoopStaticEntry;

    rcVlanIgmpSnoopStaticEntry = (rapid_city_rcVlanIgmpSnoopStaticEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanIgmpSnoopStaticEntry_t) + sizeof(gpointer));
    return rcVlanIgmpSnoopStaticEntry;
}

static int
unpack_rcVlanIgmpSnoopStaticEntry(GSnmpVarBind *vb, rapid_city_rcVlanIgmpSnoopStaticEntry_t *rcVlanIgmpSnoopStaticEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticVlanId = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanIgmpSnoopStaticEntry(guint32 *base, gint32 rcVlanIgmpSnoopStaticVlanId, guchar *rcVlanIgmpSnoopStaticIpAddress)
{
    int i, len, idx = 12;

    base[idx++] = rcVlanIgmpSnoopStaticVlanId;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopStaticIpAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcVlanIgmpSnoopStaticEntry_t *
assign_rcVlanIgmpSnoopStaticEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanIgmpSnoopStaticEntry_t *rcVlanIgmpSnoopStaticEntry;
    guint32 idx;
    char *p;

    rcVlanIgmpSnoopStaticEntry = rapid_city_new_rcVlanIgmpSnoopStaticEntry();
    if (! rcVlanIgmpSnoopStaticEntry) {
        return NULL;
    }

    p = (char *) rcVlanIgmpSnoopStaticEntry + sizeof(rapid_city_rcVlanIgmpSnoopStaticEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanIgmpSnoopStaticEntry((GSnmpVarBind *) vbl->data, rcVlanIgmpSnoopStaticEntry) < 0) {
        g_warning("illegal rcVlanIgmpSnoopStaticEntry instance identifier");
        g_free(rcVlanIgmpSnoopStaticEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanIgmpSnoopStaticEntry, sizeof(oid_rcVlanIgmpSnoopStaticEntry)/sizeof(guint32),
                   attr_rcVlanIgmpSnoopStaticEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticMemberPorts = vb->syntax.uc;
            break;
        case 4:
            rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticRowStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticNotAllowedToJoin = vb->syntax.uc;
            break;
        };
    }

    return rcVlanIgmpSnoopStaticEntry;
}

void
rapid_city_get_rcVlanIgmpSnoopStaticTable(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopStaticEntry_t ***rcVlanIgmpSnoopStaticEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 0};

    *rcVlanIgmpSnoopStaticEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanIgmpSnoopStaticEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanIgmpSnoopStaticEntry = (rapid_city_rcVlanIgmpSnoopStaticEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanIgmpSnoopStaticEntry_t *));
        if (! *rcVlanIgmpSnoopStaticEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanIgmpSnoopStaticEntry)[i] = assign_rcVlanIgmpSnoopStaticEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanIgmpSnoopStaticEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopStaticEntry_t **rcVlanIgmpSnoopStaticEntry, gint32 rcVlanIgmpSnoopStaticVlanId, guchar *rcVlanIgmpSnoopStaticIpAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopStaticEntry, sizeof(oid_rcVlanIgmpSnoopStaticEntry));
    len = pack_rcVlanIgmpSnoopStaticEntry(base, rcVlanIgmpSnoopStaticVlanId, rcVlanIgmpSnoopStaticIpAddress);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopStaticEntry index values");
        return;
    }

    *rcVlanIgmpSnoopStaticEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanIgmpSnoopStaticEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanIgmpSnoopStaticEntry = assign_rcVlanIgmpSnoopStaticEntry(out);
    }
}

void
rapid_city_set_rcVlanIgmpSnoopStaticEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopStaticEntry_t *rcVlanIgmpSnoopStaticEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopStaticEntry, sizeof(oid_rcVlanIgmpSnoopStaticEntry));
    len = pack_rcVlanIgmpSnoopStaticEntry(base, rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticVlanId, rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticIpAddress);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopStaticEntry index values");
        return;
    }

    if (rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticMemberPorts) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticMemberPorts,
                       32);
    }
    if (rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticRowStatus) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticRowStatus,
                       0);
    }
    if (rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticNotAllowedToJoin) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcVlanIgmpSnoopStaticEntry->rcVlanIgmpSnoopStaticNotAllowedToJoin,
                       32);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopStaticEntry(rapid_city_rcVlanIgmpSnoopStaticEntry_t *rcVlanIgmpSnoopStaticEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanIgmpSnoopStaticEntry) {
        p = (char *) rcVlanIgmpSnoopStaticEntry + sizeof(rapid_city_rcVlanIgmpSnoopStaticEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanIgmpSnoopStaticEntry);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopStaticTable(rapid_city_rcVlanIgmpSnoopStaticEntry_t **rcVlanIgmpSnoopStaticEntry)
{
    int i;

    if (rcVlanIgmpSnoopStaticEntry) {
        for (i = 0; rcVlanIgmpSnoopStaticEntry[i]; i++) {
            rapid_city_free_rcVlanIgmpSnoopStaticEntry(rcVlanIgmpSnoopStaticEntry[i]);
        }
        g_free(rcVlanIgmpSnoopStaticEntry);
    }
}

rapid_city_rcVlanIgmpSnoopAccessEntry_t *
rapid_city_new_rcVlanIgmpSnoopAccessEntry()
{
    rapid_city_rcVlanIgmpSnoopAccessEntry_t *rcVlanIgmpSnoopAccessEntry;

    rcVlanIgmpSnoopAccessEntry = (rapid_city_rcVlanIgmpSnoopAccessEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanIgmpSnoopAccessEntry_t) + sizeof(gpointer));
    return rcVlanIgmpSnoopAccessEntry;
}

static int
unpack_rcVlanIgmpSnoopAccessEntry(GSnmpVarBind *vb, rapid_city_rcVlanIgmpSnoopAccessEntry_t *rcVlanIgmpSnoopAccessEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessVlanId = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessGrpAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessHostAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessHostMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanIgmpSnoopAccessEntry(guint32 *base, gint32 rcVlanIgmpSnoopAccessVlanId, guchar *rcVlanIgmpSnoopAccessGrpAddr, guchar *rcVlanIgmpSnoopAccessHostAddr, guchar *rcVlanIgmpSnoopAccessHostMask)
{
    int i, len, idx = 12;

    base[idx++] = rcVlanIgmpSnoopAccessVlanId;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopAccessGrpAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopAccessHostAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopAccessHostMask[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcVlanIgmpSnoopAccessEntry_t *
assign_rcVlanIgmpSnoopAccessEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanIgmpSnoopAccessEntry_t *rcVlanIgmpSnoopAccessEntry;
    guint32 idx;
    char *p;

    rcVlanIgmpSnoopAccessEntry = rapid_city_new_rcVlanIgmpSnoopAccessEntry();
    if (! rcVlanIgmpSnoopAccessEntry) {
        return NULL;
    }

    p = (char *) rcVlanIgmpSnoopAccessEntry + sizeof(rapid_city_rcVlanIgmpSnoopAccessEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanIgmpSnoopAccessEntry((GSnmpVarBind *) vbl->data, rcVlanIgmpSnoopAccessEntry) < 0) {
        g_warning("illegal rcVlanIgmpSnoopAccessEntry instance identifier");
        g_free(rcVlanIgmpSnoopAccessEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanIgmpSnoopAccessEntry, sizeof(oid_rcVlanIgmpSnoopAccessEntry)/sizeof(guint32),
                   attr_rcVlanIgmpSnoopAccessEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessMode = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanIgmpSnoopAccessEntry;
}

void
rapid_city_get_rcVlanIgmpSnoopAccessTable(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopAccessEntry_t ***rcVlanIgmpSnoopAccessEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 0};

    *rcVlanIgmpSnoopAccessEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanIgmpSnoopAccessEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanIgmpSnoopAccessEntry = (rapid_city_rcVlanIgmpSnoopAccessEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanIgmpSnoopAccessEntry_t *));
        if (! *rcVlanIgmpSnoopAccessEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanIgmpSnoopAccessEntry)[i] = assign_rcVlanIgmpSnoopAccessEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanIgmpSnoopAccessEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopAccessEntry_t **rcVlanIgmpSnoopAccessEntry, gint32 rcVlanIgmpSnoopAccessVlanId, guchar *rcVlanIgmpSnoopAccessGrpAddr, guchar *rcVlanIgmpSnoopAccessHostAddr, guchar *rcVlanIgmpSnoopAccessHostMask, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopAccessEntry, sizeof(oid_rcVlanIgmpSnoopAccessEntry));
    len = pack_rcVlanIgmpSnoopAccessEntry(base, rcVlanIgmpSnoopAccessVlanId, rcVlanIgmpSnoopAccessGrpAddr, rcVlanIgmpSnoopAccessHostAddr, rcVlanIgmpSnoopAccessHostMask);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopAccessEntry index values");
        return;
    }

    *rcVlanIgmpSnoopAccessEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanIgmpSnoopAccessEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanIgmpSnoopAccessEntry = assign_rcVlanIgmpSnoopAccessEntry(out);
    }
}

void
rapid_city_set_rcVlanIgmpSnoopAccessEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopAccessEntry_t *rcVlanIgmpSnoopAccessEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopAccessEntry, sizeof(oid_rcVlanIgmpSnoopAccessEntry));
    len = pack_rcVlanIgmpSnoopAccessEntry(base, rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessVlanId, rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessGrpAddr, rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessHostAddr, rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessHostMask);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopAccessEntry index values");
        return;
    }

    if (rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessMode) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessMode,
                       0);
    }
    if (rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessRowStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanIgmpSnoopAccessEntry->rcVlanIgmpSnoopAccessRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopAccessEntry(rapid_city_rcVlanIgmpSnoopAccessEntry_t *rcVlanIgmpSnoopAccessEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanIgmpSnoopAccessEntry) {
        p = (char *) rcVlanIgmpSnoopAccessEntry + sizeof(rapid_city_rcVlanIgmpSnoopAccessEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanIgmpSnoopAccessEntry);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopAccessTable(rapid_city_rcVlanIgmpSnoopAccessEntry_t **rcVlanIgmpSnoopAccessEntry)
{
    int i;

    if (rcVlanIgmpSnoopAccessEntry) {
        for (i = 0; rcVlanIgmpSnoopAccessEntry[i]; i++) {
            rapid_city_free_rcVlanIgmpSnoopAccessEntry(rcVlanIgmpSnoopAccessEntry[i]);
        }
        g_free(rcVlanIgmpSnoopAccessEntry);
    }
}

rapid_city_rcVlanIgmpSnoopSenderEntry_t *
rapid_city_new_rcVlanIgmpSnoopSenderEntry()
{
    rapid_city_rcVlanIgmpSnoopSenderEntry_t *rcVlanIgmpSnoopSenderEntry;

    rcVlanIgmpSnoopSenderEntry = (rapid_city_rcVlanIgmpSnoopSenderEntry_t *) g_malloc0(sizeof(rapid_city_rcVlanIgmpSnoopSenderEntry_t) + sizeof(gpointer));
    return rcVlanIgmpSnoopSenderEntry;
}

static int
unpack_rcVlanIgmpSnoopSenderEntry(GSnmpVarBind *vb, rapid_city_rcVlanIgmpSnoopSenderEntry_t *rcVlanIgmpSnoopSenderEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderVlanId = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderMember[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcVlanIgmpSnoopSenderEntry(guint32 *base, gint32 rcVlanIgmpSnoopSenderVlanId, guchar *rcVlanIgmpSnoopSenderIpAddress, gint32 rcVlanIgmpSnoopSenderIfIndex, guchar *rcVlanIgmpSnoopSenderMember)
{
    int i, len, idx = 12;

    base[idx++] = rcVlanIgmpSnoopSenderVlanId;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopSenderIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcVlanIgmpSnoopSenderIfIndex;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcVlanIgmpSnoopSenderMember[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcVlanIgmpSnoopSenderEntry_t *
assign_rcVlanIgmpSnoopSenderEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcVlanIgmpSnoopSenderEntry_t *rcVlanIgmpSnoopSenderEntry;
    guint32 idx;
    char *p;

    rcVlanIgmpSnoopSenderEntry = rapid_city_new_rcVlanIgmpSnoopSenderEntry();
    if (! rcVlanIgmpSnoopSenderEntry) {
        return NULL;
    }

    p = (char *) rcVlanIgmpSnoopSenderEntry + sizeof(rapid_city_rcVlanIgmpSnoopSenderEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcVlanIgmpSnoopSenderEntry((GSnmpVarBind *) vbl->data, rcVlanIgmpSnoopSenderEntry) < 0) {
        g_warning("illegal rcVlanIgmpSnoopSenderEntry instance identifier");
        g_free(rcVlanIgmpSnoopSenderEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcVlanIgmpSnoopSenderEntry, sizeof(oid_rcVlanIgmpSnoopSenderEntry)/sizeof(guint32),
                   attr_rcVlanIgmpSnoopSenderEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderAction = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcVlanIgmpSnoopSenderEntry;
}

void
rapid_city_get_rcVlanIgmpSnoopSenderTable(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopSenderEntry_t ***rcVlanIgmpSnoopSenderEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 0};

    *rcVlanIgmpSnoopSenderEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcVlanIgmpSnoopSenderEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcVlanIgmpSnoopSenderEntry = (rapid_city_rcVlanIgmpSnoopSenderEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcVlanIgmpSnoopSenderEntry_t *));
        if (! *rcVlanIgmpSnoopSenderEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcVlanIgmpSnoopSenderEntry)[i] = assign_rcVlanIgmpSnoopSenderEntry(row->data);
        }
    }
}

void
rapid_city_get_rcVlanIgmpSnoopSenderEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopSenderEntry_t **rcVlanIgmpSnoopSenderEntry, gint32 rcVlanIgmpSnoopSenderVlanId, guchar *rcVlanIgmpSnoopSenderIpAddress, gint32 rcVlanIgmpSnoopSenderIfIndex, guchar *rcVlanIgmpSnoopSenderMember, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopSenderEntry, sizeof(oid_rcVlanIgmpSnoopSenderEntry));
    len = pack_rcVlanIgmpSnoopSenderEntry(base, rcVlanIgmpSnoopSenderVlanId, rcVlanIgmpSnoopSenderIpAddress, rcVlanIgmpSnoopSenderIfIndex, rcVlanIgmpSnoopSenderMember);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopSenderEntry index values");
        return;
    }

    *rcVlanIgmpSnoopSenderEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcVlanIgmpSnoopSenderEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcVlanIgmpSnoopSenderEntry = assign_rcVlanIgmpSnoopSenderEntry(out);
    }
}

void
rapid_city_set_rcVlanIgmpSnoopSenderEntry(GSnmpSession *s, rapid_city_rcVlanIgmpSnoopSenderEntry_t *rcVlanIgmpSnoopSenderEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcVlanIgmpSnoopSenderEntry, sizeof(oid_rcVlanIgmpSnoopSenderEntry));
    len = pack_rcVlanIgmpSnoopSenderEntry(base, rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderVlanId, rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderIpAddress, rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderIfIndex, rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderMember);
    if (len < 0) {
        g_warning("illegal rcVlanIgmpSnoopSenderEntry index values");
        return;
    }

    if (rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderAction) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcVlanIgmpSnoopSenderEntry->rcVlanIgmpSnoopSenderAction,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopSenderEntry(rapid_city_rcVlanIgmpSnoopSenderEntry_t *rcVlanIgmpSnoopSenderEntry)
{
    GSList *vbl;
    char *p;

    if (rcVlanIgmpSnoopSenderEntry) {
        p = (char *) rcVlanIgmpSnoopSenderEntry + sizeof(rapid_city_rcVlanIgmpSnoopSenderEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcVlanIgmpSnoopSenderEntry);
    }
}

void
rapid_city_free_rcVlanIgmpSnoopSenderTable(rapid_city_rcVlanIgmpSnoopSenderEntry_t **rcVlanIgmpSnoopSenderEntry)
{
    int i;

    if (rcVlanIgmpSnoopSenderEntry) {
        for (i = 0; rcVlanIgmpSnoopSenderEntry[i]; i++) {
            rapid_city_free_rcVlanIgmpSnoopSenderEntry(rcVlanIgmpSnoopSenderEntry[i]);
        }
        g_free(rcVlanIgmpSnoopSenderEntry);
    }
}

rapid_city_rcChassis_t *
rapid_city_new_rcChassis()
{
    rapid_city_rcChassis_t *rcChassis;

    rcChassis = (rapid_city_rcChassis_t *) g_malloc0(sizeof(rapid_city_rcChassis_t) + sizeof(gpointer));
    return rcChassis;
}

static rapid_city_rcChassis_t *
assign_rcChassis(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcChassis_t *rcChassis;
    guint32 idx;
    char *p;

    rcChassis = rapid_city_new_rcChassis();
    if (! rcChassis) {
        return NULL;
    }

    p = (char *) rcChassis + sizeof(rapid_city_rcChassis_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcChassis, sizeof(oid_rcChassis)/sizeof(guint32),
                   attr_rcChassis, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcChassis->rcChasType = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcChassis->_rcChasSerialNumberLength = vb->syntax_len;
            rcChassis->rcChasSerialNumber = vb->syntax.uc;
            break;
        case 3:
            rcChassis->_rcChasHardwareRevisionLength = vb->syntax_len;
            rcChassis->rcChasHardwareRevision = vb->syntax.uc;
            break;
        case 4:
            rcChassis->rcChasNumSlots = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcChassis->rcChasNumPorts = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcChassis->rcChasTestResult = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcChassis->rcChasAruMode = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcChassis->rcChasQuidMode = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcChassis->rcChasEocModeAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcChassis->rcChasEocModeOperStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcChassis;
}

void
rapid_city_get_rcChassis(GSnmpSession *s, rapid_city_rcChassis_t **rcChassis, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 0};

    *rcChassis = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcChassis, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcChassis = assign_rcChassis(out);
    }
}

void
rapid_city_set_rcChassis(GSnmpSession *s, rapid_city_rcChassis_t *rcChassis, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 0, 0};

    if (rcChassis->rcChasEocModeAdminStatus) {
        base[9] = 14;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcChassis->rcChasEocModeAdminStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcChassis(rapid_city_rcChassis_t *rcChassis)
{
    GSList *vbl;
    char *p;

    if (rcChassis) {
        p = (char *) rcChassis + sizeof(rapid_city_rcChassis_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcChassis);
    }
}

rapid_city_rcChasFanEntry_t *
rapid_city_new_rcChasFanEntry()
{
    rapid_city_rcChasFanEntry_t *rcChasFanEntry;

    rcChasFanEntry = (rapid_city_rcChasFanEntry_t *) g_malloc0(sizeof(rapid_city_rcChasFanEntry_t) + sizeof(gpointer));
    return rcChasFanEntry;
}

static int
unpack_rcChasFanEntry(GSnmpVarBind *vb, rapid_city_rcChasFanEntry_t *rcChasFanEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcChasFanEntry->rcChasFanId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcChasFanEntry(guint32 *base, gint32 rcChasFanId)
{
    int idx = 13;

    base[idx++] = rcChasFanId;
    return idx;
}

static rapid_city_rcChasFanEntry_t *
assign_rcChasFanEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcChasFanEntry_t *rcChasFanEntry;
    guint32 idx;
    char *p;

    rcChasFanEntry = rapid_city_new_rcChasFanEntry();
    if (! rcChasFanEntry) {
        return NULL;
    }

    p = (char *) rcChasFanEntry + sizeof(rapid_city_rcChasFanEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcChasFanEntry((GSnmpVarBind *) vbl->data, rcChasFanEntry) < 0) {
        g_warning("illegal rcChasFanEntry instance identifier");
        g_free(rcChasFanEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcChasFanEntry, sizeof(oid_rcChasFanEntry)/sizeof(guint32),
                   attr_rcChasFanEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcChasFanEntry->rcChasFanOperStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcChasFanEntry;
}

void
rapid_city_get_rcChasFanTable(GSnmpSession *s, rapid_city_rcChasFanEntry_t ***rcChasFanEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 7, 1, 1, 0};

    *rcChasFanEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcChasFanEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcChasFanEntry = (rapid_city_rcChasFanEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcChasFanEntry_t *));
        if (! *rcChasFanEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcChasFanEntry)[i] = assign_rcChasFanEntry(row->data);
        }
    }
}

void
rapid_city_get_rcChasFanEntry(GSnmpSession *s, rapid_city_rcChasFanEntry_t **rcChasFanEntry, gint32 rcChasFanId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcChasFanEntry, sizeof(oid_rcChasFanEntry));
    len = pack_rcChasFanEntry(base, rcChasFanId);
    if (len < 0) {
        g_warning("illegal rcChasFanEntry index values");
        return;
    }

    *rcChasFanEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcChasFanEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcChasFanEntry = assign_rcChasFanEntry(out);
    }
}

void
rapid_city_free_rcChasFanEntry(rapid_city_rcChasFanEntry_t *rcChasFanEntry)
{
    GSList *vbl;
    char *p;

    if (rcChasFanEntry) {
        p = (char *) rcChasFanEntry + sizeof(rapid_city_rcChasFanEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcChasFanEntry);
    }
}

void
rapid_city_free_rcChasFanTable(rapid_city_rcChasFanEntry_t **rcChasFanEntry)
{
    int i;

    if (rcChasFanEntry) {
        for (i = 0; rcChasFanEntry[i]; i++) {
            rapid_city_free_rcChasFanEntry(rcChasFanEntry[i]);
        }
        g_free(rcChasFanEntry);
    }
}

rapid_city_rcChasPowerSupplyEntry_t *
rapid_city_new_rcChasPowerSupplyEntry()
{
    rapid_city_rcChasPowerSupplyEntry_t *rcChasPowerSupplyEntry;

    rcChasPowerSupplyEntry = (rapid_city_rcChasPowerSupplyEntry_t *) g_malloc0(sizeof(rapid_city_rcChasPowerSupplyEntry_t) + sizeof(gpointer));
    return rcChasPowerSupplyEntry;
}

static int
unpack_rcChasPowerSupplyEntry(GSnmpVarBind *vb, rapid_city_rcChasPowerSupplyEntry_t *rcChasPowerSupplyEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcChasPowerSupplyEntry->rcChasPowerSupplyId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcChasPowerSupplyEntry(guint32 *base, gint32 rcChasPowerSupplyId)
{
    int idx = 13;

    base[idx++] = rcChasPowerSupplyId;
    return idx;
}

static rapid_city_rcChasPowerSupplyEntry_t *
assign_rcChasPowerSupplyEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcChasPowerSupplyEntry_t *rcChasPowerSupplyEntry;
    guint32 idx;
    char *p;

    rcChasPowerSupplyEntry = rapid_city_new_rcChasPowerSupplyEntry();
    if (! rcChasPowerSupplyEntry) {
        return NULL;
    }

    p = (char *) rcChasPowerSupplyEntry + sizeof(rapid_city_rcChasPowerSupplyEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcChasPowerSupplyEntry((GSnmpVarBind *) vbl->data, rcChasPowerSupplyEntry) < 0) {
        g_warning("illegal rcChasPowerSupplyEntry instance identifier");
        g_free(rcChasPowerSupplyEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcChasPowerSupplyEntry, sizeof(oid_rcChasPowerSupplyEntry)/sizeof(guint32),
                   attr_rcChasPowerSupplyEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcChasPowerSupplyEntry->rcChasPowerSupplyOperStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcChasPowerSupplyEntry;
}

void
rapid_city_get_rcChasPowerSupplyTable(GSnmpSession *s, rapid_city_rcChasPowerSupplyEntry_t ***rcChasPowerSupplyEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 8, 1, 1, 0};

    *rcChasPowerSupplyEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcChasPowerSupplyEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcChasPowerSupplyEntry = (rapid_city_rcChasPowerSupplyEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcChasPowerSupplyEntry_t *));
        if (! *rcChasPowerSupplyEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcChasPowerSupplyEntry)[i] = assign_rcChasPowerSupplyEntry(row->data);
        }
    }
}

void
rapid_city_get_rcChasPowerSupplyEntry(GSnmpSession *s, rapid_city_rcChasPowerSupplyEntry_t **rcChasPowerSupplyEntry, gint32 rcChasPowerSupplyId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcChasPowerSupplyEntry, sizeof(oid_rcChasPowerSupplyEntry));
    len = pack_rcChasPowerSupplyEntry(base, rcChasPowerSupplyId);
    if (len < 0) {
        g_warning("illegal rcChasPowerSupplyEntry index values");
        return;
    }

    *rcChasPowerSupplyEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcChasPowerSupplyEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcChasPowerSupplyEntry = assign_rcChasPowerSupplyEntry(out);
    }
}

void
rapid_city_free_rcChasPowerSupplyEntry(rapid_city_rcChasPowerSupplyEntry_t *rcChasPowerSupplyEntry)
{
    GSList *vbl;
    char *p;

    if (rcChasPowerSupplyEntry) {
        p = (char *) rcChasPowerSupplyEntry + sizeof(rapid_city_rcChasPowerSupplyEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcChasPowerSupplyEntry);
    }
}

void
rapid_city_free_rcChasPowerSupplyTable(rapid_city_rcChasPowerSupplyEntry_t **rcChasPowerSupplyEntry)
{
    int i;

    if (rcChasPowerSupplyEntry) {
        for (i = 0; rcChasPowerSupplyEntry[i]; i++) {
            rapid_city_free_rcChasPowerSupplyEntry(rcChasPowerSupplyEntry[i]);
        }
        g_free(rcChasPowerSupplyEntry);
    }
}

rapid_city_rcChasPowerSupplyDetailEntry_t *
rapid_city_new_rcChasPowerSupplyDetailEntry()
{
    rapid_city_rcChasPowerSupplyDetailEntry_t *rcChasPowerSupplyDetailEntry;

    rcChasPowerSupplyDetailEntry = (rapid_city_rcChasPowerSupplyDetailEntry_t *) g_malloc0(sizeof(rapid_city_rcChasPowerSupplyDetailEntry_t) + sizeof(gpointer));
    return rcChasPowerSupplyDetailEntry;
}

static int
unpack_rcChasPowerSupplyDetailEntry(GSnmpVarBind *vb, rapid_city_rcChasPowerSupplyDetailEntry_t *rcChasPowerSupplyDetailEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcChasPowerSupplyDetailEntry->rcChasPowerSupplyDetailId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcChasPowerSupplyDetailEntry(guint32 *base, gint32 rcChasPowerSupplyDetailId)
{
    int idx = 13;

    base[idx++] = rcChasPowerSupplyDetailId;
    return idx;
}

static rapid_city_rcChasPowerSupplyDetailEntry_t *
assign_rcChasPowerSupplyDetailEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcChasPowerSupplyDetailEntry_t *rcChasPowerSupplyDetailEntry;
    guint32 idx;
    char *p;

    rcChasPowerSupplyDetailEntry = rapid_city_new_rcChasPowerSupplyDetailEntry();
    if (! rcChasPowerSupplyDetailEntry) {
        return NULL;
    }

    p = (char *) rcChasPowerSupplyDetailEntry + sizeof(rapid_city_rcChasPowerSupplyDetailEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcChasPowerSupplyDetailEntry((GSnmpVarBind *) vbl->data, rcChasPowerSupplyDetailEntry) < 0) {
        g_warning("illegal rcChasPowerSupplyDetailEntry instance identifier");
        g_free(rcChasPowerSupplyDetailEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcChasPowerSupplyDetailEntry, sizeof(oid_rcChasPowerSupplyDetailEntry)/sizeof(guint32),
                   attr_rcChasPowerSupplyDetailEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcChasPowerSupplyDetailEntry->rcChasPowerSupplyDetailType = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcChasPowerSupplyDetailEntry->_rcChasPowerSupplyDetailSerialNumberLength = vb->syntax_len;
            rcChasPowerSupplyDetailEntry->rcChasPowerSupplyDetailSerialNumber = vb->syntax.uc;
            break;
        case 4:
            rcChasPowerSupplyDetailEntry->_rcChasPowerSupplyDetailHardwareRevisionLength = vb->syntax_len;
            rcChasPowerSupplyDetailEntry->rcChasPowerSupplyDetailHardwareRevision = vb->syntax.uc;
            break;
        case 5:
            rcChasPowerSupplyDetailEntry->_rcChasPowerSupplyDetailPartNumberLength = vb->syntax_len;
            rcChasPowerSupplyDetailEntry->rcChasPowerSupplyDetailPartNumber = vb->syntax.uc;
            break;
        };
    }

    return rcChasPowerSupplyDetailEntry;
}

void
rapid_city_get_rcChasPowerSupplyDetailTable(GSnmpSession *s, rapid_city_rcChasPowerSupplyDetailEntry_t ***rcChasPowerSupplyDetailEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 8, 2, 1, 0};

    *rcChasPowerSupplyDetailEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcChasPowerSupplyDetailEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcChasPowerSupplyDetailEntry = (rapid_city_rcChasPowerSupplyDetailEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcChasPowerSupplyDetailEntry_t *));
        if (! *rcChasPowerSupplyDetailEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcChasPowerSupplyDetailEntry)[i] = assign_rcChasPowerSupplyDetailEntry(row->data);
        }
    }
}

void
rapid_city_get_rcChasPowerSupplyDetailEntry(GSnmpSession *s, rapid_city_rcChasPowerSupplyDetailEntry_t **rcChasPowerSupplyDetailEntry, gint32 rcChasPowerSupplyDetailId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcChasPowerSupplyDetailEntry, sizeof(oid_rcChasPowerSupplyDetailEntry));
    len = pack_rcChasPowerSupplyDetailEntry(base, rcChasPowerSupplyDetailId);
    if (len < 0) {
        g_warning("illegal rcChasPowerSupplyDetailEntry index values");
        return;
    }

    *rcChasPowerSupplyDetailEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcChasPowerSupplyDetailEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcChasPowerSupplyDetailEntry = assign_rcChasPowerSupplyDetailEntry(out);
    }
}

void
rapid_city_free_rcChasPowerSupplyDetailEntry(rapid_city_rcChasPowerSupplyDetailEntry_t *rcChasPowerSupplyDetailEntry)
{
    GSList *vbl;
    char *p;

    if (rcChasPowerSupplyDetailEntry) {
        p = (char *) rcChasPowerSupplyDetailEntry + sizeof(rapid_city_rcChasPowerSupplyDetailEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcChasPowerSupplyDetailEntry);
    }
}

void
rapid_city_free_rcChasPowerSupplyDetailTable(rapid_city_rcChasPowerSupplyDetailEntry_t **rcChasPowerSupplyDetailEntry)
{
    int i;

    if (rcChasPowerSupplyDetailEntry) {
        for (i = 0; rcChasPowerSupplyDetailEntry[i]; i++) {
            rapid_city_free_rcChasPowerSupplyDetailEntry(rcChasPowerSupplyDetailEntry[i]);
        }
        g_free(rcChasPowerSupplyDetailEntry);
    }
}

rapid_city_rcCardEntry_t *
rapid_city_new_rcCardEntry()
{
    rapid_city_rcCardEntry_t *rcCardEntry;

    rcCardEntry = (rapid_city_rcCardEntry_t *) g_malloc0(sizeof(rapid_city_rcCardEntry_t) + sizeof(gpointer));
    return rcCardEntry;
}

static int
unpack_rcCardEntry(GSnmpVarBind *vb, rapid_city_rcCardEntry_t *rcCardEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcCardEntry->rcCardIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcCardEntry(guint32 *base, gint32 rcCardIndex)
{
    int idx = 13;

    base[idx++] = rcCardIndex;
    return idx;
}

static rapid_city_rcCardEntry_t *
assign_rcCardEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcCardEntry_t *rcCardEntry;
    guint32 idx;
    char *p;

    rcCardEntry = rapid_city_new_rcCardEntry();
    if (! rcCardEntry) {
        return NULL;
    }

    p = (char *) rcCardEntry + sizeof(rapid_city_rcCardEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcCardEntry((GSnmpVarBind *) vbl->data, rcCardEntry) < 0) {
        g_warning("illegal rcCardEntry instance identifier");
        g_free(rcCardEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcCardEntry, sizeof(oid_rcCardEntry)/sizeof(guint32),
                   attr_rcCardEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcCardEntry->rcCardType = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcCardEntry->_rcCardSerialNumberLength = vb->syntax_len;
            rcCardEntry->rcCardSerialNumber = vb->syntax.uc;
            break;
        case 4:
            rcCardEntry->_rcCardHardwareRevisionLength = vb->syntax_len;
            rcCardEntry->rcCardHardwareRevision = vb->syntax.uc;
            break;
        case 5:
            rcCardEntry->rcCardAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcCardEntry->rcCardOperStatus = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcCardEntry->rcCardPCMCIAType = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcCardEntry->_rcCardPartNumberLength = vb->syntax_len;
            rcCardEntry->rcCardPartNumber = vb->syntax.uc;
            break;
        };
    }

    return rcCardEntry;
}

void
rapid_city_get_rcCardTable(GSnmpSession *s, rapid_city_rcCardEntry_t ***rcCardEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 9, 1, 1, 0};

    *rcCardEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcCardEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcCardEntry = (rapid_city_rcCardEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcCardEntry_t *));
        if (! *rcCardEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcCardEntry)[i] = assign_rcCardEntry(row->data);
        }
    }
}

void
rapid_city_get_rcCardEntry(GSnmpSession *s, rapid_city_rcCardEntry_t **rcCardEntry, gint32 rcCardIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcCardEntry, sizeof(oid_rcCardEntry));
    len = pack_rcCardEntry(base, rcCardIndex);
    if (len < 0) {
        g_warning("illegal rcCardEntry index values");
        return;
    }

    *rcCardEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcCardEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcCardEntry = assign_rcCardEntry(out);
    }
}

void
rapid_city_set_rcCardEntry(GSnmpSession *s, rapid_city_rcCardEntry_t *rcCardEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcCardEntry, sizeof(oid_rcCardEntry));
    len = pack_rcCardEntry(base, rcCardEntry->rcCardIndex);
    if (len < 0) {
        g_warning("illegal rcCardEntry index values");
        return;
    }

    if (rcCardEntry->rcCardAdminStatus) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcCardEntry->rcCardAdminStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcCardEntry(rapid_city_rcCardEntry_t *rcCardEntry)
{
    GSList *vbl;
    char *p;

    if (rcCardEntry) {
        p = (char *) rcCardEntry + sizeof(rapid_city_rcCardEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcCardEntry);
    }
}

void
rapid_city_free_rcCardTable(rapid_city_rcCardEntry_t **rcCardEntry)
{
    int i;

    if (rcCardEntry) {
        for (i = 0; rcCardEntry[i]; i++) {
            rapid_city_free_rcCardEntry(rcCardEntry[i]);
        }
        g_free(rcCardEntry);
    }
}

rapid_city_rcPortEntry_t *
rapid_city_new_rcPortEntry()
{
    rapid_city_rcPortEntry_t *rcPortEntry;

    rcPortEntry = (rapid_city_rcPortEntry_t *) g_malloc0(sizeof(rapid_city_rcPortEntry_t) + sizeof(gpointer));
    return rcPortEntry;
}

static int
unpack_rcPortEntry(GSnmpVarBind *vb, rapid_city_rcPortEntry_t *rcPortEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcPortEntry->rcPortIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcPortEntry(guint32 *base, gint32 rcPortIndex)
{
    int idx = 13;

    base[idx++] = rcPortIndex;
    return idx;
}

static rapid_city_rcPortEntry_t *
assign_rcPortEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcPortEntry_t *rcPortEntry;
    guint32 idx;
    char *p;

    rcPortEntry = rapid_city_new_rcPortEntry();
    if (! rcPortEntry) {
        return NULL;
    }

    p = (char *) rcPortEntry + sizeof(rapid_city_rcPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcPortEntry((GSnmpVarBind *) vbl->data, rcPortEntry) < 0) {
        g_warning("illegal rcPortEntry instance identifier");
        g_free(rcPortEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcPortEntry, sizeof(oid_rcPortEntry)/sizeof(guint32),
                   attr_rcPortEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcPortEntry->rcPortType = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcPortEntry->rcPortConnectorType = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcPortEntry->rcPortPerformRouting = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcPortEntry->rcPortHighPriority = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcPortEntry->rcPortAction = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcPortEntry->rcPortResult = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcPortEntry->rcPortPrimaryConnector = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcPortEntry->rcPortActiveConnector = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcPortEntry->rcPortBackupConnectorStatus = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcPortEntry->rcPortAutoNegotiate = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcPortEntry->rcPortAdminDuplex = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcPortEntry->rcPortOperDuplex = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcPortEntry->rcPortAdminSpeed = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcPortEntry->rcPortOperSpeed = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcPortEntry->rcPortMltId = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcPortEntry->rcPortLocked = &(vb->syntax.i32[0]);
            break;
        case 18:
            rcPortEntry->rcPortAutoNegotiationSupported = &(vb->syntax.i32[0]);
            break;
        case 19:
            rcPortEntry->rcPortSingleRoutablePort = &(vb->syntax.i32[0]);
            break;
        case 20:
            rcPortEntry->rcPortUnknownMacDiscard = &(vb->syntax.i32[0]);
            break;
        case 21:
            rcPortEntry->rcPortNumStateTransition = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcPortEntry;
}

void
rapid_city_get_rcPortTable(GSnmpSession *s, rapid_city_rcPortEntry_t ***rcPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 10, 1, 1, 0};

    *rcPortEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcPortEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcPortEntry = (rapid_city_rcPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcPortEntry_t *));
        if (! *rcPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcPortEntry)[i] = assign_rcPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcPortEntry(GSnmpSession *s, rapid_city_rcPortEntry_t **rcPortEntry, gint32 rcPortIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcPortEntry, sizeof(oid_rcPortEntry));
    len = pack_rcPortEntry(base, rcPortIndex);
    if (len < 0) {
        g_warning("illegal rcPortEntry index values");
        return;
    }

    *rcPortEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcPortEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcPortEntry = assign_rcPortEntry(out);
    }
}

void
rapid_city_set_rcPortEntry(GSnmpSession *s, rapid_city_rcPortEntry_t *rcPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcPortEntry, sizeof(oid_rcPortEntry));
    len = pack_rcPortEntry(base, rcPortEntry->rcPortIndex);
    if (len < 0) {
        g_warning("illegal rcPortEntry index values");
        return;
    }

    if (rcPortEntry->rcPortPerformRouting) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortPerformRouting,
                       0);
    }
    if (rcPortEntry->rcPortHighPriority) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortHighPriority,
                       0);
    }
    if (rcPortEntry->rcPortAction) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortAction,
                       0);
    }
    if (rcPortEntry->rcPortPrimaryConnector) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortPrimaryConnector,
                       0);
    }
    if (rcPortEntry->rcPortAutoNegotiate) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortAutoNegotiate,
                       0);
    }
    if (rcPortEntry->rcPortAdminDuplex) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortAdminDuplex,
                       0);
    }
    if (rcPortEntry->rcPortAdminSpeed) {
        base[12] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortAdminSpeed,
                       0);
    }
    if (rcPortEntry->rcPortUnknownMacDiscard) {
        base[12] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortEntry->rcPortUnknownMacDiscard,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcPortEntry(rapid_city_rcPortEntry_t *rcPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcPortEntry) {
        p = (char *) rcPortEntry + sizeof(rapid_city_rcPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcPortEntry);
    }
}

void
rapid_city_free_rcPortTable(rapid_city_rcPortEntry_t **rcPortEntry)
{
    int i;

    if (rcPortEntry) {
        for (i = 0; rcPortEntry[i]; i++) {
            rapid_city_free_rcPortEntry(rcPortEntry[i]);
        }
        g_free(rcPortEntry);
    }
}

rapid_city_rcPortLock_t *
rapid_city_new_rcPortLock()
{
    rapid_city_rcPortLock_t *rcPortLock;

    rcPortLock = (rapid_city_rcPortLock_t *) g_malloc0(sizeof(rapid_city_rcPortLock_t) + sizeof(gpointer));
    return rcPortLock;
}

static rapid_city_rcPortLock_t *
assign_rcPortLock(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcPortLock_t *rcPortLock;
    guint32 idx;
    char *p;

    rcPortLock = rapid_city_new_rcPortLock();
    if (! rcPortLock) {
        return NULL;
    }

    p = (char *) rcPortLock + sizeof(rapid_city_rcPortLock_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcPortLock, sizeof(oid_rcPortLock)/sizeof(guint32),
                   attr_rcPortLock, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcPortLock->rcPortLockEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcPortLock->rcPortLockLockedPorts = vb->syntax.uc;
            break;
        };
    }

    return rcPortLock;
}

void
rapid_city_get_rcPortLock(GSnmpSession *s, rapid_city_rcPortLock_t **rcPortLock, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 11, 0};

    *rcPortLock = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcPortLock, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcPortLock = assign_rcPortLock(out);
    }
}

void
rapid_city_set_rcPortLock(GSnmpSession *s, rapid_city_rcPortLock_t *rcPortLock, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 11, 0, 0};

    if (rcPortLock->rcPortLockEnable) {
        base[10] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcPortLock->rcPortLockEnable,
                       0);
    }
    if (rcPortLock->rcPortLockLockedPorts) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcPortLock->rcPortLockLockedPorts,
                       32);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcPortLock(rapid_city_rcPortLock_t *rcPortLock)
{
    GSList *vbl;
    char *p;

    if (rcPortLock) {
        p = (char *) rcPortLock + sizeof(rapid_city_rcPortLock_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcPortLock);
    }
}

rapid_city_rcPortAtmLecExtEntry_t *
rapid_city_new_rcPortAtmLecExtEntry()
{
    rapid_city_rcPortAtmLecExtEntry_t *rcPortAtmLecExtEntry;

    rcPortAtmLecExtEntry = (rapid_city_rcPortAtmLecExtEntry_t *) g_malloc0(sizeof(rapid_city_rcPortAtmLecExtEntry_t) + sizeof(gpointer));
    return rcPortAtmLecExtEntry;
}

static int
unpack_rcPortAtmLecExtEntry(GSnmpVarBind *vb, rapid_city_rcPortAtmLecExtEntry_t *rcPortAtmLecExtEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcPortAtmLecExtEntry->rcPortAtmLecExtIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcPortAtmLecExtEntry(guint32 *base, gint32 rcPortAtmLecExtIfIndex)
{
    int idx = 13;

    base[idx++] = rcPortAtmLecExtIfIndex;
    return idx;
}

static rapid_city_rcPortAtmLecExtEntry_t *
assign_rcPortAtmLecExtEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcPortAtmLecExtEntry_t *rcPortAtmLecExtEntry;
    guint32 idx;
    char *p;

    rcPortAtmLecExtEntry = rapid_city_new_rcPortAtmLecExtEntry();
    if (! rcPortAtmLecExtEntry) {
        return NULL;
    }

    p = (char *) rcPortAtmLecExtEntry + sizeof(rapid_city_rcPortAtmLecExtEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcPortAtmLecExtEntry((GSnmpVarBind *) vbl->data, rcPortAtmLecExtEntry) < 0) {
        g_warning("illegal rcPortAtmLecExtEntry instance identifier");
        g_free(rcPortAtmLecExtEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcPortAtmLecExtEntry, sizeof(oid_rcPortAtmLecExtEntry)/sizeof(guint32),
                   attr_rcPortAtmLecExtEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcPortAtmLecExtEntry->rcPortAtmLecExtLecStatus = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcPortAtmLecExtEntry->rcPortAtmLecExtLecState = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcPortAtmLecExtEntry->rcPortAtmLecExtVirtualPortId = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcPortAtmLecExtEntry->_rcPortAtmLecExtElanNameLength = vb->syntax_len;
            rcPortAtmLecExtEntry->rcPortAtmLecExtElanName = vb->syntax.uc;
            break;
        case 6:
            rcPortAtmLecExtEntry->rcPortAtmLecExtVlanId = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcPortAtmLecExtEntry->rcPortAtmLecExtDesiredPhysicalPort = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcPortAtmLecExtEntry->rcPortAtmLecExtActualPhysicalPort = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcPortAtmLecExtEntry->rcPortAtmLecExtFailoverEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcPortAtmLecExtEntry;
}

void
rapid_city_get_rcPortAtmLecExtTable(GSnmpSession *s, rapid_city_rcPortAtmLecExtEntry_t ***rcPortAtmLecExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 4, 40, 1, 1, 0};

    *rcPortAtmLecExtEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcPortAtmLecExtEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcPortAtmLecExtEntry = (rapid_city_rcPortAtmLecExtEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcPortAtmLecExtEntry_t *));
        if (! *rcPortAtmLecExtEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcPortAtmLecExtEntry)[i] = assign_rcPortAtmLecExtEntry(row->data);
        }
    }
}

void
rapid_city_get_rcPortAtmLecExtEntry(GSnmpSession *s, rapid_city_rcPortAtmLecExtEntry_t **rcPortAtmLecExtEntry, gint32 rcPortAtmLecExtIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcPortAtmLecExtEntry, sizeof(oid_rcPortAtmLecExtEntry));
    len = pack_rcPortAtmLecExtEntry(base, rcPortAtmLecExtIfIndex);
    if (len < 0) {
        g_warning("illegal rcPortAtmLecExtEntry index values");
        return;
    }

    *rcPortAtmLecExtEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcPortAtmLecExtEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcPortAtmLecExtEntry = assign_rcPortAtmLecExtEntry(out);
    }
}

void
rapid_city_set_rcPortAtmLecExtEntry(GSnmpSession *s, rapid_city_rcPortAtmLecExtEntry_t *rcPortAtmLecExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcPortAtmLecExtEntry, sizeof(oid_rcPortAtmLecExtEntry));
    len = pack_rcPortAtmLecExtEntry(base, rcPortAtmLecExtEntry->rcPortAtmLecExtIfIndex);
    if (len < 0) {
        g_warning("illegal rcPortAtmLecExtEntry index values");
        return;
    }

    if (rcPortAtmLecExtEntry->rcPortAtmLecExtLecStatus) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortAtmLecExtEntry->rcPortAtmLecExtLecStatus,
                       0);
    }
    if (rcPortAtmLecExtEntry->rcPortAtmLecExtElanName) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcPortAtmLecExtEntry->rcPortAtmLecExtElanName,
                       rcPortAtmLecExtEntry->_rcPortAtmLecExtElanNameLength);
    }
    if (rcPortAtmLecExtEntry->rcPortAtmLecExtDesiredPhysicalPort) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortAtmLecExtEntry->rcPortAtmLecExtDesiredPhysicalPort,
                       0);
    }
    if (rcPortAtmLecExtEntry->rcPortAtmLecExtFailoverEnable) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcPortAtmLecExtEntry->rcPortAtmLecExtFailoverEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcPortAtmLecExtEntry(rapid_city_rcPortAtmLecExtEntry_t *rcPortAtmLecExtEntry)
{
    GSList *vbl;
    char *p;

    if (rcPortAtmLecExtEntry) {
        p = (char *) rcPortAtmLecExtEntry + sizeof(rapid_city_rcPortAtmLecExtEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcPortAtmLecExtEntry);
    }
}

void
rapid_city_free_rcPortAtmLecExtTable(rapid_city_rcPortAtmLecExtEntry_t **rcPortAtmLecExtEntry)
{
    int i;

    if (rcPortAtmLecExtEntry) {
        for (i = 0; rcPortAtmLecExtEntry[i]; i++) {
            rapid_city_free_rcPortAtmLecExtEntry(rcPortAtmLecExtEntry[i]);
        }
        g_free(rcPortAtmLecExtEntry);
    }
}

rapid_city_rcMirror_t *
rapid_city_new_rcMirror()
{
    rapid_city_rcMirror_t *rcMirror;

    rcMirror = (rapid_city_rcMirror_t *) g_malloc0(sizeof(rapid_city_rcMirror_t) + sizeof(gpointer));
    return rcMirror;
}

static rapid_city_rcMirror_t *
assign_rcMirror(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcMirror_t *rcMirror;
    guint32 idx;
    char *p;

    rcMirror = rapid_city_new_rcMirror();
    if (! rcMirror) {
        return NULL;
    }

    p = (char *) rcMirror + sizeof(rapid_city_rcMirror_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcMirror, sizeof(oid_rcMirror)/sizeof(guint32),
                   attr_rcMirror, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcMirror->rcMirrorSaveConfig = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcMirror;
}

void
rapid_city_get_rcMirror(GSnmpSession *s, rapid_city_rcMirror_t **rcMirror, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5, 0};

    *rcMirror = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcMirror, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcMirror = assign_rcMirror(out);
    }
}

void
rapid_city_set_rcMirror(GSnmpSession *s, rapid_city_rcMirror_t *rcMirror, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5, 0, 0};

    if (rcMirror->rcMirrorSaveConfig) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirror->rcMirrorSaveConfig,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcMirror(rapid_city_rcMirror_t *rcMirror)
{
    GSList *vbl;
    char *p;

    if (rcMirror) {
        p = (char *) rcMirror + sizeof(rapid_city_rcMirror_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcMirror);
    }
}

rapid_city_rcMirrorByPort_t *
rapid_city_new_rcMirrorByPort()
{
    rapid_city_rcMirrorByPort_t *rcMirrorByPort;

    rcMirrorByPort = (rapid_city_rcMirrorByPort_t *) g_malloc0(sizeof(rapid_city_rcMirrorByPort_t) + sizeof(gpointer));
    return rcMirrorByPort;
}

static rapid_city_rcMirrorByPort_t *
assign_rcMirrorByPort(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcMirrorByPort_t *rcMirrorByPort;
    guint32 idx;
    char *p;

    rcMirrorByPort = rapid_city_new_rcMirrorByPort();
    if (! rcMirrorByPort) {
        return NULL;
    }

    p = (char *) rcMirrorByPort + sizeof(rapid_city_rcMirrorByPort_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcMirrorByPort, sizeof(oid_rcMirrorByPort)/sizeof(guint32),
                   attr_rcMirrorByPort, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcMirrorByPort->rcMirrorByPortEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcMirrorByPort->rcMirrorByPortMirrorPort = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcMirrorByPort->rcMirrorByPortEnableMirroredPortOne = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcMirrorByPort->rcMirrorByPortMirroredPortOne = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcMirrorByPort->rcMirrorByPortEnableMirroredPortTwo = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcMirrorByPort->rcMirrorByPortMirroredPortTwo = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcMirrorByPort;
}

void
rapid_city_get_rcMirrorByPort(GSnmpSession *s, rapid_city_rcMirrorByPort_t **rcMirrorByPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5, 2, 0};

    *rcMirrorByPort = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcMirrorByPort, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcMirrorByPort = assign_rcMirrorByPort(out);
    }
}

void
rapid_city_set_rcMirrorByPort(GSnmpSession *s, rapid_city_rcMirrorByPort_t *rcMirrorByPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 5, 2, 0, 0};

    if (rcMirrorByPort->rcMirrorByPortEnable) {
        base[10] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortEnable,
                       0);
    }
    if (rcMirrorByPort->rcMirrorByPortMirrorPort) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortMirrorPort,
                       0);
    }
    if (rcMirrorByPort->rcMirrorByPortEnableMirroredPortOne) {
        base[10] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortEnableMirroredPortOne,
                       0);
    }
    if (rcMirrorByPort->rcMirrorByPortMirroredPortOne) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortMirroredPortOne,
                       0);
    }
    if (rcMirrorByPort->rcMirrorByPortEnableMirroredPortTwo) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortEnableMirroredPortTwo,
                       0);
    }
    if (rcMirrorByPort->rcMirrorByPortMirroredPortTwo) {
        base[10] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcMirrorByPort->rcMirrorByPortMirroredPortTwo,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcMirrorByPort(rapid_city_rcMirrorByPort_t *rcMirrorByPort)
{
    GSList *vbl;
    char *p;

    if (rcMirrorByPort) {
        p = (char *) rcMirrorByPort + sizeof(rapid_city_rcMirrorByPort_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcMirrorByPort);
    }
}

rapid_city_rcDipSwitch_t *
rapid_city_new_rcDipSwitch()
{
    rapid_city_rcDipSwitch_t *rcDipSwitch;

    rcDipSwitch = (rapid_city_rcDipSwitch_t *) g_malloc0(sizeof(rapid_city_rcDipSwitch_t) + sizeof(gpointer));
    return rcDipSwitch;
}

static rapid_city_rcDipSwitch_t *
assign_rcDipSwitch(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDipSwitch_t *rcDipSwitch;
    guint32 idx;
    char *p;

    rcDipSwitch = rapid_city_new_rcDipSwitch();
    if (! rcDipSwitch) {
        return NULL;
    }

    p = (char *) rcDipSwitch + sizeof(rapid_city_rcDipSwitch_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDipSwitch, sizeof(oid_rcDipSwitch)/sizeof(guint32),
                   attr_rcDipSwitch, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcDipSwitch->rcIsolateUnconfigPorts = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcDipSwitch->rcUseFactorySettings = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcDipSwitch->rcHighPriorityMode = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDipSwitch;
}

void
rapid_city_get_rcDipSwitch(GSnmpSession *s, rapid_city_rcDipSwitch_t **rcDipSwitch, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 6, 0};

    *rcDipSwitch = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcDipSwitch, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDipSwitch = assign_rcDipSwitch(out);
    }
}

void
rapid_city_free_rcDipSwitch(rapid_city_rcDipSwitch_t *rcDipSwitch)
{
    GSList *vbl;
    char *p;

    if (rcDipSwitch) {
        p = (char *) rcDipSwitch + sizeof(rapid_city_rcDipSwitch_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDipSwitch);
    }
}

rapid_city_rcTblSize_t *
rapid_city_new_rcTblSize()
{
    rapid_city_rcTblSize_t *rcTblSize;

    rcTblSize = (rapid_city_rcTblSize_t *) g_malloc0(sizeof(rapid_city_rcTblSize_t) + sizeof(gpointer));
    return rcTblSize;
}

static rapid_city_rcTblSize_t *
assign_rcTblSize(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcTblSize_t *rcTblSize;
    guint32 idx;
    char *p;

    rcTblSize = rapid_city_new_rcTblSize();
    if (! rcTblSize) {
        return NULL;
    }

    p = (char *) rcTblSize + sizeof(rapid_city_rcTblSize_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcTblSize, sizeof(oid_rcTblSize)/sizeof(guint32),
                   attr_rcTblSize, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcTblSize->rcTblRmonStatSize = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcTblSize->rcTblRmonHistoryControlSize = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcTblSize->rcTblRmonHistoryEnetSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcTblSize->rcTblRmonAlarmSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcTblSize->rcTblRmonEventSize = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcTblSize->rcTblRmonLogSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcTblSize->rcTblArTblSize = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcTblSize->rcTblArFree = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcTblSize->rcTblArNoSpace = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcTblSize->rcTblArAdded = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcTblSize->rcTblArDeleted = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcTblSize->rcTblArMacAdded = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcTblSize->rcTblArMacDeleted = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcTblSize->rcTblArMacMoved = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcTblSize->rcTblArIpAdded = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcTblSize->rcTblArIpDeleted = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcTblSize->rcTblArMcastTblSize = &(vb->syntax.i32[0]);
            break;
        case 18:
            rcTblSize->rcTblArFreeMcastGroups = &(vb->syntax.i32[0]);
            break;
        case 19:
            rcTblSize->rcTblArIpMcastAdded = &(vb->syntax.i32[0]);
            break;
        case 20:
            rcTblSize->rcTblArIpMcastDeleted = &(vb->syntax.i32[0]);
            break;
        case 21:
            rcTblSize->rcTblArVlanByPortAdded = &(vb->syntax.i32[0]);
            break;
        case 22:
            rcTblSize->rcTblArVlanByPortDeleted = &(vb->syntax.i32[0]);
            break;
        case 23:
            rcTblSize->rcTblArVlanByProtocolAdded = &(vb->syntax.i32[0]);
            break;
        case 24:
            rcTblSize->rcTblArVlanByProtocolDeleted = &(vb->syntax.i32[0]);
            break;
        case 25:
            rcTblSize->rcTblArVlanByIpSubnetAdded = &(vb->syntax.i32[0]);
            break;
        case 26:
            rcTblSize->rcTblArVlanByIpSubnetDeleted = &(vb->syntax.i32[0]);
            break;
        case 27:
            rcTblSize->rcTblArIpSubnetsAdded = &(vb->syntax.i32[0]);
            break;
        case 28:
            rcTblSize->rcTblArIpSubnetsDeleted = &(vb->syntax.i32[0]);
            break;
        case 29:
            rcTblSize->rcTblArRsvpsAdded = &(vb->syntax.i32[0]);
            break;
        case 30:
            rcTblSize->rcTblArRsvpsDeleted = &(vb->syntax.i32[0]);
            break;
        case 31:
            rcTblSize->rcTblBrdgFdbSize = &(vb->syntax.i32[0]);
            break;
        case 32:
            rcTblSize->rcTblBrdgStaticSize = &(vb->syntax.i32[0]);
            break;
        case 33:
            rcTblSize->rcTblIpAddrSize = &(vb->syntax.i32[0]);
            break;
        case 34:
            rcTblSize->rcTblIpForwardingSize = &(vb->syntax.i32[0]);
            break;
        case 35:
            rcTblSize->rcTblIpNetToMediaSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcTblSize;
}

void
rapid_city_get_rcTblSize(GSnmpSession *s, rapid_city_rcTblSize_t **rcTblSize, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 7, 0};

    *rcTblSize = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcTblSize, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcTblSize = assign_rcTblSize(out);
    }
}

void
rapid_city_free_rcTblSize(rapid_city_rcTblSize_t *rcTblSize)
{
    GSList *vbl;
    char *p;

    if (rcTblSize) {
        p = (char *) rcTblSize + sizeof(rapid_city_rcTblSize_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcTblSize);
    }
}

rapid_city_rcIpConfEntry_t *
rapid_city_new_rcIpConfEntry()
{
    rapid_city_rcIpConfEntry_t *rcIpConfEntry;

    rcIpConfEntry = (rapid_city_rcIpConfEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfEntry_t) + sizeof(gpointer));
    return rcIpConfEntry;
}

static int
unpack_rcIpConfEntry(GSnmpVarBind *vb, rapid_city_rcIpConfEntry_t *rcIpConfEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpConfEntry->rcIpConfIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfEntry(guint32 *base, gint32 rcIpConfIfIndex)
{
    int idx = 13;

    base[idx++] = rcIpConfIfIndex;
    return idx;
}

static rapid_city_rcIpConfEntry_t *
assign_rcIpConfEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfEntry_t *rcIpConfEntry;
    guint32 idx;
    char *p;

    rcIpConfEntry = rapid_city_new_rcIpConfEntry();
    if (! rcIpConfEntry) {
        return NULL;
    }

    p = (char *) rcIpConfEntry + sizeof(rapid_city_rcIpConfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfEntry((GSnmpVarBind *) vbl->data, rcIpConfEntry) < 0) {
        g_warning("illegal rcIpConfEntry instance identifier");
        g_free(rcIpConfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfEntry, sizeof(oid_rcIpConfEntry)/sizeof(guint32),
                   attr_rcIpConfEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfEntry->rcIpConfAdvertDefRte = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfEntry->rcIpConfAcceptDefRte = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpConfEntry->rcIpConfRowStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpConfEntry->rcIpConfRipEnable = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpConfEntry->rcIpConfOspfEnable = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpConfEntry->rcIpConfIgmpEnable = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpConfEntry->rcIpConfAddrAssigned = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpConfEntry->rcIpConfDhcpEnable = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpConfEntry->rcIpConfTriggeredUpdateEnable = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpConfEntry->rcIpConfRipAutoAggrerateEnable = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcIpConfEntry->rcIpConfRipGenerateDefaultRoute = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfEntry;
}

void
rapid_city_get_rcIpConfTable(GSnmpSession *s, rapid_city_rcIpConfEntry_t ***rcIpConfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 1, 1, 0};

    *rcIpConfEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpConfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfEntry = (rapid_city_rcIpConfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfEntry_t *));
        if (! *rcIpConfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfEntry)[i] = assign_rcIpConfEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfEntry(GSnmpSession *s, rapid_city_rcIpConfEntry_t **rcIpConfEntry, gint32 rcIpConfIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfEntry, sizeof(oid_rcIpConfEntry));
    len = pack_rcIpConfEntry(base, rcIpConfIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfEntry index values");
        return;
    }

    *rcIpConfEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpConfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfEntry = assign_rcIpConfEntry(out);
    }
}

void
rapid_city_set_rcIpConfEntry(GSnmpSession *s, rapid_city_rcIpConfEntry_t *rcIpConfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfEntry, sizeof(oid_rcIpConfEntry));
    len = pack_rcIpConfEntry(base, rcIpConfEntry->rcIpConfIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfEntry index values");
        return;
    }

    if (rcIpConfEntry->rcIpConfAdvertDefRte) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfAdvertDefRte,
                       0);
    }
    if (rcIpConfEntry->rcIpConfAcceptDefRte) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfAcceptDefRte,
                       0);
    }
    if (rcIpConfEntry->rcIpConfRowStatus) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfRowStatus,
                       0);
    }
    if (rcIpConfEntry->rcIpConfRipEnable) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfRipEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfOspfEnable) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfOspfEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfIgmpEnable) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfIgmpEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfDhcpEnable) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfDhcpEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfTriggeredUpdateEnable) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfTriggeredUpdateEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfRipAutoAggrerateEnable) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfRipAutoAggrerateEnable,
                       0);
    }
    if (rcIpConfEntry->rcIpConfRipGenerateDefaultRoute) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfEntry->rcIpConfRipGenerateDefaultRoute,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfEntry(rapid_city_rcIpConfEntry_t *rcIpConfEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfEntry) {
        p = (char *) rcIpConfEntry + sizeof(rapid_city_rcIpConfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfEntry);
    }
}

void
rapid_city_free_rcIpConfTable(rapid_city_rcIpConfEntry_t **rcIpConfEntry)
{
    int i;

    if (rcIpConfEntry) {
        for (i = 0; rcIpConfEntry[i]; i++) {
            rapid_city_free_rcIpConfEntry(rcIpConfEntry[i]);
        }
        g_free(rcIpConfEntry);
    }
}

rapid_city_rcIpConfOspfEntry_t *
rapid_city_new_rcIpConfOspfEntry()
{
    rapid_city_rcIpConfOspfEntry_t *rcIpConfOspfEntry;

    rcIpConfOspfEntry = (rapid_city_rcIpConfOspfEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfOspfEntry_t) + sizeof(gpointer));
    return rcIpConfOspfEntry;
}

static int
unpack_rcIpConfOspfEntry(GSnmpVarBind *vb, rapid_city_rcIpConfOspfEntry_t *rcIpConfOspfEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpConfOspfEntry->rcIpConfOspfIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfOspfEntry(guint32 *base, gint32 rcIpConfOspfIfIndex)
{
    int idx = 13;

    base[idx++] = rcIpConfOspfIfIndex;
    return idx;
}

static rapid_city_rcIpConfOspfEntry_t *
assign_rcIpConfOspfEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfOspfEntry_t *rcIpConfOspfEntry;
    guint32 idx;
    char *p;

    rcIpConfOspfEntry = rapid_city_new_rcIpConfOspfEntry();
    if (! rcIpConfOspfEntry) {
        return NULL;
    }

    p = (char *) rcIpConfOspfEntry + sizeof(rapid_city_rcIpConfOspfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfOspfEntry((GSnmpVarBind *) vbl->data, rcIpConfOspfEntry) < 0) {
        g_warning("illegal rcIpConfOspfEntry instance identifier");
        g_free(rcIpConfOspfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfOspfEntry, sizeof(oid_rcIpConfOspfEntry)/sizeof(guint32),
                   attr_rcIpConfOspfEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfOspfEntry->rcIpConfOspfRtrPriority = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfOspfEntry->rcIpConfOspfMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpConfOspfEntry->rcIpConfOspfAuthKey = vb->syntax.uc;
            break;
        case 5:
            rcIpConfOspfEntry->rcIpConfOspfRowStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpConfOspfEntry->rcIpConfOspfHelloInterval = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpConfOspfEntry->rcIpConfOspfRtrDeadInterval = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpConfOspfEntry->rcIpConfOspfIfAreaId = vb->syntax.uc;
            break;
        case 9:
            rcIpConfOspfEntry->rcIpConfOspfAuthType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfOspfEntry;
}

void
rapid_city_get_rcIpConfOspfTable(GSnmpSession *s, rapid_city_rcIpConfOspfEntry_t ***rcIpConfOspfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 2, 1, 0};

    *rcIpConfOspfEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpConfOspfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfOspfEntry = (rapid_city_rcIpConfOspfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfOspfEntry_t *));
        if (! *rcIpConfOspfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfOspfEntry)[i] = assign_rcIpConfOspfEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfOspfEntry(GSnmpSession *s, rapid_city_rcIpConfOspfEntry_t **rcIpConfOspfEntry, gint32 rcIpConfOspfIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfOspfEntry, sizeof(oid_rcIpConfOspfEntry));
    len = pack_rcIpConfOspfEntry(base, rcIpConfOspfIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfOspfEntry index values");
        return;
    }

    *rcIpConfOspfEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpConfOspfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfOspfEntry = assign_rcIpConfOspfEntry(out);
    }
}

void
rapid_city_set_rcIpConfOspfEntry(GSnmpSession *s, rapid_city_rcIpConfOspfEntry_t *rcIpConfOspfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfOspfEntry, sizeof(oid_rcIpConfOspfEntry));
    len = pack_rcIpConfOspfEntry(base, rcIpConfOspfEntry->rcIpConfOspfIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfOspfEntry index values");
        return;
    }

    if (rcIpConfOspfEntry->rcIpConfOspfRtrPriority) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfRtrPriority,
                       0);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfMetric) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfMetric,
                       0);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfAuthKey) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpConfOspfEntry->rcIpConfOspfAuthKey,
                       8);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfRowStatus) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfRowStatus,
                       0);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfHelloInterval) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfHelloInterval,
                       0);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfRtrDeadInterval) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfRtrDeadInterval,
                       0);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfIfAreaId) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcIpConfOspfEntry->rcIpConfOspfIfAreaId,
                       4);
    }
    if (rcIpConfOspfEntry->rcIpConfOspfAuthType) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfEntry->rcIpConfOspfAuthType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfOspfEntry(rapid_city_rcIpConfOspfEntry_t *rcIpConfOspfEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfOspfEntry) {
        p = (char *) rcIpConfOspfEntry + sizeof(rapid_city_rcIpConfOspfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfOspfEntry);
    }
}

void
rapid_city_free_rcIpConfOspfTable(rapid_city_rcIpConfOspfEntry_t **rcIpConfOspfEntry)
{
    int i;

    if (rcIpConfOspfEntry) {
        for (i = 0; rcIpConfOspfEntry[i]; i++) {
            rapid_city_free_rcIpConfOspfEntry(rcIpConfOspfEntry[i]);
        }
        g_free(rcIpConfOspfEntry);
    }
}

rapid_city_rcIpConfOspfDefaultMetric_t *
rapid_city_new_rcIpConfOspfDefaultMetric()
{
    rapid_city_rcIpConfOspfDefaultMetric_t *rcIpConfOspfDefaultMetric;

    rcIpConfOspfDefaultMetric = (rapid_city_rcIpConfOspfDefaultMetric_t *) g_malloc0(sizeof(rapid_city_rcIpConfOspfDefaultMetric_t) + sizeof(gpointer));
    return rcIpConfOspfDefaultMetric;
}

static rapid_city_rcIpConfOspfDefaultMetric_t *
assign_rcIpConfOspfDefaultMetric(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfOspfDefaultMetric_t *rcIpConfOspfDefaultMetric;
    guint32 idx;
    char *p;

    rcIpConfOspfDefaultMetric = rapid_city_new_rcIpConfOspfDefaultMetric();
    if (! rcIpConfOspfDefaultMetric) {
        return NULL;
    }

    p = (char *) rcIpConfOspfDefaultMetric + sizeof(rapid_city_rcIpConfOspfDefaultMetric_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfOspfDefaultMetric, sizeof(oid_rcIpConfOspfDefaultMetric)/sizeof(guint32),
                   attr_rcIpConfOspfDefaultMetric, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric10MegPort = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric100MegPort = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric1000MegPort = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfOspfDefaultMetric;
}

void
rapid_city_get_rcIpConfOspfDefaultMetric(GSnmpSession *s, rapid_city_rcIpConfOspfDefaultMetric_t **rcIpConfOspfDefaultMetric, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 3, 0};

    *rcIpConfOspfDefaultMetric = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpConfOspfDefaultMetric, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfOspfDefaultMetric = assign_rcIpConfOspfDefaultMetric(out);
    }
}

void
rapid_city_set_rcIpConfOspfDefaultMetric(GSnmpSession *s, rapid_city_rcIpConfOspfDefaultMetric_t *rcIpConfOspfDefaultMetric, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 3, 0, 0};

    if (rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric10MegPort) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric10MegPort,
                       0);
    }
    if (rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric100MegPort) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric100MegPort,
                       0);
    }
    if (rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric1000MegPort) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspfDefaultMetric->rcIpConfOspfDefaultMetric1000MegPort,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfOspfDefaultMetric(rapid_city_rcIpConfOspfDefaultMetric_t *rcIpConfOspfDefaultMetric)
{
    GSList *vbl;
    char *p;

    if (rcIpConfOspfDefaultMetric) {
        p = (char *) rcIpConfOspfDefaultMetric + sizeof(rapid_city_rcIpConfOspfDefaultMetric_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfOspfDefaultMetric);
    }
}

rapid_city_rcIpConfOspf_t *
rapid_city_new_rcIpConfOspf()
{
    rapid_city_rcIpConfOspf_t *rcIpConfOspf;

    rcIpConfOspf = (rapid_city_rcIpConfOspf_t *) g_malloc0(sizeof(rapid_city_rcIpConfOspf_t) + sizeof(gpointer));
    return rcIpConfOspf;
}

static rapid_city_rcIpConfOspf_t *
assign_rcIpConfOspf(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfOspf_t *rcIpConfOspf;
    guint32 idx;
    char *p;

    rcIpConfOspf = rapid_city_new_rcIpConfOspf();
    if (! rcIpConfOspf) {
        return NULL;
    }

    p = (char *) rcIpConfOspf + sizeof(rapid_city_rcIpConfOspf_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfOspf, sizeof(oid_rcIpConfOspf)/sizeof(guint32),
                   attr_rcIpConfOspf, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpConfOspf->rcIpConfOspfTrapEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpConfOspf->rcIpConfOspfAutoVirtLinkEnable = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfOspf->rcIpConfOspfSpfHoldDownTime = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfOspf;
}

void
rapid_city_get_rcIpConfOspf(GSnmpSession *s, rapid_city_rcIpConfOspf_t **rcIpConfOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 4, 0};

    *rcIpConfOspf = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpConfOspf, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfOspf = assign_rcIpConfOspf(out);
    }
}

void
rapid_city_set_rcIpConfOspf(GSnmpSession *s, rapid_city_rcIpConfOspf_t *rcIpConfOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 4, 0, 0};

    if (rcIpConfOspf->rcIpConfOspfTrapEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspf->rcIpConfOspfTrapEnable,
                       0);
    }
    if (rcIpConfOspf->rcIpConfOspfAutoVirtLinkEnable) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspf->rcIpConfOspfAutoVirtLinkEnable,
                       0);
    }
    if (rcIpConfOspf->rcIpConfOspfSpfHoldDownTime) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfOspf->rcIpConfOspfSpfHoldDownTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfOspf(rapid_city_rcIpConfOspf_t *rcIpConfOspf)
{
    GSList *vbl;
    char *p;

    if (rcIpConfOspf) {
        p = (char *) rcIpConfOspf + sizeof(rapid_city_rcIpConfOspf_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfOspf);
    }
}

rapid_city_rcIpConfGlobal_t *
rapid_city_new_rcIpConfGlobal()
{
    rapid_city_rcIpConfGlobal_t *rcIpConfGlobal;

    rcIpConfGlobal = (rapid_city_rcIpConfGlobal_t *) g_malloc0(sizeof(rapid_city_rcIpConfGlobal_t) + sizeof(gpointer));
    return rcIpConfGlobal;
}

static rapid_city_rcIpConfGlobal_t *
assign_rcIpConfGlobal(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfGlobal_t *rcIpConfGlobal;
    guint32 idx;
    char *p;

    rcIpConfGlobal = rapid_city_new_rcIpConfGlobal();
    if (! rcIpConfGlobal) {
        return NULL;
    }

    p = (char *) rcIpConfGlobal + sizeof(rapid_city_rcIpConfGlobal_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfGlobal, sizeof(oid_rcIpConfGlobal)/sizeof(guint32),
                   attr_rcIpConfGlobal, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpConfGlobal->rcIpConfGlobalRipHoldDownTime = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfGlobal;
}

void
rapid_city_get_rcIpConfGlobal(GSnmpSession *s, rapid_city_rcIpConfGlobal_t **rcIpConfGlobal, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 6, 0};

    *rcIpConfGlobal = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpConfGlobal, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfGlobal = assign_rcIpConfGlobal(out);
    }
}

void
rapid_city_set_rcIpConfGlobal(GSnmpSession *s, rapid_city_rcIpConfGlobal_t *rcIpConfGlobal, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 6, 0, 0};

    if (rcIpConfGlobal->rcIpConfGlobalRipHoldDownTime) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpConfGlobal->rcIpConfGlobalRipHoldDownTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfGlobal(rapid_city_rcIpConfGlobal_t *rcIpConfGlobal)
{
    GSList *vbl;
    char *p;

    if (rcIpConfGlobal) {
        p = (char *) rcIpConfGlobal + sizeof(rapid_city_rcIpConfGlobal_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfGlobal);
    }
}

rapid_city_rcIpConfOspfAreaEntry_t *
rapid_city_new_rcIpConfOspfAreaEntry()
{
    rapid_city_rcIpConfOspfAreaEntry_t *rcIpConfOspfAreaEntry;

    rcIpConfOspfAreaEntry = (rapid_city_rcIpConfOspfAreaEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfOspfAreaEntry_t) + sizeof(gpointer));
    return rcIpConfOspfAreaEntry;
}

static int
unpack_rcIpConfOspfAreaEntry(GSnmpVarBind *vb, rapid_city_rcIpConfOspfAreaEntry_t *rcIpConfOspfAreaEntry)
{
    int i, len, idx = 13;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpConfOspfAreaEntry->rcIpConfOspfAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfOspfAreaEntry(guint32 *base, guchar *rcIpConfOspfAreaId)
{
    int i, len, idx = 13;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpConfOspfAreaId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpConfOspfAreaEntry_t *
assign_rcIpConfOspfAreaEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfOspfAreaEntry_t *rcIpConfOspfAreaEntry;
    guint32 idx;
    char *p;

    rcIpConfOspfAreaEntry = rapid_city_new_rcIpConfOspfAreaEntry();
    if (! rcIpConfOspfAreaEntry) {
        return NULL;
    }

    p = (char *) rcIpConfOspfAreaEntry + sizeof(rapid_city_rcIpConfOspfAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfOspfAreaEntry((GSnmpVarBind *) vbl->data, rcIpConfOspfAreaEntry) < 0) {
        g_warning("illegal rcIpConfOspfAreaEntry instance identifier");
        g_free(rcIpConfOspfAreaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfOspfAreaEntry, sizeof(oid_rcIpConfOspfAreaEntry)/sizeof(guint32),
                   attr_rcIpConfOspfAreaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfOspfAreaEntry->rcIpConfOspfAreaImportSummary = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfOspfAreaEntry->rcIpConfOspfAreaActiveIfCount = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfOspfAreaEntry;
}

void
rapid_city_get_rcIpConfOspfAreaTable(GSnmpSession *s, rapid_city_rcIpConfOspfAreaEntry_t ***rcIpConfOspfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 1, 7, 1, 0};

    *rcIpConfOspfAreaEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpConfOspfAreaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfOspfAreaEntry = (rapid_city_rcIpConfOspfAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfOspfAreaEntry_t *));
        if (! *rcIpConfOspfAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfOspfAreaEntry)[i] = assign_rcIpConfOspfAreaEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfOspfAreaEntry(GSnmpSession *s, rapid_city_rcIpConfOspfAreaEntry_t **rcIpConfOspfAreaEntry, guchar *rcIpConfOspfAreaId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfOspfAreaEntry, sizeof(oid_rcIpConfOspfAreaEntry));
    len = pack_rcIpConfOspfAreaEntry(base, rcIpConfOspfAreaId);
    if (len < 0) {
        g_warning("illegal rcIpConfOspfAreaEntry index values");
        return;
    }

    *rcIpConfOspfAreaEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpConfOspfAreaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfOspfAreaEntry = assign_rcIpConfOspfAreaEntry(out);
    }
}

void
rapid_city_set_rcIpConfOspfAreaEntry(GSnmpSession *s, rapid_city_rcIpConfOspfAreaEntry_t *rcIpConfOspfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfOspfAreaEntry, sizeof(oid_rcIpConfOspfAreaEntry));
    len = pack_rcIpConfOspfAreaEntry(base, rcIpConfOspfAreaEntry->rcIpConfOspfAreaId);
    if (len < 0) {
        g_warning("illegal rcIpConfOspfAreaEntry index values");
        return;
    }

    if (rcIpConfOspfAreaEntry->rcIpConfOspfAreaImportSummary) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfOspfAreaEntry->rcIpConfOspfAreaImportSummary,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfOspfAreaEntry(rapid_city_rcIpConfOspfAreaEntry_t *rcIpConfOspfAreaEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfOspfAreaEntry) {
        p = (char *) rcIpConfOspfAreaEntry + sizeof(rapid_city_rcIpConfOspfAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfOspfAreaEntry);
    }
}

void
rapid_city_free_rcIpConfOspfAreaTable(rapid_city_rcIpConfOspfAreaEntry_t **rcIpConfOspfAreaEntry)
{
    int i;

    if (rcIpConfOspfAreaEntry) {
        for (i = 0; rcIpConfOspfAreaEntry[i]; i++) {
            rapid_city_free_rcIpConfOspfAreaEntry(rcIpConfOspfAreaEntry[i]);
        }
        g_free(rcIpConfOspfAreaEntry);
    }
}

rapid_city_rcIpAddrEntry_t *
rapid_city_new_rcIpAddrEntry()
{
    rapid_city_rcIpAddrEntry_t *rcIpAddrEntry;

    rcIpAddrEntry = (rapid_city_rcIpAddrEntry_t *) g_malloc0(sizeof(rapid_city_rcIpAddrEntry_t) + sizeof(gpointer));
    return rcIpAddrEntry;
}

static int
unpack_rcIpAddrEntry(GSnmpVarBind *vb, rapid_city_rcIpAddrEntry_t *rcIpAddrEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcIpAddrEntry->rcIpAdEntIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpAddrEntry->rcIpAdEntAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpAddrEntry(guint32 *base, gint32 rcIpAdEntIfIndex, guchar *rcIpAdEntAddr)
{
    int i, len, idx = 12;

    base[idx++] = rcIpAdEntIfIndex;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpAdEntAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpAddrEntry_t *
assign_rcIpAddrEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpAddrEntry_t *rcIpAddrEntry;
    guint32 idx;
    char *p;

    rcIpAddrEntry = rapid_city_new_rcIpAddrEntry();
    if (! rcIpAddrEntry) {
        return NULL;
    }

    p = (char *) rcIpAddrEntry + sizeof(rapid_city_rcIpAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpAddrEntry((GSnmpVarBind *) vbl->data, rcIpAddrEntry) < 0) {
        g_warning("illegal rcIpAddrEntry instance identifier");
        g_free(rcIpAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpAddrEntry, sizeof(oid_rcIpAddrEntry)/sizeof(guint32),
                   attr_rcIpAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpAddrEntry->rcIpAdEntNetMask = vb->syntax.uc;
            break;
        case 4:
            rcIpAddrEntry->rcIpAdEntBcastAddrFormat = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpAddrEntry->rcIpAdEntReasmMaxSize = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpAddrEntry->rcIpAdEntRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpAddrEntry;
}

void
rapid_city_get_rcIpAddrTable(GSnmpSession *s, rapid_city_rcIpAddrEntry_t ***rcIpAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 2, 1, 0};

    *rcIpAddrEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpAddrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpAddrEntry = (rapid_city_rcIpAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpAddrEntry_t *));
        if (! *rcIpAddrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpAddrEntry)[i] = assign_rcIpAddrEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpAddrEntry(GSnmpSession *s, rapid_city_rcIpAddrEntry_t **rcIpAddrEntry, gint32 rcIpAdEntIfIndex, guchar *rcIpAdEntAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpAddrEntry, sizeof(oid_rcIpAddrEntry));
    len = pack_rcIpAddrEntry(base, rcIpAdEntIfIndex, rcIpAdEntAddr);
    if (len < 0) {
        g_warning("illegal rcIpAddrEntry index values");
        return;
    }

    *rcIpAddrEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpAddrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpAddrEntry = assign_rcIpAddrEntry(out);
    }
}

void
rapid_city_set_rcIpAddrEntry(GSnmpSession *s, rapid_city_rcIpAddrEntry_t *rcIpAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpAddrEntry, sizeof(oid_rcIpAddrEntry));
    len = pack_rcIpAddrEntry(base, rcIpAddrEntry->rcIpAdEntIfIndex, rcIpAddrEntry->rcIpAdEntAddr);
    if (len < 0) {
        g_warning("illegal rcIpAddrEntry index values");
        return;
    }

    if (rcIpAddrEntry->rcIpAdEntNetMask) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcIpAddrEntry->rcIpAdEntNetMask,
                       4);
    }
    if (rcIpAddrEntry->rcIpAdEntRowStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpAddrEntry->rcIpAdEntRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpAddrEntry(rapid_city_rcIpAddrEntry_t *rcIpAddrEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpAddrEntry) {
        p = (char *) rcIpAddrEntry + sizeof(rapid_city_rcIpAddrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpAddrEntry);
    }
}

void
rapid_city_free_rcIpAddrTable(rapid_city_rcIpAddrEntry_t **rcIpAddrEntry)
{
    int i;

    if (rcIpAddrEntry) {
        for (i = 0; rcIpAddrEntry[i]; i++) {
            rapid_city_free_rcIpAddrEntry(rcIpAddrEntry[i]);
        }
        g_free(rcIpAddrEntry);
    }
}

rapid_city_rcIpFlowEntry_t *
rapid_city_new_rcIpFlowEntry()
{
    rapid_city_rcIpFlowEntry_t *rcIpFlowEntry;

    rcIpFlowEntry = (rapid_city_rcIpFlowEntry_t *) g_malloc0(sizeof(rapid_city_rcIpFlowEntry_t) + sizeof(gpointer));
    return rcIpFlowEntry;
}

static int
unpack_rcIpFlowEntry(GSnmpVarBind *vb, rapid_city_rcIpFlowEntry_t *rcIpFlowEntry)
{
    int i, len, idx = 12;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFlowEntry->rcIpFlowSrcIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcIpFlowEntry->rcIpFlowSrcIpPort = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFlowEntry->rcIpFlowDstIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcIpFlowEntry->rcIpFlowDstIpPort = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    rcIpFlowEntry->rcIpFlowProtocol = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpFlowEntry(guint32 *base, guchar *rcIpFlowSrcIpAddress, gint32 rcIpFlowSrcIpPort, guchar *rcIpFlowDstIpAddress, gint32 rcIpFlowDstIpPort, gint32 rcIpFlowProtocol)
{
    int i, len, idx = 12;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFlowSrcIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcIpFlowSrcIpPort;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFlowDstIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcIpFlowDstIpPort;
    base[idx++] = rcIpFlowProtocol;
    return idx;
}

static rapid_city_rcIpFlowEntry_t *
assign_rcIpFlowEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFlowEntry_t *rcIpFlowEntry;
    guint32 idx;
    char *p;

    rcIpFlowEntry = rapid_city_new_rcIpFlowEntry();
    if (! rcIpFlowEntry) {
        return NULL;
    }

    p = (char *) rcIpFlowEntry + sizeof(rapid_city_rcIpFlowEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpFlowEntry((GSnmpVarBind *) vbl->data, rcIpFlowEntry) < 0) {
        g_warning("illegal rcIpFlowEntry instance identifier");
        g_free(rcIpFlowEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFlowEntry, sizeof(oid_rcIpFlowEntry)/sizeof(guint32),
                   attr_rcIpFlowEntry, &idx) < 0) continue;

        switch (idx) {
        case 6:
            rcIpFlowEntry->rcIpFlowRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpFlowEntry;
}

void
rapid_city_get_rcIpFlowTable(GSnmpSession *s, rapid_city_rcIpFlowEntry_t ***rcIpFlowEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 3, 1, 0};

    *rcIpFlowEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpFlowEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpFlowEntry = (rapid_city_rcIpFlowEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpFlowEntry_t *));
        if (! *rcIpFlowEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpFlowEntry)[i] = assign_rcIpFlowEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpFlowEntry(GSnmpSession *s, rapid_city_rcIpFlowEntry_t **rcIpFlowEntry, guchar *rcIpFlowSrcIpAddress, gint32 rcIpFlowSrcIpPort, guchar *rcIpFlowDstIpAddress, gint32 rcIpFlowDstIpPort, gint32 rcIpFlowProtocol, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFlowEntry, sizeof(oid_rcIpFlowEntry));
    len = pack_rcIpFlowEntry(base, rcIpFlowSrcIpAddress, rcIpFlowSrcIpPort, rcIpFlowDstIpAddress, rcIpFlowDstIpPort, rcIpFlowProtocol);
    if (len < 0) {
        g_warning("illegal rcIpFlowEntry index values");
        return;
    }

    *rcIpFlowEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpFlowEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFlowEntry = assign_rcIpFlowEntry(out);
    }
}

void
rapid_city_set_rcIpFlowEntry(GSnmpSession *s, rapid_city_rcIpFlowEntry_t *rcIpFlowEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFlowEntry, sizeof(oid_rcIpFlowEntry));
    len = pack_rcIpFlowEntry(base, rcIpFlowEntry->rcIpFlowSrcIpAddress, rcIpFlowEntry->rcIpFlowSrcIpPort, rcIpFlowEntry->rcIpFlowDstIpAddress, rcIpFlowEntry->rcIpFlowDstIpPort, rcIpFlowEntry->rcIpFlowProtocol);
    if (len < 0) {
        g_warning("illegal rcIpFlowEntry index values");
        return;
    }

    if (rcIpFlowEntry->rcIpFlowRowStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFlowEntry->rcIpFlowRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpFlowEntry(rapid_city_rcIpFlowEntry_t *rcIpFlowEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpFlowEntry) {
        p = (char *) rcIpFlowEntry + sizeof(rapid_city_rcIpFlowEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFlowEntry);
    }
}

void
rapid_city_free_rcIpFlowTable(rapid_city_rcIpFlowEntry_t **rcIpFlowEntry)
{
    int i;

    if (rcIpFlowEntry) {
        for (i = 0; rcIpFlowEntry[i]; i++) {
            rapid_city_free_rcIpFlowEntry(rcIpFlowEntry[i]);
        }
        g_free(rcIpFlowEntry);
    }
}

rapid_city_rcIpRoutingRedistributeRipToOspf_t *
rapid_city_new_rcIpRoutingRedistributeRipToOspf()
{
    rapid_city_rcIpRoutingRedistributeRipToOspf_t *rcIpRoutingRedistributeRipToOspf;

    rcIpRoutingRedistributeRipToOspf = (rapid_city_rcIpRoutingRedistributeRipToOspf_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeRipToOspf_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeRipToOspf;
}

static rapid_city_rcIpRoutingRedistributeRipToOspf_t *
assign_rcIpRoutingRedistributeRipToOspf(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeRipToOspf_t *rcIpRoutingRedistributeRipToOspf;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeRipToOspf = rapid_city_new_rcIpRoutingRedistributeRipToOspf();
    if (! rcIpRoutingRedistributeRipToOspf) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeRipToOspf + sizeof(rapid_city_rcIpRoutingRedistributeRipToOspf_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeRipToOspf, sizeof(oid_rcIpRoutingRedistributeRipToOspf)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeRipToOspf, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfUseExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExternalMetricType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeRipToOspf;
}

void
rapid_city_get_rcIpRoutingRedistributeRipToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeRipToOspf_t **rcIpRoutingRedistributeRipToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 1, 0};

    *rcIpRoutingRedistributeRipToOspf = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeRipToOspf, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeRipToOspf = assign_rcIpRoutingRedistributeRipToOspf(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeRipToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeRipToOspf_t *rcIpRoutingRedistributeRipToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 1, 0, 0};

    if (rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfEnable,
                       0);
    }
    if (rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExplicitMetric) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfUseExplicitMetric) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfUseExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExternalMetricType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeRipToOspf->rcIpRoutingRedistributeRipToOspfExternalMetricType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeRipToOspf(rapid_city_rcIpRoutingRedistributeRipToOspf_t *rcIpRoutingRedistributeRipToOspf)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeRipToOspf) {
        p = (char *) rcIpRoutingRedistributeRipToOspf + sizeof(rapid_city_rcIpRoutingRedistributeRipToOspf_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeRipToOspf);
    }
}

rapid_city_rcIpRoutingRedistributeOspfToRip_t *
rapid_city_new_rcIpRoutingRedistributeOspfToRip()
{
    rapid_city_rcIpRoutingRedistributeOspfToRip_t *rcIpRoutingRedistributeOspfToRip;

    rcIpRoutingRedistributeOspfToRip = (rapid_city_rcIpRoutingRedistributeOspfToRip_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeOspfToRip_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeOspfToRip;
}

static rapid_city_rcIpRoutingRedistributeOspfToRip_t *
assign_rcIpRoutingRedistributeOspfToRip(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeOspfToRip_t *rcIpRoutingRedistributeOspfToRip;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeOspfToRip = rapid_city_new_rcIpRoutingRedistributeOspfToRip();
    if (! rcIpRoutingRedistributeOspfToRip) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeOspfToRip + sizeof(rapid_city_rcIpRoutingRedistributeOspfToRip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeOspfToRip, sizeof(oid_rcIpRoutingRedistributeOspfToRip)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeOspfToRip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipUseExplicitMetric = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeOspfToRip;
}

void
rapid_city_get_rcIpRoutingRedistributeOspfToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeOspfToRip_t **rcIpRoutingRedistributeOspfToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 2, 0};

    *rcIpRoutingRedistributeOspfToRip = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeOspfToRip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeOspfToRip = assign_rcIpRoutingRedistributeOspfToRip(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeOspfToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeOspfToRip_t *rcIpRoutingRedistributeOspfToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 2, 0, 0};

    if (rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipEnable,
                       0);
    }
    if (rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipExplicitMetric) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipUseExplicitMetric) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeOspfToRip->rcIpRoutingRedistributeOspfToRipUseExplicitMetric,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeOspfToRip(rapid_city_rcIpRoutingRedistributeOspfToRip_t *rcIpRoutingRedistributeOspfToRip)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeOspfToRip) {
        p = (char *) rcIpRoutingRedistributeOspfToRip + sizeof(rapid_city_rcIpRoutingRedistributeOspfToRip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeOspfToRip);
    }
}

rapid_city_rcIpRoutingRedistributeDirectToOspf_t *
rapid_city_new_rcIpRoutingRedistributeDirectToOspf()
{
    rapid_city_rcIpRoutingRedistributeDirectToOspf_t *rcIpRoutingRedistributeDirectToOspf;

    rcIpRoutingRedistributeDirectToOspf = (rapid_city_rcIpRoutingRedistributeDirectToOspf_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeDirectToOspf_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeDirectToOspf;
}

static rapid_city_rcIpRoutingRedistributeDirectToOspf_t *
assign_rcIpRoutingRedistributeDirectToOspf(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeDirectToOspf_t *rcIpRoutingRedistributeDirectToOspf;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeDirectToOspf = rapid_city_new_rcIpRoutingRedistributeDirectToOspf();
    if (! rcIpRoutingRedistributeDirectToOspf) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeDirectToOspf + sizeof(rapid_city_rcIpRoutingRedistributeDirectToOspf_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeDirectToOspf, sizeof(oid_rcIpRoutingRedistributeDirectToOspf)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeDirectToOspf, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfMethod = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExternalMetricType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeDirectToOspf;
}

void
rapid_city_get_rcIpRoutingRedistributeDirectToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeDirectToOspf_t **rcIpRoutingRedistributeDirectToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 3, 0};

    *rcIpRoutingRedistributeDirectToOspf = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeDirectToOspf, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeDirectToOspf = assign_rcIpRoutingRedistributeDirectToOspf(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeDirectToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeDirectToOspf_t *rcIpRoutingRedistributeDirectToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 3, 0, 0};

    if (rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfEnable,
                       0);
    }
    if (rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfMethod) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfMethod,
                       0);
    }
    if (rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExplicitMetric) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExternalMetricType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeDirectToOspf->rcIpRoutingRedistributeDirectToOspfExternalMetricType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeDirectToOspf(rapid_city_rcIpRoutingRedistributeDirectToOspf_t *rcIpRoutingRedistributeDirectToOspf)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeDirectToOspf) {
        p = (char *) rcIpRoutingRedistributeDirectToOspf + sizeof(rapid_city_rcIpRoutingRedistributeDirectToOspf_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeDirectToOspf);
    }
}

rapid_city_rcIpRoutingRedistributeStaticToOspf_t *
rapid_city_new_rcIpRoutingRedistributeStaticToOspf()
{
    rapid_city_rcIpRoutingRedistributeStaticToOspf_t *rcIpRoutingRedistributeStaticToOspf;

    rcIpRoutingRedistributeStaticToOspf = (rapid_city_rcIpRoutingRedistributeStaticToOspf_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeStaticToOspf_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeStaticToOspf;
}

static rapid_city_rcIpRoutingRedistributeStaticToOspf_t *
assign_rcIpRoutingRedistributeStaticToOspf(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeStaticToOspf_t *rcIpRoutingRedistributeStaticToOspf;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeStaticToOspf = rapid_city_new_rcIpRoutingRedistributeStaticToOspf();
    if (! rcIpRoutingRedistributeStaticToOspf) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeStaticToOspf + sizeof(rapid_city_rcIpRoutingRedistributeStaticToOspf_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeStaticToOspf, sizeof(oid_rcIpRoutingRedistributeStaticToOspf)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeStaticToOspf, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfUseExplicitMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExternalMetricType = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfAdvertDefRte = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeStaticToOspf;
}

void
rapid_city_get_rcIpRoutingRedistributeStaticToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeStaticToOspf_t **rcIpRoutingRedistributeStaticToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 4, 0};

    *rcIpRoutingRedistributeStaticToOspf = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeStaticToOspf, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeStaticToOspf = assign_rcIpRoutingRedistributeStaticToOspf(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeStaticToOspf(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeStaticToOspf_t *rcIpRoutingRedistributeStaticToOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 4, 0, 0};

    if (rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfEnable,
                       0);
    }
    if (rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExplicitMetric) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfUseExplicitMetric) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfUseExplicitMetric,
                       0);
    }
    if (rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExternalMetricType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfExternalMetricType,
                       0);
    }
    if (rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfAdvertDefRte) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToOspf->rcIpRoutingRedistributeStaticToOspfAdvertDefRte,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeStaticToOspf(rapid_city_rcIpRoutingRedistributeStaticToOspf_t *rcIpRoutingRedistributeStaticToOspf)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeStaticToOspf) {
        p = (char *) rcIpRoutingRedistributeStaticToOspf + sizeof(rapid_city_rcIpRoutingRedistributeStaticToOspf_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeStaticToOspf);
    }
}

rapid_city_rcIpRoutingRedistributeDirectToRip_t *
rapid_city_new_rcIpRoutingRedistributeDirectToRip()
{
    rapid_city_rcIpRoutingRedistributeDirectToRip_t *rcIpRoutingRedistributeDirectToRip;

    rcIpRoutingRedistributeDirectToRip = (rapid_city_rcIpRoutingRedistributeDirectToRip_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeDirectToRip_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeDirectToRip;
}

static rapid_city_rcIpRoutingRedistributeDirectToRip_t *
assign_rcIpRoutingRedistributeDirectToRip(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeDirectToRip_t *rcIpRoutingRedistributeDirectToRip;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeDirectToRip = rapid_city_new_rcIpRoutingRedistributeDirectToRip();
    if (! rcIpRoutingRedistributeDirectToRip) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeDirectToRip + sizeof(rapid_city_rcIpRoutingRedistributeDirectToRip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeDirectToRip, sizeof(oid_rcIpRoutingRedistributeDirectToRip)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeDirectToRip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeDirectToRip->rcIpRoutingRedistributeDirectToRipEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeDirectToRip;
}

void
rapid_city_get_rcIpRoutingRedistributeDirectToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeDirectToRip_t **rcIpRoutingRedistributeDirectToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 5, 0};

    *rcIpRoutingRedistributeDirectToRip = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeDirectToRip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeDirectToRip = assign_rcIpRoutingRedistributeDirectToRip(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeDirectToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeDirectToRip_t *rcIpRoutingRedistributeDirectToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 5, 0, 0};

    if (rcIpRoutingRedistributeDirectToRip->rcIpRoutingRedistributeDirectToRipEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeDirectToRip->rcIpRoutingRedistributeDirectToRipEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeDirectToRip(rapid_city_rcIpRoutingRedistributeDirectToRip_t *rcIpRoutingRedistributeDirectToRip)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeDirectToRip) {
        p = (char *) rcIpRoutingRedistributeDirectToRip + sizeof(rapid_city_rcIpRoutingRedistributeDirectToRip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeDirectToRip);
    }
}

rapid_city_rcIpRoutingRedistributeStaticToRip_t *
rapid_city_new_rcIpRoutingRedistributeStaticToRip()
{
    rapid_city_rcIpRoutingRedistributeStaticToRip_t *rcIpRoutingRedistributeStaticToRip;

    rcIpRoutingRedistributeStaticToRip = (rapid_city_rcIpRoutingRedistributeStaticToRip_t *) g_malloc0(sizeof(rapid_city_rcIpRoutingRedistributeStaticToRip_t) + sizeof(gpointer));
    return rcIpRoutingRedistributeStaticToRip;
}

static rapid_city_rcIpRoutingRedistributeStaticToRip_t *
assign_rcIpRoutingRedistributeStaticToRip(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRoutingRedistributeStaticToRip_t *rcIpRoutingRedistributeStaticToRip;
    guint32 idx;
    char *p;

    rcIpRoutingRedistributeStaticToRip = rapid_city_new_rcIpRoutingRedistributeStaticToRip();
    if (! rcIpRoutingRedistributeStaticToRip) {
        return NULL;
    }

    p = (char *) rcIpRoutingRedistributeStaticToRip + sizeof(rapid_city_rcIpRoutingRedistributeStaticToRip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRoutingRedistributeStaticToRip, sizeof(oid_rcIpRoutingRedistributeStaticToRip)/sizeof(guint32),
                   attr_rcIpRoutingRedistributeStaticToRip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpRoutingRedistributeStaticToRip->rcIpRoutingRedistributeStaticToRipEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRoutingRedistributeStaticToRip;
}

void
rapid_city_get_rcIpRoutingRedistributeStaticToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeStaticToRip_t **rcIpRoutingRedistributeStaticToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 6, 0};

    *rcIpRoutingRedistributeStaticToRip = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRoutingRedistributeStaticToRip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRoutingRedistributeStaticToRip = assign_rcIpRoutingRedistributeStaticToRip(out);
    }
}

void
rapid_city_set_rcIpRoutingRedistributeStaticToRip(GSnmpSession *s, rapid_city_rcIpRoutingRedistributeStaticToRip_t *rcIpRoutingRedistributeStaticToRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 4, 6, 0, 0};

    if (rcIpRoutingRedistributeStaticToRip->rcIpRoutingRedistributeStaticToRipEnable) {
        base[11] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpRoutingRedistributeStaticToRip->rcIpRoutingRedistributeStaticToRipEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRoutingRedistributeStaticToRip(rapid_city_rcIpRoutingRedistributeStaticToRip_t *rcIpRoutingRedistributeStaticToRip)
{
    GSList *vbl;
    char *p;

    if (rcIpRoutingRedistributeStaticToRip) {
        p = (char *) rcIpRoutingRedistributeStaticToRip + sizeof(rapid_city_rcIpRoutingRedistributeStaticToRip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRoutingRedistributeStaticToRip);
    }
}

rapid_city_rcIpConfIgmpEntry_t *
rapid_city_new_rcIpConfIgmpEntry()
{
    rapid_city_rcIpConfIgmpEntry_t *rcIpConfIgmpEntry;

    rcIpConfIgmpEntry = (rapid_city_rcIpConfIgmpEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfIgmpEntry_t) + sizeof(gpointer));
    return rcIpConfIgmpEntry;
}

static int
unpack_rcIpConfIgmpEntry(GSnmpVarBind *vb, rapid_city_rcIpConfIgmpEntry_t *rcIpConfIgmpEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcIpConfIgmpEntry->rcIpConfIgmpIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfIgmpEntry(guint32 *base, gint32 rcIpConfIgmpIfIndex)
{
    int idx = 12;

    base[idx++] = rcIpConfIgmpIfIndex;
    return idx;
}

static rapid_city_rcIpConfIgmpEntry_t *
assign_rcIpConfIgmpEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfIgmpEntry_t *rcIpConfIgmpEntry;
    guint32 idx;
    char *p;

    rcIpConfIgmpEntry = rapid_city_new_rcIpConfIgmpEntry();
    if (! rcIpConfIgmpEntry) {
        return NULL;
    }

    p = (char *) rcIpConfIgmpEntry + sizeof(rapid_city_rcIpConfIgmpEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfIgmpEntry((GSnmpVarBind *) vbl->data, rcIpConfIgmpEntry) < 0) {
        g_warning("illegal rcIpConfIgmpEntry instance identifier");
        g_free(rcIpConfIgmpEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfIgmpEntry, sizeof(oid_rcIpConfIgmpEntry)/sizeof(guint32),
                   attr_rcIpConfIgmpEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfIgmpEntry->rcIpConfIgmpQueryInterval = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfIgmpEntry->rcIpConfIgmpVersion = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpConfIgmpEntry->rcIpConfIgmpQueryMaxResponseTime = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpConfIgmpEntry->rcIpConfIgmpQuerierPresentTimeout = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpConfIgmpEntry->rcIpConfIgmpLeaveEnabled = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpConfIgmpEntry->rcIpConfIgmpRowStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpConfIgmpEntry->rcIpConfIgmpRobustness = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpConfIgmpEntry->rcIpConfIgmpLastMemberQueryInterval = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfIgmpEntry;
}

void
rapid_city_get_rcIpConfIgmpTable(GSnmpSession *s, rapid_city_rcIpConfIgmpEntry_t ***rcIpConfIgmpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 5, 1, 0};

    *rcIpConfIgmpEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpConfIgmpEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfIgmpEntry = (rapid_city_rcIpConfIgmpEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfIgmpEntry_t *));
        if (! *rcIpConfIgmpEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfIgmpEntry)[i] = assign_rcIpConfIgmpEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfIgmpEntry(GSnmpSession *s, rapid_city_rcIpConfIgmpEntry_t **rcIpConfIgmpEntry, gint32 rcIpConfIgmpIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfIgmpEntry, sizeof(oid_rcIpConfIgmpEntry));
    len = pack_rcIpConfIgmpEntry(base, rcIpConfIgmpIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfIgmpEntry index values");
        return;
    }

    *rcIpConfIgmpEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpConfIgmpEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfIgmpEntry = assign_rcIpConfIgmpEntry(out);
    }
}

void
rapid_city_set_rcIpConfIgmpEntry(GSnmpSession *s, rapid_city_rcIpConfIgmpEntry_t *rcIpConfIgmpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfIgmpEntry, sizeof(oid_rcIpConfIgmpEntry));
    len = pack_rcIpConfIgmpEntry(base, rcIpConfIgmpEntry->rcIpConfIgmpIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfIgmpEntry index values");
        return;
    }

    if (rcIpConfIgmpEntry->rcIpConfIgmpQueryInterval) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpQueryInterval,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpVersion) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpVersion,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpQueryMaxResponseTime) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpQueryMaxResponseTime,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpQuerierPresentTimeout) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpQuerierPresentTimeout,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpLeaveEnabled) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpLeaveEnabled,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpRowStatus) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpRowStatus,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpRobustness) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpRobustness,
                       0);
    }
    if (rcIpConfIgmpEntry->rcIpConfIgmpLastMemberQueryInterval) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfIgmpEntry->rcIpConfIgmpLastMemberQueryInterval,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfIgmpEntry(rapid_city_rcIpConfIgmpEntry_t *rcIpConfIgmpEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfIgmpEntry) {
        p = (char *) rcIpConfIgmpEntry + sizeof(rapid_city_rcIpConfIgmpEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfIgmpEntry);
    }
}

void
rapid_city_free_rcIpConfIgmpTable(rapid_city_rcIpConfIgmpEntry_t **rcIpConfIgmpEntry)
{
    int i;

    if (rcIpConfIgmpEntry) {
        for (i = 0; rcIpConfIgmpEntry[i]; i++) {
            rapid_city_free_rcIpConfIgmpEntry(rcIpConfIgmpEntry[i]);
        }
        g_free(rcIpConfIgmpEntry);
    }
}

rapid_city_rcIgmpGroupEntry_t *
rapid_city_new_rcIgmpGroupEntry()
{
    rapid_city_rcIgmpGroupEntry_t *rcIgmpGroupEntry;

    rcIgmpGroupEntry = (rapid_city_rcIgmpGroupEntry_t *) g_malloc0(sizeof(rapid_city_rcIgmpGroupEntry_t) + sizeof(gpointer));
    return rcIgmpGroupEntry;
}

static int
unpack_rcIgmpGroupEntry(GSnmpVarBind *vb, rapid_city_rcIgmpGroupEntry_t *rcIgmpGroupEntry)
{
    int i, len, idx = 12;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIgmpGroupEntry->rcIgmpGroupIpAddress[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIgmpGroupEntry->rcIgmpGroupMembers[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIgmpGroupEntry(guint32 *base, guchar *rcIgmpGroupIpAddress, guchar *rcIgmpGroupMembers)
{
    int i, len, idx = 12;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIgmpGroupIpAddress[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIgmpGroupMembers[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIgmpGroupEntry_t *
assign_rcIgmpGroupEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIgmpGroupEntry_t *rcIgmpGroupEntry;
    guint32 idx;
    char *p;

    rcIgmpGroupEntry = rapid_city_new_rcIgmpGroupEntry();
    if (! rcIgmpGroupEntry) {
        return NULL;
    }

    p = (char *) rcIgmpGroupEntry + sizeof(rapid_city_rcIgmpGroupEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIgmpGroupEntry((GSnmpVarBind *) vbl->data, rcIgmpGroupEntry) < 0) {
        g_warning("illegal rcIgmpGroupEntry instance identifier");
        g_free(rcIgmpGroupEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIgmpGroupEntry, sizeof(oid_rcIgmpGroupEntry)/sizeof(guint32),
                   attr_rcIgmpGroupEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIgmpGroupEntry->rcIgmpGroupInPort = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIgmpGroupEntry->rcIgmpGroupExpiration = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIgmpGroupEntry;
}

void
rapid_city_get_rcIgmpGroupTable(GSnmpSession *s, rapid_city_rcIgmpGroupEntry_t ***rcIgmpGroupEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 6, 1, 0};

    *rcIgmpGroupEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIgmpGroupEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIgmpGroupEntry = (rapid_city_rcIgmpGroupEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIgmpGroupEntry_t *));
        if (! *rcIgmpGroupEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIgmpGroupEntry)[i] = assign_rcIgmpGroupEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIgmpGroupEntry(GSnmpSession *s, rapid_city_rcIgmpGroupEntry_t **rcIgmpGroupEntry, guchar *rcIgmpGroupIpAddress, guchar *rcIgmpGroupMembers, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIgmpGroupEntry, sizeof(oid_rcIgmpGroupEntry));
    len = pack_rcIgmpGroupEntry(base, rcIgmpGroupIpAddress, rcIgmpGroupMembers);
    if (len < 0) {
        g_warning("illegal rcIgmpGroupEntry index values");
        return;
    }

    *rcIgmpGroupEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIgmpGroupEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIgmpGroupEntry = assign_rcIgmpGroupEntry(out);
    }
}

void
rapid_city_free_rcIgmpGroupEntry(rapid_city_rcIgmpGroupEntry_t *rcIgmpGroupEntry)
{
    GSList *vbl;
    char *p;

    if (rcIgmpGroupEntry) {
        p = (char *) rcIgmpGroupEntry + sizeof(rapid_city_rcIgmpGroupEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIgmpGroupEntry);
    }
}

void
rapid_city_free_rcIgmpGroupTable(rapid_city_rcIgmpGroupEntry_t **rcIgmpGroupEntry)
{
    int i;

    if (rcIgmpGroupEntry) {
        for (i = 0; rcIgmpGroupEntry[i]; i++) {
            rapid_city_free_rcIgmpGroupEntry(rcIgmpGroupEntry[i]);
        }
        g_free(rcIgmpGroupEntry);
    }
}

rapid_city_rcIpRouteEntry_t *
rapid_city_new_rcIpRouteEntry()
{
    rapid_city_rcIpRouteEntry_t *rcIpRouteEntry;

    rcIpRouteEntry = (rapid_city_rcIpRouteEntry_t *) g_malloc0(sizeof(rapid_city_rcIpRouteEntry_t) + sizeof(gpointer));
    return rcIpRouteEntry;
}

static int
unpack_rcIpRouteEntry(GSnmpVarBind *vb, rapid_city_rcIpRouteEntry_t *rcIpRouteEntry)
{
    int i, len, idx = 12;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpRouteEntry->rcIpRouteDest[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpRouteEntry->rcIpRouteMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpRouteEntry(guint32 *base, guchar *rcIpRouteDest, guchar *rcIpRouteMask)
{
    int i, len, idx = 12;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpRouteDest[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpRouteMask[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpRouteEntry_t *
assign_rcIpRouteEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpRouteEntry_t *rcIpRouteEntry;
    guint32 idx;
    char *p;

    rcIpRouteEntry = rapid_city_new_rcIpRouteEntry();
    if (! rcIpRouteEntry) {
        return NULL;
    }

    p = (char *) rcIpRouteEntry + sizeof(rapid_city_rcIpRouteEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpRouteEntry((GSnmpVarBind *) vbl->data, rcIpRouteEntry) < 0) {
        g_warning("illegal rcIpRouteEntry instance identifier");
        g_free(rcIpRouteEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpRouteEntry, sizeof(oid_rcIpRouteEntry)/sizeof(guint32),
                   attr_rcIpRouteEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpRouteEntry->rcIpRouteNextHop = vb->syntax.uc;
            break;
        case 4:
            rcIpRouteEntry->rcIpRouteMetric = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpRouteEntry->rcIpRouteIfIndex = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpRouteEntry->rcIpRouteType = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpRouteEntry->rcIpRouteProto = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpRouteEntry->rcIpRouteAge = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpRouteEntry->rcIpRouteRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpRouteEntry;
}

void
rapid_city_get_rcIpRouteTable(GSnmpSession *s, rapid_city_rcIpRouteEntry_t ***rcIpRouteEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 7, 1, 0};

    *rcIpRouteEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpRouteEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpRouteEntry = (rapid_city_rcIpRouteEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpRouteEntry_t *));
        if (! *rcIpRouteEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpRouteEntry)[i] = assign_rcIpRouteEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpRouteEntry(GSnmpSession *s, rapid_city_rcIpRouteEntry_t **rcIpRouteEntry, guchar *rcIpRouteDest, guchar *rcIpRouteMask, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpRouteEntry, sizeof(oid_rcIpRouteEntry));
    len = pack_rcIpRouteEntry(base, rcIpRouteDest, rcIpRouteMask);
    if (len < 0) {
        g_warning("illegal rcIpRouteEntry index values");
        return;
    }

    *rcIpRouteEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpRouteEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpRouteEntry = assign_rcIpRouteEntry(out);
    }
}

void
rapid_city_set_rcIpRouteEntry(GSnmpSession *s, rapid_city_rcIpRouteEntry_t *rcIpRouteEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpRouteEntry, sizeof(oid_rcIpRouteEntry));
    len = pack_rcIpRouteEntry(base, rcIpRouteEntry->rcIpRouteDest, rcIpRouteEntry->rcIpRouteMask);
    if (len < 0) {
        g_warning("illegal rcIpRouteEntry index values");
        return;
    }

    if (rcIpRouteEntry->rcIpRouteNextHop) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcIpRouteEntry->rcIpRouteNextHop,
                       4);
    }
    if (rcIpRouteEntry->rcIpRouteMetric) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpRouteEntry->rcIpRouteMetric,
                       0);
    }
    if (rcIpRouteEntry->rcIpRouteRowStatus) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpRouteEntry->rcIpRouteRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpRouteEntry(rapid_city_rcIpRouteEntry_t *rcIpRouteEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpRouteEntry) {
        p = (char *) rcIpRouteEntry + sizeof(rapid_city_rcIpRouteEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpRouteEntry);
    }
}

void
rapid_city_free_rcIpRouteTable(rapid_city_rcIpRouteEntry_t **rcIpRouteEntry)
{
    int i;

    if (rcIpRouteEntry) {
        for (i = 0; rcIpRouteEntry[i]; i++) {
            rapid_city_free_rcIpRouteEntry(rcIpRouteEntry[i]);
        }
        g_free(rcIpRouteEntry);
    }
}

rapid_city_rcIpConfDhcpEntry_t *
rapid_city_new_rcIpConfDhcpEntry()
{
    rapid_city_rcIpConfDhcpEntry_t *rcIpConfDhcpEntry;

    rcIpConfDhcpEntry = (rapid_city_rcIpConfDhcpEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfDhcpEntry_t) + sizeof(gpointer));
    return rcIpConfDhcpEntry;
}

static int
unpack_rcIpConfDhcpEntry(GSnmpVarBind *vb, rapid_city_rcIpConfDhcpEntry_t *rcIpConfDhcpEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcIpConfDhcpEntry->rcIpConfDhcpIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfDhcpEntry(guint32 *base, gint32 rcIpConfDhcpIfIndex)
{
    int idx = 12;

    base[idx++] = rcIpConfDhcpIfIndex;
    return idx;
}

static rapid_city_rcIpConfDhcpEntry_t *
assign_rcIpConfDhcpEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfDhcpEntry_t *rcIpConfDhcpEntry;
    guint32 idx;
    char *p;

    rcIpConfDhcpEntry = rapid_city_new_rcIpConfDhcpEntry();
    if (! rcIpConfDhcpEntry) {
        return NULL;
    }

    p = (char *) rcIpConfDhcpEntry + sizeof(rapid_city_rcIpConfDhcpEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfDhcpEntry((GSnmpVarBind *) vbl->data, rcIpConfDhcpEntry) < 0) {
        g_warning("illegal rcIpConfDhcpEntry instance identifier");
        g_free(rcIpConfDhcpEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfDhcpEntry, sizeof(oid_rcIpConfDhcpEntry)/sizeof(guint32),
                   attr_rcIpConfDhcpEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfDhcpEntry->rcIpConfDhcpMaxHop = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfDhcpEntry->rcIpConfDhcpMinSec = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpConfDhcpEntry->rcIpConfDhcpMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpConfDhcpEntry->rcIpConfDhcpRowStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpConfDhcpEntry->rcIpConfDhcpNumRequests = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcIpConfDhcpEntry->rcIpConfDhcpNumReplies = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcIpConfDhcpEntry->rcIpConfDhcpAlwaysBroadcast = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfDhcpEntry;
}

void
rapid_city_get_rcIpConfDhcpTable(GSnmpSession *s, rapid_city_rcIpConfDhcpEntry_t ***rcIpConfDhcpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 8, 1, 0};

    *rcIpConfDhcpEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpConfDhcpEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfDhcpEntry = (rapid_city_rcIpConfDhcpEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfDhcpEntry_t *));
        if (! *rcIpConfDhcpEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfDhcpEntry)[i] = assign_rcIpConfDhcpEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfDhcpEntry(GSnmpSession *s, rapid_city_rcIpConfDhcpEntry_t **rcIpConfDhcpEntry, gint32 rcIpConfDhcpIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfDhcpEntry, sizeof(oid_rcIpConfDhcpEntry));
    len = pack_rcIpConfDhcpEntry(base, rcIpConfDhcpIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfDhcpEntry index values");
        return;
    }

    *rcIpConfDhcpEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpConfDhcpEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfDhcpEntry = assign_rcIpConfDhcpEntry(out);
    }
}

void
rapid_city_set_rcIpConfDhcpEntry(GSnmpSession *s, rapid_city_rcIpConfDhcpEntry_t *rcIpConfDhcpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfDhcpEntry, sizeof(oid_rcIpConfDhcpEntry));
    len = pack_rcIpConfDhcpEntry(base, rcIpConfDhcpEntry->rcIpConfDhcpIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfDhcpEntry index values");
        return;
    }

    if (rcIpConfDhcpEntry->rcIpConfDhcpMaxHop) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDhcpEntry->rcIpConfDhcpMaxHop,
                       0);
    }
    if (rcIpConfDhcpEntry->rcIpConfDhcpMinSec) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDhcpEntry->rcIpConfDhcpMinSec,
                       0);
    }
    if (rcIpConfDhcpEntry->rcIpConfDhcpMode) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDhcpEntry->rcIpConfDhcpMode,
                       0);
    }
    if (rcIpConfDhcpEntry->rcIpConfDhcpRowStatus) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDhcpEntry->rcIpConfDhcpRowStatus,
                       0);
    }
    if (rcIpConfDhcpEntry->rcIpConfDhcpAlwaysBroadcast) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDhcpEntry->rcIpConfDhcpAlwaysBroadcast,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfDhcpEntry(rapid_city_rcIpConfDhcpEntry_t *rcIpConfDhcpEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfDhcpEntry) {
        p = (char *) rcIpConfDhcpEntry + sizeof(rapid_city_rcIpConfDhcpEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfDhcpEntry);
    }
}

void
rapid_city_free_rcIpConfDhcpTable(rapid_city_rcIpConfDhcpEntry_t **rcIpConfDhcpEntry)
{
    int i;

    if (rcIpConfDhcpEntry) {
        for (i = 0; rcIpConfDhcpEntry[i]; i++) {
            rapid_city_free_rcIpConfDhcpEntry(rcIpConfDhcpEntry[i]);
        }
        g_free(rcIpConfDhcpEntry);
    }
}

rapid_city_rcIpDhcpForwardEntry_t *
rapid_city_new_rcIpDhcpForwardEntry()
{
    rapid_city_rcIpDhcpForwardEntry_t *rcIpDhcpForwardEntry;

    rcIpDhcpForwardEntry = (rapid_city_rcIpDhcpForwardEntry_t *) g_malloc0(sizeof(rapid_city_rcIpDhcpForwardEntry_t) + sizeof(gpointer));
    return rcIpDhcpForwardEntry;
}

static int
unpack_rcIpDhcpForwardEntry(GSnmpVarBind *vb, rapid_city_rcIpDhcpForwardEntry_t *rcIpDhcpForwardEntry)
{
    int i, len, idx = 12;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpDhcpForwardEntry->rcIpDhcpForwardAgentAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpDhcpForwardEntry->rcIpDhcpForwardServerAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpDhcpForwardEntry(guint32 *base, guchar *rcIpDhcpForwardAgentAddr, guchar *rcIpDhcpForwardServerAddr)
{
    int i, len, idx = 12;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpDhcpForwardAgentAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpDhcpForwardServerAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpDhcpForwardEntry_t *
assign_rcIpDhcpForwardEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpDhcpForwardEntry_t *rcIpDhcpForwardEntry;
    guint32 idx;
    char *p;

    rcIpDhcpForwardEntry = rapid_city_new_rcIpDhcpForwardEntry();
    if (! rcIpDhcpForwardEntry) {
        return NULL;
    }

    p = (char *) rcIpDhcpForwardEntry + sizeof(rapid_city_rcIpDhcpForwardEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpDhcpForwardEntry((GSnmpVarBind *) vbl->data, rcIpDhcpForwardEntry) < 0) {
        g_warning("illegal rcIpDhcpForwardEntry instance identifier");
        g_free(rcIpDhcpForwardEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpDhcpForwardEntry, sizeof(oid_rcIpDhcpForwardEntry)/sizeof(guint32),
                   attr_rcIpDhcpForwardEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpDhcpForwardEntry->rcIpDhcpForwardEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpDhcpForwardEntry->rcIpDhcpForwardMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpDhcpForwardEntry->rcIpDhcpForwardRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpDhcpForwardEntry;
}

void
rapid_city_get_rcIpDhcpForwardTable(GSnmpSession *s, rapid_city_rcIpDhcpForwardEntry_t ***rcIpDhcpForwardEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 9, 1, 0};

    *rcIpDhcpForwardEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpDhcpForwardEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpDhcpForwardEntry = (rapid_city_rcIpDhcpForwardEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpDhcpForwardEntry_t *));
        if (! *rcIpDhcpForwardEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpDhcpForwardEntry)[i] = assign_rcIpDhcpForwardEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpDhcpForwardEntry(GSnmpSession *s, rapid_city_rcIpDhcpForwardEntry_t **rcIpDhcpForwardEntry, guchar *rcIpDhcpForwardAgentAddr, guchar *rcIpDhcpForwardServerAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpDhcpForwardEntry, sizeof(oid_rcIpDhcpForwardEntry));
    len = pack_rcIpDhcpForwardEntry(base, rcIpDhcpForwardAgentAddr, rcIpDhcpForwardServerAddr);
    if (len < 0) {
        g_warning("illegal rcIpDhcpForwardEntry index values");
        return;
    }

    *rcIpDhcpForwardEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpDhcpForwardEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpDhcpForwardEntry = assign_rcIpDhcpForwardEntry(out);
    }
}

void
rapid_city_set_rcIpDhcpForwardEntry(GSnmpSession *s, rapid_city_rcIpDhcpForwardEntry_t *rcIpDhcpForwardEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpDhcpForwardEntry, sizeof(oid_rcIpDhcpForwardEntry));
    len = pack_rcIpDhcpForwardEntry(base, rcIpDhcpForwardEntry->rcIpDhcpForwardAgentAddr, rcIpDhcpForwardEntry->rcIpDhcpForwardServerAddr);
    if (len < 0) {
        g_warning("illegal rcIpDhcpForwardEntry index values");
        return;
    }

    if (rcIpDhcpForwardEntry->rcIpDhcpForwardEnable) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpDhcpForwardEntry->rcIpDhcpForwardEnable,
                       0);
    }
    if (rcIpDhcpForwardEntry->rcIpDhcpForwardMode) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpDhcpForwardEntry->rcIpDhcpForwardMode,
                       0);
    }
    if (rcIpDhcpForwardEntry->rcIpDhcpForwardRowStatus) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpDhcpForwardEntry->rcIpDhcpForwardRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpDhcpForwardEntry(rapid_city_rcIpDhcpForwardEntry_t *rcIpDhcpForwardEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpDhcpForwardEntry) {
        p = (char *) rcIpDhcpForwardEntry + sizeof(rapid_city_rcIpDhcpForwardEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpDhcpForwardEntry);
    }
}

void
rapid_city_free_rcIpDhcpForwardTable(rapid_city_rcIpDhcpForwardEntry_t **rcIpDhcpForwardEntry)
{
    int i;

    if (rcIpDhcpForwardEntry) {
        for (i = 0; rcIpDhcpForwardEntry[i]; i++) {
            rapid_city_free_rcIpDhcpForwardEntry(rcIpDhcpForwardEntry[i]);
        }
        g_free(rcIpDhcpForwardEntry);
    }
}

rapid_city_rcIpFilter_t *
rapid_city_new_rcIpFilter()
{
    rapid_city_rcIpFilter_t *rcIpFilter;

    rcIpFilter = (rapid_city_rcIpFilter_t *) g_malloc0(sizeof(rapid_city_rcIpFilter_t) + sizeof(gpointer));
    return rcIpFilter;
}

static rapid_city_rcIpFilter_t *
assign_rcIpFilter(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFilter_t *rcIpFilter;
    guint32 idx;
    char *p;

    rcIpFilter = rapid_city_new_rcIpFilter();
    if (! rcIpFilter) {
        return NULL;
    }

    p = (char *) rcIpFilter + sizeof(rapid_city_rcIpFilter_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFilter, sizeof(oid_rcIpFilter)/sizeof(guint32),
                   attr_rcIpFilter, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpFilter->rcIpFilterFilterTableSize = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcIpFilter->rcIpFilterGlobalListTableSize = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpFilter->rcIpFilterBaseListTableSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpFilter->rcIpFilterPortTableSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpFilter->rcIpFilterNextAvailFilterId = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpFilter;
}

void
rapid_city_get_rcIpFilter(GSnmpSession *s, rapid_city_rcIpFilter_t **rcIpFilter, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 0};

    *rcIpFilter = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcIpFilter, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFilter = assign_rcIpFilter(out);
    }
}

void
rapid_city_free_rcIpFilter(rapid_city_rcIpFilter_t *rcIpFilter)
{
    GSList *vbl;
    char *p;

    if (rcIpFilter) {
        p = (char *) rcIpFilter + sizeof(rapid_city_rcIpFilter_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFilter);
    }
}

rapid_city_rcIpFilterEntry_t *
rapid_city_new_rcIpFilterEntry()
{
    rapid_city_rcIpFilterEntry_t *rcIpFilterEntry;

    rcIpFilterEntry = (rapid_city_rcIpFilterEntry_t *) g_malloc0(sizeof(rapid_city_rcIpFilterEntry_t) + sizeof(gpointer));
    return rcIpFilterEntry;
}

static int
unpack_rcIpFilterEntry(GSnmpVarBind *vb, rapid_city_rcIpFilterEntry_t *rcIpFilterEntry)
{
    int i, len, idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpFilterEntry->rcIpFilterType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFilterEntry->rcIpFilterDstAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFilterEntry->rcIpFilterDstMask[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFilterEntry->rcIpFilterSrcAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpFilterEntry->rcIpFilterSrcMask[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcIpFilterEntry->rcIpFilterId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpFilterEntry(guint32 *base, gint32 rcIpFilterType, guchar *rcIpFilterDstAddr, guchar *rcIpFilterDstMask, guchar *rcIpFilterSrcAddr, guchar *rcIpFilterSrcMask, gint32 rcIpFilterId)
{
    int i, len, idx = 13;

    base[idx++] = rcIpFilterType;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFilterDstAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFilterDstMask[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFilterSrcAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpFilterSrcMask[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcIpFilterId;
    return idx;
}

static rapid_city_rcIpFilterEntry_t *
assign_rcIpFilterEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFilterEntry_t *rcIpFilterEntry;
    guint32 idx;
    char *p;

    rcIpFilterEntry = rapid_city_new_rcIpFilterEntry();
    if (! rcIpFilterEntry) {
        return NULL;
    }

    p = (char *) rcIpFilterEntry + sizeof(rapid_city_rcIpFilterEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpFilterEntry((GSnmpVarBind *) vbl->data, rcIpFilterEntry) < 0) {
        g_warning("illegal rcIpFilterEntry instance identifier");
        g_free(rcIpFilterEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFilterEntry, sizeof(oid_rcIpFilterEntry)/sizeof(guint32),
                   attr_rcIpFilterEntry, &idx) < 0) continue;

        switch (idx) {
        case 7:
            rcIpFilterEntry->_rcIpFilterNameLength = vb->syntax_len;
            rcIpFilterEntry->rcIpFilterName = vb->syntax.uc;
            break;
        case 8:
            rcIpFilterEntry->rcIpFilterProtocolType = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpFilterEntry->rcIpFilterSrcPort = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpFilterEntry->rcIpFilterSrcOption = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpFilterEntry->rcIpFilterDstPort = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcIpFilterEntry->rcIpFilterDstOption = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcIpFilterEntry->rcIpFilterCopyToCpu = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcIpFilterEntry->rcIpFilterMirror = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcIpFilterEntry->rcIpFilterHighPriority = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcIpFilterEntry->rcIpFilterTcpConnect = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcIpFilterEntry->rcIpFilterIeeeVlanPriority = &(vb->syntax.i32[0]);
            break;
        case 18:
            rcIpFilterEntry->rcIpFilterUsePktLimit = &(vb->syntax.i32[0]);
            break;
        case 19:
            rcIpFilterEntry->rcIpFilterPktLimit = &(vb->syntax.i32[0]);
            break;
        case 20:
            rcIpFilterEntry->rcIpFilterRowStatus = &(vb->syntax.i32[0]);
            break;
        case 21:
            rcIpFilterEntry->rcIpFilterMode = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpFilterEntry;
}

void
rapid_city_get_rcIpFilterTable(GSnmpSession *s, rapid_city_rcIpFilterEntry_t ***rcIpFilterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 20, 1, 0};

    *rcIpFilterEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpFilterEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpFilterEntry = (rapid_city_rcIpFilterEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpFilterEntry_t *));
        if (! *rcIpFilterEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpFilterEntry)[i] = assign_rcIpFilterEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpFilterEntry(GSnmpSession *s, rapid_city_rcIpFilterEntry_t **rcIpFilterEntry, gint32 rcIpFilterType, guchar *rcIpFilterDstAddr, guchar *rcIpFilterDstMask, guchar *rcIpFilterSrcAddr, guchar *rcIpFilterSrcMask, gint32 rcIpFilterId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterEntry, sizeof(oid_rcIpFilterEntry));
    len = pack_rcIpFilterEntry(base, rcIpFilterType, rcIpFilterDstAddr, rcIpFilterDstMask, rcIpFilterSrcAddr, rcIpFilterSrcMask, rcIpFilterId);
    if (len < 0) {
        g_warning("illegal rcIpFilterEntry index values");
        return;
    }

    *rcIpFilterEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpFilterEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFilterEntry = assign_rcIpFilterEntry(out);
    }
}

void
rapid_city_set_rcIpFilterEntry(GSnmpSession *s, rapid_city_rcIpFilterEntry_t *rcIpFilterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterEntry, sizeof(oid_rcIpFilterEntry));
    len = pack_rcIpFilterEntry(base, rcIpFilterEntry->rcIpFilterType, rcIpFilterEntry->rcIpFilterDstAddr, rcIpFilterEntry->rcIpFilterDstMask, rcIpFilterEntry->rcIpFilterSrcAddr, rcIpFilterEntry->rcIpFilterSrcMask, rcIpFilterEntry->rcIpFilterId);
    if (len < 0) {
        g_warning("illegal rcIpFilterEntry index values");
        return;
    }

    if (rcIpFilterEntry->rcIpFilterName) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterEntry->rcIpFilterName,
                       rcIpFilterEntry->_rcIpFilterNameLength);
    }
    if (rcIpFilterEntry->rcIpFilterProtocolType) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterProtocolType,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterSrcPort) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterSrcPort,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterSrcOption) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterSrcOption,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterDstPort) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterDstPort,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterDstOption) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterDstOption,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterCopyToCpu) {
        base[12] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterCopyToCpu,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterMirror) {
        base[12] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterMirror,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterHighPriority) {
        base[12] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterHighPriority,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterTcpConnect) {
        base[12] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterTcpConnect,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterIeeeVlanPriority) {
        base[12] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterIeeeVlanPriority,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterUsePktLimit) {
        base[12] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterUsePktLimit,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterPktLimit) {
        base[12] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterPktLimit,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterRowStatus) {
        base[12] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterRowStatus,
                       0);
    }
    if (rcIpFilterEntry->rcIpFilterMode) {
        base[12] = 21;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterEntry->rcIpFilterMode,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpFilterEntry(rapid_city_rcIpFilterEntry_t *rcIpFilterEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpFilterEntry) {
        p = (char *) rcIpFilterEntry + sizeof(rapid_city_rcIpFilterEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFilterEntry);
    }
}

void
rapid_city_free_rcIpFilterTable(rapid_city_rcIpFilterEntry_t **rcIpFilterEntry)
{
    int i;

    if (rcIpFilterEntry) {
        for (i = 0; rcIpFilterEntry[i]; i++) {
            rapid_city_free_rcIpFilterEntry(rcIpFilterEntry[i]);
        }
        g_free(rcIpFilterEntry);
    }
}

rapid_city_rcIpFilterGlobalListEntry_t *
rapid_city_new_rcIpFilterGlobalListEntry()
{
    rapid_city_rcIpFilterGlobalListEntry_t *rcIpFilterGlobalListEntry;

    rcIpFilterGlobalListEntry = (rapid_city_rcIpFilterGlobalListEntry_t *) g_malloc0(sizeof(rapid_city_rcIpFilterGlobalListEntry_t) + sizeof(gpointer));
    return rcIpFilterGlobalListEntry;
}

static int
unpack_rcIpFilterGlobalListEntry(GSnmpVarBind *vb, rapid_city_rcIpFilterGlobalListEntry_t *rcIpFilterGlobalListEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpFilterGlobalListEntry->rcIpFilterGlobalListId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpFilterGlobalListEntry(guint32 *base, gint32 rcIpFilterGlobalListId)
{
    int idx = 13;

    base[idx++] = rcIpFilterGlobalListId;
    return idx;
}

static rapid_city_rcIpFilterGlobalListEntry_t *
assign_rcIpFilterGlobalListEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFilterGlobalListEntry_t *rcIpFilterGlobalListEntry;
    guint32 idx;
    char *p;

    rcIpFilterGlobalListEntry = rapid_city_new_rcIpFilterGlobalListEntry();
    if (! rcIpFilterGlobalListEntry) {
        return NULL;
    }

    p = (char *) rcIpFilterGlobalListEntry + sizeof(rapid_city_rcIpFilterGlobalListEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpFilterGlobalListEntry((GSnmpVarBind *) vbl->data, rcIpFilterGlobalListEntry) < 0) {
        g_warning("illegal rcIpFilterGlobalListEntry instance identifier");
        g_free(rcIpFilterGlobalListEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFilterGlobalListEntry, sizeof(oid_rcIpFilterGlobalListEntry)/sizeof(guint32),
                   attr_rcIpFilterGlobalListEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpFilterGlobalListEntry->_rcIpFilterGlobalListNameLength = vb->syntax_len;
            rcIpFilterGlobalListEntry->rcIpFilterGlobalListName = vb->syntax.uc;
            break;
        case 3:
            rcIpFilterGlobalListEntry->rcIpFilterGlobalListFilterIdListSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpFilterGlobalListEntry->rcIpFilterGlobalListFilterIdList = vb->syntax.uc;
            break;
        case 5:
            rcIpFilterGlobalListEntry->rcIpFilterGlobalListRowStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpFilterGlobalListEntry->rcIpFilterGlobalListMemberPorts = vb->syntax.uc;
            break;
        };
    }

    return rcIpFilterGlobalListEntry;
}

void
rapid_city_get_rcIpFilterGlobalListTable(GSnmpSession *s, rapid_city_rcIpFilterGlobalListEntry_t ***rcIpFilterGlobalListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 21, 1, 0};

    *rcIpFilterGlobalListEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpFilterGlobalListEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpFilterGlobalListEntry = (rapid_city_rcIpFilterGlobalListEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpFilterGlobalListEntry_t *));
        if (! *rcIpFilterGlobalListEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpFilterGlobalListEntry)[i] = assign_rcIpFilterGlobalListEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpFilterGlobalListEntry(GSnmpSession *s, rapid_city_rcIpFilterGlobalListEntry_t **rcIpFilterGlobalListEntry, gint32 rcIpFilterGlobalListId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterGlobalListEntry, sizeof(oid_rcIpFilterGlobalListEntry));
    len = pack_rcIpFilterGlobalListEntry(base, rcIpFilterGlobalListId);
    if (len < 0) {
        g_warning("illegal rcIpFilterGlobalListEntry index values");
        return;
    }

    *rcIpFilterGlobalListEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpFilterGlobalListEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFilterGlobalListEntry = assign_rcIpFilterGlobalListEntry(out);
    }
}

void
rapid_city_set_rcIpFilterGlobalListEntry(GSnmpSession *s, rapid_city_rcIpFilterGlobalListEntry_t *rcIpFilterGlobalListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterGlobalListEntry, sizeof(oid_rcIpFilterGlobalListEntry));
    len = pack_rcIpFilterGlobalListEntry(base, rcIpFilterGlobalListEntry->rcIpFilterGlobalListId);
    if (len < 0) {
        g_warning("illegal rcIpFilterGlobalListEntry index values");
        return;
    }

    if (rcIpFilterGlobalListEntry->rcIpFilterGlobalListName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterGlobalListEntry->rcIpFilterGlobalListName,
                       rcIpFilterGlobalListEntry->_rcIpFilterGlobalListNameLength);
    }
    if (rcIpFilterGlobalListEntry->rcIpFilterGlobalListFilterIdList) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterGlobalListEntry->rcIpFilterGlobalListFilterIdList,
                       16);
    }
    if (rcIpFilterGlobalListEntry->rcIpFilterGlobalListRowStatus) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterGlobalListEntry->rcIpFilterGlobalListRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpFilterGlobalListEntry(rapid_city_rcIpFilterGlobalListEntry_t *rcIpFilterGlobalListEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpFilterGlobalListEntry) {
        p = (char *) rcIpFilterGlobalListEntry + sizeof(rapid_city_rcIpFilterGlobalListEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFilterGlobalListEntry);
    }
}

void
rapid_city_free_rcIpFilterGlobalListTable(rapid_city_rcIpFilterGlobalListEntry_t **rcIpFilterGlobalListEntry)
{
    int i;

    if (rcIpFilterGlobalListEntry) {
        for (i = 0; rcIpFilterGlobalListEntry[i]; i++) {
            rapid_city_free_rcIpFilterGlobalListEntry(rcIpFilterGlobalListEntry[i]);
        }
        g_free(rcIpFilterGlobalListEntry);
    }
}

rapid_city_rcIpFilterBaseListEntry_t *
rapid_city_new_rcIpFilterBaseListEntry()
{
    rapid_city_rcIpFilterBaseListEntry_t *rcIpFilterBaseListEntry;

    rcIpFilterBaseListEntry = (rapid_city_rcIpFilterBaseListEntry_t *) g_malloc0(sizeof(rapid_city_rcIpFilterBaseListEntry_t) + sizeof(gpointer));
    return rcIpFilterBaseListEntry;
}

static int
unpack_rcIpFilterBaseListEntry(GSnmpVarBind *vb, rapid_city_rcIpFilterBaseListEntry_t *rcIpFilterBaseListEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpFilterBaseListEntry->rcIpFilterBaseListId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpFilterBaseListEntry(guint32 *base, gint32 rcIpFilterBaseListId)
{
    int idx = 13;

    base[idx++] = rcIpFilterBaseListId;
    return idx;
}

static rapid_city_rcIpFilterBaseListEntry_t *
assign_rcIpFilterBaseListEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFilterBaseListEntry_t *rcIpFilterBaseListEntry;
    guint32 idx;
    char *p;

    rcIpFilterBaseListEntry = rapid_city_new_rcIpFilterBaseListEntry();
    if (! rcIpFilterBaseListEntry) {
        return NULL;
    }

    p = (char *) rcIpFilterBaseListEntry + sizeof(rapid_city_rcIpFilterBaseListEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpFilterBaseListEntry((GSnmpVarBind *) vbl->data, rcIpFilterBaseListEntry) < 0) {
        g_warning("illegal rcIpFilterBaseListEntry instance identifier");
        g_free(rcIpFilterBaseListEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFilterBaseListEntry, sizeof(oid_rcIpFilterBaseListEntry)/sizeof(guint32),
                   attr_rcIpFilterBaseListEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpFilterBaseListEntry->_rcIpFilterBaseListNameLength = vb->syntax_len;
            rcIpFilterBaseListEntry->rcIpFilterBaseListName = vb->syntax.uc;
            break;
        case 3:
            rcIpFilterBaseListEntry->rcIpFilterBaseListFilterIdListSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpFilterBaseListEntry->rcIpFilterBaseListFilterIdList = vb->syntax.uc;
            break;
        case 5:
            rcIpFilterBaseListEntry->rcIpFilterBaseListRowStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpFilterBaseListEntry->rcIpFilterBaseListMemberPorts = vb->syntax.uc;
            break;
        };
    }

    return rcIpFilterBaseListEntry;
}

void
rapid_city_get_rcIpFilterBaseListTable(GSnmpSession *s, rapid_city_rcIpFilterBaseListEntry_t ***rcIpFilterBaseListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 22, 1, 0};

    *rcIpFilterBaseListEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpFilterBaseListEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpFilterBaseListEntry = (rapid_city_rcIpFilterBaseListEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpFilterBaseListEntry_t *));
        if (! *rcIpFilterBaseListEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpFilterBaseListEntry)[i] = assign_rcIpFilterBaseListEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpFilterBaseListEntry(GSnmpSession *s, rapid_city_rcIpFilterBaseListEntry_t **rcIpFilterBaseListEntry, gint32 rcIpFilterBaseListId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterBaseListEntry, sizeof(oid_rcIpFilterBaseListEntry));
    len = pack_rcIpFilterBaseListEntry(base, rcIpFilterBaseListId);
    if (len < 0) {
        g_warning("illegal rcIpFilterBaseListEntry index values");
        return;
    }

    *rcIpFilterBaseListEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpFilterBaseListEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFilterBaseListEntry = assign_rcIpFilterBaseListEntry(out);
    }
}

void
rapid_city_set_rcIpFilterBaseListEntry(GSnmpSession *s, rapid_city_rcIpFilterBaseListEntry_t *rcIpFilterBaseListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterBaseListEntry, sizeof(oid_rcIpFilterBaseListEntry));
    len = pack_rcIpFilterBaseListEntry(base, rcIpFilterBaseListEntry->rcIpFilterBaseListId);
    if (len < 0) {
        g_warning("illegal rcIpFilterBaseListEntry index values");
        return;
    }

    if (rcIpFilterBaseListEntry->rcIpFilterBaseListName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterBaseListEntry->rcIpFilterBaseListName,
                       rcIpFilterBaseListEntry->_rcIpFilterBaseListNameLength);
    }
    if (rcIpFilterBaseListEntry->rcIpFilterBaseListFilterIdList) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterBaseListEntry->rcIpFilterBaseListFilterIdList,
                       256);
    }
    if (rcIpFilterBaseListEntry->rcIpFilterBaseListRowStatus) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterBaseListEntry->rcIpFilterBaseListRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpFilterBaseListEntry(rapid_city_rcIpFilterBaseListEntry_t *rcIpFilterBaseListEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpFilterBaseListEntry) {
        p = (char *) rcIpFilterBaseListEntry + sizeof(rapid_city_rcIpFilterBaseListEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFilterBaseListEntry);
    }
}

void
rapid_city_free_rcIpFilterBaseListTable(rapid_city_rcIpFilterBaseListEntry_t **rcIpFilterBaseListEntry)
{
    int i;

    if (rcIpFilterBaseListEntry) {
        for (i = 0; rcIpFilterBaseListEntry[i]; i++) {
            rapid_city_free_rcIpFilterBaseListEntry(rcIpFilterBaseListEntry[i]);
        }
        g_free(rcIpFilterBaseListEntry);
    }
}

rapid_city_rcIpFilterPortEntry_t *
rapid_city_new_rcIpFilterPortEntry()
{
    rapid_city_rcIpFilterPortEntry_t *rcIpFilterPortEntry;

    rcIpFilterPortEntry = (rapid_city_rcIpFilterPortEntry_t *) g_malloc0(sizeof(rapid_city_rcIpFilterPortEntry_t) + sizeof(gpointer));
    return rcIpFilterPortEntry;
}

static int
unpack_rcIpFilterPortEntry(GSnmpVarBind *vb, rapid_city_rcIpFilterPortEntry_t *rcIpFilterPortEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpFilterPortEntry->rcIpFilterPortIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpFilterPortEntry(guint32 *base, gint32 rcIpFilterPortIfIndex)
{
    int idx = 13;

    base[idx++] = rcIpFilterPortIfIndex;
    return idx;
}

static rapid_city_rcIpFilterPortEntry_t *
assign_rcIpFilterPortEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpFilterPortEntry_t *rcIpFilterPortEntry;
    guint32 idx;
    char *p;

    rcIpFilterPortEntry = rapid_city_new_rcIpFilterPortEntry();
    if (! rcIpFilterPortEntry) {
        return NULL;
    }

    p = (char *) rcIpFilterPortEntry + sizeof(rapid_city_rcIpFilterPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpFilterPortEntry((GSnmpVarBind *) vbl->data, rcIpFilterPortEntry) < 0) {
        g_warning("illegal rcIpFilterPortEntry instance identifier");
        g_free(rcIpFilterPortEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpFilterPortEntry, sizeof(oid_rcIpFilterPortEntry)/sizeof(guint32),
                   attr_rcIpFilterPortEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpFilterPortEntry->rcIpFilterPortFilterListSize = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpFilterPortEntry->rcIpFilterPortFilterList = vb->syntax.uc;
            break;
        case 4:
            rcIpFilterPortEntry->rcIpFilterPortMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpFilterPortEntry->rcIpFilterPortEnable = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpFilterPortEntry->rcIpFilterPortRowStatus = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpFilterPortEntry->rcIpFilterPortDefaultAction = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpFilterPortEntry->rcIpFilterPortNumGlobalFilters = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpFilterPortEntry->rcIpFilterPortNumBaseFilters = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpFilterPortEntry;
}

void
rapid_city_get_rcIpFilterPortTable(GSnmpSession *s, rapid_city_rcIpFilterPortEntry_t ***rcIpFilterPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 10, 23, 1, 0};

    *rcIpFilterPortEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpFilterPortEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpFilterPortEntry = (rapid_city_rcIpFilterPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpFilterPortEntry_t *));
        if (! *rcIpFilterPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpFilterPortEntry)[i] = assign_rcIpFilterPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpFilterPortEntry(GSnmpSession *s, rapid_city_rcIpFilterPortEntry_t **rcIpFilterPortEntry, gint32 rcIpFilterPortIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterPortEntry, sizeof(oid_rcIpFilterPortEntry));
    len = pack_rcIpFilterPortEntry(base, rcIpFilterPortIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpFilterPortEntry index values");
        return;
    }

    *rcIpFilterPortEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpFilterPortEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpFilterPortEntry = assign_rcIpFilterPortEntry(out);
    }
}

void
rapid_city_set_rcIpFilterPortEntry(GSnmpSession *s, rapid_city_rcIpFilterPortEntry_t *rcIpFilterPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpFilterPortEntry, sizeof(oid_rcIpFilterPortEntry));
    len = pack_rcIpFilterPortEntry(base, rcIpFilterPortEntry->rcIpFilterPortIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpFilterPortEntry index values");
        return;
    }

    if (rcIpFilterPortEntry->rcIpFilterPortFilterList) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpFilterPortEntry->rcIpFilterPortFilterList,
                       256);
    }
    if (rcIpFilterPortEntry->rcIpFilterPortMode) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterPortEntry->rcIpFilterPortMode,
                       0);
    }
    if (rcIpFilterPortEntry->rcIpFilterPortEnable) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterPortEntry->rcIpFilterPortEnable,
                       0);
    }
    if (rcIpFilterPortEntry->rcIpFilterPortRowStatus) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterPortEntry->rcIpFilterPortRowStatus,
                       0);
    }
    if (rcIpFilterPortEntry->rcIpFilterPortDefaultAction) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpFilterPortEntry->rcIpFilterPortDefaultAction,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpFilterPortEntry(rapid_city_rcIpFilterPortEntry_t *rcIpFilterPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpFilterPortEntry) {
        p = (char *) rcIpFilterPortEntry + sizeof(rapid_city_rcIpFilterPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpFilterPortEntry);
    }
}

void
rapid_city_free_rcIpFilterPortTable(rapid_city_rcIpFilterPortEntry_t **rcIpFilterPortEntry)
{
    int i;

    if (rcIpFilterPortEntry) {
        for (i = 0; rcIpFilterPortEntry[i]; i++) {
            rapid_city_free_rcIpFilterPortEntry(rcIpFilterPortEntry[i]);
        }
        g_free(rcIpFilterPortEntry);
    }
}

rapid_city_rcIpPolicy_t *
rapid_city_new_rcIpPolicy()
{
    rapid_city_rcIpPolicy_t *rcIpPolicy;

    rcIpPolicy = (rapid_city_rcIpPolicy_t *) g_malloc0(sizeof(rapid_city_rcIpPolicy_t) + sizeof(gpointer));
    return rcIpPolicy;
}

static rapid_city_rcIpPolicy_t *
assign_rcIpPolicy(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicy_t *rcIpPolicy;
    guint32 idx;
    char *p;

    rcIpPolicy = rapid_city_new_rcIpPolicy();
    if (! rcIpPolicy) {
        return NULL;
    }

    p = (char *) rcIpPolicy + sizeof(rapid_city_rcIpPolicy_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicy, sizeof(oid_rcIpPolicy)/sizeof(guint32),
                   attr_rcIpPolicy, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpPolicy->rcIpPolicyAddrTableSize = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpPolicy->rcIpPolicyNetTableSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicy->rcIpPolicyAddrListTableSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicy->rcIpPolicyRipAnnounceTableSize = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpPolicy->rcIpPolicyOspfAnnounceTableSize = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpPolicy->rcIpPolicyRipAcceptTableSize = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcIpPolicy->rcIpPolicyOspfAcceptTableSize = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcIpPolicy->rcIpPolicyNetListTableSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicy;
}

void
rapid_city_get_rcIpPolicy(GSnmpSession *s, rapid_city_rcIpPolicy_t **rcIpPolicy, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 0};

    *rcIpPolicy = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcIpPolicy, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicy = assign_rcIpPolicy(out);
    }
}

void
rapid_city_free_rcIpPolicy(rapid_city_rcIpPolicy_t *rcIpPolicy)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicy) {
        p = (char *) rcIpPolicy + sizeof(rapid_city_rcIpPolicy_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicy);
    }
}

rapid_city_rcIpPolicyAddrEntry_t *
rapid_city_new_rcIpPolicyAddrEntry()
{
    rapid_city_rcIpPolicyAddrEntry_t *rcIpPolicyAddrEntry;

    rcIpPolicyAddrEntry = (rapid_city_rcIpPolicyAddrEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyAddrEntry_t) + sizeof(gpointer));
    return rcIpPolicyAddrEntry;
}

static int
unpack_rcIpPolicyAddrEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyAddrEntry_t *rcIpPolicyAddrEntry)
{
    int i, len, idx = 13;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpPolicyAddrEntry->rcIpPolicyAddrIpAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyAddrEntry(guint32 *base, guchar *rcIpPolicyAddrIpAddr)
{
    int i, len, idx = 13;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpPolicyAddrIpAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpPolicyAddrEntry_t *
assign_rcIpPolicyAddrEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyAddrEntry_t *rcIpPolicyAddrEntry;
    guint32 idx;
    char *p;

    rcIpPolicyAddrEntry = rapid_city_new_rcIpPolicyAddrEntry();
    if (! rcIpPolicyAddrEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyAddrEntry + sizeof(rapid_city_rcIpPolicyAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyAddrEntry((GSnmpVarBind *) vbl->data, rcIpPolicyAddrEntry) < 0) {
        g_warning("illegal rcIpPolicyAddrEntry instance identifier");
        g_free(rcIpPolicyAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyAddrEntry, sizeof(oid_rcIpPolicyAddrEntry)/sizeof(guint32),
                   attr_rcIpPolicyAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpPolicyAddrEntry->rcIpPolicyAddrId = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpPolicyAddrEntry->rcIpPolicyAddrAddrListIdListSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyAddrEntry->rcIpPolicyAddrAddrListIdList = vb->syntax.uc;
            break;
        case 5:
            rcIpPolicyAddrEntry->rcIpPolicyAddrRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyAddrEntry;
}

void
rapid_city_get_rcIpPolicyAddrTable(GSnmpSession *s, rapid_city_rcIpPolicyAddrEntry_t ***rcIpPolicyAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 2, 1, 0};

    *rcIpPolicyAddrEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyAddrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyAddrEntry = (rapid_city_rcIpPolicyAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyAddrEntry_t *));
        if (! *rcIpPolicyAddrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyAddrEntry)[i] = assign_rcIpPolicyAddrEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyAddrEntry(GSnmpSession *s, rapid_city_rcIpPolicyAddrEntry_t **rcIpPolicyAddrEntry, guchar *rcIpPolicyAddrIpAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyAddrEntry, sizeof(oid_rcIpPolicyAddrEntry));
    len = pack_rcIpPolicyAddrEntry(base, rcIpPolicyAddrIpAddr);
    if (len < 0) {
        g_warning("illegal rcIpPolicyAddrEntry index values");
        return;
    }

    *rcIpPolicyAddrEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyAddrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyAddrEntry = assign_rcIpPolicyAddrEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyAddrEntry(GSnmpSession *s, rapid_city_rcIpPolicyAddrEntry_t *rcIpPolicyAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyAddrEntry, sizeof(oid_rcIpPolicyAddrEntry));
    len = pack_rcIpPolicyAddrEntry(base, rcIpPolicyAddrEntry->rcIpPolicyAddrIpAddr);
    if (len < 0) {
        g_warning("illegal rcIpPolicyAddrEntry index values");
        return;
    }

    if (rcIpPolicyAddrEntry->rcIpPolicyAddrRowStatus) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyAddrEntry->rcIpPolicyAddrRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyAddrEntry(rapid_city_rcIpPolicyAddrEntry_t *rcIpPolicyAddrEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyAddrEntry) {
        p = (char *) rcIpPolicyAddrEntry + sizeof(rapid_city_rcIpPolicyAddrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyAddrEntry);
    }
}

void
rapid_city_free_rcIpPolicyAddrTable(rapid_city_rcIpPolicyAddrEntry_t **rcIpPolicyAddrEntry)
{
    int i;

    if (rcIpPolicyAddrEntry) {
        for (i = 0; rcIpPolicyAddrEntry[i]; i++) {
            rapid_city_free_rcIpPolicyAddrEntry(rcIpPolicyAddrEntry[i]);
        }
        g_free(rcIpPolicyAddrEntry);
    }
}

rapid_city_rcIpPolicyNetEntry_t *
rapid_city_new_rcIpPolicyNetEntry()
{
    rapid_city_rcIpPolicyNetEntry_t *rcIpPolicyNetEntry;

    rcIpPolicyNetEntry = (rapid_city_rcIpPolicyNetEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyNetEntry_t) + sizeof(gpointer));
    return rcIpPolicyNetEntry;
}

static int
unpack_rcIpPolicyNetEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyNetEntry_t *rcIpPolicyNetEntry)
{
    int i, len, idx = 13;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpPolicyNetEntry->rcIpPolicyNetAddr[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpPolicyNetEntry->rcIpPolicyNetMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyNetEntry(guint32 *base, guchar *rcIpPolicyNetAddr, guchar *rcIpPolicyNetMask)
{
    int i, len, idx = 13;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpPolicyNetAddr[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpPolicyNetMask[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpPolicyNetEntry_t *
assign_rcIpPolicyNetEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyNetEntry_t *rcIpPolicyNetEntry;
    guint32 idx;
    char *p;

    rcIpPolicyNetEntry = rapid_city_new_rcIpPolicyNetEntry();
    if (! rcIpPolicyNetEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyNetEntry + sizeof(rapid_city_rcIpPolicyNetEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyNetEntry((GSnmpVarBind *) vbl->data, rcIpPolicyNetEntry) < 0) {
        g_warning("illegal rcIpPolicyNetEntry instance identifier");
        g_free(rcIpPolicyNetEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyNetEntry, sizeof(oid_rcIpPolicyNetEntry)/sizeof(guint32),
                   attr_rcIpPolicyNetEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpPolicyNetEntry->rcIpPolicyNetId = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyNetEntry->rcIpPolicyNetNetListIdListSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyNetEntry->rcIpPolicyNetNetListIdList = vb->syntax.uc;
            break;
        case 6:
            rcIpPolicyNetEntry->rcIpPolicyNetRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyNetEntry;
}

void
rapid_city_get_rcIpPolicyNetTable(GSnmpSession *s, rapid_city_rcIpPolicyNetEntry_t ***rcIpPolicyNetEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 4, 1, 0};

    *rcIpPolicyNetEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyNetEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyNetEntry = (rapid_city_rcIpPolicyNetEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyNetEntry_t *));
        if (! *rcIpPolicyNetEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyNetEntry)[i] = assign_rcIpPolicyNetEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyNetEntry(GSnmpSession *s, rapid_city_rcIpPolicyNetEntry_t **rcIpPolicyNetEntry, guchar *rcIpPolicyNetAddr, guchar *rcIpPolicyNetMask, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyNetEntry, sizeof(oid_rcIpPolicyNetEntry));
    len = pack_rcIpPolicyNetEntry(base, rcIpPolicyNetAddr, rcIpPolicyNetMask);
    if (len < 0) {
        g_warning("illegal rcIpPolicyNetEntry index values");
        return;
    }

    *rcIpPolicyNetEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyNetEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyNetEntry = assign_rcIpPolicyNetEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyNetEntry(GSnmpSession *s, rapid_city_rcIpPolicyNetEntry_t *rcIpPolicyNetEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyNetEntry, sizeof(oid_rcIpPolicyNetEntry));
    len = pack_rcIpPolicyNetEntry(base, rcIpPolicyNetEntry->rcIpPolicyNetAddr, rcIpPolicyNetEntry->rcIpPolicyNetMask);
    if (len < 0) {
        g_warning("illegal rcIpPolicyNetEntry index values");
        return;
    }

    if (rcIpPolicyNetEntry->rcIpPolicyNetRowStatus) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyNetEntry->rcIpPolicyNetRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyNetEntry(rapid_city_rcIpPolicyNetEntry_t *rcIpPolicyNetEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyNetEntry) {
        p = (char *) rcIpPolicyNetEntry + sizeof(rapid_city_rcIpPolicyNetEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyNetEntry);
    }
}

void
rapid_city_free_rcIpPolicyNetTable(rapid_city_rcIpPolicyNetEntry_t **rcIpPolicyNetEntry)
{
    int i;

    if (rcIpPolicyNetEntry) {
        for (i = 0; rcIpPolicyNetEntry[i]; i++) {
            rapid_city_free_rcIpPolicyNetEntry(rcIpPolicyNetEntry[i]);
        }
        g_free(rcIpPolicyNetEntry);
    }
}

rapid_city_rcIpPolicyAddrListEntry_t *
rapid_city_new_rcIpPolicyAddrListEntry()
{
    rapid_city_rcIpPolicyAddrListEntry_t *rcIpPolicyAddrListEntry;

    rcIpPolicyAddrListEntry = (rapid_city_rcIpPolicyAddrListEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyAddrListEntry_t) + sizeof(gpointer));
    return rcIpPolicyAddrListEntry;
}

static int
unpack_rcIpPolicyAddrListEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyAddrListEntry_t *rcIpPolicyAddrListEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyAddrListEntry->rcIpPolicyAddrListId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyAddrListEntry(guint32 *base, gint32 rcIpPolicyAddrListId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyAddrListId;
    return idx;
}

static rapid_city_rcIpPolicyAddrListEntry_t *
assign_rcIpPolicyAddrListEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyAddrListEntry_t *rcIpPolicyAddrListEntry;
    guint32 idx;
    char *p;

    rcIpPolicyAddrListEntry = rapid_city_new_rcIpPolicyAddrListEntry();
    if (! rcIpPolicyAddrListEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyAddrListEntry + sizeof(rapid_city_rcIpPolicyAddrListEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyAddrListEntry((GSnmpVarBind *) vbl->data, rcIpPolicyAddrListEntry) < 0) {
        g_warning("illegal rcIpPolicyAddrListEntry instance identifier");
        g_free(rcIpPolicyAddrListEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyAddrListEntry, sizeof(oid_rcIpPolicyAddrListEntry)/sizeof(guint32),
                   attr_rcIpPolicyAddrListEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpPolicyAddrListEntry->_rcIpPolicyAddrListNameLength = vb->syntax_len;
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListName = vb->syntax.uc;
            break;
        case 4:
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListIdListSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListIdList = vb->syntax.uc;
            break;
        case 6:
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListPolicyIdListSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListPolicyIdList = vb->syntax.uc;
            break;
        case 8:
            rcIpPolicyAddrListEntry->rcIpPolicyAddrListRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyAddrListEntry;
}

void
rapid_city_get_rcIpPolicyAddrListTable(GSnmpSession *s, rapid_city_rcIpPolicyAddrListEntry_t ***rcIpPolicyAddrListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 6, 1, 0};

    *rcIpPolicyAddrListEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyAddrListEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyAddrListEntry = (rapid_city_rcIpPolicyAddrListEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyAddrListEntry_t *));
        if (! *rcIpPolicyAddrListEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyAddrListEntry)[i] = assign_rcIpPolicyAddrListEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyAddrListEntry(GSnmpSession *s, rapid_city_rcIpPolicyAddrListEntry_t **rcIpPolicyAddrListEntry, gint32 rcIpPolicyAddrListId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyAddrListEntry, sizeof(oid_rcIpPolicyAddrListEntry));
    len = pack_rcIpPolicyAddrListEntry(base, rcIpPolicyAddrListId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyAddrListEntry index values");
        return;
    }

    *rcIpPolicyAddrListEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyAddrListEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyAddrListEntry = assign_rcIpPolicyAddrListEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyAddrListEntry(GSnmpSession *s, rapid_city_rcIpPolicyAddrListEntry_t *rcIpPolicyAddrListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyAddrListEntry, sizeof(oid_rcIpPolicyAddrListEntry));
    len = pack_rcIpPolicyAddrListEntry(base, rcIpPolicyAddrListEntry->rcIpPolicyAddrListId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyAddrListEntry index values");
        return;
    }

    if (rcIpPolicyAddrListEntry->rcIpPolicyAddrListName) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyAddrListEntry->rcIpPolicyAddrListName,
                       rcIpPolicyAddrListEntry->_rcIpPolicyAddrListNameLength);
    }
    if (rcIpPolicyAddrListEntry->rcIpPolicyAddrListIdList) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyAddrListEntry->rcIpPolicyAddrListIdList,
                       256);
    }
    if (rcIpPolicyAddrListEntry->rcIpPolicyAddrListRowStatus) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyAddrListEntry->rcIpPolicyAddrListRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyAddrListEntry(rapid_city_rcIpPolicyAddrListEntry_t *rcIpPolicyAddrListEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyAddrListEntry) {
        p = (char *) rcIpPolicyAddrListEntry + sizeof(rapid_city_rcIpPolicyAddrListEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyAddrListEntry);
    }
}

void
rapid_city_free_rcIpPolicyAddrListTable(rapid_city_rcIpPolicyAddrListEntry_t **rcIpPolicyAddrListEntry)
{
    int i;

    if (rcIpPolicyAddrListEntry) {
        for (i = 0; rcIpPolicyAddrListEntry[i]; i++) {
            rapid_city_free_rcIpPolicyAddrListEntry(rcIpPolicyAddrListEntry[i]);
        }
        g_free(rcIpPolicyAddrListEntry);
    }
}

rapid_city_rcIpPolicyRipAnnounceEntry_t *
rapid_city_new_rcIpPolicyRipAnnounceEntry()
{
    rapid_city_rcIpPolicyRipAnnounceEntry_t *rcIpPolicyRipAnnounceEntry;

    rcIpPolicyRipAnnounceEntry = (rapid_city_rcIpPolicyRipAnnounceEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyRipAnnounceEntry_t) + sizeof(gpointer));
    return rcIpPolicyRipAnnounceEntry;
}

static int
unpack_rcIpPolicyRipAnnounceEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyRipAnnounceEntry_t *rcIpPolicyRipAnnounceEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyRipAnnounceEntry(guint32 *base, gint32 rcIpPolicyRipAnnounceId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyRipAnnounceId;
    return idx;
}

static rapid_city_rcIpPolicyRipAnnounceEntry_t *
assign_rcIpPolicyRipAnnounceEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyRipAnnounceEntry_t *rcIpPolicyRipAnnounceEntry;
    guint32 idx;
    char *p;

    rcIpPolicyRipAnnounceEntry = rapid_city_new_rcIpPolicyRipAnnounceEntry();
    if (! rcIpPolicyRipAnnounceEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyRipAnnounceEntry + sizeof(rapid_city_rcIpPolicyRipAnnounceEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyRipAnnounceEntry((GSnmpVarBind *) vbl->data, rcIpPolicyRipAnnounceEntry) < 0) {
        g_warning("illegal rcIpPolicyRipAnnounceEntry instance identifier");
        g_free(rcIpPolicyRipAnnounceEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyRipAnnounceEntry, sizeof(oid_rcIpPolicyRipAnnounceEntry)/sizeof(guint32),
                   attr_rcIpPolicyRipAnnounceEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpPolicyRipAnnounceEntry->_rcIpPolicyRipAnnounceNameLength = vb->syntax_len;
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceName = vb->syntax.uc;
            break;
        case 3:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceExactNetListId = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRangeNetListId = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipGatewayListId = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipInterfaceListId = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouterListId = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAnnounceInterfaceListId = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnouncePrecedence = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRouteSource = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAdvertiseNetListId = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAction = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouteType = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipMetric = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyRipAnnounceEntry;
}

void
rapid_city_get_rcIpPolicyRipAnnounceTable(GSnmpSession *s, rapid_city_rcIpPolicyRipAnnounceEntry_t ***rcIpPolicyRipAnnounceEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 8, 1, 0};

    *rcIpPolicyRipAnnounceEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyRipAnnounceEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyRipAnnounceEntry = (rapid_city_rcIpPolicyRipAnnounceEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyRipAnnounceEntry_t *));
        if (! *rcIpPolicyRipAnnounceEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyRipAnnounceEntry)[i] = assign_rcIpPolicyRipAnnounceEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyRipAnnounceEntry(GSnmpSession *s, rapid_city_rcIpPolicyRipAnnounceEntry_t **rcIpPolicyRipAnnounceEntry, gint32 rcIpPolicyRipAnnounceId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyRipAnnounceEntry, sizeof(oid_rcIpPolicyRipAnnounceEntry));
    len = pack_rcIpPolicyRipAnnounceEntry(base, rcIpPolicyRipAnnounceId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyRipAnnounceEntry index values");
        return;
    }

    *rcIpPolicyRipAnnounceEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyRipAnnounceEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyRipAnnounceEntry = assign_rcIpPolicyRipAnnounceEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyRipAnnounceEntry(GSnmpSession *s, rapid_city_rcIpPolicyRipAnnounceEntry_t *rcIpPolicyRipAnnounceEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyRipAnnounceEntry, sizeof(oid_rcIpPolicyRipAnnounceEntry));
    len = pack_rcIpPolicyRipAnnounceEntry(base, rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyRipAnnounceEntry index values");
        return;
    }

    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceName,
                       rcIpPolicyRipAnnounceEntry->_rcIpPolicyRipAnnounceNameLength);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceEnable) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceEnable,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceExactNetListId) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceExactNetListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRangeNetListId) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRangeNetListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipGatewayListId) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipGatewayListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipInterfaceListId) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipInterfaceListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouterListId) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouterListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAnnounceInterfaceListId) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAnnounceInterfaceListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnouncePrecedence) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnouncePrecedence,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRouteSource) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRouteSource,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAdvertiseNetListId) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAdvertiseNetListId,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAction) {
        base[12] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceAction,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouteType) {
        base[12] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceOspfRouteType,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipMetric) {
        base[12] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRipMetric,
                       0);
    }
    if (rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRowStatus) {
        base[12] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAnnounceEntry->rcIpPolicyRipAnnounceRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyRipAnnounceEntry(rapid_city_rcIpPolicyRipAnnounceEntry_t *rcIpPolicyRipAnnounceEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyRipAnnounceEntry) {
        p = (char *) rcIpPolicyRipAnnounceEntry + sizeof(rapid_city_rcIpPolicyRipAnnounceEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyRipAnnounceEntry);
    }
}

void
rapid_city_free_rcIpPolicyRipAnnounceTable(rapid_city_rcIpPolicyRipAnnounceEntry_t **rcIpPolicyRipAnnounceEntry)
{
    int i;

    if (rcIpPolicyRipAnnounceEntry) {
        for (i = 0; rcIpPolicyRipAnnounceEntry[i]; i++) {
            rapid_city_free_rcIpPolicyRipAnnounceEntry(rcIpPolicyRipAnnounceEntry[i]);
        }
        g_free(rcIpPolicyRipAnnounceEntry);
    }
}

rapid_city_rcIpPolicyOspfAnnounceEntry_t *
rapid_city_new_rcIpPolicyOspfAnnounceEntry()
{
    rapid_city_rcIpPolicyOspfAnnounceEntry_t *rcIpPolicyOspfAnnounceEntry;

    rcIpPolicyOspfAnnounceEntry = (rapid_city_rcIpPolicyOspfAnnounceEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyOspfAnnounceEntry_t) + sizeof(gpointer));
    return rcIpPolicyOspfAnnounceEntry;
}

static int
unpack_rcIpPolicyOspfAnnounceEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyOspfAnnounceEntry_t *rcIpPolicyOspfAnnounceEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyOspfAnnounceEntry(guint32 *base, gint32 rcIpPolicyOspfAnnounceId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyOspfAnnounceId;
    return idx;
}

static rapid_city_rcIpPolicyOspfAnnounceEntry_t *
assign_rcIpPolicyOspfAnnounceEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyOspfAnnounceEntry_t *rcIpPolicyOspfAnnounceEntry;
    guint32 idx;
    char *p;

    rcIpPolicyOspfAnnounceEntry = rapid_city_new_rcIpPolicyOspfAnnounceEntry();
    if (! rcIpPolicyOspfAnnounceEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyOspfAnnounceEntry + sizeof(rapid_city_rcIpPolicyOspfAnnounceEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyOspfAnnounceEntry((GSnmpVarBind *) vbl->data, rcIpPolicyOspfAnnounceEntry) < 0) {
        g_warning("illegal rcIpPolicyOspfAnnounceEntry instance identifier");
        g_free(rcIpPolicyOspfAnnounceEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyOspfAnnounceEntry, sizeof(oid_rcIpPolicyOspfAnnounceEntry)/sizeof(guint32),
                   attr_rcIpPolicyOspfAnnounceEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpPolicyOspfAnnounceEntry->_rcIpPolicyOspfAnnounceNameLength = vb->syntax_len;
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceName = vb->syntax.uc;
            break;
        case 3:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExactNetListId = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRangeNetListId = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipGatewayListId = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipInterfaceListId = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnouncePrecedence = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRouteSource = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAdvertiseNetListId = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAction = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetricType = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetric = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyOspfAnnounceEntry;
}

void
rapid_city_get_rcIpPolicyOspfAnnounceTable(GSnmpSession *s, rapid_city_rcIpPolicyOspfAnnounceEntry_t ***rcIpPolicyOspfAnnounceEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 10, 1, 0};

    *rcIpPolicyOspfAnnounceEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyOspfAnnounceEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyOspfAnnounceEntry = (rapid_city_rcIpPolicyOspfAnnounceEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyOspfAnnounceEntry_t *));
        if (! *rcIpPolicyOspfAnnounceEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyOspfAnnounceEntry)[i] = assign_rcIpPolicyOspfAnnounceEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyOspfAnnounceEntry(GSnmpSession *s, rapid_city_rcIpPolicyOspfAnnounceEntry_t **rcIpPolicyOspfAnnounceEntry, gint32 rcIpPolicyOspfAnnounceId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyOspfAnnounceEntry, sizeof(oid_rcIpPolicyOspfAnnounceEntry));
    len = pack_rcIpPolicyOspfAnnounceEntry(base, rcIpPolicyOspfAnnounceId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyOspfAnnounceEntry index values");
        return;
    }

    *rcIpPolicyOspfAnnounceEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyOspfAnnounceEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyOspfAnnounceEntry = assign_rcIpPolicyOspfAnnounceEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyOspfAnnounceEntry(GSnmpSession *s, rapid_city_rcIpPolicyOspfAnnounceEntry_t *rcIpPolicyOspfAnnounceEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyOspfAnnounceEntry, sizeof(oid_rcIpPolicyOspfAnnounceEntry));
    len = pack_rcIpPolicyOspfAnnounceEntry(base, rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyOspfAnnounceEntry index values");
        return;
    }

    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceName,
                       rcIpPolicyOspfAnnounceEntry->_rcIpPolicyOspfAnnounceNameLength);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceEnable) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceEnable,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExactNetListId) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExactNetListId,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRangeNetListId) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRangeNetListId,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipGatewayListId) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipGatewayListId,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipInterfaceListId) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRipInterfaceListId,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnouncePrecedence) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnouncePrecedence,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRouteSource) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRouteSource,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAdvertiseNetListId) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAdvertiseNetListId,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAction) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceAction,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetricType) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetricType,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetric) {
        base[12] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceExtMetric,
                       0);
    }
    if (rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRowStatus) {
        base[12] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAnnounceEntry->rcIpPolicyOspfAnnounceRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyOspfAnnounceEntry(rapid_city_rcIpPolicyOspfAnnounceEntry_t *rcIpPolicyOspfAnnounceEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyOspfAnnounceEntry) {
        p = (char *) rcIpPolicyOspfAnnounceEntry + sizeof(rapid_city_rcIpPolicyOspfAnnounceEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyOspfAnnounceEntry);
    }
}

void
rapid_city_free_rcIpPolicyOspfAnnounceTable(rapid_city_rcIpPolicyOspfAnnounceEntry_t **rcIpPolicyOspfAnnounceEntry)
{
    int i;

    if (rcIpPolicyOspfAnnounceEntry) {
        for (i = 0; rcIpPolicyOspfAnnounceEntry[i]; i++) {
            rapid_city_free_rcIpPolicyOspfAnnounceEntry(rcIpPolicyOspfAnnounceEntry[i]);
        }
        g_free(rcIpPolicyOspfAnnounceEntry);
    }
}

rapid_city_rcIpPolicyRipAcceptEntry_t *
rapid_city_new_rcIpPolicyRipAcceptEntry()
{
    rapid_city_rcIpPolicyRipAcceptEntry_t *rcIpPolicyRipAcceptEntry;

    rcIpPolicyRipAcceptEntry = (rapid_city_rcIpPolicyRipAcceptEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyRipAcceptEntry_t) + sizeof(gpointer));
    return rcIpPolicyRipAcceptEntry;
}

static int
unpack_rcIpPolicyRipAcceptEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyRipAcceptEntry_t *rcIpPolicyRipAcceptEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyRipAcceptEntry(guint32 *base, gint32 rcIpPolicyRipAcceptId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyRipAcceptId;
    return idx;
}

static rapid_city_rcIpPolicyRipAcceptEntry_t *
assign_rcIpPolicyRipAcceptEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyRipAcceptEntry_t *rcIpPolicyRipAcceptEntry;
    guint32 idx;
    char *p;

    rcIpPolicyRipAcceptEntry = rapid_city_new_rcIpPolicyRipAcceptEntry();
    if (! rcIpPolicyRipAcceptEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyRipAcceptEntry + sizeof(rapid_city_rcIpPolicyRipAcceptEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyRipAcceptEntry((GSnmpVarBind *) vbl->data, rcIpPolicyRipAcceptEntry) < 0) {
        g_warning("illegal rcIpPolicyRipAcceptEntry instance identifier");
        g_free(rcIpPolicyRipAcceptEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyRipAcceptEntry, sizeof(oid_rcIpPolicyRipAcceptEntry)/sizeof(guint32),
                   attr_rcIpPolicyRipAcceptEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpPolicyRipAcceptEntry->_rcIpPolicyRipAcceptNameLength = vb->syntax_len;
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptName = vb->syntax.uc;
            break;
        case 3:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptExactNetListId = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRangeNetListId = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipGatewayListId = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipInterfaceListId = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptPrecedence = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptAction = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptInjectNetListId = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptApplyMask = vb->syntax.uc;
            break;
        case 12:
            rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyRipAcceptEntry;
}

void
rapid_city_get_rcIpPolicyRipAcceptTable(GSnmpSession *s, rapid_city_rcIpPolicyRipAcceptEntry_t ***rcIpPolicyRipAcceptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 12, 1, 0};

    *rcIpPolicyRipAcceptEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyRipAcceptEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyRipAcceptEntry = (rapid_city_rcIpPolicyRipAcceptEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyRipAcceptEntry_t *));
        if (! *rcIpPolicyRipAcceptEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyRipAcceptEntry)[i] = assign_rcIpPolicyRipAcceptEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyRipAcceptEntry(GSnmpSession *s, rapid_city_rcIpPolicyRipAcceptEntry_t **rcIpPolicyRipAcceptEntry, gint32 rcIpPolicyRipAcceptId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyRipAcceptEntry, sizeof(oid_rcIpPolicyRipAcceptEntry));
    len = pack_rcIpPolicyRipAcceptEntry(base, rcIpPolicyRipAcceptId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyRipAcceptEntry index values");
        return;
    }

    *rcIpPolicyRipAcceptEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyRipAcceptEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyRipAcceptEntry = assign_rcIpPolicyRipAcceptEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyRipAcceptEntry(GSnmpSession *s, rapid_city_rcIpPolicyRipAcceptEntry_t *rcIpPolicyRipAcceptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyRipAcceptEntry, sizeof(oid_rcIpPolicyRipAcceptEntry));
    len = pack_rcIpPolicyRipAcceptEntry(base, rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyRipAcceptEntry index values");
        return;
    }

    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptName,
                       rcIpPolicyRipAcceptEntry->_rcIpPolicyRipAcceptNameLength);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptEnable) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptEnable,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptExactNetListId) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptExactNetListId,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRangeNetListId) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRangeNetListId,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipGatewayListId) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipGatewayListId,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipInterfaceListId) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRipInterfaceListId,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptPrecedence) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptPrecedence,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptAction) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptAction,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptInjectNetListId) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptInjectNetListId,
                       0);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptApplyMask) {
        base[12] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptApplyMask,
                       4);
    }
    if (rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRowStatus) {
        base[12] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyRipAcceptEntry->rcIpPolicyRipAcceptRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyRipAcceptEntry(rapid_city_rcIpPolicyRipAcceptEntry_t *rcIpPolicyRipAcceptEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyRipAcceptEntry) {
        p = (char *) rcIpPolicyRipAcceptEntry + sizeof(rapid_city_rcIpPolicyRipAcceptEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyRipAcceptEntry);
    }
}

void
rapid_city_free_rcIpPolicyRipAcceptTable(rapid_city_rcIpPolicyRipAcceptEntry_t **rcIpPolicyRipAcceptEntry)
{
    int i;

    if (rcIpPolicyRipAcceptEntry) {
        for (i = 0; rcIpPolicyRipAcceptEntry[i]; i++) {
            rapid_city_free_rcIpPolicyRipAcceptEntry(rcIpPolicyRipAcceptEntry[i]);
        }
        g_free(rcIpPolicyRipAcceptEntry);
    }
}

rapid_city_rcIpPolicyOspfAcceptEntry_t *
rapid_city_new_rcIpPolicyOspfAcceptEntry()
{
    rapid_city_rcIpPolicyOspfAcceptEntry_t *rcIpPolicyOspfAcceptEntry;

    rcIpPolicyOspfAcceptEntry = (rapid_city_rcIpPolicyOspfAcceptEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyOspfAcceptEntry_t) + sizeof(gpointer));
    return rcIpPolicyOspfAcceptEntry;
}

static int
unpack_rcIpPolicyOspfAcceptEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyOspfAcceptEntry_t *rcIpPolicyOspfAcceptEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyOspfAcceptEntry(guint32 *base, gint32 rcIpPolicyOspfAcceptId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyOspfAcceptId;
    return idx;
}

static rapid_city_rcIpPolicyOspfAcceptEntry_t *
assign_rcIpPolicyOspfAcceptEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyOspfAcceptEntry_t *rcIpPolicyOspfAcceptEntry;
    guint32 idx;
    char *p;

    rcIpPolicyOspfAcceptEntry = rapid_city_new_rcIpPolicyOspfAcceptEntry();
    if (! rcIpPolicyOspfAcceptEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyOspfAcceptEntry + sizeof(rapid_city_rcIpPolicyOspfAcceptEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyOspfAcceptEntry((GSnmpVarBind *) vbl->data, rcIpPolicyOspfAcceptEntry) < 0) {
        g_warning("illegal rcIpPolicyOspfAcceptEntry instance identifier");
        g_free(rcIpPolicyOspfAcceptEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyOspfAcceptEntry, sizeof(oid_rcIpPolicyOspfAcceptEntry)/sizeof(guint32),
                   attr_rcIpPolicyOspfAcceptEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpPolicyOspfAcceptEntry->_rcIpPolicyOspfAcceptNameLength = vb->syntax_len;
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptName = vb->syntax.uc;
            break;
        case 3:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptEnable = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExactNetListId = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRangeNetListId = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptPrecedence = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptAction = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptInjectNetListId = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExtType = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyOspfAcceptEntry;
}

void
rapid_city_get_rcIpPolicyOspfAcceptTable(GSnmpSession *s, rapid_city_rcIpPolicyOspfAcceptEntry_t ***rcIpPolicyOspfAcceptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 14, 1, 0};

    *rcIpPolicyOspfAcceptEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyOspfAcceptEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyOspfAcceptEntry = (rapid_city_rcIpPolicyOspfAcceptEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyOspfAcceptEntry_t *));
        if (! *rcIpPolicyOspfAcceptEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyOspfAcceptEntry)[i] = assign_rcIpPolicyOspfAcceptEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyOspfAcceptEntry(GSnmpSession *s, rapid_city_rcIpPolicyOspfAcceptEntry_t **rcIpPolicyOspfAcceptEntry, gint32 rcIpPolicyOspfAcceptId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyOspfAcceptEntry, sizeof(oid_rcIpPolicyOspfAcceptEntry));
    len = pack_rcIpPolicyOspfAcceptEntry(base, rcIpPolicyOspfAcceptId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyOspfAcceptEntry index values");
        return;
    }

    *rcIpPolicyOspfAcceptEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyOspfAcceptEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyOspfAcceptEntry = assign_rcIpPolicyOspfAcceptEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyOspfAcceptEntry(GSnmpSession *s, rapid_city_rcIpPolicyOspfAcceptEntry_t *rcIpPolicyOspfAcceptEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyOspfAcceptEntry, sizeof(oid_rcIpPolicyOspfAcceptEntry));
    len = pack_rcIpPolicyOspfAcceptEntry(base, rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyOspfAcceptEntry index values");
        return;
    }

    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptName,
                       rcIpPolicyOspfAcceptEntry->_rcIpPolicyOspfAcceptNameLength);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptEnable) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptEnable,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExactNetListId) {
        base[12] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExactNetListId,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRangeNetListId) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRangeNetListId,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptPrecedence) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptPrecedence,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptAction) {
        base[12] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptAction,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptInjectNetListId) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptInjectNetListId,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExtType) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptExtType,
                       0);
    }
    if (rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRowStatus) {
        base[12] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyOspfAcceptEntry->rcIpPolicyOspfAcceptRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyOspfAcceptEntry(rapid_city_rcIpPolicyOspfAcceptEntry_t *rcIpPolicyOspfAcceptEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyOspfAcceptEntry) {
        p = (char *) rcIpPolicyOspfAcceptEntry + sizeof(rapid_city_rcIpPolicyOspfAcceptEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyOspfAcceptEntry);
    }
}

void
rapid_city_free_rcIpPolicyOspfAcceptTable(rapid_city_rcIpPolicyOspfAcceptEntry_t **rcIpPolicyOspfAcceptEntry)
{
    int i;

    if (rcIpPolicyOspfAcceptEntry) {
        for (i = 0; rcIpPolicyOspfAcceptEntry[i]; i++) {
            rapid_city_free_rcIpPolicyOspfAcceptEntry(rcIpPolicyOspfAcceptEntry[i]);
        }
        g_free(rcIpPolicyOspfAcceptEntry);
    }
}

rapid_city_rcIpPolicyNetListEntry_t *
rapid_city_new_rcIpPolicyNetListEntry()
{
    rapid_city_rcIpPolicyNetListEntry_t *rcIpPolicyNetListEntry;

    rcIpPolicyNetListEntry = (rapid_city_rcIpPolicyNetListEntry_t *) g_malloc0(sizeof(rapid_city_rcIpPolicyNetListEntry_t) + sizeof(gpointer));
    return rcIpPolicyNetListEntry;
}

static int
unpack_rcIpPolicyNetListEntry(GSnmpVarBind *vb, rapid_city_rcIpPolicyNetListEntry_t *rcIpPolicyNetListEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpPolicyNetListEntry->rcIpPolicyNetListId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpPolicyNetListEntry(guint32 *base, gint32 rcIpPolicyNetListId)
{
    int idx = 13;

    base[idx++] = rcIpPolicyNetListId;
    return idx;
}

static rapid_city_rcIpPolicyNetListEntry_t *
assign_rcIpPolicyNetListEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpPolicyNetListEntry_t *rcIpPolicyNetListEntry;
    guint32 idx;
    char *p;

    rcIpPolicyNetListEntry = rapid_city_new_rcIpPolicyNetListEntry();
    if (! rcIpPolicyNetListEntry) {
        return NULL;
    }

    p = (char *) rcIpPolicyNetListEntry + sizeof(rapid_city_rcIpPolicyNetListEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpPolicyNetListEntry((GSnmpVarBind *) vbl->data, rcIpPolicyNetListEntry) < 0) {
        g_warning("illegal rcIpPolicyNetListEntry instance identifier");
        g_free(rcIpPolicyNetListEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpPolicyNetListEntry, sizeof(oid_rcIpPolicyNetListEntry)/sizeof(guint32),
                   attr_rcIpPolicyNetListEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpPolicyNetListEntry->_rcIpPolicyNetListNameLength = vb->syntax_len;
            rcIpPolicyNetListEntry->rcIpPolicyNetListName = vb->syntax.uc;
            break;
        case 4:
            rcIpPolicyNetListEntry->rcIpPolicyNetListIdListSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpPolicyNetListEntry->rcIpPolicyNetListIdList = vb->syntax.uc;
            break;
        case 6:
            rcIpPolicyNetListEntry->rcIpPolicyNetListPolicyIdListSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpPolicyNetListEntry->rcIpPolicyNetListPolicyIdList = vb->syntax.uc;
            break;
        case 8:
            rcIpPolicyNetListEntry->rcIpPolicyNetListRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpPolicyNetListEntry;
}

void
rapid_city_get_rcIpPolicyNetListTable(GSnmpSession *s, rapid_city_rcIpPolicyNetListEntry_t ***rcIpPolicyNetListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 11, 16, 1, 0};

    *rcIpPolicyNetListEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpPolicyNetListEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpPolicyNetListEntry = (rapid_city_rcIpPolicyNetListEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpPolicyNetListEntry_t *));
        if (! *rcIpPolicyNetListEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpPolicyNetListEntry)[i] = assign_rcIpPolicyNetListEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpPolicyNetListEntry(GSnmpSession *s, rapid_city_rcIpPolicyNetListEntry_t **rcIpPolicyNetListEntry, gint32 rcIpPolicyNetListId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyNetListEntry, sizeof(oid_rcIpPolicyNetListEntry));
    len = pack_rcIpPolicyNetListEntry(base, rcIpPolicyNetListId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyNetListEntry index values");
        return;
    }

    *rcIpPolicyNetListEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpPolicyNetListEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpPolicyNetListEntry = assign_rcIpPolicyNetListEntry(out);
    }
}

void
rapid_city_set_rcIpPolicyNetListEntry(GSnmpSession *s, rapid_city_rcIpPolicyNetListEntry_t *rcIpPolicyNetListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpPolicyNetListEntry, sizeof(oid_rcIpPolicyNetListEntry));
    len = pack_rcIpPolicyNetListEntry(base, rcIpPolicyNetListEntry->rcIpPolicyNetListId);
    if (len < 0) {
        g_warning("illegal rcIpPolicyNetListEntry index values");
        return;
    }

    if (rcIpPolicyNetListEntry->rcIpPolicyNetListName) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyNetListEntry->rcIpPolicyNetListName,
                       rcIpPolicyNetListEntry->_rcIpPolicyNetListNameLength);
    }
    if (rcIpPolicyNetListEntry->rcIpPolicyNetListIdList) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpPolicyNetListEntry->rcIpPolicyNetListIdList,
                       256);
    }
    if (rcIpPolicyNetListEntry->rcIpPolicyNetListRowStatus) {
        base[12] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpPolicyNetListEntry->rcIpPolicyNetListRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpPolicyNetListEntry(rapid_city_rcIpPolicyNetListEntry_t *rcIpPolicyNetListEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpPolicyNetListEntry) {
        p = (char *) rcIpPolicyNetListEntry + sizeof(rapid_city_rcIpPolicyNetListEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpPolicyNetListEntry);
    }
}

void
rapid_city_free_rcIpPolicyNetListTable(rapid_city_rcIpPolicyNetListEntry_t **rcIpPolicyNetListEntry)
{
    int i;

    if (rcIpPolicyNetListEntry) {
        for (i = 0; rcIpPolicyNetListEntry[i]; i++) {
            rapid_city_free_rcIpPolicyNetListEntry(rcIpPolicyNetListEntry[i]);
        }
        g_free(rcIpPolicyNetListEntry);
    }
}

rapid_city_rcIpDvmrp_t *
rapid_city_new_rcIpDvmrp()
{
    rapid_city_rcIpDvmrp_t *rcIpDvmrp;

    rcIpDvmrp = (rapid_city_rcIpDvmrp_t *) g_malloc0(sizeof(rapid_city_rcIpDvmrp_t) + sizeof(gpointer));
    return rcIpDvmrp;
}

static rapid_city_rcIpDvmrp_t *
assign_rcIpDvmrp(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpDvmrp_t *rcIpDvmrp;
    guint32 idx;
    char *p;

    rcIpDvmrp = rapid_city_new_rcIpDvmrp();
    if (! rcIpDvmrp) {
        return NULL;
    }

    p = (char *) rcIpDvmrp + sizeof(rapid_city_rcIpDvmrp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpDvmrp, sizeof(oid_rcIpDvmrp)/sizeof(guint32),
                   attr_rcIpDvmrp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpDvmrp->rcIpDvmrpEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpDvmrp;
}

void
rapid_city_get_rcIpDvmrp(GSnmpSession *s, rapid_city_rcIpDvmrp_t **rcIpDvmrp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 12, 0};

    *rcIpDvmrp = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcIpDvmrp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpDvmrp = assign_rcIpDvmrp(out);
    }
}

void
rapid_city_set_rcIpDvmrp(GSnmpSession *s, rapid_city_rcIpDvmrp_t *rcIpDvmrp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 12, 0, 0};

    if (rcIpDvmrp->rcIpDvmrpEnable) {
        base[10] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpDvmrp->rcIpDvmrpEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpDvmrp(rapid_city_rcIpDvmrp_t *rcIpDvmrp)
{
    GSList *vbl;
    char *p;

    if (rcIpDvmrp) {
        p = (char *) rcIpDvmrp + sizeof(rapid_city_rcIpDvmrp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpDvmrp);
    }
}

rapid_city_rcIpConfDvmrpTableEntry_t *
rapid_city_new_rcIpConfDvmrpTableEntry()
{
    rapid_city_rcIpConfDvmrpTableEntry_t *rcIpConfDvmrpTableEntry;

    rcIpConfDvmrpTableEntry = (rapid_city_rcIpConfDvmrpTableEntry_t *) g_malloc0(sizeof(rapid_city_rcIpConfDvmrpTableEntry_t) + sizeof(gpointer));
    return rcIpConfDvmrpTableEntry;
}

static int
unpack_rcIpConfDvmrpTableEntry(GSnmpVarBind *vb, rapid_city_rcIpConfDvmrpTableEntry_t *rcIpConfDvmrpTableEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpConfDvmrpTableEntry(guint32 *base, gint32 rcIpConfDvmrpTableIfIndex)
{
    int idx = 13;

    base[idx++] = rcIpConfDvmrpTableIfIndex;
    return idx;
}

static rapid_city_rcIpConfDvmrpTableEntry_t *
assign_rcIpConfDvmrpTableEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpConfDvmrpTableEntry_t *rcIpConfDvmrpTableEntry;
    guint32 idx;
    char *p;

    rcIpConfDvmrpTableEntry = rapid_city_new_rcIpConfDvmrpTableEntry();
    if (! rcIpConfDvmrpTableEntry) {
        return NULL;
    }

    p = (char *) rcIpConfDvmrpTableEntry + sizeof(rapid_city_rcIpConfDvmrpTableEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpConfDvmrpTableEntry((GSnmpVarBind *) vbl->data, rcIpConfDvmrpTableEntry) < 0) {
        g_warning("illegal rcIpConfDvmrpTableEntry instance identifier");
        g_free(rcIpConfDvmrpTableEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpConfDvmrpTableEntry, sizeof(oid_rcIpConfDvmrpTableEntry)/sizeof(guint32),
                   attr_rcIpConfDvmrpTableEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableEnable = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableMetric = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpConfDvmrpTableEntry;
}

void
rapid_city_get_rcIpConfDvmrpTable(GSnmpSession *s, rapid_city_rcIpConfDvmrpTableEntry_t ***rcIpConfDvmrpTableEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 12, 10, 1, 0};

    *rcIpConfDvmrpTableEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpConfDvmrpTableEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpConfDvmrpTableEntry = (rapid_city_rcIpConfDvmrpTableEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpConfDvmrpTableEntry_t *));
        if (! *rcIpConfDvmrpTableEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpConfDvmrpTableEntry)[i] = assign_rcIpConfDvmrpTableEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpConfDvmrpTableEntry(GSnmpSession *s, rapid_city_rcIpConfDvmrpTableEntry_t **rcIpConfDvmrpTableEntry, gint32 rcIpConfDvmrpTableIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfDvmrpTableEntry, sizeof(oid_rcIpConfDvmrpTableEntry));
    len = pack_rcIpConfDvmrpTableEntry(base, rcIpConfDvmrpTableIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfDvmrpTableEntry index values");
        return;
    }

    *rcIpConfDvmrpTableEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpConfDvmrpTableEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpConfDvmrpTableEntry = assign_rcIpConfDvmrpTableEntry(out);
    }
}

void
rapid_city_set_rcIpConfDvmrpTableEntry(GSnmpSession *s, rapid_city_rcIpConfDvmrpTableEntry_t *rcIpConfDvmrpTableEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpConfDvmrpTableEntry, sizeof(oid_rcIpConfDvmrpTableEntry));
    len = pack_rcIpConfDvmrpTableEntry(base, rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableIfIndex);
    if (len < 0) {
        g_warning("illegal rcIpConfDvmrpTableEntry index values");
        return;
    }

    if (rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableEnable) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableEnable,
                       0);
    }
    if (rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableMetric) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpConfDvmrpTableEntry->rcIpConfDvmrpTableMetric,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpConfDvmrpTableEntry(rapid_city_rcIpConfDvmrpTableEntry_t *rcIpConfDvmrpTableEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpConfDvmrpTableEntry) {
        p = (char *) rcIpConfDvmrpTableEntry + sizeof(rapid_city_rcIpConfDvmrpTableEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpConfDvmrpTableEntry);
    }
}

void
rapid_city_free_rcIpConfDvmrpTable(rapid_city_rcIpConfDvmrpTableEntry_t **rcIpConfDvmrpTableEntry)
{
    int i;

    if (rcIpConfDvmrpTableEntry) {
        for (i = 0; rcIpConfDvmrpTableEntry[i]; i++) {
            rapid_city_free_rcIpConfDvmrpTableEntry(rcIpConfDvmrpTableEntry[i]);
        }
        g_free(rcIpConfDvmrpTableEntry);
    }
}

rapid_city_rcIpUdp_t *
rapid_city_new_rcIpUdp()
{
    rapid_city_rcIpUdp_t *rcIpUdp;

    rcIpUdp = (rapid_city_rcIpUdp_t *) g_malloc0(sizeof(rapid_city_rcIpUdp_t) + sizeof(gpointer));
    return rcIpUdp;
}

static rapid_city_rcIpUdp_t *
assign_rcIpUdp(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpUdp_t *rcIpUdp;
    guint32 idx;
    char *p;

    rcIpUdp = rapid_city_new_rcIpUdp();
    if (! rcIpUdp) {
        return NULL;
    }

    p = (char *) rcIpUdp + sizeof(rapid_city_rcIpUdp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpUdp, sizeof(oid_rcIpUdp)/sizeof(guint32),
                   attr_rcIpUdp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpUdp->rcIpUdpProtocolTableSize = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpUdp->rcIpUdpPortFwdTableSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpUdp->rcIpUdpPortFwdListTableSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcIpUdp->rcIpUdpConfBroadcastIntfTableSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpUdp;
}

void
rapid_city_get_rcIpUdp(GSnmpSession *s, rapid_city_rcIpUdp_t **rcIpUdp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 0};

    *rcIpUdp = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcIpUdp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpUdp = assign_rcIpUdp(out);
    }
}

void
rapid_city_free_rcIpUdp(rapid_city_rcIpUdp_t *rcIpUdp)
{
    GSList *vbl;
    char *p;

    if (rcIpUdp) {
        p = (char *) rcIpUdp + sizeof(rapid_city_rcIpUdp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpUdp);
    }
}

rapid_city_rcIpUdpProtocolEntry_t *
rapid_city_new_rcIpUdpProtocolEntry()
{
    rapid_city_rcIpUdpProtocolEntry_t *rcIpUdpProtocolEntry;

    rcIpUdpProtocolEntry = (rapid_city_rcIpUdpProtocolEntry_t *) g_malloc0(sizeof(rapid_city_rcIpUdpProtocolEntry_t) + sizeof(gpointer));
    return rcIpUdpProtocolEntry;
}

static int
unpack_rcIpUdpProtocolEntry(GSnmpVarBind *vb, rapid_city_rcIpUdpProtocolEntry_t *rcIpUdpProtocolEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpUdpProtocolEntry->rcIpUdpProtocolPortNumber = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpUdpProtocolEntry(guint32 *base, gint32 rcIpUdpProtocolPortNumber)
{
    int idx = 13;

    base[idx++] = rcIpUdpProtocolPortNumber;
    return idx;
}

static rapid_city_rcIpUdpProtocolEntry_t *
assign_rcIpUdpProtocolEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpUdpProtocolEntry_t *rcIpUdpProtocolEntry;
    guint32 idx;
    char *p;

    rcIpUdpProtocolEntry = rapid_city_new_rcIpUdpProtocolEntry();
    if (! rcIpUdpProtocolEntry) {
        return NULL;
    }

    p = (char *) rcIpUdpProtocolEntry + sizeof(rapid_city_rcIpUdpProtocolEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpUdpProtocolEntry((GSnmpVarBind *) vbl->data, rcIpUdpProtocolEntry) < 0) {
        g_warning("illegal rcIpUdpProtocolEntry instance identifier");
        g_free(rcIpUdpProtocolEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpUdpProtocolEntry, sizeof(oid_rcIpUdpProtocolEntry)/sizeof(guint32),
                   attr_rcIpUdpProtocolEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpUdpProtocolEntry->_rcIpUdpProtocolNameLength = vb->syntax_len;
            rcIpUdpProtocolEntry->rcIpUdpProtocolName = vb->syntax.uc;
            break;
        case 3:
            rcIpUdpProtocolEntry->rcIpUdpProtocolRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpUdpProtocolEntry;
}

void
rapid_city_get_rcIpUdpProtocolTable(GSnmpSession *s, rapid_city_rcIpUdpProtocolEntry_t ***rcIpUdpProtocolEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 2, 1, 0};

    *rcIpUdpProtocolEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpUdpProtocolEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpUdpProtocolEntry = (rapid_city_rcIpUdpProtocolEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpUdpProtocolEntry_t *));
        if (! *rcIpUdpProtocolEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpUdpProtocolEntry)[i] = assign_rcIpUdpProtocolEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpUdpProtocolEntry(GSnmpSession *s, rapid_city_rcIpUdpProtocolEntry_t **rcIpUdpProtocolEntry, gint32 rcIpUdpProtocolPortNumber, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpProtocolEntry, sizeof(oid_rcIpUdpProtocolEntry));
    len = pack_rcIpUdpProtocolEntry(base, rcIpUdpProtocolPortNumber);
    if (len < 0) {
        g_warning("illegal rcIpUdpProtocolEntry index values");
        return;
    }

    *rcIpUdpProtocolEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpUdpProtocolEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpUdpProtocolEntry = assign_rcIpUdpProtocolEntry(out);
    }
}

void
rapid_city_set_rcIpUdpProtocolEntry(GSnmpSession *s, rapid_city_rcIpUdpProtocolEntry_t *rcIpUdpProtocolEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpProtocolEntry, sizeof(oid_rcIpUdpProtocolEntry));
    len = pack_rcIpUdpProtocolEntry(base, rcIpUdpProtocolEntry->rcIpUdpProtocolPortNumber);
    if (len < 0) {
        g_warning("illegal rcIpUdpProtocolEntry index values");
        return;
    }

    if (rcIpUdpProtocolEntry->rcIpUdpProtocolName) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpUdpProtocolEntry->rcIpUdpProtocolName,
                       rcIpUdpProtocolEntry->_rcIpUdpProtocolNameLength);
    }
    if (rcIpUdpProtocolEntry->rcIpUdpProtocolRowStatus) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpProtocolEntry->rcIpUdpProtocolRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpUdpProtocolEntry(rapid_city_rcIpUdpProtocolEntry_t *rcIpUdpProtocolEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpUdpProtocolEntry) {
        p = (char *) rcIpUdpProtocolEntry + sizeof(rapid_city_rcIpUdpProtocolEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpUdpProtocolEntry);
    }
}

void
rapid_city_free_rcIpUdpProtocolTable(rapid_city_rcIpUdpProtocolEntry_t **rcIpUdpProtocolEntry)
{
    int i;

    if (rcIpUdpProtocolEntry) {
        for (i = 0; rcIpUdpProtocolEntry[i]; i++) {
            rapid_city_free_rcIpUdpProtocolEntry(rcIpUdpProtocolEntry[i]);
        }
        g_free(rcIpUdpProtocolEntry);
    }
}

rapid_city_rcIpUdpPortFwdEntry_t *
rapid_city_new_rcIpUdpPortFwdEntry()
{
    rapid_city_rcIpUdpPortFwdEntry_t *rcIpUdpPortFwdEntry;

    rcIpUdpPortFwdEntry = (rapid_city_rcIpUdpPortFwdEntry_t *) g_malloc0(sizeof(rapid_city_rcIpUdpPortFwdEntry_t) + sizeof(gpointer));
    return rcIpUdpPortFwdEntry;
}

static int
unpack_rcIpUdpPortFwdEntry(GSnmpVarBind *vb, rapid_city_rcIpUdpPortFwdEntry_t *rcIpUdpPortFwdEntry)
{
    int i, len, idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpUdpPortFwdEntry->rcIpUdpPortFwdDestPort = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpUdpPortFwdEntry->rcIpUdpPortFwdDestAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpUdpPortFwdEntry(guint32 *base, gint32 rcIpUdpPortFwdDestPort, guchar *rcIpUdpPortFwdDestAddr)
{
    int i, len, idx = 13;

    base[idx++] = rcIpUdpPortFwdDestPort;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpUdpPortFwdDestAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpUdpPortFwdEntry_t *
assign_rcIpUdpPortFwdEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpUdpPortFwdEntry_t *rcIpUdpPortFwdEntry;
    guint32 idx;
    char *p;

    rcIpUdpPortFwdEntry = rapid_city_new_rcIpUdpPortFwdEntry();
    if (! rcIpUdpPortFwdEntry) {
        return NULL;
    }

    p = (char *) rcIpUdpPortFwdEntry + sizeof(rapid_city_rcIpUdpPortFwdEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpUdpPortFwdEntry((GSnmpVarBind *) vbl->data, rcIpUdpPortFwdEntry) < 0) {
        g_warning("illegal rcIpUdpPortFwdEntry instance identifier");
        g_free(rcIpUdpPortFwdEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpUdpPortFwdEntry, sizeof(oid_rcIpUdpPortFwdEntry)/sizeof(guint32),
                   attr_rcIpUdpPortFwdEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdId = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdFwdListIdListSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdFwdListIdList = vb->syntax.uc;
            break;
        case 6:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdNumFwdPackets = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdNumDropPacketsTtlExpired = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdNumDropPacketsDestUnreach = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcIpUdpPortFwdEntry->rcIpUdpPortFwdRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpUdpPortFwdEntry;
}

void
rapid_city_get_rcIpUdpPortFwdTable(GSnmpSession *s, rapid_city_rcIpUdpPortFwdEntry_t ***rcIpUdpPortFwdEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 4, 1, 0};

    *rcIpUdpPortFwdEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpUdpPortFwdEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpUdpPortFwdEntry = (rapid_city_rcIpUdpPortFwdEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpUdpPortFwdEntry_t *));
        if (! *rcIpUdpPortFwdEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpUdpPortFwdEntry)[i] = assign_rcIpUdpPortFwdEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpUdpPortFwdEntry(GSnmpSession *s, rapid_city_rcIpUdpPortFwdEntry_t **rcIpUdpPortFwdEntry, gint32 rcIpUdpPortFwdDestPort, guchar *rcIpUdpPortFwdDestAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpPortFwdEntry, sizeof(oid_rcIpUdpPortFwdEntry));
    len = pack_rcIpUdpPortFwdEntry(base, rcIpUdpPortFwdDestPort, rcIpUdpPortFwdDestAddr);
    if (len < 0) {
        g_warning("illegal rcIpUdpPortFwdEntry index values");
        return;
    }

    *rcIpUdpPortFwdEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpUdpPortFwdEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpUdpPortFwdEntry = assign_rcIpUdpPortFwdEntry(out);
    }
}

void
rapid_city_set_rcIpUdpPortFwdEntry(GSnmpSession *s, rapid_city_rcIpUdpPortFwdEntry_t *rcIpUdpPortFwdEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpPortFwdEntry, sizeof(oid_rcIpUdpPortFwdEntry));
    len = pack_rcIpUdpPortFwdEntry(base, rcIpUdpPortFwdEntry->rcIpUdpPortFwdDestPort, rcIpUdpPortFwdEntry->rcIpUdpPortFwdDestAddr);
    if (len < 0) {
        g_warning("illegal rcIpUdpPortFwdEntry index values");
        return;
    }

    if (rcIpUdpPortFwdEntry->rcIpUdpPortFwdRowStatus) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpPortFwdEntry->rcIpUdpPortFwdRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpUdpPortFwdEntry(rapid_city_rcIpUdpPortFwdEntry_t *rcIpUdpPortFwdEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpUdpPortFwdEntry) {
        p = (char *) rcIpUdpPortFwdEntry + sizeof(rapid_city_rcIpUdpPortFwdEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpUdpPortFwdEntry);
    }
}

void
rapid_city_free_rcIpUdpPortFwdTable(rapid_city_rcIpUdpPortFwdEntry_t **rcIpUdpPortFwdEntry)
{
    int i;

    if (rcIpUdpPortFwdEntry) {
        for (i = 0; rcIpUdpPortFwdEntry[i]; i++) {
            rapid_city_free_rcIpUdpPortFwdEntry(rcIpUdpPortFwdEntry[i]);
        }
        g_free(rcIpUdpPortFwdEntry);
    }
}

rapid_city_rcIpUdpPortFwdListEntry_t *
rapid_city_new_rcIpUdpPortFwdListEntry()
{
    rapid_city_rcIpUdpPortFwdListEntry_t *rcIpUdpPortFwdListEntry;

    rcIpUdpPortFwdListEntry = (rapid_city_rcIpUdpPortFwdListEntry_t *) g_malloc0(sizeof(rapid_city_rcIpUdpPortFwdListEntry_t) + sizeof(gpointer));
    return rcIpUdpPortFwdListEntry;
}

static int
unpack_rcIpUdpPortFwdListEntry(GSnmpVarBind *vb, rapid_city_rcIpUdpPortFwdListEntry_t *rcIpUdpPortFwdListEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpUdpPortFwdListEntry(guint32 *base, gint32 rcIpUdpPortFwdListId)
{
    int idx = 13;

    base[idx++] = rcIpUdpPortFwdListId;
    return idx;
}

static rapid_city_rcIpUdpPortFwdListEntry_t *
assign_rcIpUdpPortFwdListEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpUdpPortFwdListEntry_t *rcIpUdpPortFwdListEntry;
    guint32 idx;
    char *p;

    rcIpUdpPortFwdListEntry = rapid_city_new_rcIpUdpPortFwdListEntry();
    if (! rcIpUdpPortFwdListEntry) {
        return NULL;
    }

    p = (char *) rcIpUdpPortFwdListEntry + sizeof(rapid_city_rcIpUdpPortFwdListEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpUdpPortFwdListEntry((GSnmpVarBind *) vbl->data, rcIpUdpPortFwdListEntry) < 0) {
        g_warning("illegal rcIpUdpPortFwdListEntry instance identifier");
        g_free(rcIpUdpPortFwdListEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpUdpPortFwdListEntry, sizeof(oid_rcIpUdpPortFwdListEntry)/sizeof(guint32),
                   attr_rcIpUdpPortFwdListEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcIpUdpPortFwdListEntry->_rcIpUdpPortFwdListNameLength = vb->syntax_len;
            rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListName = vb->syntax.uc;
            break;
        case 4:
            rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListFwdIdListSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListFwdIdList = vb->syntax.uc;
            break;
        case 6:
            rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpUdpPortFwdListEntry;
}

void
rapid_city_get_rcIpUdpPortFwdListTable(GSnmpSession *s, rapid_city_rcIpUdpPortFwdListEntry_t ***rcIpUdpPortFwdListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 6, 1, 0};

    *rcIpUdpPortFwdListEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpUdpPortFwdListEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpUdpPortFwdListEntry = (rapid_city_rcIpUdpPortFwdListEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpUdpPortFwdListEntry_t *));
        if (! *rcIpUdpPortFwdListEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpUdpPortFwdListEntry)[i] = assign_rcIpUdpPortFwdListEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpUdpPortFwdListEntry(GSnmpSession *s, rapid_city_rcIpUdpPortFwdListEntry_t **rcIpUdpPortFwdListEntry, gint32 rcIpUdpPortFwdListId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpPortFwdListEntry, sizeof(oid_rcIpUdpPortFwdListEntry));
    len = pack_rcIpUdpPortFwdListEntry(base, rcIpUdpPortFwdListId);
    if (len < 0) {
        g_warning("illegal rcIpUdpPortFwdListEntry index values");
        return;
    }

    *rcIpUdpPortFwdListEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpUdpPortFwdListEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpUdpPortFwdListEntry = assign_rcIpUdpPortFwdListEntry(out);
    }
}

void
rapid_city_set_rcIpUdpPortFwdListEntry(GSnmpSession *s, rapid_city_rcIpUdpPortFwdListEntry_t *rcIpUdpPortFwdListEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpPortFwdListEntry, sizeof(oid_rcIpUdpPortFwdListEntry));
    len = pack_rcIpUdpPortFwdListEntry(base, rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListId);
    if (len < 0) {
        g_warning("illegal rcIpUdpPortFwdListEntry index values");
        return;
    }

    if (rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListName) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListName,
                       rcIpUdpPortFwdListEntry->_rcIpUdpPortFwdListNameLength);
    }
    if (rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListFwdIdList) {
        base[12] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListFwdIdList,
                       32);
    }
    if (rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListRowStatus) {
        base[12] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpPortFwdListEntry->rcIpUdpPortFwdListRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpUdpPortFwdListEntry(rapid_city_rcIpUdpPortFwdListEntry_t *rcIpUdpPortFwdListEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpUdpPortFwdListEntry) {
        p = (char *) rcIpUdpPortFwdListEntry + sizeof(rapid_city_rcIpUdpPortFwdListEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpUdpPortFwdListEntry);
    }
}

void
rapid_city_free_rcIpUdpPortFwdListTable(rapid_city_rcIpUdpPortFwdListEntry_t **rcIpUdpPortFwdListEntry)
{
    int i;

    if (rcIpUdpPortFwdListEntry) {
        for (i = 0; rcIpUdpPortFwdListEntry[i]; i++) {
            rapid_city_free_rcIpUdpPortFwdListEntry(rcIpUdpPortFwdListEntry[i]);
        }
        g_free(rcIpUdpPortFwdListEntry);
    }
}

rapid_city_rcIpUdpConfBroadcastIntfEntry_t *
rapid_city_new_rcIpUdpConfBroadcastIntfEntry()
{
    rapid_city_rcIpUdpConfBroadcastIntfEntry_t *rcIpUdpConfBroadcastIntfEntry;

    rcIpUdpConfBroadcastIntfEntry = (rapid_city_rcIpUdpConfBroadcastIntfEntry_t *) g_malloc0(sizeof(rapid_city_rcIpUdpConfBroadcastIntfEntry_t) + sizeof(gpointer));
    return rcIpUdpConfBroadcastIntfEntry;
}

static int
unpack_rcIpUdpConfBroadcastIntfEntry(GSnmpVarBind *vb, rapid_city_rcIpUdpConfBroadcastIntfEntry_t *rcIpUdpConfBroadcastIntfEntry)
{
    int i, len, idx = 13;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfLocalIfAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpUdpConfBroadcastIntfEntry(guint32 *base, guchar *rcIpUdpConfBroadcastIntfLocalIfAddr)
{
    int i, len, idx = 13;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpUdpConfBroadcastIntfLocalIfAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcIpUdpConfBroadcastIntfEntry_t *
assign_rcIpUdpConfBroadcastIntfEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpUdpConfBroadcastIntfEntry_t *rcIpUdpConfBroadcastIntfEntry;
    guint32 idx;
    char *p;

    rcIpUdpConfBroadcastIntfEntry = rapid_city_new_rcIpUdpConfBroadcastIntfEntry();
    if (! rcIpUdpConfBroadcastIntfEntry) {
        return NULL;
    }

    p = (char *) rcIpUdpConfBroadcastIntfEntry + sizeof(rapid_city_rcIpUdpConfBroadcastIntfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpUdpConfBroadcastIntfEntry((GSnmpVarBind *) vbl->data, rcIpUdpConfBroadcastIntfEntry) < 0) {
        g_warning("illegal rcIpUdpConfBroadcastIntfEntry instance identifier");
        g_free(rcIpUdpConfBroadcastIntfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpUdpConfBroadcastIntfEntry, sizeof(oid_rcIpUdpConfBroadcastIntfEntry)/sizeof(guint32),
                   attr_rcIpUdpConfBroadcastIntfEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfUdpPortFwdListId = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfMaxTtl = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfNumRxPkts = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfNumFwdPkts = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfNumDropPktsMaxTtlExpired = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfNumDropPktsDestUnreach = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfNumDropPktsUnknownPort = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpUdpConfBroadcastIntfEntry;
}

void
rapid_city_get_rcIpUdpConfBroadcastIntfTable(GSnmpSession *s, rapid_city_rcIpUdpConfBroadcastIntfEntry_t ***rcIpUdpConfBroadcastIntfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 8, 13, 8, 1, 0};

    *rcIpUdpConfBroadcastIntfEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcIpUdpConfBroadcastIntfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpUdpConfBroadcastIntfEntry = (rapid_city_rcIpUdpConfBroadcastIntfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpUdpConfBroadcastIntfEntry_t *));
        if (! *rcIpUdpConfBroadcastIntfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpUdpConfBroadcastIntfEntry)[i] = assign_rcIpUdpConfBroadcastIntfEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpUdpConfBroadcastIntfEntry(GSnmpSession *s, rapid_city_rcIpUdpConfBroadcastIntfEntry_t **rcIpUdpConfBroadcastIntfEntry, guchar *rcIpUdpConfBroadcastIntfLocalIfAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpConfBroadcastIntfEntry, sizeof(oid_rcIpUdpConfBroadcastIntfEntry));
    len = pack_rcIpUdpConfBroadcastIntfEntry(base, rcIpUdpConfBroadcastIntfLocalIfAddr);
    if (len < 0) {
        g_warning("illegal rcIpUdpConfBroadcastIntfEntry index values");
        return;
    }

    *rcIpUdpConfBroadcastIntfEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcIpUdpConfBroadcastIntfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpUdpConfBroadcastIntfEntry = assign_rcIpUdpConfBroadcastIntfEntry(out);
    }
}

void
rapid_city_set_rcIpUdpConfBroadcastIntfEntry(GSnmpSession *s, rapid_city_rcIpUdpConfBroadcastIntfEntry_t *rcIpUdpConfBroadcastIntfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpUdpConfBroadcastIntfEntry, sizeof(oid_rcIpUdpConfBroadcastIntfEntry));
    len = pack_rcIpUdpConfBroadcastIntfEntry(base, rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfLocalIfAddr);
    if (len < 0) {
        g_warning("illegal rcIpUdpConfBroadcastIntfEntry index values");
        return;
    }

    if (rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfUdpPortFwdListId) {
        base[12] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfUdpPortFwdListId,
                       0);
    }
    if (rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfMaxTtl) {
        base[12] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfMaxTtl,
                       0);
    }
    if (rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfRowStatus) {
        base[12] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpUdpConfBroadcastIntfEntry->rcIpUdpConfBroadcastIntfRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpUdpConfBroadcastIntfEntry(rapid_city_rcIpUdpConfBroadcastIntfEntry_t *rcIpUdpConfBroadcastIntfEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpUdpConfBroadcastIntfEntry) {
        p = (char *) rcIpUdpConfBroadcastIntfEntry + sizeof(rapid_city_rcIpUdpConfBroadcastIntfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpUdpConfBroadcastIntfEntry);
    }
}

void
rapid_city_free_rcIpUdpConfBroadcastIntfTable(rapid_city_rcIpUdpConfBroadcastIntfEntry_t **rcIpUdpConfBroadcastIntfEntry)
{
    int i;

    if (rcIpUdpConfBroadcastIntfEntry) {
        for (i = 0; rcIpUdpConfBroadcastIntfEntry[i]; i++) {
            rapid_city_free_rcIpUdpConfBroadcastIntfEntry(rcIpUdpConfBroadcastIntfEntry[i]);
        }
        g_free(rcIpUdpConfBroadcastIntfEntry);
    }
}

rapid_city_rcArp_t *
rapid_city_new_rcArp()
{
    rapid_city_rcArp_t *rcArp;

    rcArp = (rapid_city_rcArp_t *) g_malloc0(sizeof(rapid_city_rcArp_t) + sizeof(gpointer));
    return rcArp;
}

static rapid_city_rcArp_t *
assign_rcArp(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcArp_t *rcArp;
    guint32 idx;
    char *p;

    rcArp = rapid_city_new_rcArp();
    if (! rcArp) {
        return NULL;
    }

    p = (char *) rcArp + sizeof(rapid_city_rcArp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcArp, sizeof(oid_rcArp)/sizeof(guint32),
                   attr_rcArp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcArp->rcArpExtLifeTime = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcArp;
}

void
rapid_city_get_rcArp(GSnmpSession *s, rapid_city_rcArp_t **rcArp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 9, 0};

    *rcArp = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcArp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcArp = assign_rcArp(out);
    }
}

void
rapid_city_set_rcArp(GSnmpSession *s, rapid_city_rcArp_t *rcArp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 9, 0, 0};

    if (rcArp->rcArpExtLifeTime) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcArp->rcArpExtLifeTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcArp(rapid_city_rcArp_t *rcArp)
{
    GSList *vbl;
    char *p;

    if (rcArp) {
        p = (char *) rcArp + sizeof(rapid_city_rcArp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcArp);
    }
}

rapid_city_rcArpExtEntry_t *
rapid_city_new_rcArpExtEntry()
{
    rapid_city_rcArpExtEntry_t *rcArpExtEntry;

    rcArpExtEntry = (rapid_city_rcArpExtEntry_t *) g_malloc0(sizeof(rapid_city_rcArpExtEntry_t) + sizeof(gpointer));
    return rcArpExtEntry;
}

static int
unpack_rcArpExtEntry(GSnmpVarBind *vb, rapid_city_rcArpExtEntry_t *rcArpExtEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcArpExtEntry->rcArpExtEntIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcArpExtEntry(guint32 *base, gint32 rcArpExtEntIfIndex)
{
    int idx = 12;

    base[idx++] = rcArpExtEntIfIndex;
    return idx;
}

static rapid_city_rcArpExtEntry_t *
assign_rcArpExtEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcArpExtEntry_t *rcArpExtEntry;
    guint32 idx;
    char *p;

    rcArpExtEntry = rapid_city_new_rcArpExtEntry();
    if (! rcArpExtEntry) {
        return NULL;
    }

    p = (char *) rcArpExtEntry + sizeof(rapid_city_rcArpExtEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcArpExtEntry((GSnmpVarBind *) vbl->data, rcArpExtEntry) < 0) {
        g_warning("illegal rcArpExtEntry instance identifier");
        g_free(rcArpExtEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcArpExtEntry, sizeof(oid_rcArpExtEntry)/sizeof(guint32),
                   attr_rcArpExtEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcArpExtEntry->rcArpExtEntDoProxy = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcArpExtEntry->rcArpExtEntDoResp = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcArpExtEntry;
}

void
rapid_city_get_rcArpExtTable(GSnmpSession *s, rapid_city_rcArpExtEntry_t ***rcArpExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 9, 2, 1, 0};

    *rcArpExtEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcArpExtEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcArpExtEntry = (rapid_city_rcArpExtEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcArpExtEntry_t *));
        if (! *rcArpExtEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcArpExtEntry)[i] = assign_rcArpExtEntry(row->data);
        }
    }
}

void
rapid_city_get_rcArpExtEntry(GSnmpSession *s, rapid_city_rcArpExtEntry_t **rcArpExtEntry, gint32 rcArpExtEntIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcArpExtEntry, sizeof(oid_rcArpExtEntry));
    len = pack_rcArpExtEntry(base, rcArpExtEntIfIndex);
    if (len < 0) {
        g_warning("illegal rcArpExtEntry index values");
        return;
    }

    *rcArpExtEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcArpExtEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcArpExtEntry = assign_rcArpExtEntry(out);
    }
}

void
rapid_city_set_rcArpExtEntry(GSnmpSession *s, rapid_city_rcArpExtEntry_t *rcArpExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcArpExtEntry, sizeof(oid_rcArpExtEntry));
    len = pack_rcArpExtEntry(base, rcArpExtEntry->rcArpExtEntIfIndex);
    if (len < 0) {
        g_warning("illegal rcArpExtEntry index values");
        return;
    }

    if (rcArpExtEntry->rcArpExtEntDoProxy) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcArpExtEntry->rcArpExtEntDoProxy,
                       0);
    }
    if (rcArpExtEntry->rcArpExtEntDoResp) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcArpExtEntry->rcArpExtEntDoResp,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcArpExtEntry(rapid_city_rcArpExtEntry_t *rcArpExtEntry)
{
    GSList *vbl;
    char *p;

    if (rcArpExtEntry) {
        p = (char *) rcArpExtEntry + sizeof(rapid_city_rcArpExtEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcArpExtEntry);
    }
}

void
rapid_city_free_rcArpExtTable(rapid_city_rcArpExtEntry_t **rcArpExtEntry)
{
    int i;

    if (rcArpExtEntry) {
        for (i = 0; rcArpExtEntry[i]; i++) {
            rapid_city_free_rcArpExtEntry(rcArpExtEntry[i]);
        }
        g_free(rcArpExtEntry);
    }
}

rapid_city_rcRip_t *
rapid_city_new_rcRip()
{
    rapid_city_rcRip_t *rcRip;

    rcRip = (rapid_city_rcRip_t *) g_malloc0(sizeof(rapid_city_rcRip_t) + sizeof(gpointer));
    return rcRip;
}

static rapid_city_rcRip_t *
assign_rcRip(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcRip_t *rcRip;
    guint32 idx;
    char *p;

    rcRip = rapid_city_new_rcRip();
    if (! rcRip) {
        return NULL;
    }

    p = (char *) rcRip + sizeof(rapid_city_rcRip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcRip, sizeof(oid_rcRip)/sizeof(guint32),
                   attr_rcRip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcRip->rcRipExtOperation = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcRip->rcRipExtUpdateTime = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcRip;
}

void
rapid_city_get_rcRip(GSnmpSession *s, rapid_city_rcRip_t **rcRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 10, 0};

    *rcRip = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcRip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcRip = assign_rcRip(out);
    }
}

void
rapid_city_set_rcRip(GSnmpSession *s, rapid_city_rcRip_t *rcRip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 10, 0, 0};

    if (rcRip->rcRipExtOperation) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcRip->rcRipExtOperation,
                       0);
    }
    if (rcRip->rcRipExtUpdateTime) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcRip->rcRipExtUpdateTime,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcRip(rapid_city_rcRip_t *rcRip)
{
    GSList *vbl;
    char *p;

    if (rcRip) {
        p = (char *) rcRip + sizeof(rapid_city_rcRip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcRip);
    }
}

rapid_city_rcRipExtEntry_t *
rapid_city_new_rcRipExtEntry()
{
    rapid_city_rcRipExtEntry_t *rcRipExtEntry;

    rcRipExtEntry = (rapid_city_rcRipExtEntry_t *) g_malloc0(sizeof(rapid_city_rcRipExtEntry_t) + sizeof(gpointer));
    return rcRipExtEntry;
}

static int
unpack_rcRipExtEntry(GSnmpVarBind *vb, rapid_city_rcRipExtEntry_t *rcRipExtEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcRipExtEntry->rcRipExtEntIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcRipExtEntry(guint32 *base, gint32 rcRipExtEntIfIndex)
{
    int idx = 12;

    base[idx++] = rcRipExtEntIfIndex;
    return idx;
}

static rapid_city_rcRipExtEntry_t *
assign_rcRipExtEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcRipExtEntry_t *rcRipExtEntry;
    guint32 idx;
    char *p;

    rcRipExtEntry = rapid_city_new_rcRipExtEntry();
    if (! rcRipExtEntry) {
        return NULL;
    }

    p = (char *) rcRipExtEntry + sizeof(rapid_city_rcRipExtEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcRipExtEntry((GSnmpVarBind *) vbl->data, rcRipExtEntry) < 0) {
        g_warning("illegal rcRipExtEntry instance identifier");
        g_free(rcRipExtEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcRipExtEntry, sizeof(oid_rcRipExtEntry)/sizeof(guint32),
                   attr_rcRipExtEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcRipExtEntry->rcRipExtEntTalk = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcRipExtEntry->rcRipExtEntListen = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcRipExtEntry->rcRipExtEntPoison = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcRipExtEntry;
}

void
rapid_city_get_rcRipExtTable(GSnmpSession *s, rapid_city_rcRipExtEntry_t ***rcRipExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 10, 3, 1, 0};

    *rcRipExtEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcRipExtEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcRipExtEntry = (rapid_city_rcRipExtEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcRipExtEntry_t *));
        if (! *rcRipExtEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcRipExtEntry)[i] = assign_rcRipExtEntry(row->data);
        }
    }
}

void
rapid_city_get_rcRipExtEntry(GSnmpSession *s, rapid_city_rcRipExtEntry_t **rcRipExtEntry, gint32 rcRipExtEntIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcRipExtEntry, sizeof(oid_rcRipExtEntry));
    len = pack_rcRipExtEntry(base, rcRipExtEntIfIndex);
    if (len < 0) {
        g_warning("illegal rcRipExtEntry index values");
        return;
    }

    *rcRipExtEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcRipExtEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcRipExtEntry = assign_rcRipExtEntry(out);
    }
}

void
rapid_city_set_rcRipExtEntry(GSnmpSession *s, rapid_city_rcRipExtEntry_t *rcRipExtEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcRipExtEntry, sizeof(oid_rcRipExtEntry));
    len = pack_rcRipExtEntry(base, rcRipExtEntry->rcRipExtEntIfIndex);
    if (len < 0) {
        g_warning("illegal rcRipExtEntry index values");
        return;
    }

    if (rcRipExtEntry->rcRipExtEntTalk) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcRipExtEntry->rcRipExtEntTalk,
                       0);
    }
    if (rcRipExtEntry->rcRipExtEntListen) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcRipExtEntry->rcRipExtEntListen,
                       0);
    }
    if (rcRipExtEntry->rcRipExtEntPoison) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcRipExtEntry->rcRipExtEntPoison,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcRipExtEntry(rapid_city_rcRipExtEntry_t *rcRipExtEntry)
{
    GSList *vbl;
    char *p;

    if (rcRipExtEntry) {
        p = (char *) rcRipExtEntry + sizeof(rapid_city_rcRipExtEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcRipExtEntry);
    }
}

void
rapid_city_free_rcRipExtTable(rapid_city_rcRipExtEntry_t **rcRipExtEntry)
{
    int i;

    if (rcRipExtEntry) {
        for (i = 0; rcRipExtEntry[i]; i++) {
            rapid_city_free_rcRipExtEntry(rcRipExtEntry[i]);
        }
        g_free(rcRipExtEntry);
    }
}

rapid_city_rcTestEntry_t *
rapid_city_new_rcTestEntry()
{
    rapid_city_rcTestEntry_t *rcTestEntry;

    rcTestEntry = (rapid_city_rcTestEntry_t *) g_malloc0(sizeof(rapid_city_rcTestEntry_t) + sizeof(gpointer));
    return rcTestEntry;
}

static int
unpack_rcTestEntry(GSnmpVarBind *vb, rapid_city_rcTestEntry_t *rcTestEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcTestEntry->rcTestExtIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcTestEntry(guint32 *base, gint32 rcTestExtIfIndex)
{
    int idx = 12;

    base[idx++] = rcTestExtIfIndex;
    return idx;
}

static rapid_city_rcTestEntry_t *
assign_rcTestEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcTestEntry_t *rcTestEntry;
    guint32 idx;
    char *p;

    rcTestEntry = rapid_city_new_rcTestEntry();
    if (! rcTestEntry) {
        return NULL;
    }

    p = (char *) rcTestEntry + sizeof(rapid_city_rcTestEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcTestEntry((GSnmpVarBind *) vbl->data, rcTestEntry) < 0) {
        g_warning("illegal rcTestEntry instance identifier");
        g_free(rcTestEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcTestEntry, sizeof(oid_rcTestEntry)/sizeof(guint32),
                   attr_rcTestEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcTestEntry->rcTestExtPassCount = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcTestEntry->rcTestExtFailCount = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcTestEntry;
}

void
rapid_city_get_rcTestExtTable(GSnmpSession *s, rapid_city_rcTestEntry_t ***rcTestEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 11, 1, 1, 0};

    *rcTestEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcTestEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcTestEntry = (rapid_city_rcTestEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcTestEntry_t *));
        if (! *rcTestEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcTestEntry)[i] = assign_rcTestEntry(row->data);
        }
    }
}

void
rapid_city_get_rcTestEntry(GSnmpSession *s, rapid_city_rcTestEntry_t **rcTestEntry, gint32 rcTestExtIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcTestEntry, sizeof(oid_rcTestEntry));
    len = pack_rcTestEntry(base, rcTestExtIfIndex);
    if (len < 0) {
        g_warning("illegal rcTestEntry index values");
        return;
    }

    *rcTestEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcTestEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcTestEntry = assign_rcTestEntry(out);
    }
}

void
rapid_city_free_rcTestEntry(rapid_city_rcTestEntry_t *rcTestEntry)
{
    GSList *vbl;
    char *p;

    if (rcTestEntry) {
        p = (char *) rcTestEntry + sizeof(rapid_city_rcTestEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcTestEntry);
    }
}

void
rapid_city_free_rcTestExtTable(rapid_city_rcTestEntry_t **rcTestEntry)
{
    int i;

    if (rcTestEntry) {
        for (i = 0; rcTestEntry[i]; i++) {
            rapid_city_free_rcTestEntry(rcTestEntry[i]);
        }
        g_free(rcTestEntry);
    }
}

rapid_city_rcStatEntry_t *
rapid_city_new_rcStatEntry()
{
    rapid_city_rcStatEntry_t *rcStatEntry;

    rcStatEntry = (rapid_city_rcStatEntry_t *) g_malloc0(sizeof(rapid_city_rcStatEntry_t) + sizeof(gpointer));
    return rcStatEntry;
}

static int
unpack_rcStatEntry(GSnmpVarBind *vb, rapid_city_rcStatEntry_t *rcStatEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcStatEntry->rcStatPortIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatEntry(guint32 *base, gint32 rcStatPortIndex)
{
    int idx = 12;

    base[idx++] = rcStatPortIndex;
    return idx;
}

static rapid_city_rcStatEntry_t *
assign_rcStatEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatEntry_t *rcStatEntry;
    guint32 idx;
    char *p;

    rcStatEntry = rapid_city_new_rcStatEntry();
    if (! rcStatEntry) {
        return NULL;
    }

    p = (char *) rcStatEntry + sizeof(rapid_city_rcStatEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatEntry((GSnmpVarBind *) vbl->data, rcStatEntry) < 0) {
        g_warning("illegal rcStatEntry instance identifier");
        g_free(rcStatEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatEntry, sizeof(oid_rcStatEntry)/sizeof(guint32),
                   attr_rcStatEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatEntry->rcStatFrameTooShorts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatEntry->rcStatBridgeInUnicastFrames = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatEntry->rcStatBridgeInMulticastFrames = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatEntry->rcStatBridgeInBroadcastFrames = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatEntry->rcStatBridgeInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatEntry->rcStatBridgeOutUnicastFrames = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcStatEntry->rcStatBridgeOutMulticastFrames = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStatEntry->rcStatBridgeOutBroadcastFrames = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStatEntry->rcStatRouteInUnicastFrames = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcStatEntry->rcStatRouteInMulticastFrames = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcStatEntry->rcStatRouteInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcStatEntry->rcStatRouteOutUnicastFrames = &(vb->syntax.ui32[0]);
            break;
        case 14:
            rcStatEntry->rcStatRouteOutMulticastFrames = &(vb->syntax.ui32[0]);
            break;
        case 15:
            rcStatEntry->rcStatStgForwardTransitions = &(vb->syntax.ui32[0]);
            break;
        case 16:
            rcStatEntry->rcStatStgInConfigBpdus = &(vb->syntax.ui32[0]);
            break;
        case 17:
            rcStatEntry->rcStatStgInTcnBpdus = &(vb->syntax.ui32[0]);
            break;
        case 18:
            rcStatEntry->rcStatStgInBadBpdus = &(vb->syntax.ui32[0]);
            break;
        case 19:
            rcStatEntry->rcStatStgOutConfigBpdus = &(vb->syntax.ui32[0]);
            break;
        case 20:
            rcStatEntry->rcStatStgOutTcnBpdus = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatEntry;
}

void
rapid_city_get_rcStatTable(GSnmpSession *s, rapid_city_rcStatEntry_t ***rcStatEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 1, 1, 0};

    *rcStatEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcStatEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatEntry = (rapid_city_rcStatEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatEntry_t *));
        if (! *rcStatEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatEntry)[i] = assign_rcStatEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatEntry(GSnmpSession *s, rapid_city_rcStatEntry_t **rcStatEntry, gint32 rcStatPortIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatEntry, sizeof(oid_rcStatEntry));
    len = pack_rcStatEntry(base, rcStatPortIndex);
    if (len < 0) {
        g_warning("illegal rcStatEntry index values");
        return;
    }

    *rcStatEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcStatEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatEntry = assign_rcStatEntry(out);
    }
}

void
rapid_city_free_rcStatEntry(rapid_city_rcStatEntry_t *rcStatEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatEntry) {
        p = (char *) rcStatEntry + sizeof(rapid_city_rcStatEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatEntry);
    }
}

void
rapid_city_free_rcStatTable(rapid_city_rcStatEntry_t **rcStatEntry)
{
    int i;

    if (rcStatEntry) {
        for (i = 0; rcStatEntry[i]; i++) {
            rapid_city_free_rcStatEntry(rcStatEntry[i]);
        }
        g_free(rcStatEntry);
    }
}

rapid_city_rcStatGigEntry_t *
rapid_city_new_rcStatGigEntry()
{
    rapid_city_rcStatGigEntry_t *rcStatGigEntry;

    rcStatGigEntry = (rapid_city_rcStatGigEntry_t *) g_malloc0(sizeof(rapid_city_rcStatGigEntry_t) + sizeof(gpointer));
    return rcStatGigEntry;
}

static int
unpack_rcStatGigEntry(GSnmpVarBind *vb, rapid_city_rcStatGigEntry_t *rcStatGigEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcStatGigEntry->rcStatGigPortIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatGigEntry(guint32 *base, gint32 rcStatGigPortIndex)
{
    int idx = 12;

    base[idx++] = rcStatGigPortIndex;
    return idx;
}

static rapid_city_rcStatGigEntry_t *
assign_rcStatGigEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatGigEntry_t *rcStatGigEntry;
    guint32 idx;
    char *p;

    rcStatGigEntry = rapid_city_new_rcStatGigEntry();
    if (! rcStatGigEntry) {
        return NULL;
    }

    p = (char *) rcStatGigEntry + sizeof(rapid_city_rcStatGigEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatGigEntry((GSnmpVarBind *) vbl->data, rcStatGigEntry) < 0) {
        g_warning("illegal rcStatGigEntry instance identifier");
        g_free(rcStatGigEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatGigEntry, sizeof(oid_rcStatGigEntry)/sizeof(guint32),
                   attr_rcStatGigEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatGigEntry->rcStatGigLinkFailures = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatGigEntry->rcStatGigPacketErrors = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatGigEntry->rcStatGigCarrierErrors = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatGigEntry->rcStatGigLinkInactiveErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatGigEntry->rcStatGigInFlowCtrlPkts = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatGigEntry->rcStatGigOutFlowCtrlPkts = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatGigEntry;
}

void
rapid_city_get_rcStatGigTable(GSnmpSession *s, rapid_city_rcStatGigEntry_t ***rcStatGigEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 2, 1, 0};

    *rcStatGigEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcStatGigEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatGigEntry = (rapid_city_rcStatGigEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatGigEntry_t *));
        if (! *rcStatGigEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatGigEntry)[i] = assign_rcStatGigEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatGigEntry(GSnmpSession *s, rapid_city_rcStatGigEntry_t **rcStatGigEntry, gint32 rcStatGigPortIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatGigEntry, sizeof(oid_rcStatGigEntry));
    len = pack_rcStatGigEntry(base, rcStatGigPortIndex);
    if (len < 0) {
        g_warning("illegal rcStatGigEntry index values");
        return;
    }

    *rcStatGigEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcStatGigEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatGigEntry = assign_rcStatGigEntry(out);
    }
}

void
rapid_city_free_rcStatGigEntry(rapid_city_rcStatGigEntry_t *rcStatGigEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatGigEntry) {
        p = (char *) rcStatGigEntry + sizeof(rapid_city_rcStatGigEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatGigEntry);
    }
}

void
rapid_city_free_rcStatGigTable(rapid_city_rcStatGigEntry_t **rcStatGigEntry)
{
    int i;

    if (rcStatGigEntry) {
        for (i = 0; rcStatGigEntry[i]; i++) {
            rapid_city_free_rcStatGigEntry(rcStatGigEntry[i]);
        }
        g_free(rcStatGigEntry);
    }
}

rapid_city_rcStatOspf_t *
rapid_city_new_rcStatOspf()
{
    rapid_city_rcStatOspf_t *rcStatOspf;

    rcStatOspf = (rapid_city_rcStatOspf_t *) g_malloc0(sizeof(rapid_city_rcStatOspf_t) + sizeof(gpointer));
    return rcStatOspf;
}

static rapid_city_rcStatOspf_t *
assign_rcStatOspf(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatOspf_t *rcStatOspf;
    guint32 idx;
    char *p;

    rcStatOspf = rapid_city_new_rcStatOspf();
    if (! rcStatOspf) {
        return NULL;
    }

    p = (char *) rcStatOspf + sizeof(rapid_city_rcStatOspf_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatOspf, sizeof(oid_rcStatOspf)/sizeof(guint32),
                   attr_rcStatOspf, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcStatOspf->rcStatOspfBuffersAllocated = &(vb->syntax.ui32[0]);
            break;
        case 2:
            rcStatOspf->rcStatOspfBuffersFreed = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatOspf->rcStatOspfBufferAllocFailures = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatOspf->rcStatOspfBufferFreeFailures = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatOspf->rcStatOspfTxPackets = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatOspf->rcStatOspfRxPackets = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatOspf->rcStatOspfTxDropPackets = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcStatOspf->rcStatOspfRxDropPackets = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStatOspf->rcStatOspfRxBadPackets = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStatOspf->rcStatOspfSpfRuns = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcStatOspf->rcStatOspfLastSpfRun = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcStatOspf->rcStatOspfLsdbTblSize = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatOspf;
}

void
rapid_city_get_rcStatOspf(GSnmpSession *s, rapid_city_rcStatOspf_t **rcStatOspf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 3, 0};

    *rcStatOspf = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcStatOspf, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatOspf = assign_rcStatOspf(out);
    }
}

void
rapid_city_free_rcStatOspf(rapid_city_rcStatOspf_t *rcStatOspf)
{
    GSList *vbl;
    char *p;

    if (rcStatOspf) {
        p = (char *) rcStatOspf + sizeof(rapid_city_rcStatOspf_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatOspf);
    }
}

rapid_city_rcStatIgmp_t *
rapid_city_new_rcStatIgmp()
{
    rapid_city_rcStatIgmp_t *rcStatIgmp;

    rcStatIgmp = (rapid_city_rcStatIgmp_t *) g_malloc0(sizeof(rapid_city_rcStatIgmp_t) + sizeof(gpointer));
    return rcStatIgmp;
}

static rapid_city_rcStatIgmp_t *
assign_rcStatIgmp(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatIgmp_t *rcStatIgmp;
    guint32 idx;
    char *p;

    rcStatIgmp = rapid_city_new_rcStatIgmp();
    if (! rcStatIgmp) {
        return NULL;
    }

    p = (char *) rcStatIgmp + sizeof(rapid_city_rcStatIgmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatIgmp, sizeof(oid_rcStatIgmp)/sizeof(guint32),
                   attr_rcStatIgmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcStatIgmp->rcStatIgmpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            rcStatIgmp->rcStatIgmpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatIgmp->rcStatIgmpInQueries = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatIgmp->rcStatIgmpInReports = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatIgmp->rcStatIgmpInLeaves = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatIgmp->rcStatIgmpInvalid = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatIgmp->rcStatIgmpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatIgmp;
}

void
rapid_city_get_rcStatIgmp(GSnmpSession *s, rapid_city_rcStatIgmp_t **rcStatIgmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 4, 0};

    *rcStatIgmp = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcStatIgmp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatIgmp = assign_rcStatIgmp(out);
    }
}

void
rapid_city_free_rcStatIgmp(rapid_city_rcStatIgmp_t *rcStatIgmp)
{
    GSList *vbl;
    char *p;

    if (rcStatIgmp) {
        p = (char *) rcStatIgmp + sizeof(rapid_city_rcStatIgmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatIgmp);
    }
}

rapid_city_rcStatOspfIfEntry_t *
rapid_city_new_rcStatOspfIfEntry()
{
    rapid_city_rcStatOspfIfEntry_t *rcStatOspfIfEntry;

    rcStatOspfIfEntry = (rapid_city_rcStatOspfIfEntry_t *) g_malloc0(sizeof(rapid_city_rcStatOspfIfEntry_t) + sizeof(gpointer));
    return rcStatOspfIfEntry;
}

static int
unpack_rcStatOspfIfEntry(GSnmpVarBind *vb, rapid_city_rcStatOspfIfEntry_t *rcStatOspfIfEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcStatOspfIfEntry->rcStatOspfIfIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatOspfIfEntry(guint32 *base, gint32 rcStatOspfIfIndex)
{
    int idx = 12;

    base[idx++] = rcStatOspfIfIndex;
    return idx;
}

static rapid_city_rcStatOspfIfEntry_t *
assign_rcStatOspfIfEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatOspfIfEntry_t *rcStatOspfIfEntry;
    guint32 idx;
    char *p;

    rcStatOspfIfEntry = rapid_city_new_rcStatOspfIfEntry();
    if (! rcStatOspfIfEntry) {
        return NULL;
    }

    p = (char *) rcStatOspfIfEntry + sizeof(rapid_city_rcStatOspfIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatOspfIfEntry((GSnmpVarBind *) vbl->data, rcStatOspfIfEntry) < 0) {
        g_warning("illegal rcStatOspfIfEntry instance identifier");
        g_free(rcStatOspfIfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatOspfIfEntry, sizeof(oid_rcStatOspfIfEntry)/sizeof(guint32),
                   attr_rcStatOspfIfEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatOspfIfEntry->rcStatOspfIfRxHellos = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatOspfIfEntry->rcStatOspfIfRxDBDescrs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatOspfIfEntry->rcStatOspfIfRxLSUpdates = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatOspfIfEntry->rcStatOspfIfRxLSReqs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatOspfIfEntry->rcStatOspfIfRxLSAcks = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatOspfIfEntry->rcStatOspfIfTxHellos = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcStatOspfIfEntry->rcStatOspfIfTxDBDescrs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStatOspfIfEntry->rcStatOspfIfTxLSUpdates = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStatOspfIfEntry->rcStatOspfIfTxLSReqs = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcStatOspfIfEntry->rcStatOspfIfTxLSAcks = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcStatOspfIfEntry->rcStatOspfIfVersionMismatches = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcStatOspfIfEntry->rcStatOspfIfAreaMismatches = &(vb->syntax.ui32[0]);
            break;
        case 14:
            rcStatOspfIfEntry->rcStatOspfIfAuthTypeMismatches = &(vb->syntax.ui32[0]);
            break;
        case 15:
            rcStatOspfIfEntry->rcStatOspfIfAuthFailures = &(vb->syntax.ui32[0]);
            break;
        case 16:
            rcStatOspfIfEntry->rcStatOspfIfNetMaskMismatches = &(vb->syntax.ui32[0]);
            break;
        case 17:
            rcStatOspfIfEntry->rcStatOspfIfHelloIntervalMismatches = &(vb->syntax.ui32[0]);
            break;
        case 18:
            rcStatOspfIfEntry->rcStatOspfIfDeadIntervalMismatches = &(vb->syntax.ui32[0]);
            break;
        case 19:
            rcStatOspfIfEntry->rcStatOspfIfOptionMismatches = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatOspfIfEntry;
}

void
rapid_city_get_rcStatOspfIfTable(GSnmpSession *s, rapid_city_rcStatOspfIfEntry_t ***rcStatOspfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 5, 1, 0};

    *rcStatOspfIfEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcStatOspfIfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatOspfIfEntry = (rapid_city_rcStatOspfIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatOspfIfEntry_t *));
        if (! *rcStatOspfIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatOspfIfEntry)[i] = assign_rcStatOspfIfEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatOspfIfEntry(GSnmpSession *s, rapid_city_rcStatOspfIfEntry_t **rcStatOspfIfEntry, gint32 rcStatOspfIfIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatOspfIfEntry, sizeof(oid_rcStatOspfIfEntry));
    len = pack_rcStatOspfIfEntry(base, rcStatOspfIfIndex);
    if (len < 0) {
        g_warning("illegal rcStatOspfIfEntry index values");
        return;
    }

    *rcStatOspfIfEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcStatOspfIfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatOspfIfEntry = assign_rcStatOspfIfEntry(out);
    }
}

void
rapid_city_free_rcStatOspfIfEntry(rapid_city_rcStatOspfIfEntry_t *rcStatOspfIfEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatOspfIfEntry) {
        p = (char *) rcStatOspfIfEntry + sizeof(rapid_city_rcStatOspfIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatOspfIfEntry);
    }
}

void
rapid_city_free_rcStatOspfIfTable(rapid_city_rcStatOspfIfEntry_t **rcStatOspfIfEntry)
{
    int i;

    if (rcStatOspfIfEntry) {
        for (i = 0; rcStatOspfIfEntry[i]; i++) {
            rapid_city_free_rcStatOspfIfEntry(rcStatOspfIfEntry[i]);
        }
        g_free(rcStatOspfIfEntry);
    }
}

rapid_city_rcStatMltIfExtnEntry_t *
rapid_city_new_rcStatMltIfExtnEntry()
{
    rapid_city_rcStatMltIfExtnEntry_t *rcStatMltIfExtnEntry;

    rcStatMltIfExtnEntry = (rapid_city_rcStatMltIfExtnEntry_t *) g_malloc0(sizeof(rapid_city_rcStatMltIfExtnEntry_t) + sizeof(gpointer));
    return rcStatMltIfExtnEntry;
}

static int
unpack_rcStatMltIfExtnEntry(GSnmpVarBind *vb, rapid_city_rcStatMltIfExtnEntry_t *rcStatMltIfExtnEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcStatMltIfExtnEntry->rcStatMltIfExtnMltId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatMltIfExtnEntry(guint32 *base, gint32 rcStatMltIfExtnMltId)
{
    int idx = 13;

    base[idx++] = rcStatMltIfExtnMltId;
    return idx;
}

static rapid_city_rcStatMltIfExtnEntry_t *
assign_rcStatMltIfExtnEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatMltIfExtnEntry_t *rcStatMltIfExtnEntry;
    guint32 idx;
    char *p;

    rcStatMltIfExtnEntry = rapid_city_new_rcStatMltIfExtnEntry();
    if (! rcStatMltIfExtnEntry) {
        return NULL;
    }

    p = (char *) rcStatMltIfExtnEntry + sizeof(rapid_city_rcStatMltIfExtnEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatMltIfExtnEntry((GSnmpVarBind *) vbl->data, rcStatMltIfExtnEntry) < 0) {
        g_warning("illegal rcStatMltIfExtnEntry instance identifier");
        g_free(rcStatMltIfExtnEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatMltIfExtnEntry, sizeof(oid_rcStatMltIfExtnEntry)/sizeof(guint32),
                   attr_rcStatMltIfExtnEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfInMulticastPkts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfInBroadcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfOutMulticastPkts = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfOutBroadcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCInOctets = &(vb->syntax.ui64[0]);
            break;
        case 7:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCInUcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 8:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCInMulticastPkt = &(vb->syntax.ui64[0]);
            break;
        case 9:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCInBroadcastPkt = &(vb->syntax.ui64[0]);
            break;
        case 10:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCOutOctets = &(vb->syntax.ui64[0]);
            break;
        case 11:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCOutUcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 12:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCOutMulticast = &(vb->syntax.ui64[0]);
            break;
        case 13:
            rcStatMltIfExtnEntry->rcStatMltIfExtnIfHCOutBroadcast = &(vb->syntax.ui64[0]);
            break;
        };
    }

    return rcStatMltIfExtnEntry;
}

void
rapid_city_get_rcStatMltIfExtnTable(GSnmpSession *s, rapid_city_rcStatMltIfExtnEntry_t ***rcStatMltIfExtnEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 0};

    *rcStatMltIfExtnEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcStatMltIfExtnEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatMltIfExtnEntry = (rapid_city_rcStatMltIfExtnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatMltIfExtnEntry_t *));
        if (! *rcStatMltIfExtnEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatMltIfExtnEntry)[i] = assign_rcStatMltIfExtnEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatMltIfExtnEntry(GSnmpSession *s, rapid_city_rcStatMltIfExtnEntry_t **rcStatMltIfExtnEntry, gint32 rcStatMltIfExtnMltId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatMltIfExtnEntry, sizeof(oid_rcStatMltIfExtnEntry));
    len = pack_rcStatMltIfExtnEntry(base, rcStatMltIfExtnMltId);
    if (len < 0) {
        g_warning("illegal rcStatMltIfExtnEntry index values");
        return;
    }

    *rcStatMltIfExtnEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcStatMltIfExtnEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatMltIfExtnEntry = assign_rcStatMltIfExtnEntry(out);
    }
}

void
rapid_city_free_rcStatMltIfExtnEntry(rapid_city_rcStatMltIfExtnEntry_t *rcStatMltIfExtnEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatMltIfExtnEntry) {
        p = (char *) rcStatMltIfExtnEntry + sizeof(rapid_city_rcStatMltIfExtnEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatMltIfExtnEntry);
    }
}

void
rapid_city_free_rcStatMltIfExtnTable(rapid_city_rcStatMltIfExtnEntry_t **rcStatMltIfExtnEntry)
{
    int i;

    if (rcStatMltIfExtnEntry) {
        for (i = 0; rcStatMltIfExtnEntry[i]; i++) {
            rapid_city_free_rcStatMltIfExtnEntry(rcStatMltIfExtnEntry[i]);
        }
        g_free(rcStatMltIfExtnEntry);
    }
}

rapid_city_rcStatMltEtherEntry_t *
rapid_city_new_rcStatMltEtherEntry()
{
    rapid_city_rcStatMltEtherEntry_t *rcStatMltEtherEntry;

    rcStatMltEtherEntry = (rapid_city_rcStatMltEtherEntry_t *) g_malloc0(sizeof(rapid_city_rcStatMltEtherEntry_t) + sizeof(gpointer));
    return rcStatMltEtherEntry;
}

static int
unpack_rcStatMltEtherEntry(GSnmpVarBind *vb, rapid_city_rcStatMltEtherEntry_t *rcStatMltEtherEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcStatMltEtherEntry->rcStatMltEtherMltId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatMltEtherEntry(guint32 *base, gint32 rcStatMltEtherMltId)
{
    int idx = 13;

    base[idx++] = rcStatMltEtherMltId;
    return idx;
}

static rapid_city_rcStatMltEtherEntry_t *
assign_rcStatMltEtherEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatMltEtherEntry_t *rcStatMltEtherEntry;
    guint32 idx;
    char *p;

    rcStatMltEtherEntry = rapid_city_new_rcStatMltEtherEntry();
    if (! rcStatMltEtherEntry) {
        return NULL;
    }

    p = (char *) rcStatMltEtherEntry + sizeof(rapid_city_rcStatMltEtherEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatMltEtherEntry((GSnmpVarBind *) vbl->data, rcStatMltEtherEntry) < 0) {
        g_warning("illegal rcStatMltEtherEntry instance identifier");
        g_free(rcStatMltEtherEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatMltEtherEntry, sizeof(oid_rcStatMltEtherEntry)/sizeof(guint32),
                   attr_rcStatMltEtherEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatMltEtherEntry->rcStatMltEtherAlignmentErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatMltEtherEntry->rcStatMltEtherFCSErrors = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatMltEtherEntry->rcStatMltEtherSingleCollFrames = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatMltEtherEntry->rcStatMltEtherMultipleCollFrames = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatMltEtherEntry->rcStatMltEtherSQETestError = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatMltEtherEntry->rcStatMltEtherDeferredTransmiss = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcStatMltEtherEntry->rcStatMltEtherLateCollisions = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStatMltEtherEntry->rcStatMltEtherExcessiveCollis = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStatMltEtherEntry->rcStatMltEtherIMacTransmitError = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcStatMltEtherEntry->rcStatMltEtherCarrierSenseError = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcStatMltEtherEntry->rcStatMltEtherFrameTooLong = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcStatMltEtherEntry->rcStatMltEtherIMacReceiveError = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatMltEtherEntry;
}

void
rapid_city_get_rcStatMltEtherTable(GSnmpSession *s, rapid_city_rcStatMltEtherEntry_t ***rcStatMltEtherEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 0};

    *rcStatMltEtherEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcStatMltEtherEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatMltEtherEntry = (rapid_city_rcStatMltEtherEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatMltEtherEntry_t *));
        if (! *rcStatMltEtherEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatMltEtherEntry)[i] = assign_rcStatMltEtherEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatMltEtherEntry(GSnmpSession *s, rapid_city_rcStatMltEtherEntry_t **rcStatMltEtherEntry, gint32 rcStatMltEtherMltId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatMltEtherEntry, sizeof(oid_rcStatMltEtherEntry));
    len = pack_rcStatMltEtherEntry(base, rcStatMltEtherMltId);
    if (len < 0) {
        g_warning("illegal rcStatMltEtherEntry index values");
        return;
    }

    *rcStatMltEtherEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcStatMltEtherEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatMltEtherEntry = assign_rcStatMltEtherEntry(out);
    }
}

void
rapid_city_free_rcStatMltEtherEntry(rapid_city_rcStatMltEtherEntry_t *rcStatMltEtherEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatMltEtherEntry) {
        p = (char *) rcStatMltEtherEntry + sizeof(rapid_city_rcStatMltEtherEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatMltEtherEntry);
    }
}

void
rapid_city_free_rcStatMltEtherTable(rapid_city_rcStatMltEtherEntry_t **rcStatMltEtherEntry)
{
    int i;

    if (rcStatMltEtherEntry) {
        for (i = 0; rcStatMltEtherEntry[i]; i++) {
            rapid_city_free_rcStatMltEtherEntry(rcStatMltEtherEntry[i]);
        }
        g_free(rcStatMltEtherEntry);
    }
}

rapid_city_rcStatMltIpEntry_t *
rapid_city_new_rcStatMltIpEntry()
{
    rapid_city_rcStatMltIpEntry_t *rcStatMltIpEntry;

    rcStatMltIpEntry = (rapid_city_rcStatMltIpEntry_t *) g_malloc0(sizeof(rapid_city_rcStatMltIpEntry_t) + sizeof(gpointer));
    return rcStatMltIpEntry;
}

static int
unpack_rcStatMltIpEntry(GSnmpVarBind *vb, rapid_city_rcStatMltIpEntry_t *rcStatMltIpEntry)
{
    int idx = 13;

    if (vb->id_len < idx) return -1;
    rcStatMltIpEntry->rcStatMltIpMltId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStatMltIpEntry(guint32 *base, gint32 rcStatMltIpMltId)
{
    int idx = 13;

    base[idx++] = rcStatMltIpMltId;
    return idx;
}

static rapid_city_rcStatMltIpEntry_t *
assign_rcStatMltIpEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStatMltIpEntry_t *rcStatMltIpEntry;
    guint32 idx;
    char *p;

    rcStatMltIpEntry = rapid_city_new_rcStatMltIpEntry();
    if (! rcStatMltIpEntry) {
        return NULL;
    }

    p = (char *) rcStatMltIpEntry + sizeof(rapid_city_rcStatMltIpEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStatMltIpEntry((GSnmpVarBind *) vbl->data, rcStatMltIpEntry) < 0) {
        g_warning("illegal rcStatMltIpEntry instance identifier");
        g_free(rcStatMltIpEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStatMltIpEntry, sizeof(oid_rcStatMltIpEntry)/sizeof(guint32),
                   attr_rcStatMltIpEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStatMltIpEntry->rcStatMltIpInReceives = &(vb->syntax.ui32[0]);
            break;
        case 3:
            rcStatMltIpEntry->rcStatMltIpInHdrErrors = &(vb->syntax.ui32[0]);
            break;
        case 4:
            rcStatMltIpEntry->rcStatMltIpInAddrErrors = &(vb->syntax.ui32[0]);
            break;
        case 5:
            rcStatMltIpEntry->rcStatMltIpForwDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 6:
            rcStatMltIpEntry->rcStatMltIpInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 7:
            rcStatMltIpEntry->rcStatMltIpInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 8:
            rcStatMltIpEntry->rcStatMltIpInDelivers = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStatMltIpEntry->rcStatMltIpOutRequest = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStatMltIpEntry->rcStatMltIpOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 11:
            rcStatMltIpEntry->rcStatMltIpOutNoRoutes = &(vb->syntax.ui32[0]);
            break;
        case 12:
            rcStatMltIpEntry->rcStatMltIpReasmReqds = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcStatMltIpEntry->rcStatMltIpReasmOKs = &(vb->syntax.ui32[0]);
            break;
        case 14:
            rcStatMltIpEntry->rcStatMltIpReasmFails = &(vb->syntax.ui32[0]);
            break;
        case 15:
            rcStatMltIpEntry->rcStatMltIpFragOKs = &(vb->syntax.ui32[0]);
            break;
        case 16:
            rcStatMltIpEntry->rcStatMltIpFragFails = &(vb->syntax.ui32[0]);
            break;
        case 17:
            rcStatMltIpEntry->rcStatMltIpFragCreates = &(vb->syntax.ui32[0]);
            break;
        case 18:
            rcStatMltIpEntry->rcStatMltIpRoutingDiscards = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return rcStatMltIpEntry;
}

void
rapid_city_get_rcStatMltIpTable(GSnmpSession *s, rapid_city_rcStatMltIpEntry_t ***rcStatMltIpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 0};

    *rcStatMltIpEntry = NULL;

    add_attributes(s, &in, base, 13, 12, attr_rcStatMltIpEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStatMltIpEntry = (rapid_city_rcStatMltIpEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStatMltIpEntry_t *));
        if (! *rcStatMltIpEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStatMltIpEntry)[i] = assign_rcStatMltIpEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStatMltIpEntry(GSnmpSession *s, rapid_city_rcStatMltIpEntry_t **rcStatMltIpEntry, gint32 rcStatMltIpMltId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStatMltIpEntry, sizeof(oid_rcStatMltIpEntry));
    len = pack_rcStatMltIpEntry(base, rcStatMltIpMltId);
    if (len < 0) {
        g_warning("illegal rcStatMltIpEntry index values");
        return;
    }

    *rcStatMltIpEntry = NULL;

    add_attributes(s, &in, base, len, 12, attr_rcStatMltIpEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStatMltIpEntry = assign_rcStatMltIpEntry(out);
    }
}

void
rapid_city_free_rcStatMltIpEntry(rapid_city_rcStatMltIpEntry_t *rcStatMltIpEntry)
{
    GSList *vbl;
    char *p;

    if (rcStatMltIpEntry) {
        p = (char *) rcStatMltIpEntry + sizeof(rapid_city_rcStatMltIpEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStatMltIpEntry);
    }
}

void
rapid_city_free_rcStatMltIpTable(rapid_city_rcStatMltIpEntry_t **rcStatMltIpEntry)
{
    int i;

    if (rcStatMltIpEntry) {
        for (i = 0; rcStatMltIpEntry[i]; i++) {
            rapid_city_free_rcStatMltIpEntry(rcStatMltIpEntry[i]);
        }
        g_free(rcStatMltIpEntry);
    }
}

rapid_city_rcStg_t *
rapid_city_new_rcStg()
{
    rapid_city_rcStg_t *rcStg;

    rcStg = (rapid_city_rcStg_t *) g_malloc0(sizeof(rapid_city_rcStg_t) + sizeof(gpointer));
    return rcStg;
}

static rapid_city_rcStg_t *
assign_rcStg(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStg_t *rcStg;
    guint32 idx;
    char *p;

    rcStg = rapid_city_new_rcStg();
    if (! rcStg) {
        return NULL;
    }

    p = (char *) rcStg + sizeof(rapid_city_rcStg_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStg, sizeof(oid_rcStg)/sizeof(guint32),
                   attr_rcStg, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcStg->rcStgMaxStgs = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcStg->rcStgNumStgs = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcStg->rcStgUnassignedPorts = vb->syntax.uc;
            break;
        case 6:
            rcStg->rcStgNotAllowedPorts = vb->syntax.uc;
            break;
        };
    }

    return rcStg;
}

void
rapid_city_get_rcStg(GSnmpSession *s, rapid_city_rcStg_t **rcStg, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 0};

    *rcStg = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcStg, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStg = assign_rcStg(out);
    }
}

void
rapid_city_set_rcStg(GSnmpSession *s, rapid_city_rcStg_t *rcStg, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 0, 0};

    if (rcStg->rcStgMaxStgs) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcStg->rcStgMaxStgs,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcStg(rapid_city_rcStg_t *rcStg)
{
    GSList *vbl;
    char *p;

    if (rcStg) {
        p = (char *) rcStg + sizeof(rapid_city_rcStg_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStg);
    }
}

rapid_city_rcStgEntry_t *
rapid_city_new_rcStgEntry()
{
    rapid_city_rcStgEntry_t *rcStgEntry;

    rcStgEntry = (rapid_city_rcStgEntry_t *) g_malloc0(sizeof(rapid_city_rcStgEntry_t) + sizeof(gpointer));
    return rcStgEntry;
}

static int
unpack_rcStgEntry(GSnmpVarBind *vb, rapid_city_rcStgEntry_t *rcStgEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcStgEntry->rcStgId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStgEntry(guint32 *base, gint32 rcStgId)
{
    int idx = 12;

    base[idx++] = rcStgId;
    return idx;
}

static rapid_city_rcStgEntry_t *
assign_rcStgEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStgEntry_t *rcStgEntry;
    guint32 idx;
    char *p;

    rcStgEntry = rapid_city_new_rcStgEntry();
    if (! rcStgEntry) {
        return NULL;
    }

    p = (char *) rcStgEntry + sizeof(rapid_city_rcStgEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStgEntry((GSnmpVarBind *) vbl->data, rcStgEntry) < 0) {
        g_warning("illegal rcStgEntry instance identifier");
        g_free(rcStgEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStgEntry, sizeof(oid_rcStgEntry)/sizeof(guint32),
                   attr_rcStgEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcStgEntry->rcStgTaggedBpduAddress = vb->syntax.uc;
            break;
        case 3:
            rcStgEntry->rcStgTaggedBpduVlanId = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcStgEntry->rcStgBridgeAddress = vb->syntax.uc;
            break;
        case 5:
            rcStgEntry->rcStgNumPorts = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcStgEntry->rcStgProtocolSpecification = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcStgEntry->rcStgPriority = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcStgEntry->rcStgTimeSinceTopologyChange = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcStgEntry->rcStgTopChanges = &(vb->syntax.ui32[0]);
            break;
        case 10:
            rcStgEntry->rcStgDesignatedRoot = vb->syntax.uc;
            break;
        case 11:
            rcStgEntry->rcStgRootCost = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcStgEntry->rcStgRootPort = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcStgEntry->rcStgMaxAge = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcStgEntry->rcStgHelloTime = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcStgEntry->rcStgHoldTime = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcStgEntry->rcStgForwardDelay = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcStgEntry->rcStgBridgeMaxAge = &(vb->syntax.i32[0]);
            break;
        case 18:
            rcStgEntry->rcStgBridgeHelloTime = &(vb->syntax.i32[0]);
            break;
        case 19:
            rcStgEntry->rcStgBridgeForwardDelay = &(vb->syntax.i32[0]);
            break;
        case 20:
            rcStgEntry->rcStgEnableStp = &(vb->syntax.i32[0]);
            break;
        case 21:
            rcStgEntry->rcStgStpTrapEnable = &(vb->syntax.i32[0]);
            break;
        case 22:
            rcStgEntry->rcStgPortMembers = vb->syntax.uc;
            break;
        case 23:
            rcStgEntry->rcStgRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcStgEntry;
}

void
rapid_city_get_rcStgTable(GSnmpSession *s, rapid_city_rcStgEntry_t ***rcStgEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 4, 1, 0};

    *rcStgEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcStgEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStgEntry = (rapid_city_rcStgEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStgEntry_t *));
        if (! *rcStgEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStgEntry)[i] = assign_rcStgEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStgEntry(GSnmpSession *s, rapid_city_rcStgEntry_t **rcStgEntry, gint32 rcStgId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStgEntry, sizeof(oid_rcStgEntry));
    len = pack_rcStgEntry(base, rcStgId);
    if (len < 0) {
        g_warning("illegal rcStgEntry index values");
        return;
    }

    *rcStgEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcStgEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStgEntry = assign_rcStgEntry(out);
    }
}

void
rapid_city_set_rcStgEntry(GSnmpSession *s, rapid_city_rcStgEntry_t *rcStgEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStgEntry, sizeof(oid_rcStgEntry));
    len = pack_rcStgEntry(base, rcStgEntry->rcStgId);
    if (len < 0) {
        g_warning("illegal rcStgEntry index values");
        return;
    }

    if (rcStgEntry->rcStgTaggedBpduAddress) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcStgEntry->rcStgTaggedBpduAddress,
                       6);
    }
    if (rcStgEntry->rcStgTaggedBpduVlanId) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgTaggedBpduVlanId,
                       0);
    }
    if (rcStgEntry->rcStgPriority) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgPriority,
                       0);
    }
    if (rcStgEntry->rcStgBridgeMaxAge) {
        base[11] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgBridgeMaxAge,
                       0);
    }
    if (rcStgEntry->rcStgBridgeHelloTime) {
        base[11] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgBridgeHelloTime,
                       0);
    }
    if (rcStgEntry->rcStgBridgeForwardDelay) {
        base[11] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgBridgeForwardDelay,
                       0);
    }
    if (rcStgEntry->rcStgEnableStp) {
        base[11] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgEnableStp,
                       0);
    }
    if (rcStgEntry->rcStgStpTrapEnable) {
        base[11] = 21;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgStpTrapEnable,
                       0);
    }
    if (rcStgEntry->rcStgPortMembers) {
        base[11] = 22;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcStgEntry->rcStgPortMembers,
                       32);
    }
    if (rcStgEntry->rcStgRowStatus) {
        base[11] = 23;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgEntry->rcStgRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcStgEntry(rapid_city_rcStgEntry_t *rcStgEntry)
{
    GSList *vbl;
    char *p;

    if (rcStgEntry) {
        p = (char *) rcStgEntry + sizeof(rapid_city_rcStgEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStgEntry);
    }
}

void
rapid_city_free_rcStgTable(rapid_city_rcStgEntry_t **rcStgEntry)
{
    int i;

    if (rcStgEntry) {
        for (i = 0; rcStgEntry[i]; i++) {
            rapid_city_free_rcStgEntry(rcStgEntry[i]);
        }
        g_free(rcStgEntry);
    }
}

rapid_city_rcStgPortEntry_t *
rapid_city_new_rcStgPortEntry()
{
    rapid_city_rcStgPortEntry_t *rcStgPortEntry;

    rcStgPortEntry = (rapid_city_rcStgPortEntry_t *) g_malloc0(sizeof(rapid_city_rcStgPortEntry_t) + sizeof(gpointer));
    return rcStgPortEntry;
}

static int
unpack_rcStgPortEntry(GSnmpVarBind *vb, rapid_city_rcStgPortEntry_t *rcStgPortEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcStgPortEntry->rcStgPort = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    rcStgPortEntry->rcStgPortStgId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcStgPortEntry(guint32 *base, gint32 rcStgPort, gint32 rcStgPortStgId)
{
    int idx = 12;

    base[idx++] = rcStgPort;
    base[idx++] = rcStgPortStgId;
    return idx;
}

static rapid_city_rcStgPortEntry_t *
assign_rcStgPortEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcStgPortEntry_t *rcStgPortEntry;
    guint32 idx;
    char *p;

    rcStgPortEntry = rapid_city_new_rcStgPortEntry();
    if (! rcStgPortEntry) {
        return NULL;
    }

    p = (char *) rcStgPortEntry + sizeof(rapid_city_rcStgPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcStgPortEntry((GSnmpVarBind *) vbl->data, rcStgPortEntry) < 0) {
        g_warning("illegal rcStgPortEntry instance identifier");
        g_free(rcStgPortEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcStgPortEntry, sizeof(oid_rcStgPortEntry)/sizeof(guint32),
                   attr_rcStgPortEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcStgPortEntry->rcStgPortPriority = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcStgPortEntry->rcStgPortState = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcStgPortEntry->rcStgPortEnableStp = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcStgPortEntry->rcStgPortFastStart = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcStgPortEntry->rcStgPortPathCost = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcStgPortEntry->rcStgPortDesignatedRoot = vb->syntax.uc;
            break;
        case 9:
            rcStgPortEntry->rcStgPortDesignatedCost = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcStgPortEntry->rcStgPortDesignatedBridge = vb->syntax.uc;
            break;
        case 11:
            rcStgPortEntry->rcStgPortDesignatedPort = vb->syntax.uc;
            break;
        case 12:
            rcStgPortEntry->rcStgPortForwardTransitions = &(vb->syntax.ui32[0]);
            break;
        case 13:
            rcStgPortEntry->rcStgPortInConfigBpdus = &(vb->syntax.ui32[0]);
            break;
        case 14:
            rcStgPortEntry->rcStgPortInTcnBpdus = &(vb->syntax.ui32[0]);
            break;
        case 15:
            rcStgPortEntry->rcStgPortInBadBpdus = &(vb->syntax.ui32[0]);
            break;
        case 16:
            rcStgPortEntry->rcStgPortOutConfigBpdus = &(vb->syntax.ui32[0]);
            break;
        case 17:
            rcStgPortEntry->rcStgPortOutTcnBpdus = &(vb->syntax.ui32[0]);
            break;
        case 18:
            rcStgPortEntry->rcStgPortRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcStgPortEntry;
}

void
rapid_city_get_rcStgPortTable(GSnmpSession *s, rapid_city_rcStgPortEntry_t ***rcStgPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 13, 5, 1, 0};

    *rcStgPortEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcStgPortEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcStgPortEntry = (rapid_city_rcStgPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcStgPortEntry_t *));
        if (! *rcStgPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcStgPortEntry)[i] = assign_rcStgPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcStgPortEntry(GSnmpSession *s, rapid_city_rcStgPortEntry_t **rcStgPortEntry, gint32 rcStgPort, gint32 rcStgPortStgId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStgPortEntry, sizeof(oid_rcStgPortEntry));
    len = pack_rcStgPortEntry(base, rcStgPort, rcStgPortStgId);
    if (len < 0) {
        g_warning("illegal rcStgPortEntry index values");
        return;
    }

    *rcStgPortEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcStgPortEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcStgPortEntry = assign_rcStgPortEntry(out);
    }
}

void
rapid_city_set_rcStgPortEntry(GSnmpSession *s, rapid_city_rcStgPortEntry_t *rcStgPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcStgPortEntry, sizeof(oid_rcStgPortEntry));
    len = pack_rcStgPortEntry(base, rcStgPortEntry->rcStgPort, rcStgPortEntry->rcStgPortStgId);
    if (len < 0) {
        g_warning("illegal rcStgPortEntry index values");
        return;
    }

    if (rcStgPortEntry->rcStgPortPriority) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgPortEntry->rcStgPortPriority,
                       0);
    }
    if (rcStgPortEntry->rcStgPortEnableStp) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgPortEntry->rcStgPortEnableStp,
                       0);
    }
    if (rcStgPortEntry->rcStgPortFastStart) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgPortEntry->rcStgPortFastStart,
                       0);
    }
    if (rcStgPortEntry->rcStgPortPathCost) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgPortEntry->rcStgPortPathCost,
                       0);
    }
    if (rcStgPortEntry->rcStgPortRowStatus) {
        base[11] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcStgPortEntry->rcStgPortRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcStgPortEntry(rapid_city_rcStgPortEntry_t *rcStgPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcStgPortEntry) {
        p = (char *) rcStgPortEntry + sizeof(rapid_city_rcStgPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcStgPortEntry);
    }
}

void
rapid_city_free_rcStgPortTable(rapid_city_rcStgPortEntry_t **rcStgPortEntry)
{
    int i;

    if (rcStgPortEntry) {
        for (i = 0; rcStgPortEntry[i]; i++) {
            rapid_city_free_rcStgPortEntry(rcStgPortEntry[i]);
        }
        g_free(rcStgPortEntry);
    }
}

rapid_city_rcBridge_t *
rapid_city_new_rcBridge()
{
    rapid_city_rcBridge_t *rcBridge;

    rcBridge = (rapid_city_rcBridge_t *) g_malloc0(sizeof(rapid_city_rcBridge_t) + sizeof(gpointer));
    return rcBridge;
}

static rapid_city_rcBridge_t *
assign_rcBridge(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcBridge_t *rcBridge;
    guint32 idx;
    char *p;

    rcBridge = rapid_city_new_rcBridge();
    if (! rcBridge) {
        return NULL;
    }

    p = (char *) rcBridge + sizeof(rapid_city_rcBridge_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcBridge, sizeof(oid_rcBridge)/sizeof(guint32),
                   attr_rcBridge, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcBridge->rcBridgeFdbTblSize = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcBridge->rcBridgeStaticTblSize = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcBridge->rcBridgeFilterTblSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcBridge;
}

void
rapid_city_get_rcBridge(GSnmpSession *s, rapid_city_rcBridge_t **rcBridge, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 0};

    *rcBridge = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcBridge, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcBridge = assign_rcBridge(out);
    }
}

void
rapid_city_free_rcBridge(rapid_city_rcBridge_t *rcBridge)
{
    GSList *vbl;
    char *p;

    if (rcBridge) {
        p = (char *) rcBridge + sizeof(rapid_city_rcBridge_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcBridge);
    }
}

rapid_city_rcBridgeFdbEntry_t *
rapid_city_new_rcBridgeFdbEntry()
{
    rapid_city_rcBridgeFdbEntry_t *rcBridgeFdbEntry;

    rcBridgeFdbEntry = (rapid_city_rcBridgeFdbEntry_t *) g_malloc0(sizeof(rapid_city_rcBridgeFdbEntry_t) + sizeof(gpointer));
    return rcBridgeFdbEntry;
}

static int
unpack_rcBridgeFdbEntry(GSnmpVarBind *vb, rapid_city_rcBridgeFdbEntry_t *rcBridgeFdbEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcBridgeFdbEntry->rcBridgeFdbStatus = vb->id[idx++];
    len = 6;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcBridgeFdbEntry->rcBridgeFdbAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcBridgeFdbEntry(guint32 *base, gint32 rcBridgeFdbStatus, guchar *rcBridgeFdbAddress)
{
    int i, len, idx = 12;

    base[idx++] = rcBridgeFdbStatus;
    len = 6;
    for (i = 0; i < len; i++) {
        base[idx++] = rcBridgeFdbAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rapid_city_rcBridgeFdbEntry_t *
assign_rcBridgeFdbEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcBridgeFdbEntry_t *rcBridgeFdbEntry;
    guint32 idx;
    char *p;

    rcBridgeFdbEntry = rapid_city_new_rcBridgeFdbEntry();
    if (! rcBridgeFdbEntry) {
        return NULL;
    }

    p = (char *) rcBridgeFdbEntry + sizeof(rapid_city_rcBridgeFdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcBridgeFdbEntry((GSnmpVarBind *) vbl->data, rcBridgeFdbEntry) < 0) {
        g_warning("illegal rcBridgeFdbEntry instance identifier");
        g_free(rcBridgeFdbEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcBridgeFdbEntry, sizeof(oid_rcBridgeFdbEntry)/sizeof(guint32),
                   attr_rcBridgeFdbEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcBridgeFdbEntry->rcBridgeFdbPort = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcBridgeFdbEntry->rcBridgeFdbMonitor = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcBridgeFdbEntry->rcBridgeFdbPriority = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcBridgeFdbEntry;
}

void
rapid_city_get_rcBridgeFdbTable(GSnmpSession *s, rapid_city_rcBridgeFdbEntry_t ***rcBridgeFdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 1, 1, 0};

    *rcBridgeFdbEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcBridgeFdbEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcBridgeFdbEntry = (rapid_city_rcBridgeFdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcBridgeFdbEntry_t *));
        if (! *rcBridgeFdbEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcBridgeFdbEntry)[i] = assign_rcBridgeFdbEntry(row->data);
        }
    }
}

void
rapid_city_get_rcBridgeFdbEntry(GSnmpSession *s, rapid_city_rcBridgeFdbEntry_t **rcBridgeFdbEntry, gint32 rcBridgeFdbStatus, guchar *rcBridgeFdbAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeFdbEntry, sizeof(oid_rcBridgeFdbEntry));
    len = pack_rcBridgeFdbEntry(base, rcBridgeFdbStatus, rcBridgeFdbAddress);
    if (len < 0) {
        g_warning("illegal rcBridgeFdbEntry index values");
        return;
    }

    *rcBridgeFdbEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcBridgeFdbEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcBridgeFdbEntry = assign_rcBridgeFdbEntry(out);
    }
}

void
rapid_city_set_rcBridgeFdbEntry(GSnmpSession *s, rapid_city_rcBridgeFdbEntry_t *rcBridgeFdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeFdbEntry, sizeof(oid_rcBridgeFdbEntry));
    len = pack_rcBridgeFdbEntry(base, rcBridgeFdbEntry->rcBridgeFdbStatus, rcBridgeFdbEntry->rcBridgeFdbAddress);
    if (len < 0) {
        g_warning("illegal rcBridgeFdbEntry index values");
        return;
    }

    if (rcBridgeFdbEntry->rcBridgeFdbMonitor) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeFdbEntry->rcBridgeFdbMonitor,
                       0);
    }
    if (rcBridgeFdbEntry->rcBridgeFdbPriority) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeFdbEntry->rcBridgeFdbPriority,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcBridgeFdbEntry(rapid_city_rcBridgeFdbEntry_t *rcBridgeFdbEntry)
{
    GSList *vbl;
    char *p;

    if (rcBridgeFdbEntry) {
        p = (char *) rcBridgeFdbEntry + sizeof(rapid_city_rcBridgeFdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcBridgeFdbEntry);
    }
}

void
rapid_city_free_rcBridgeFdbTable(rapid_city_rcBridgeFdbEntry_t **rcBridgeFdbEntry)
{
    int i;

    if (rcBridgeFdbEntry) {
        for (i = 0; rcBridgeFdbEntry[i]; i++) {
            rapid_city_free_rcBridgeFdbEntry(rcBridgeFdbEntry[i]);
        }
        g_free(rcBridgeFdbEntry);
    }
}

rapid_city_rcBridgeStaticEntry_t *
rapid_city_new_rcBridgeStaticEntry()
{
    rapid_city_rcBridgeStaticEntry_t *rcBridgeStaticEntry;

    rcBridgeStaticEntry = (rapid_city_rcBridgeStaticEntry_t *) g_malloc0(sizeof(rapid_city_rcBridgeStaticEntry_t) + sizeof(gpointer));
    return rcBridgeStaticEntry;
}

static int
unpack_rcBridgeStaticEntry(GSnmpVarBind *vb, rapid_city_rcBridgeStaticEntry_t *rcBridgeStaticEntry)
{
    int i, len, idx = 12;

    len = 6;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcBridgeStaticEntry->rcBridgeStaticAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcBridgeStaticEntry->rcBridgeStaticPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcBridgeStaticEntry(guint32 *base, guchar *rcBridgeStaticAddress, gint32 rcBridgeStaticPort)
{
    int i, len, idx = 12;

    len = 6;
    for (i = 0; i < len; i++) {
        base[idx++] = rcBridgeStaticAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcBridgeStaticPort;
    return idx;
}

static rapid_city_rcBridgeStaticEntry_t *
assign_rcBridgeStaticEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcBridgeStaticEntry_t *rcBridgeStaticEntry;
    guint32 idx;
    char *p;

    rcBridgeStaticEntry = rapid_city_new_rcBridgeStaticEntry();
    if (! rcBridgeStaticEntry) {
        return NULL;
    }

    p = (char *) rcBridgeStaticEntry + sizeof(rapid_city_rcBridgeStaticEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcBridgeStaticEntry((GSnmpVarBind *) vbl->data, rcBridgeStaticEntry) < 0) {
        g_warning("illegal rcBridgeStaticEntry instance identifier");
        g_free(rcBridgeStaticEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcBridgeStaticEntry, sizeof(oid_rcBridgeStaticEntry)/sizeof(guint32),
                   attr_rcBridgeStaticEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcBridgeStaticEntry->rcBridgeStaticMonitor = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcBridgeStaticEntry->rcBridgeStaticPriority = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcBridgeStaticEntry->rcBridgeStaticStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcBridgeStaticEntry;
}

void
rapid_city_get_rcBridgeStaticTable(GSnmpSession *s, rapid_city_rcBridgeStaticEntry_t ***rcBridgeStaticEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 3, 1, 0};

    *rcBridgeStaticEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcBridgeStaticEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcBridgeStaticEntry = (rapid_city_rcBridgeStaticEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcBridgeStaticEntry_t *));
        if (! *rcBridgeStaticEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcBridgeStaticEntry)[i] = assign_rcBridgeStaticEntry(row->data);
        }
    }
}

void
rapid_city_get_rcBridgeStaticEntry(GSnmpSession *s, rapid_city_rcBridgeStaticEntry_t **rcBridgeStaticEntry, guchar *rcBridgeStaticAddress, gint32 rcBridgeStaticPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeStaticEntry, sizeof(oid_rcBridgeStaticEntry));
    len = pack_rcBridgeStaticEntry(base, rcBridgeStaticAddress, rcBridgeStaticPort);
    if (len < 0) {
        g_warning("illegal rcBridgeStaticEntry index values");
        return;
    }

    *rcBridgeStaticEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcBridgeStaticEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcBridgeStaticEntry = assign_rcBridgeStaticEntry(out);
    }
}

void
rapid_city_set_rcBridgeStaticEntry(GSnmpSession *s, rapid_city_rcBridgeStaticEntry_t *rcBridgeStaticEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeStaticEntry, sizeof(oid_rcBridgeStaticEntry));
    len = pack_rcBridgeStaticEntry(base, rcBridgeStaticEntry->rcBridgeStaticAddress, rcBridgeStaticEntry->rcBridgeStaticPort);
    if (len < 0) {
        g_warning("illegal rcBridgeStaticEntry index values");
        return;
    }

    if (rcBridgeStaticEntry->rcBridgeStaticMonitor) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeStaticEntry->rcBridgeStaticMonitor,
                       0);
    }
    if (rcBridgeStaticEntry->rcBridgeStaticPriority) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeStaticEntry->rcBridgeStaticPriority,
                       0);
    }
    if (rcBridgeStaticEntry->rcBridgeStaticStatus) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeStaticEntry->rcBridgeStaticStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcBridgeStaticEntry(rapid_city_rcBridgeStaticEntry_t *rcBridgeStaticEntry)
{
    GSList *vbl;
    char *p;

    if (rcBridgeStaticEntry) {
        p = (char *) rcBridgeStaticEntry + sizeof(rapid_city_rcBridgeStaticEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcBridgeStaticEntry);
    }
}

void
rapid_city_free_rcBridgeStaticTable(rapid_city_rcBridgeStaticEntry_t **rcBridgeStaticEntry)
{
    int i;

    if (rcBridgeStaticEntry) {
        for (i = 0; rcBridgeStaticEntry[i]; i++) {
            rapid_city_free_rcBridgeStaticEntry(rcBridgeStaticEntry[i]);
        }
        g_free(rcBridgeStaticEntry);
    }
}

rapid_city_rcBridgeFilterEntry_t *
rapid_city_new_rcBridgeFilterEntry()
{
    rapid_city_rcBridgeFilterEntry_t *rcBridgeFilterEntry;

    rcBridgeFilterEntry = (rapid_city_rcBridgeFilterEntry_t *) g_malloc0(sizeof(rapid_city_rcBridgeFilterEntry_t) + sizeof(gpointer));
    return rcBridgeFilterEntry;
}

static int
unpack_rcBridgeFilterEntry(GSnmpVarBind *vb, rapid_city_rcBridgeFilterEntry_t *rcBridgeFilterEntry)
{
    int i, len, idx = 12;

    len = 6;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcBridgeFilterEntry->rcBridgeFilterAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcBridgeFilterEntry->rcBridgeFilterPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcBridgeFilterEntry(guint32 *base, guchar *rcBridgeFilterAddress, gint32 rcBridgeFilterPort)
{
    int i, len, idx = 12;

    len = 6;
    for (i = 0; i < len; i++) {
        base[idx++] = rcBridgeFilterAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcBridgeFilterPort;
    return idx;
}

static rapid_city_rcBridgeFilterEntry_t *
assign_rcBridgeFilterEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcBridgeFilterEntry_t *rcBridgeFilterEntry;
    guint32 idx;
    char *p;

    rcBridgeFilterEntry = rapid_city_new_rcBridgeFilterEntry();
    if (! rcBridgeFilterEntry) {
        return NULL;
    }

    p = (char *) rcBridgeFilterEntry + sizeof(rapid_city_rcBridgeFilterEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcBridgeFilterEntry((GSnmpVarBind *) vbl->data, rcBridgeFilterEntry) < 0) {
        g_warning("illegal rcBridgeFilterEntry instance identifier");
        g_free(rcBridgeFilterEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcBridgeFilterEntry, sizeof(oid_rcBridgeFilterEntry)/sizeof(guint32),
                   attr_rcBridgeFilterEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            rcBridgeFilterEntry->rcBridgeFilterNotAllowedFrom = vb->syntax.uc;
            break;
        case 4:
            rcBridgeFilterEntry->rcBridgeFilterStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcBridgeFilterEntry;
}

void
rapid_city_get_rcBridgeFilterTable(GSnmpSession *s, rapid_city_rcBridgeFilterEntry_t ***rcBridgeFilterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 14, 5, 1, 0};

    *rcBridgeFilterEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcBridgeFilterEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcBridgeFilterEntry = (rapid_city_rcBridgeFilterEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcBridgeFilterEntry_t *));
        if (! *rcBridgeFilterEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcBridgeFilterEntry)[i] = assign_rcBridgeFilterEntry(row->data);
        }
    }
}

void
rapid_city_get_rcBridgeFilterEntry(GSnmpSession *s, rapid_city_rcBridgeFilterEntry_t **rcBridgeFilterEntry, guchar *rcBridgeFilterAddress, gint32 rcBridgeFilterPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeFilterEntry, sizeof(oid_rcBridgeFilterEntry));
    len = pack_rcBridgeFilterEntry(base, rcBridgeFilterAddress, rcBridgeFilterPort);
    if (len < 0) {
        g_warning("illegal rcBridgeFilterEntry index values");
        return;
    }

    *rcBridgeFilterEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcBridgeFilterEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcBridgeFilterEntry = assign_rcBridgeFilterEntry(out);
    }
}

void
rapid_city_set_rcBridgeFilterEntry(GSnmpSession *s, rapid_city_rcBridgeFilterEntry_t *rcBridgeFilterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcBridgeFilterEntry, sizeof(oid_rcBridgeFilterEntry));
    len = pack_rcBridgeFilterEntry(base, rcBridgeFilterEntry->rcBridgeFilterAddress, rcBridgeFilterEntry->rcBridgeFilterPort);
    if (len < 0) {
        g_warning("illegal rcBridgeFilterEntry index values");
        return;
    }

    if (rcBridgeFilterEntry->rcBridgeFilterNotAllowedFrom) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcBridgeFilterEntry->rcBridgeFilterNotAllowedFrom,
                       32);
    }
    if (rcBridgeFilterEntry->rcBridgeFilterStatus) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcBridgeFilterEntry->rcBridgeFilterStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcBridgeFilterEntry(rapid_city_rcBridgeFilterEntry_t *rcBridgeFilterEntry)
{
    GSList *vbl;
    char *p;

    if (rcBridgeFilterEntry) {
        p = (char *) rcBridgeFilterEntry + sizeof(rapid_city_rcBridgeFilterEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcBridgeFilterEntry);
    }
}

void
rapid_city_free_rcBridgeFilterTable(rapid_city_rcBridgeFilterEntry_t **rcBridgeFilterEntry)
{
    int i;

    if (rcBridgeFilterEntry) {
        for (i = 0; rcBridgeFilterEntry[i]; i++) {
            rapid_city_free_rcBridgeFilterEntry(rcBridgeFilterEntry[i]);
        }
        g_free(rcBridgeFilterEntry);
    }
}

rapid_city_rcBoot_t *
rapid_city_new_rcBoot()
{
    rapid_city_rcBoot_t *rcBoot;

    rcBoot = (rapid_city_rcBoot_t *) g_malloc0(sizeof(rapid_city_rcBoot_t) + sizeof(gpointer));
    return rcBoot;
}

static rapid_city_rcBoot_t *
assign_rcBoot(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcBoot_t *rcBoot;
    guint32 idx;
    char *p;

    rcBoot = rapid_city_new_rcBoot();
    if (! rcBoot) {
        return NULL;
    }

    p = (char *) rcBoot + sizeof(rapid_city_rcBoot_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcBoot, sizeof(oid_rcBoot)/sizeof(guint32),
                   attr_rcBoot, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcBoot->_rcBootFlashSwVersionLength = vb->syntax_len;
            rcBoot->rcBootFlashSwVersion = vb->syntax.uc;
            break;
        case 2:
            rcBoot->_rcBootPcmciaSwVersionLength = vb->syntax_len;
            rcBoot->rcBootPcmciaSwVersion = vb->syntax.uc;
            break;
        case 3:
            rcBoot->_rcBootLastBootSourceLength = vb->syntax_len;
            rcBoot->rcBootLastBootSource = vb->syntax.uc;
            break;
        case 4:
            rcBoot->rcBootPrimary = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcBoot->rcBootSecondary = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcBoot->rcBootTertiary = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcBoot;
}

void
rapid_city_get_rcBoot(GSnmpSession *s, rapid_city_rcBoot_t **rcBoot, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 15, 0};

    *rcBoot = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcBoot, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcBoot = assign_rcBoot(out);
    }
}

void
rapid_city_set_rcBoot(GSnmpSession *s, rapid_city_rcBoot_t *rcBoot, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 15, 0, 0};

    if (rcBoot->rcBootPrimary) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcBoot->rcBootPrimary,
                       0);
    }
    if (rcBoot->rcBootSecondary) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcBoot->rcBootSecondary,
                       0);
    }
    if (rcBoot->rcBootTertiary) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcBoot->rcBootTertiary,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcBoot(rapid_city_rcBoot_t *rcBoot)
{
    GSList *vbl;
    char *p;

    if (rcBoot) {
        p = (char *) rcBoot + sizeof(rapid_city_rcBoot_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcBoot);
    }
}

rapid_city_rcDevice_t *
rapid_city_new_rcDevice()
{
    rapid_city_rcDevice_t *rcDevice;

    rcDevice = (rapid_city_rcDevice_t *) g_malloc0(sizeof(rapid_city_rcDevice_t) + sizeof(gpointer));
    return rcDevice;
}

static rapid_city_rcDevice_t *
assign_rcDevice(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDevice_t *rcDevice;
    guint32 idx;
    char *p;

    rcDevice = rapid_city_new_rcDevice();
    if (! rcDevice) {
        return NULL;
    }

    p = (char *) rcDevice + sizeof(rapid_city_rcDevice_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDevice, sizeof(oid_rcDevice)/sizeof(guint32),
                   attr_rcDevice, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcDevice->_rcDeviceLastBootSourceLength = vb->syntax_len;
            rcDevice->rcDeviceLastBootSource = vb->syntax.uc;
            break;
        case 2:
            rcDevice->rcDevicePrimarySource = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcDevice->_rcDevicePrimarySourceFileNameLength = vb->syntax_len;
            rcDevice->rcDevicePrimarySourceFileName = vb->syntax.uc;
            break;
        case 4:
            rcDevice->rcDeviceSecondarySource = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDevice->_rcDeviceSecondarySourceFileNameLength = vb->syntax_len;
            rcDevice->rcDeviceSecondarySourceFileName = vb->syntax.uc;
            break;
        case 6:
            rcDevice->rcDeviceTertiarySource = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcDevice->_rcDeviceTertiarySourceFileNameLength = vb->syntax_len;
            rcDevice->rcDeviceTertiarySourceFileName = vb->syntax.uc;
            break;
        case 8:
            rcDevice->rcDeviceConfigSource = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcDevice->_rcDeviceConfigSourceFileNameLength = vb->syntax_len;
            rcDevice->rcDeviceConfigSourceFileName = vb->syntax.uc;
            break;
        case 10:
            rcDevice->rcDeviceFlashBytesUsed = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcDevice->rcDeviceFlashBytesFree = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcDevice->rcDevicePcmciaBytesUsed = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcDevice->rcDevicePcmciaBytesFree = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcDevice->rcDeviceAction = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcDevice->rcDeviceResult = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcDevice->rcDeviceFlashNumFiles = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcDevice->rcDevicePcmciaNumFiles = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDevice;
}

void
rapid_city_get_rcDevice(GSnmpSession *s, rapid_city_rcDevice_t **rcDevice, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 0};

    *rcDevice = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcDevice, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDevice = assign_rcDevice(out);
    }
}

void
rapid_city_set_rcDevice(GSnmpSession *s, rapid_city_rcDevice_t *rcDevice, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 0, 0};

    if (rcDevice->rcDevicePrimarySource) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDevice->rcDevicePrimarySource,
                       0);
    }
    if (rcDevice->rcDevicePrimarySourceFileName) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcDevice->rcDevicePrimarySourceFileName,
                       rcDevice->_rcDevicePrimarySourceFileNameLength);
    }
    if (rcDevice->rcDeviceSecondarySource) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDevice->rcDeviceSecondarySource,
                       0);
    }
    if (rcDevice->rcDeviceSecondarySourceFileName) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcDevice->rcDeviceSecondarySourceFileName,
                       rcDevice->_rcDeviceSecondarySourceFileNameLength);
    }
    if (rcDevice->rcDeviceTertiarySource) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDevice->rcDeviceTertiarySource,
                       0);
    }
    if (rcDevice->rcDeviceTertiarySourceFileName) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcDevice->rcDeviceTertiarySourceFileName,
                       rcDevice->_rcDeviceTertiarySourceFileNameLength);
    }
    if (rcDevice->rcDeviceConfigSource) {
        base[9] = 8;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDevice->rcDeviceConfigSource,
                       0);
    }
    if (rcDevice->rcDeviceConfigSourceFileName) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcDevice->rcDeviceConfigSourceFileName,
                       rcDevice->_rcDeviceConfigSourceFileNameLength);
    }
    if (rcDevice->rcDeviceAction) {
        base[9] = 14;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDevice->rcDeviceAction,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDevice(rapid_city_rcDevice_t *rcDevice)
{
    GSList *vbl;
    char *p;

    if (rcDevice) {
        p = (char *) rcDevice + sizeof(rapid_city_rcDevice_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDevice);
    }
}

rapid_city_rcDeviceFlashEntry_t *
rapid_city_new_rcDeviceFlashEntry()
{
    rapid_city_rcDeviceFlashEntry_t *rcDeviceFlashEntry;

    rcDeviceFlashEntry = (rapid_city_rcDeviceFlashEntry_t *) g_malloc0(sizeof(rapid_city_rcDeviceFlashEntry_t) + sizeof(gpointer));
    return rcDeviceFlashEntry;
}

static int
unpack_rcDeviceFlashEntry(GSnmpVarBind *vb, rapid_city_rcDeviceFlashEntry_t *rcDeviceFlashEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcDeviceFlashEntry->rcDeviceFlashFileNum = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcDeviceFlashEntry(guint32 *base, gint32 rcDeviceFlashFileNum)
{
    int idx = 12;

    base[idx++] = rcDeviceFlashFileNum;
    return idx;
}

static rapid_city_rcDeviceFlashEntry_t *
assign_rcDeviceFlashEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDeviceFlashEntry_t *rcDeviceFlashEntry;
    guint32 idx;
    char *p;

    rcDeviceFlashEntry = rapid_city_new_rcDeviceFlashEntry();
    if (! rcDeviceFlashEntry) {
        return NULL;
    }

    p = (char *) rcDeviceFlashEntry + sizeof(rapid_city_rcDeviceFlashEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcDeviceFlashEntry((GSnmpVarBind *) vbl->data, rcDeviceFlashEntry) < 0) {
        g_warning("illegal rcDeviceFlashEntry instance identifier");
        g_free(rcDeviceFlashEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDeviceFlashEntry, sizeof(oid_rcDeviceFlashEntry)/sizeof(guint32),
                   attr_rcDeviceFlashEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcDeviceFlashEntry->_rcDeviceFlashFileNameLength = vb->syntax_len;
            rcDeviceFlashEntry->rcDeviceFlashFileName = vb->syntax.uc;
            break;
        case 3:
            rcDeviceFlashEntry->_rcDeviceFlashFileVersionLength = vb->syntax_len;
            rcDeviceFlashEntry->rcDeviceFlashFileVersion = vb->syntax.uc;
            break;
        case 4:
            rcDeviceFlashEntry->rcDeviceFlashFileType = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDeviceFlashEntry->rcDeviceFlashFileMode = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcDeviceFlashEntry->rcDeviceFlashFileSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcDeviceFlashEntry->rcDeviceFlashFileCrc = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcDeviceFlashEntry->rcDeviceFlashFileStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcDeviceFlashEntry->rcDeviceFlashRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDeviceFlashEntry;
}

void
rapid_city_get_rcDeviceFlashTable(GSnmpSession *s, rapid_city_rcDeviceFlashEntry_t ***rcDeviceFlashEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 25, 1, 0};

    *rcDeviceFlashEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcDeviceFlashEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcDeviceFlashEntry = (rapid_city_rcDeviceFlashEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcDeviceFlashEntry_t *));
        if (! *rcDeviceFlashEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcDeviceFlashEntry)[i] = assign_rcDeviceFlashEntry(row->data);
        }
    }
}

void
rapid_city_get_rcDeviceFlashEntry(GSnmpSession *s, rapid_city_rcDeviceFlashEntry_t **rcDeviceFlashEntry, gint32 rcDeviceFlashFileNum, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDeviceFlashEntry, sizeof(oid_rcDeviceFlashEntry));
    len = pack_rcDeviceFlashEntry(base, rcDeviceFlashFileNum);
    if (len < 0) {
        g_warning("illegal rcDeviceFlashEntry index values");
        return;
    }

    *rcDeviceFlashEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcDeviceFlashEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDeviceFlashEntry = assign_rcDeviceFlashEntry(out);
    }
}

void
rapid_city_set_rcDeviceFlashEntry(GSnmpSession *s, rapid_city_rcDeviceFlashEntry_t *rcDeviceFlashEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDeviceFlashEntry, sizeof(oid_rcDeviceFlashEntry));
    len = pack_rcDeviceFlashEntry(base, rcDeviceFlashEntry->rcDeviceFlashFileNum);
    if (len < 0) {
        g_warning("illegal rcDeviceFlashEntry index values");
        return;
    }

    if (rcDeviceFlashEntry->rcDeviceFlashRowStatus) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDeviceFlashEntry->rcDeviceFlashRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDeviceFlashEntry(rapid_city_rcDeviceFlashEntry_t *rcDeviceFlashEntry)
{
    GSList *vbl;
    char *p;

    if (rcDeviceFlashEntry) {
        p = (char *) rcDeviceFlashEntry + sizeof(rapid_city_rcDeviceFlashEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDeviceFlashEntry);
    }
}

void
rapid_city_free_rcDeviceFlashTable(rapid_city_rcDeviceFlashEntry_t **rcDeviceFlashEntry)
{
    int i;

    if (rcDeviceFlashEntry) {
        for (i = 0; rcDeviceFlashEntry[i]; i++) {
            rapid_city_free_rcDeviceFlashEntry(rcDeviceFlashEntry[i]);
        }
        g_free(rcDeviceFlashEntry);
    }
}

rapid_city_rcDevicePcmciaEntry_t *
rapid_city_new_rcDevicePcmciaEntry()
{
    rapid_city_rcDevicePcmciaEntry_t *rcDevicePcmciaEntry;

    rcDevicePcmciaEntry = (rapid_city_rcDevicePcmciaEntry_t *) g_malloc0(sizeof(rapid_city_rcDevicePcmciaEntry_t) + sizeof(gpointer));
    return rcDevicePcmciaEntry;
}

static int
unpack_rcDevicePcmciaEntry(GSnmpVarBind *vb, rapid_city_rcDevicePcmciaEntry_t *rcDevicePcmciaEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcDevicePcmciaEntry->rcDevicePcmciaFileNum = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcDevicePcmciaEntry(guint32 *base, gint32 rcDevicePcmciaFileNum)
{
    int idx = 12;

    base[idx++] = rcDevicePcmciaFileNum;
    return idx;
}

static rapid_city_rcDevicePcmciaEntry_t *
assign_rcDevicePcmciaEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDevicePcmciaEntry_t *rcDevicePcmciaEntry;
    guint32 idx;
    char *p;

    rcDevicePcmciaEntry = rapid_city_new_rcDevicePcmciaEntry();
    if (! rcDevicePcmciaEntry) {
        return NULL;
    }

    p = (char *) rcDevicePcmciaEntry + sizeof(rapid_city_rcDevicePcmciaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcDevicePcmciaEntry((GSnmpVarBind *) vbl->data, rcDevicePcmciaEntry) < 0) {
        g_warning("illegal rcDevicePcmciaEntry instance identifier");
        g_free(rcDevicePcmciaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDevicePcmciaEntry, sizeof(oid_rcDevicePcmciaEntry)/sizeof(guint32),
                   attr_rcDevicePcmciaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcDevicePcmciaEntry->_rcDevicePcmciaFileNameLength = vb->syntax_len;
            rcDevicePcmciaEntry->rcDevicePcmciaFileName = vb->syntax.uc;
            break;
        case 3:
            rcDevicePcmciaEntry->_rcDevicePcmciaFileVersionLength = vb->syntax_len;
            rcDevicePcmciaEntry->rcDevicePcmciaFileVersion = vb->syntax.uc;
            break;
        case 4:
            rcDevicePcmciaEntry->rcDevicePcmciaFileType = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDevicePcmciaEntry->rcDevicePcmciaFileMode = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcDevicePcmciaEntry->rcDevicePcmciaFileSize = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcDevicePcmciaEntry->rcDevicePcmciaFileCrc = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcDevicePcmciaEntry->rcDevicePcmciaFileStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcDevicePcmciaEntry->rcDevicePcmciaRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDevicePcmciaEntry;
}

void
rapid_city_get_rcDevicePcmciaTable(GSnmpSession *s, rapid_city_rcDevicePcmciaEntry_t ***rcDevicePcmciaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 16, 26, 1, 0};

    *rcDevicePcmciaEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcDevicePcmciaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcDevicePcmciaEntry = (rapid_city_rcDevicePcmciaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcDevicePcmciaEntry_t *));
        if (! *rcDevicePcmciaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcDevicePcmciaEntry)[i] = assign_rcDevicePcmciaEntry(row->data);
        }
    }
}

void
rapid_city_get_rcDevicePcmciaEntry(GSnmpSession *s, rapid_city_rcDevicePcmciaEntry_t **rcDevicePcmciaEntry, gint32 rcDevicePcmciaFileNum, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDevicePcmciaEntry, sizeof(oid_rcDevicePcmciaEntry));
    len = pack_rcDevicePcmciaEntry(base, rcDevicePcmciaFileNum);
    if (len < 0) {
        g_warning("illegal rcDevicePcmciaEntry index values");
        return;
    }

    *rcDevicePcmciaEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcDevicePcmciaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDevicePcmciaEntry = assign_rcDevicePcmciaEntry(out);
    }
}

void
rapid_city_set_rcDevicePcmciaEntry(GSnmpSession *s, rapid_city_rcDevicePcmciaEntry_t *rcDevicePcmciaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDevicePcmciaEntry, sizeof(oid_rcDevicePcmciaEntry));
    len = pack_rcDevicePcmciaEntry(base, rcDevicePcmciaEntry->rcDevicePcmciaFileNum);
    if (len < 0) {
        g_warning("illegal rcDevicePcmciaEntry index values");
        return;
    }

    if (rcDevicePcmciaEntry->rcDevicePcmciaRowStatus) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDevicePcmciaEntry->rcDevicePcmciaRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDevicePcmciaEntry(rapid_city_rcDevicePcmciaEntry_t *rcDevicePcmciaEntry)
{
    GSList *vbl;
    char *p;

    if (rcDevicePcmciaEntry) {
        p = (char *) rcDevicePcmciaEntry + sizeof(rapid_city_rcDevicePcmciaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDevicePcmciaEntry);
    }
}

void
rapid_city_free_rcDevicePcmciaTable(rapid_city_rcDevicePcmciaEntry_t **rcDevicePcmciaEntry)
{
    int i;

    if (rcDevicePcmciaEntry) {
        for (i = 0; rcDevicePcmciaEntry[i]; i++) {
            rapid_city_free_rcDevicePcmciaEntry(rcDevicePcmciaEntry[i]);
        }
        g_free(rcDevicePcmciaEntry);
    }
}

rapid_city_rcMlt_t *
rapid_city_new_rcMlt()
{
    rapid_city_rcMlt_t *rcMlt;

    rcMlt = (rapid_city_rcMlt_t *) g_malloc0(sizeof(rapid_city_rcMlt_t) + sizeof(gpointer));
    return rcMlt;
}

static rapid_city_rcMlt_t *
assign_rcMlt(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcMlt_t *rcMlt;
    guint32 idx;
    char *p;

    rcMlt = rapid_city_new_rcMlt();
    if (! rcMlt) {
        return NULL;
    }

    p = (char *) rcMlt + sizeof(rapid_city_rcMlt_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcMlt, sizeof(oid_rcMlt)/sizeof(guint32),
                   attr_rcMlt, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcMlt->rcMltNumMlts = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcMlt->rcMltPotentialMembers = vb->syntax.uc;
            break;
        };
    }

    return rcMlt;
}

void
rapid_city_get_rcMlt(GSnmpSession *s, rapid_city_rcMlt_t **rcMlt, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 17, 0};

    *rcMlt = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcMlt, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcMlt = assign_rcMlt(out);
    }
}

void
rapid_city_free_rcMlt(rapid_city_rcMlt_t *rcMlt)
{
    GSList *vbl;
    char *p;

    if (rcMlt) {
        p = (char *) rcMlt + sizeof(rapid_city_rcMlt_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcMlt);
    }
}

rapid_city_rcMltEntry_t *
rapid_city_new_rcMltEntry()
{
    rapid_city_rcMltEntry_t *rcMltEntry;

    rcMltEntry = (rapid_city_rcMltEntry_t *) g_malloc0(sizeof(rapid_city_rcMltEntry_t) + sizeof(gpointer));
    return rcMltEntry;
}

static int
unpack_rcMltEntry(GSnmpVarBind *vb, rapid_city_rcMltEntry_t *rcMltEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcMltEntry->rcMltId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcMltEntry(guint32 *base, gint32 rcMltId)
{
    int idx = 12;

    base[idx++] = rcMltId;
    return idx;
}

static rapid_city_rcMltEntry_t *
assign_rcMltEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcMltEntry_t *rcMltEntry;
    guint32 idx;
    char *p;

    rcMltEntry = rapid_city_new_rcMltEntry();
    if (! rcMltEntry) {
        return NULL;
    }

    p = (char *) rcMltEntry + sizeof(rapid_city_rcMltEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcMltEntry((GSnmpVarBind *) vbl->data, rcMltEntry) < 0) {
        g_warning("illegal rcMltEntry instance identifier");
        g_free(rcMltEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcMltEntry, sizeof(oid_rcMltEntry)/sizeof(guint32),
                   attr_rcMltEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcMltEntry->_rcMltNameLength = vb->syntax_len;
            rcMltEntry->rcMltName = vb->syntax.uc;
            break;
        case 3:
            rcMltEntry->rcMltPortMembers = vb->syntax.uc;
            break;
        case 4:
            rcMltEntry->rcMltPortType = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcMltEntry->rcMltNumVlanIds = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcMltEntry->rcMltVlanIds = vb->syntax.uc;
            break;
        case 7:
            rcMltEntry->rcMltRowStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcMltEntry->rcMltEnable = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcMltEntry->rcMltLoadBalance = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcMltEntry->rcMltDistributionAlgorithm = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcMltEntry->rcMltIfIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcMltEntry;
}

void
rapid_city_get_rcMltTable(GSnmpSession *s, rapid_city_rcMltEntry_t ***rcMltEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 0};

    *rcMltEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcMltEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcMltEntry = (rapid_city_rcMltEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcMltEntry_t *));
        if (! *rcMltEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcMltEntry)[i] = assign_rcMltEntry(row->data);
        }
    }
}

void
rapid_city_get_rcMltEntry(GSnmpSession *s, rapid_city_rcMltEntry_t **rcMltEntry, gint32 rcMltId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcMltEntry, sizeof(oid_rcMltEntry));
    len = pack_rcMltEntry(base, rcMltId);
    if (len < 0) {
        g_warning("illegal rcMltEntry index values");
        return;
    }

    *rcMltEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcMltEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcMltEntry = assign_rcMltEntry(out);
    }
}

void
rapid_city_set_rcMltEntry(GSnmpSession *s, rapid_city_rcMltEntry_t *rcMltEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcMltEntry, sizeof(oid_rcMltEntry));
    len = pack_rcMltEntry(base, rcMltEntry->rcMltId);
    if (len < 0) {
        g_warning("illegal rcMltEntry index values");
        return;
    }

    if (rcMltEntry->rcMltName) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcMltEntry->rcMltName,
                       rcMltEntry->_rcMltNameLength);
    }
    if (rcMltEntry->rcMltPortMembers) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcMltEntry->rcMltPortMembers,
                       32);
    }
    if (rcMltEntry->rcMltPortType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcMltEntry->rcMltPortType,
                       0);
    }
    if (rcMltEntry->rcMltVlanIds) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcMltEntry->rcMltVlanIds,
                       250);
    }
    if (rcMltEntry->rcMltRowStatus) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcMltEntry->rcMltRowStatus,
                       0);
    }
    if (rcMltEntry->rcMltEnable) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcMltEntry->rcMltEnable,
                       0);
    }
    if (rcMltEntry->rcMltLoadBalance) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcMltEntry->rcMltLoadBalance,
                       0);
    }
    if (rcMltEntry->rcMltDistributionAlgorithm) {
        base[11] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcMltEntry->rcMltDistributionAlgorithm,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcMltEntry(rapid_city_rcMltEntry_t *rcMltEntry)
{
    GSList *vbl;
    char *p;

    if (rcMltEntry) {
        p = (char *) rcMltEntry + sizeof(rapid_city_rcMltEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcMltEntry);
    }
}

void
rapid_city_free_rcMltTable(rapid_city_rcMltEntry_t **rcMltEntry)
{
    int i;

    if (rcMltEntry) {
        for (i = 0; rcMltEntry[i]; i++) {
            rapid_city_free_rcMltEntry(rcMltEntry[i]);
        }
        g_free(rcMltEntry);
    }
}

rapid_city_rcWeb_t *
rapid_city_new_rcWeb()
{
    rapid_city_rcWeb_t *rcWeb;

    rcWeb = (rapid_city_rcWeb_t *) g_malloc0(sizeof(rapid_city_rcWeb_t) + sizeof(gpointer));
    return rcWeb;
}

static rapid_city_rcWeb_t *
assign_rcWeb(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcWeb_t *rcWeb;
    guint32 idx;
    char *p;

    rcWeb = rapid_city_new_rcWeb();
    if (! rcWeb) {
        return NULL;
    }

    p = (char *) rcWeb + sizeof(rapid_city_rcWeb_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcWeb, sizeof(oid_rcWeb)/sizeof(guint32),
                   attr_rcWeb, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcWeb->rcWebEnableServer = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcWeb->_rcWebRWAUserNameLength = vb->syntax_len;
            rcWeb->rcWebRWAUserName = vb->syntax.uc;
            break;
        case 3:
            rcWeb->_rcWebRWAPasswordLength = vb->syntax_len;
            rcWeb->rcWebRWAPassword = vb->syntax.uc;
            break;
        case 4:
            rcWeb->_rcWebRWUserNameLength = vb->syntax_len;
            rcWeb->rcWebRWUserName = vb->syntax.uc;
            break;
        case 5:
            rcWeb->_rcWebRWPasswordLength = vb->syntax_len;
            rcWeb->rcWebRWPassword = vb->syntax.uc;
            break;
        case 6:
            rcWeb->_rcWebROUserNameLength = vb->syntax_len;
            rcWeb->rcWebROUserName = vb->syntax.uc;
            break;
        case 7:
            rcWeb->_rcWebROPasswordLength = vb->syntax_len;
            rcWeb->rcWebROPassword = vb->syntax.uc;
            break;
        case 8:
            rcWeb->rcWebLastChange = &(vb->syntax.ui32[0]);
            break;
        case 9:
            rcWeb->rcWebNumHits = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcWeb->rcWebNumAccessChecks = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcWeb->rcWebNumAccessBlocks = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcWeb->rcWebNumRxErrors = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcWeb->rcWebNumTxErrors = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcWeb->rcWebNumSetRequest = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcWeb;
}

void
rapid_city_get_rcWeb(GSnmpSession *s, rapid_city_rcWeb_t **rcWeb, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 18, 0};

    *rcWeb = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcWeb, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcWeb = assign_rcWeb(out);
    }
}

void
rapid_city_set_rcWeb(GSnmpSession *s, rapid_city_rcWeb_t *rcWeb, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 18, 0, 0};

    if (rcWeb->rcWebEnableServer) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcWeb->rcWebEnableServer,
                       0);
    }
    if (rcWeb->rcWebRWAUserName) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebRWAUserName,
                       rcWeb->_rcWebRWAUserNameLength);
    }
    if (rcWeb->rcWebRWAPassword) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebRWAPassword,
                       rcWeb->_rcWebRWAPasswordLength);
    }
    if (rcWeb->rcWebRWUserName) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebRWUserName,
                       rcWeb->_rcWebRWUserNameLength);
    }
    if (rcWeb->rcWebRWPassword) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebRWPassword,
                       rcWeb->_rcWebRWPasswordLength);
    }
    if (rcWeb->rcWebROUserName) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebROUserName,
                       rcWeb->_rcWebROUserNameLength);
    }
    if (rcWeb->rcWebROPassword) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcWeb->rcWebROPassword,
                       rcWeb->_rcWebROPasswordLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcWeb(rapid_city_rcWeb_t *rcWeb)
{
    GSList *vbl;
    char *p;

    if (rcWeb) {
        p = (char *) rcWeb + sizeof(rapid_city_rcWeb_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcWeb);
    }
}

rapid_city_rcCli_t *
rapid_city_new_rcCli()
{
    rapid_city_rcCli_t *rcCli;

    rcCli = (rapid_city_rcCli_t *) g_malloc0(sizeof(rapid_city_rcCli_t) + sizeof(gpointer));
    return rcCli;
}

static rapid_city_rcCli_t *
assign_rcCli(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcCli_t *rcCli;
    guint32 idx;
    char *p;

    rcCli = rapid_city_new_rcCli();
    if (! rcCli) {
        return NULL;
    }

    p = (char *) rcCli + sizeof(rapid_city_rcCli_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcCli, sizeof(oid_rcCli)/sizeof(guint32),
                   attr_rcCli, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcCli->_rcCliRWAUserNameLength = vb->syntax_len;
            rcCli->rcCliRWAUserName = vb->syntax.uc;
            break;
        case 2:
            rcCli->_rcCliRWAPasswordLength = vb->syntax_len;
            rcCli->rcCliRWAPassword = vb->syntax.uc;
            break;
        case 3:
            rcCli->_rcCliRWUserNameLength = vb->syntax_len;
            rcCli->rcCliRWUserName = vb->syntax.uc;
            break;
        case 4:
            rcCli->_rcCliRWPasswordLength = vb->syntax_len;
            rcCli->rcCliRWPassword = vb->syntax.uc;
            break;
        case 5:
            rcCli->_rcCliRWL3UserNameLength = vb->syntax_len;
            rcCli->rcCliRWL3UserName = vb->syntax.uc;
            break;
        case 6:
            rcCli->_rcCliRWL3PasswordLength = vb->syntax_len;
            rcCli->rcCliRWL3Password = vb->syntax.uc;
            break;
        case 7:
            rcCli->_rcCliRWL2UserNameLength = vb->syntax_len;
            rcCli->rcCliRWL2UserName = vb->syntax.uc;
            break;
        case 8:
            rcCli->_rcCliRWL2PasswordLength = vb->syntax_len;
            rcCli->rcCliRWL2Password = vb->syntax.uc;
            break;
        case 9:
            rcCli->_rcCliROUserNameLength = vb->syntax_len;
            rcCli->rcCliROUserName = vb->syntax.uc;
            break;
        case 10:
            rcCli->_rcCliROPasswordLength = vb->syntax_len;
            rcCli->rcCliROPassword = vb->syntax.uc;
            break;
        case 11:
            rcCli->rcCliMaxTelnetSessions = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcCli->rcCliMaxRloginSessions = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcCli->rcCliTimeout = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcCli->rcCliNumAccessViolations = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcCli;
}

void
rapid_city_get_rcCli(GSnmpSession *s, rapid_city_rcCli_t **rcCli, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 19, 0};

    *rcCli = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcCli, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcCli = assign_rcCli(out);
    }
}

void
rapid_city_set_rcCli(GSnmpSession *s, rapid_city_rcCli_t *rcCli, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 19, 0, 0};

    if (rcCli->rcCliRWAUserName) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWAUserName,
                       rcCli->_rcCliRWAUserNameLength);
    }
    if (rcCli->rcCliRWAPassword) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWAPassword,
                       rcCli->_rcCliRWAPasswordLength);
    }
    if (rcCli->rcCliRWUserName) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWUserName,
                       rcCli->_rcCliRWUserNameLength);
    }
    if (rcCli->rcCliRWPassword) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWPassword,
                       rcCli->_rcCliRWPasswordLength);
    }
    if (rcCli->rcCliRWL3UserName) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWL3UserName,
                       rcCli->_rcCliRWL3UserNameLength);
    }
    if (rcCli->rcCliRWL3Password) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWL3Password,
                       rcCli->_rcCliRWL3PasswordLength);
    }
    if (rcCli->rcCliRWL2UserName) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWL2UserName,
                       rcCli->_rcCliRWL2UserNameLength);
    }
    if (rcCli->rcCliRWL2Password) {
        base[9] = 8;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliRWL2Password,
                       rcCli->_rcCliRWL2PasswordLength);
    }
    if (rcCli->rcCliROUserName) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliROUserName,
                       rcCli->_rcCliROUserNameLength);
    }
    if (rcCli->rcCliROPassword) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       rcCli->rcCliROPassword,
                       rcCli->_rcCliROPasswordLength);
    }
    if (rcCli->rcCliMaxTelnetSessions) {
        base[9] = 11;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcCli->rcCliMaxTelnetSessions,
                       0);
    }
    if (rcCli->rcCliMaxRloginSessions) {
        base[9] = 12;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcCli->rcCliMaxRloginSessions,
                       0);
    }
    if (rcCli->rcCliTimeout) {
        base[9] = 13;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcCli->rcCliTimeout,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcCli(rapid_city_rcCli_t *rcCli)
{
    GSList *vbl;
    char *p;

    if (rcCli) {
        p = (char *) rcCli + sizeof(rapid_city_rcCli_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcCli);
    }
}

rapid_city_rcError_t *
rapid_city_new_rcError()
{
    rapid_city_rcError_t *rcError;

    rcError = (rapid_city_rcError_t *) g_malloc0(sizeof(rapid_city_rcError_t) + sizeof(gpointer));
    return rcError;
}

static rapid_city_rcError_t *
assign_rcError(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcError_t *rcError;
    guint32 idx;
    char *p;

    rcError = rapid_city_new_rcError();
    if (! rcError) {
        return NULL;
    }

    p = (char *) rcError + sizeof(rapid_city_rcError_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcError, sizeof(oid_rcError)/sizeof(guint32),
                   attr_rcError, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcError->rcErrorLevel = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcError->rcErrorCode = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcError->_rcErrorTextLength = vb->syntax_len;
            rcError->rcErrorText = vb->syntax.uc;
            break;
        case 4:
            rcError->rcErrorReturnCode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcError->rcErrorSendTrap = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcError;
}

void
rapid_city_get_rcError(GSnmpSession *s, rapid_city_rcError_t **rcError, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 20, 0};

    *rcError = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcError, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcError = assign_rcError(out);
    }
}

void
rapid_city_set_rcError(GSnmpSession *s, rapid_city_rcError_t *rcError, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 20, 0, 0};

    if (rcError->rcErrorSendTrap) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcError->rcErrorSendTrap,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcError(rapid_city_rcError_t *rcError)
{
    GSList *vbl;
    char *p;

    if (rcError) {
        p = (char *) rcError + sizeof(rapid_city_rcError_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcError);
    }
}

rapid_city_rcSyslogGlobal_t *
rapid_city_new_rcSyslogGlobal()
{
    rapid_city_rcSyslogGlobal_t *rcSyslogGlobal;

    rcSyslogGlobal = (rapid_city_rcSyslogGlobal_t *) g_malloc0(sizeof(rapid_city_rcSyslogGlobal_t) + sizeof(gpointer));
    return rcSyslogGlobal;
}

static rapid_city_rcSyslogGlobal_t *
assign_rcSyslogGlobal(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcSyslogGlobal_t *rcSyslogGlobal;
    guint32 idx;
    char *p;

    rcSyslogGlobal = rapid_city_new_rcSyslogGlobal();
    if (! rcSyslogGlobal) {
        return NULL;
    }

    p = (char *) rcSyslogGlobal + sizeof(rapid_city_rcSyslogGlobal_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcSyslogGlobal, sizeof(oid_rcSyslogGlobal)/sizeof(guint32),
                   attr_rcSyslogGlobal, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcSyslogGlobal->rcSyslogGlobalEnable = &(vb->syntax.i32[0]);
            break;
        case 2:
            rcSyslogGlobal->rcSyslogGlobalMaxHosts = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcSyslogGlobal->rcSyslogGlobalOperState = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcSyslogGlobal;
}

void
rapid_city_get_rcSyslogGlobal(GSnmpSession *s, rapid_city_rcSyslogGlobal_t **rcSyslogGlobal, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 22, 1, 0};

    *rcSyslogGlobal = NULL;

    add_attributes(s, &in, base, 11, 10, attr_rcSyslogGlobal, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcSyslogGlobal = assign_rcSyslogGlobal(out);
    }
}

void
rapid_city_set_rcSyslogGlobal(GSnmpSession *s, rapid_city_rcSyslogGlobal_t *rcSyslogGlobal, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 22, 1, 0, 0};

    if (rcSyslogGlobal->rcSyslogGlobalEnable) {
        base[10] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSyslogGlobal->rcSyslogGlobalEnable,
                       0);
    }
    if (rcSyslogGlobal->rcSyslogGlobalMaxHosts) {
        base[10] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcSyslogGlobal->rcSyslogGlobalMaxHosts,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcSyslogGlobal(rapid_city_rcSyslogGlobal_t *rcSyslogGlobal)
{
    GSList *vbl;
    char *p;

    if (rcSyslogGlobal) {
        p = (char *) rcSyslogGlobal + sizeof(rapid_city_rcSyslogGlobal_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcSyslogGlobal);
    }
}

rapid_city_rcSyslogHostEntry_t *
rapid_city_new_rcSyslogHostEntry()
{
    rapid_city_rcSyslogHostEntry_t *rcSyslogHostEntry;

    rcSyslogHostEntry = (rapid_city_rcSyslogHostEntry_t *) g_malloc0(sizeof(rapid_city_rcSyslogHostEntry_t) + sizeof(gpointer));
    return rcSyslogHostEntry;
}

static int
unpack_rcSyslogHostEntry(GSnmpVarBind *vb, rapid_city_rcSyslogHostEntry_t *rcSyslogHostEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcSyslogHostEntry->rcSyslogHostId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcSyslogHostEntry(guint32 *base, gint32 rcSyslogHostId)
{
    int idx = 12;

    base[idx++] = rcSyslogHostId;
    return idx;
}

static rapid_city_rcSyslogHostEntry_t *
assign_rcSyslogHostEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcSyslogHostEntry_t *rcSyslogHostEntry;
    guint32 idx;
    char *p;

    rcSyslogHostEntry = rapid_city_new_rcSyslogHostEntry();
    if (! rcSyslogHostEntry) {
        return NULL;
    }

    p = (char *) rcSyslogHostEntry + sizeof(rapid_city_rcSyslogHostEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcSyslogHostEntry((GSnmpVarBind *) vbl->data, rcSyslogHostEntry) < 0) {
        g_warning("illegal rcSyslogHostEntry instance identifier");
        g_free(rcSyslogHostEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcSyslogHostEntry, sizeof(oid_rcSyslogHostEntry)/sizeof(guint32),
                   attr_rcSyslogHostEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcSyslogHostEntry->rcSyslogHostIpAddr = vb->syntax.uc;
            break;
        case 3:
            rcSyslogHostEntry->rcSyslogHostUdpPort = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcSyslogHostEntry->rcSyslogHostFacility = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcSyslogHostEntry->rcSyslogHostModuleId = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcSyslogHostEntry->rcSyslogHostModuleId2 = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcSyslogHostEntry->rcSyslogHostSeverity = &(vb->syntax.i32[0]);
            break;
        case 8:
            rcSyslogHostEntry->rcSyslogHostMapInfoSeverity = &(vb->syntax.i32[0]);
            break;
        case 9:
            rcSyslogHostEntry->rcSyslogHostMapWarningSeverity = &(vb->syntax.i32[0]);
            break;
        case 10:
            rcSyslogHostEntry->rcSyslogHostMapErrorSeverity = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcSyslogHostEntry->rcSyslogHostMapMfgSeverity = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcSyslogHostEntry->rcSyslogHostMapFatalSeverity = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcSyslogHostEntry->rcSyslogHostMapTraceMsg = &(vb->syntax.i32[0]);
            break;
        case 14:
            rcSyslogHostEntry->rcSyslogHostMapTrapMsg = &(vb->syntax.i32[0]);
            break;
        case 15:
            rcSyslogHostEntry->rcSyslogHostLogTraceMsgs = &(vb->syntax.i32[0]);
            break;
        case 16:
            rcSyslogHostEntry->rcSyslogHostLogTrapMsgs = &(vb->syntax.i32[0]);
            break;
        case 17:
            rcSyslogHostEntry->rcSyslogHostEnable = &(vb->syntax.i32[0]);
            break;
        case 18:
            rcSyslogHostEntry->rcSyslogHostRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcSyslogHostEntry;
}

void
rapid_city_get_rcSyslogHostTbl(GSnmpSession *s, rapid_city_rcSyslogHostEntry_t ***rcSyslogHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 22, 2, 1, 0};

    *rcSyslogHostEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcSyslogHostEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcSyslogHostEntry = (rapid_city_rcSyslogHostEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcSyslogHostEntry_t *));
        if (! *rcSyslogHostEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcSyslogHostEntry)[i] = assign_rcSyslogHostEntry(row->data);
        }
    }
}

void
rapid_city_get_rcSyslogHostEntry(GSnmpSession *s, rapid_city_rcSyslogHostEntry_t **rcSyslogHostEntry, gint32 rcSyslogHostId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSyslogHostEntry, sizeof(oid_rcSyslogHostEntry));
    len = pack_rcSyslogHostEntry(base, rcSyslogHostId);
    if (len < 0) {
        g_warning("illegal rcSyslogHostEntry index values");
        return;
    }

    *rcSyslogHostEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcSyslogHostEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcSyslogHostEntry = assign_rcSyslogHostEntry(out);
    }
}

void
rapid_city_set_rcSyslogHostEntry(GSnmpSession *s, rapid_city_rcSyslogHostEntry_t *rcSyslogHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcSyslogHostEntry, sizeof(oid_rcSyslogHostEntry));
    len = pack_rcSyslogHostEntry(base, rcSyslogHostEntry->rcSyslogHostId);
    if (len < 0) {
        g_warning("illegal rcSyslogHostEntry index values");
        return;
    }

    if (rcSyslogHostEntry->rcSyslogHostIpAddr) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       rcSyslogHostEntry->rcSyslogHostIpAddr,
                       4);
    }
    if (rcSyslogHostEntry->rcSyslogHostUdpPort) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostUdpPort,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostFacility) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostFacility,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostModuleId) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostModuleId,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostModuleId2) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostModuleId2,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostSeverity) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapInfoSeverity) {
        base[11] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapInfoSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapWarningSeverity) {
        base[11] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapWarningSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapErrorSeverity) {
        base[11] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapErrorSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapMfgSeverity) {
        base[11] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapMfgSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapFatalSeverity) {
        base[11] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapFatalSeverity,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapTraceMsg) {
        base[11] = 13;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapTraceMsg,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostMapTrapMsg) {
        base[11] = 14;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostMapTrapMsg,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostLogTraceMsgs) {
        base[11] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostLogTraceMsgs,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostLogTrapMsgs) {
        base[11] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostLogTrapMsgs,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostEnable) {
        base[11] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostEnable,
                       0);
    }
    if (rcSyslogHostEntry->rcSyslogHostRowStatus) {
        base[11] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcSyslogHostEntry->rcSyslogHostRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcSyslogHostEntry(rapid_city_rcSyslogHostEntry_t *rcSyslogHostEntry)
{
    GSList *vbl;
    char *p;

    if (rcSyslogHostEntry) {
        p = (char *) rcSyslogHostEntry + sizeof(rapid_city_rcSyslogHostEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcSyslogHostEntry);
    }
}

void
rapid_city_free_rcSyslogHostTbl(rapid_city_rcSyslogHostEntry_t **rcSyslogHostEntry)
{
    int i;

    if (rcSyslogHostEntry) {
        for (i = 0; rcSyslogHostEntry[i]; i++) {
            rapid_city_free_rcSyslogHostEntry(rcSyslogHostEntry[i]);
        }
        g_free(rcSyslogHostEntry);
    }
}

rapid_city_rcDiag_t *
rapid_city_new_rcDiag()
{
    rapid_city_rcDiag_t *rcDiag;

    rcDiag = (rapid_city_rcDiag_t *) g_malloc0(sizeof(rapid_city_rcDiag_t) + sizeof(gpointer));
    return rcDiag;
}

static rapid_city_rcDiag_t *
assign_rcDiag(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDiag_t *rcDiag;
    guint32 idx;
    char *p;

    rcDiag = rapid_city_new_rcDiag();
    if (! rcDiag) {
        return NULL;
    }

    p = (char *) rcDiag + sizeof(rapid_city_rcDiag_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDiag, sizeof(oid_rcDiag)/sizeof(guint32),
                   attr_rcDiag, &idx) < 0) continue;

        switch (idx) {
        case 10:
            rcDiag->rcDiagSaveConfig = &(vb->syntax.i32[0]);
            break;
        case 11:
            rcDiag->rcDiagMirrorByPortTblSize = &(vb->syntax.i32[0]);
            break;
        case 12:
            rcDiag->rcDiagPortConvSteeringTblSize = &(vb->syntax.i32[0]);
            break;
        case 13:
            rcDiag->rcDiagMacConvSteeringTblSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDiag;
}

void
rapid_city_get_rcDiag(GSnmpSession *s, rapid_city_rcDiag_t **rcDiag, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 0};

    *rcDiag = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcDiag, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDiag = assign_rcDiag(out);
    }
}

void
rapid_city_set_rcDiag(GSnmpSession *s, rapid_city_rcDiag_t *rcDiag, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 0, 0};

    if (rcDiag->rcDiagSaveConfig) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcDiag->rcDiagSaveConfig,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDiag(rapid_city_rcDiag_t *rcDiag)
{
    GSList *vbl;
    char *p;

    if (rcDiag) {
        p = (char *) rcDiag + sizeof(rapid_city_rcDiag_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDiag);
    }
}

rapid_city_rcDiagMirrorByPortEntry_t *
rapid_city_new_rcDiagMirrorByPortEntry()
{
    rapid_city_rcDiagMirrorByPortEntry_t *rcDiagMirrorByPortEntry;

    rcDiagMirrorByPortEntry = (rapid_city_rcDiagMirrorByPortEntry_t *) g_malloc0(sizeof(rapid_city_rcDiagMirrorByPortEntry_t) + sizeof(gpointer));
    return rcDiagMirrorByPortEntry;
}

static int
unpack_rcDiagMirrorByPortEntry(GSnmpVarBind *vb, rapid_city_rcDiagMirrorByPortEntry_t *rcDiagMirrorByPortEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcDiagMirrorByPortEntry->rcDiagMirrorByPortId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcDiagMirrorByPortEntry(guint32 *base, gint32 rcDiagMirrorByPortId)
{
    int idx = 12;

    base[idx++] = rcDiagMirrorByPortId;
    return idx;
}

static rapid_city_rcDiagMirrorByPortEntry_t *
assign_rcDiagMirrorByPortEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDiagMirrorByPortEntry_t *rcDiagMirrorByPortEntry;
    guint32 idx;
    char *p;

    rcDiagMirrorByPortEntry = rapid_city_new_rcDiagMirrorByPortEntry();
    if (! rcDiagMirrorByPortEntry) {
        return NULL;
    }

    p = (char *) rcDiagMirrorByPortEntry + sizeof(rapid_city_rcDiagMirrorByPortEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcDiagMirrorByPortEntry((GSnmpVarBind *) vbl->data, rcDiagMirrorByPortEntry) < 0) {
        g_warning("illegal rcDiagMirrorByPortEntry instance identifier");
        g_free(rcDiagMirrorByPortEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDiagMirrorByPortEntry, sizeof(oid_rcDiagMirrorByPortEntry)/sizeof(guint32),
                   attr_rcDiagMirrorByPortEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroredPort = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroringPort = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcDiagMirrorByPortEntry->rcDiagMirrorByPortMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDiagMirrorByPortEntry->rcDiagMirrorByPortEnable = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcDiagMirrorByPortEntry->rcDiagMirrorByPortRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDiagMirrorByPortEntry;
}

void
rapid_city_get_rcDiagMirrorByPortTable(GSnmpSession *s, rapid_city_rcDiagMirrorByPortEntry_t ***rcDiagMirrorByPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 1, 1, 0};

    *rcDiagMirrorByPortEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcDiagMirrorByPortEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcDiagMirrorByPortEntry = (rapid_city_rcDiagMirrorByPortEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcDiagMirrorByPortEntry_t *));
        if (! *rcDiagMirrorByPortEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcDiagMirrorByPortEntry)[i] = assign_rcDiagMirrorByPortEntry(row->data);
        }
    }
}

void
rapid_city_get_rcDiagMirrorByPortEntry(GSnmpSession *s, rapid_city_rcDiagMirrorByPortEntry_t **rcDiagMirrorByPortEntry, gint32 rcDiagMirrorByPortId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagMirrorByPortEntry, sizeof(oid_rcDiagMirrorByPortEntry));
    len = pack_rcDiagMirrorByPortEntry(base, rcDiagMirrorByPortId);
    if (len < 0) {
        g_warning("illegal rcDiagMirrorByPortEntry index values");
        return;
    }

    *rcDiagMirrorByPortEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcDiagMirrorByPortEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDiagMirrorByPortEntry = assign_rcDiagMirrorByPortEntry(out);
    }
}

void
rapid_city_set_rcDiagMirrorByPortEntry(GSnmpSession *s, rapid_city_rcDiagMirrorByPortEntry_t *rcDiagMirrorByPortEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagMirrorByPortEntry, sizeof(oid_rcDiagMirrorByPortEntry));
    len = pack_rcDiagMirrorByPortEntry(base, rcDiagMirrorByPortEntry->rcDiagMirrorByPortId);
    if (len < 0) {
        g_warning("illegal rcDiagMirrorByPortEntry index values");
        return;
    }

    if (rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroredPort) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroredPort,
                       0);
    }
    if (rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroringPort) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMirrorByPortEntry->rcDiagMirrorByPortMirroringPort,
                       0);
    }
    if (rcDiagMirrorByPortEntry->rcDiagMirrorByPortMode) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMirrorByPortEntry->rcDiagMirrorByPortMode,
                       0);
    }
    if (rcDiagMirrorByPortEntry->rcDiagMirrorByPortEnable) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMirrorByPortEntry->rcDiagMirrorByPortEnable,
                       0);
    }
    if (rcDiagMirrorByPortEntry->rcDiagMirrorByPortRowStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMirrorByPortEntry->rcDiagMirrorByPortRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDiagMirrorByPortEntry(rapid_city_rcDiagMirrorByPortEntry_t *rcDiagMirrorByPortEntry)
{
    GSList *vbl;
    char *p;

    if (rcDiagMirrorByPortEntry) {
        p = (char *) rcDiagMirrorByPortEntry + sizeof(rapid_city_rcDiagMirrorByPortEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDiagMirrorByPortEntry);
    }
}

void
rapid_city_free_rcDiagMirrorByPortTable(rapid_city_rcDiagMirrorByPortEntry_t **rcDiagMirrorByPortEntry)
{
    int i;

    if (rcDiagMirrorByPortEntry) {
        for (i = 0; rcDiagMirrorByPortEntry[i]; i++) {
            rapid_city_free_rcDiagMirrorByPortEntry(rcDiagMirrorByPortEntry[i]);
        }
        g_free(rcDiagMirrorByPortEntry);
    }
}

rapid_city_rcDiagPortConvSteeringEntry_t *
rapid_city_new_rcDiagPortConvSteeringEntry()
{
    rapid_city_rcDiagPortConvSteeringEntry_t *rcDiagPortConvSteeringEntry;

    rcDiagPortConvSteeringEntry = (rapid_city_rcDiagPortConvSteeringEntry_t *) g_malloc0(sizeof(rapid_city_rcDiagPortConvSteeringEntry_t) + sizeof(gpointer));
    return rcDiagPortConvSteeringEntry;
}

static int
unpack_rcDiagPortConvSteeringEntry(GSnmpVarBind *vb, rapid_city_rcDiagPortConvSteeringEntry_t *rcDiagPortConvSteeringEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcDiagPortConvSteeringEntry(guint32 *base, gint32 rcDiagPortConvSteeringId)
{
    int idx = 12;

    base[idx++] = rcDiagPortConvSteeringId;
    return idx;
}

static rapid_city_rcDiagPortConvSteeringEntry_t *
assign_rcDiagPortConvSteeringEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDiagPortConvSteeringEntry_t *rcDiagPortConvSteeringEntry;
    guint32 idx;
    char *p;

    rcDiagPortConvSteeringEntry = rapid_city_new_rcDiagPortConvSteeringEntry();
    if (! rcDiagPortConvSteeringEntry) {
        return NULL;
    }

    p = (char *) rcDiagPortConvSteeringEntry + sizeof(rapid_city_rcDiagPortConvSteeringEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcDiagPortConvSteeringEntry((GSnmpVarBind *) vbl->data, rcDiagPortConvSteeringEntry) < 0) {
        g_warning("illegal rcDiagPortConvSteeringEntry instance identifier");
        g_free(rcDiagPortConvSteeringEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDiagPortConvSteeringEntry, sizeof(oid_rcDiagPortConvSteeringEntry)/sizeof(guint32),
                   attr_rcDiagPortConvSteeringEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortOne = &(vb->syntax.i32[0]);
            break;
        case 3:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortTwo = &(vb->syntax.i32[0]);
            break;
        case 4:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringMode = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringForwardPort = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringEnable = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDiagPortConvSteeringEntry;
}

void
rapid_city_get_rcDiagPortConvSteeringTable(GSnmpSession *s, rapid_city_rcDiagPortConvSteeringEntry_t ***rcDiagPortConvSteeringEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 2, 1, 0};

    *rcDiagPortConvSteeringEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcDiagPortConvSteeringEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcDiagPortConvSteeringEntry = (rapid_city_rcDiagPortConvSteeringEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcDiagPortConvSteeringEntry_t *));
        if (! *rcDiagPortConvSteeringEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcDiagPortConvSteeringEntry)[i] = assign_rcDiagPortConvSteeringEntry(row->data);
        }
    }
}

void
rapid_city_get_rcDiagPortConvSteeringEntry(GSnmpSession *s, rapid_city_rcDiagPortConvSteeringEntry_t **rcDiagPortConvSteeringEntry, gint32 rcDiagPortConvSteeringId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagPortConvSteeringEntry, sizeof(oid_rcDiagPortConvSteeringEntry));
    len = pack_rcDiagPortConvSteeringEntry(base, rcDiagPortConvSteeringId);
    if (len < 0) {
        g_warning("illegal rcDiagPortConvSteeringEntry index values");
        return;
    }

    *rcDiagPortConvSteeringEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcDiagPortConvSteeringEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDiagPortConvSteeringEntry = assign_rcDiagPortConvSteeringEntry(out);
    }
}

void
rapid_city_set_rcDiagPortConvSteeringEntry(GSnmpSession *s, rapid_city_rcDiagPortConvSteeringEntry_t *rcDiagPortConvSteeringEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagPortConvSteeringEntry, sizeof(oid_rcDiagPortConvSteeringEntry));
    len = pack_rcDiagPortConvSteeringEntry(base, rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringId);
    if (len < 0) {
        g_warning("illegal rcDiagPortConvSteeringEntry index values");
        return;
    }

    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortOne) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortOne,
                       0);
    }
    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortTwo) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringPortTwo,
                       0);
    }
    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringMode) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringMode,
                       0);
    }
    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringForwardPort) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringForwardPort,
                       0);
    }
    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringEnable) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringEnable,
                       0);
    }
    if (rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringRowStatus) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagPortConvSteeringEntry->rcDiagPortConvSteeringRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDiagPortConvSteeringEntry(rapid_city_rcDiagPortConvSteeringEntry_t *rcDiagPortConvSteeringEntry)
{
    GSList *vbl;
    char *p;

    if (rcDiagPortConvSteeringEntry) {
        p = (char *) rcDiagPortConvSteeringEntry + sizeof(rapid_city_rcDiagPortConvSteeringEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDiagPortConvSteeringEntry);
    }
}

void
rapid_city_free_rcDiagPortConvSteeringTable(rapid_city_rcDiagPortConvSteeringEntry_t **rcDiagPortConvSteeringEntry)
{
    int i;

    if (rcDiagPortConvSteeringEntry) {
        for (i = 0; rcDiagPortConvSteeringEntry[i]; i++) {
            rapid_city_free_rcDiagPortConvSteeringEntry(rcDiagPortConvSteeringEntry[i]);
        }
        g_free(rcDiagPortConvSteeringEntry);
    }
}

rapid_city_rcDiagMacConvSteeringEntry_t *
rapid_city_new_rcDiagMacConvSteeringEntry()
{
    rapid_city_rcDiagMacConvSteeringEntry_t *rcDiagMacConvSteeringEntry;

    rcDiagMacConvSteeringEntry = (rapid_city_rcDiagMacConvSteeringEntry_t *) g_malloc0(sizeof(rapid_city_rcDiagMacConvSteeringEntry_t) + sizeof(gpointer));
    return rcDiagMacConvSteeringEntry;
}

static int
unpack_rcDiagMacConvSteeringEntry(GSnmpVarBind *vb, rapid_city_rcDiagMacConvSteeringEntry_t *rcDiagMacConvSteeringEntry)
{
    int idx = 12;

    if (vb->id_len < idx) return -1;
    rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringId = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcDiagMacConvSteeringEntry(guint32 *base, gint32 rcDiagMacConvSteeringId)
{
    int idx = 12;

    base[idx++] = rcDiagMacConvSteeringId;
    return idx;
}

static rapid_city_rcDiagMacConvSteeringEntry_t *
assign_rcDiagMacConvSteeringEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcDiagMacConvSteeringEntry_t *rcDiagMacConvSteeringEntry;
    guint32 idx;
    char *p;

    rcDiagMacConvSteeringEntry = rapid_city_new_rcDiagMacConvSteeringEntry();
    if (! rcDiagMacConvSteeringEntry) {
        return NULL;
    }

    p = (char *) rcDiagMacConvSteeringEntry + sizeof(rapid_city_rcDiagMacConvSteeringEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcDiagMacConvSteeringEntry((GSnmpVarBind *) vbl->data, rcDiagMacConvSteeringEntry) < 0) {
        g_warning("illegal rcDiagMacConvSteeringEntry instance identifier");
        g_free(rcDiagMacConvSteeringEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcDiagMacConvSteeringEntry, sizeof(oid_rcDiagMacConvSteeringEntry)/sizeof(guint32),
                   attr_rcDiagMacConvSteeringEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringSrcMac = vb->syntax.uc;
            break;
        case 3:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringDstMac = vb->syntax.uc;
            break;
        case 4:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringInPort = &(vb->syntax.i32[0]);
            break;
        case 5:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringForwardPort = &(vb->syntax.i32[0]);
            break;
        case 6:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringEnable = &(vb->syntax.i32[0]);
            break;
        case 7:
            rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringRowStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcDiagMacConvSteeringEntry;
}

void
rapid_city_get_rcDiagMacConvSteeringTable(GSnmpSession *s, rapid_city_rcDiagMacConvSteeringEntry_t ***rcDiagMacConvSteeringEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 23, 3, 1, 0};

    *rcDiagMacConvSteeringEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcDiagMacConvSteeringEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcDiagMacConvSteeringEntry = (rapid_city_rcDiagMacConvSteeringEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcDiagMacConvSteeringEntry_t *));
        if (! *rcDiagMacConvSteeringEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcDiagMacConvSteeringEntry)[i] = assign_rcDiagMacConvSteeringEntry(row->data);
        }
    }
}

void
rapid_city_get_rcDiagMacConvSteeringEntry(GSnmpSession *s, rapid_city_rcDiagMacConvSteeringEntry_t **rcDiagMacConvSteeringEntry, gint32 rcDiagMacConvSteeringId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagMacConvSteeringEntry, sizeof(oid_rcDiagMacConvSteeringEntry));
    len = pack_rcDiagMacConvSteeringEntry(base, rcDiagMacConvSteeringId);
    if (len < 0) {
        g_warning("illegal rcDiagMacConvSteeringEntry index values");
        return;
    }

    *rcDiagMacConvSteeringEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcDiagMacConvSteeringEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcDiagMacConvSteeringEntry = assign_rcDiagMacConvSteeringEntry(out);
    }
}

void
rapid_city_set_rcDiagMacConvSteeringEntry(GSnmpSession *s, rapid_city_rcDiagMacConvSteeringEntry_t *rcDiagMacConvSteeringEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcDiagMacConvSteeringEntry, sizeof(oid_rcDiagMacConvSteeringEntry));
    len = pack_rcDiagMacConvSteeringEntry(base, rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringId);
    if (len < 0) {
        g_warning("illegal rcDiagMacConvSteeringEntry index values");
        return;
    }

    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringSrcMac) {
        base[11] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringSrcMac,
                       6);
    }
    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringDstMac) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringDstMac,
                       6);
    }
    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringInPort) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringInPort,
                       0);
    }
    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringForwardPort) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringForwardPort,
                       0);
    }
    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringEnable) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringEnable,
                       0);
    }
    if (rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringRowStatus) {
        base[11] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcDiagMacConvSteeringEntry->rcDiagMacConvSteeringRowStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcDiagMacConvSteeringEntry(rapid_city_rcDiagMacConvSteeringEntry_t *rcDiagMacConvSteeringEntry)
{
    GSList *vbl;
    char *p;

    if (rcDiagMacConvSteeringEntry) {
        p = (char *) rcDiagMacConvSteeringEntry + sizeof(rapid_city_rcDiagMacConvSteeringEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcDiagMacConvSteeringEntry);
    }
}

void
rapid_city_free_rcDiagMacConvSteeringTable(rapid_city_rcDiagMacConvSteeringEntry_t **rcDiagMacConvSteeringEntry)
{
    int i;

    if (rcDiagMacConvSteeringEntry) {
        for (i = 0; rcDiagMacConvSteeringEntry[i]; i++) {
            rapid_city_free_rcDiagMacConvSteeringEntry(rcDiagMacConvSteeringEntry[i]);
        }
        g_free(rcDiagMacConvSteeringEntry);
    }
}

rapid_city_rcIpx_t *
rapid_city_new_rcIpx()
{
    rapid_city_rcIpx_t *rcIpx;

    rcIpx = (rapid_city_rcIpx_t *) g_malloc0(sizeof(rapid_city_rcIpx_t) + sizeof(gpointer));
    return rcIpx;
}

static rapid_city_rcIpx_t *
assign_rcIpx(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpx_t *rcIpx;
    guint32 idx;
    char *p;

    rcIpx = rapid_city_new_rcIpx();
    if (! rcIpx) {
        return NULL;
    }

    p = (char *) rcIpx + sizeof(rapid_city_rcIpx_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpx, sizeof(oid_rcIpx)/sizeof(guint32),
                   attr_rcIpx, &idx) < 0) continue;

        switch (idx) {
        case 1:
            rcIpx->rcIpxRoutingEnable = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpx;
}

void
rapid_city_get_rcIpx(GSnmpSession *s, rapid_city_rcIpx_t **rcIpx, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 24, 0};

    *rcIpx = NULL;

    add_attributes(s, &in, base, 10, 9, attr_rcIpx, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpx = assign_rcIpx(out);
    }
}

void
rapid_city_set_rcIpx(GSnmpSession *s, rapid_city_rcIpx_t *rcIpx, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 24, 0, 0};

    if (rcIpx->rcIpxRoutingEnable) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       rcIpx->rcIpxRoutingEnable,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpx(rapid_city_rcIpx_t *rcIpx)
{
    GSList *vbl;
    char *p;

    if (rcIpx) {
        p = (char *) rcIpx + sizeof(rapid_city_rcIpx_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpx);
    }
}

rapid_city_rcIpxAddrEntry_t *
rapid_city_new_rcIpxAddrEntry()
{
    rapid_city_rcIpxAddrEntry_t *rcIpxAddrEntry;

    rcIpxAddrEntry = (rapid_city_rcIpxAddrEntry_t *) g_malloc0(sizeof(rapid_city_rcIpxAddrEntry_t) + sizeof(gpointer));
    return rcIpxAddrEntry;
}

static int
unpack_rcIpxAddrEntry(GSnmpVarBind *vb, rapid_city_rcIpxAddrEntry_t *rcIpxAddrEntry)
{
    int i, len, idx = 12;

    if (vb->id_len < idx) return -1;
    rcIpxAddrEntry->rcIpxAddrVlanId = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rcIpxAddrEntry->rcIpxAddrNetAddr[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    rcIpxAddrEntry->rcIpxAddrEncap = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_rcIpxAddrEntry(guint32 *base, gint32 rcIpxAddrVlanId, guchar *rcIpxAddrNetAddr, gint32 rcIpxAddrEncap)
{
    int i, len, idx = 12;

    base[idx++] = rcIpxAddrVlanId;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = rcIpxAddrNetAddr[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rcIpxAddrEncap;
    return idx;
}

static rapid_city_rcIpxAddrEntry_t *
assign_rcIpxAddrEntry(GSList *vbl)
{
    GSList *elem;
    rapid_city_rcIpxAddrEntry_t *rcIpxAddrEntry;
    guint32 idx;
    char *p;

    rcIpxAddrEntry = rapid_city_new_rcIpxAddrEntry();
    if (! rcIpxAddrEntry) {
        return NULL;
    }

    p = (char *) rcIpxAddrEntry + sizeof(rapid_city_rcIpxAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_rcIpxAddrEntry((GSnmpVarBind *) vbl->data, rcIpxAddrEntry) < 0) {
        g_warning("illegal rcIpxAddrEntry instance identifier");
        g_free(rcIpxAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_rcIpxAddrEntry, sizeof(oid_rcIpxAddrEntry)/sizeof(guint32),
                   attr_rcIpxAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            rcIpxAddrEntry->rcIpxAddrEntryStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return rcIpxAddrEntry;
}

void
rapid_city_get_rcIpxAddrTable(GSnmpSession *s, rapid_city_rcIpxAddrEntry_t ***rcIpxAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 2272, 1, 24, 2, 1, 0};

    *rcIpxAddrEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_rcIpxAddrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *rcIpxAddrEntry = (rapid_city_rcIpxAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rapid_city_rcIpxAddrEntry_t *));
        if (! *rcIpxAddrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*rcIpxAddrEntry)[i] = assign_rcIpxAddrEntry(row->data);
        }
    }
}

void
rapid_city_get_rcIpxAddrEntry(GSnmpSession *s, rapid_city_rcIpxAddrEntry_t **rcIpxAddrEntry, gint32 rcIpxAddrVlanId, guchar *rcIpxAddrNetAddr, gint32 rcIpxAddrEncap, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpxAddrEntry, sizeof(oid_rcIpxAddrEntry));
    len = pack_rcIpxAddrEntry(base, rcIpxAddrVlanId, rcIpxAddrNetAddr, rcIpxAddrEncap);
    if (len < 0) {
        g_warning("illegal rcIpxAddrEntry index values");
        return;
    }

    *rcIpxAddrEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_rcIpxAddrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *rcIpxAddrEntry = assign_rcIpxAddrEntry(out);
    }
}

void
rapid_city_set_rcIpxAddrEntry(GSnmpSession *s, rapid_city_rcIpxAddrEntry_t *rcIpxAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_rcIpxAddrEntry, sizeof(oid_rcIpxAddrEntry));
    len = pack_rcIpxAddrEntry(base, rcIpxAddrEntry->rcIpxAddrVlanId, rcIpxAddrEntry->rcIpxAddrNetAddr, rcIpxAddrEntry->rcIpxAddrEncap);
    if (len < 0) {
        g_warning("illegal rcIpxAddrEntry index values");
        return;
    }

    if (rcIpxAddrEntry->rcIpxAddrEntryStatus) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       rcIpxAddrEntry->rcIpxAddrEntryStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rapid_city_free_rcIpxAddrEntry(rapid_city_rcIpxAddrEntry_t *rcIpxAddrEntry)
{
    GSList *vbl;
    char *p;

    if (rcIpxAddrEntry) {
        p = (char *) rcIpxAddrEntry + sizeof(rapid_city_rcIpxAddrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(rcIpxAddrEntry);
    }
}

void
rapid_city_free_rcIpxAddrTable(rapid_city_rcIpxAddrEntry_t **rcIpxAddrEntry)
{
    int i;

    if (rcIpxAddrEntry) {
        for (i = 0; rcIpxAddrEntry[i]; i++) {
            rapid_city_free_rcIpxAddrEntry(rcIpxAddrEntry[i]);
        }
        g_free(rcIpxAddrEntry);
    }
}


