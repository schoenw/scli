/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.17 for the scli package.
 *
 * Derived from HOST-RESOURCES-MIB:
 *   This MIB is for use in managing host systems. The term
 *   `host' is construed to mean any computer that communicates
 *   with other similar computers attached to the internet and
 *   that is directly used by one or more human beings. Although
 *   this MIB does not necessarily apply to devices whose primary
 *   function is communications services (e.g., terminal servers,
 *   routers, bridges, monitoring equipment), such relevance is
 *   not explicitly precluded.  This MIB instruments attributes
 *   common to all internet hosts including, for example, both
 *   personal computers and systems that run variants of Unix.
 *
 * Revision 2000-03-06 00:00:
 *   Clarifications and bug fixes based on implementation
 *   experience.  This revision was also reformatted in the SMIv2
 *   format. The revisions made were:
 *   
 *   New RFC document standards:
 *      Added Copyright notice, updated introduction to SNMP
 *      Framework, updated references section, added reference to
 *      RFC 2119, and added a meaningful Security Considerations
 *      section.
 *   
 *   New IANA considerations section for registration of new types
 *   
 *   Conversion to new SMIv2 syntax for the following types and
 *   macros:
 *       Counter32, Integer32, Gauge32, MODULE-IDENTITY,
 *       OBJECT-TYPE, TEXTUAL-CONVENTION, OBJECT-IDENTITY,
 *       MODULE-COMPLIANCE, OBJECT-GROUP
 *   
 *   Used new Textual Conventions:
 *       TruthValue, DateAndTime, AutonomousType,
 *       InterfaceIndexOrZero
 *   
 *   Fixed typo in hrPrinterStatus.
 *   
 *   Added missing error bits to hrPrinterDetectedErrorState and
 *   clarified confusion resulting from suggested mappings to
 *   hrPrinterStatus.
 *   Clarified that size of objects of type
 *   InternationalDisplayString is number of octets, not number
 *   of encoded symbols.
 *   
 *   Clarified the use of the following objects based on
 *   implementation experience:
 *       hrSystemInitialLoadDevice, hrSystemInitialLoadParameters,
 *       hrMemorySize, hrStorageSize, hrStorageAllocationFailures,
 *       hrDeviceErrors, hrProcessorLoad, hrNetworkIfIndex,
 *       hrDiskStorageCapacity, hrSWRunStatus, hrSWRunPerfCPU,
 *       and hrSWInstalledDate.
 *   
 *   Clarified implementation technique for hrSWInstalledTable.
 *   
 *   Used new AUGMENTS clause for hrSWRunPerfTable.
 *   
 *   Added Internationalization Considerations section.
 *   
 *   This revision published as RFC2790.
 *
 * Revision 1999-10-20 22:00:
 *   The original version of this MIB, published as
 *   RFC1514.
 *
 * $Id$
 */

#include "host-resources-mib.h"

GSnmpEnum const host_resources_mib_enums_hrDeviceStatus[] = {
    { HOST_RESOURCES_MIB_HRDEVICESTATUS_UNKNOWN,	"unknown" },
    { HOST_RESOURCES_MIB_HRDEVICESTATUS_RUNNING,	"running" },
    { HOST_RESOURCES_MIB_HRDEVICESTATUS_WARNING,	"warning" },
    { HOST_RESOURCES_MIB_HRDEVICESTATUS_TESTING,	"testing" },
    { HOST_RESOURCES_MIB_HRDEVICESTATUS_DOWN,	"down" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrPrinterStatus[] = {
    { HOST_RESOURCES_MIB_HRPRINTERSTATUS_OTHER,	"other" },
    { HOST_RESOURCES_MIB_HRPRINTERSTATUS_UNKNOWN,	"unknown" },
    { HOST_RESOURCES_MIB_HRPRINTERSTATUS_IDLE,	"idle" },
    { HOST_RESOURCES_MIB_HRPRINTERSTATUS_PRINTING,	"printing" },
    { HOST_RESOURCES_MIB_HRPRINTERSTATUS_WARMUP,	"warmup" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrDiskStorageAccess[] = {
    { HOST_RESOURCES_MIB_HRDISKSTORAGEACCESS_READWRITE,	"readWrite" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEACCESS_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrDiskStorageMedia[] = {
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_OTHER,	"other" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_UNKNOWN,	"unknown" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_HARDDISK,	"hardDisk" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_FLOPPYDISK,	"floppyDisk" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_OPTICALDISKROM,	"opticalDiskROM" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_OPTICALDISKWORM,	"opticalDiskWORM" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_OPTICALDISKRW,	"opticalDiskRW" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA_RAMDISK,	"ramDisk" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrDiskStorageRemoveble[] = {
    { HOST_RESOURCES_MIB_HRDISKSTORAGEREMOVEBLE_TRUE,	"true" },
    { HOST_RESOURCES_MIB_HRDISKSTORAGEREMOVEBLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrFSAccess[] = {
    { HOST_RESOURCES_MIB_HRFSACCESS_READWRITE,	"readWrite" },
    { HOST_RESOURCES_MIB_HRFSACCESS_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrFSBootable[] = {
    { HOST_RESOURCES_MIB_HRFSBOOTABLE_TRUE,	"true" },
    { HOST_RESOURCES_MIB_HRFSBOOTABLE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrSWRunType[] = {
    { HOST_RESOURCES_MIB_HRSWRUNTYPE_UNKNOWN,	"unknown" },
    { HOST_RESOURCES_MIB_HRSWRUNTYPE_OPERATINGSYSTEM,	"operatingSystem" },
    { HOST_RESOURCES_MIB_HRSWRUNTYPE_DEVICEDRIVER,	"deviceDriver" },
    { HOST_RESOURCES_MIB_HRSWRUNTYPE_APPLICATION,	"application" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrSWRunStatus[] = {
    { HOST_RESOURCES_MIB_HRSWRUNSTATUS_RUNNING,	"running" },
    { HOST_RESOURCES_MIB_HRSWRUNSTATUS_RUNNABLE,	"runnable" },
    { HOST_RESOURCES_MIB_HRSWRUNSTATUS_NOTRUNNABLE,	"notRunnable" },
    { HOST_RESOURCES_MIB_HRSWRUNSTATUS_INVALID,	"invalid" },
    { 0, NULL }
};

GSnmpEnum const host_resources_mib_enums_hrSWInstalledType[] = {
    { HOST_RESOURCES_MIB_HRSWINSTALLEDTYPE_UNKNOWN,	"unknown" },
    { HOST_RESOURCES_MIB_HRSWINSTALLEDTYPE_OPERATINGSYSTEM,	"operatingSystem" },
    { HOST_RESOURCES_MIB_HRSWINSTALLEDTYPE_DEVICEDRIVER,	"deviceDriver" },
    { HOST_RESOURCES_MIB_HRSWINSTALLEDTYPE_APPLICATION,	"application" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, gsize len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, gsize const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		g_warning("type tag 0x%02x does not match 0x%02x (%s)",
			  vb->type, attributes[i].type, attributes[i].label);
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_hrSystem[] = {1, 3, 6, 1, 2, 1, 25, 1};

static attribute_t attr_hrSystem[] = {
    { 1, G_SNMP_TIMETICKS, HOST_RESOURCES_MIB_HRSYSTEMUPTIME, "hrSystemUptime" },
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSYSTEMDATE, "hrSystemDate" },
    { 3, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSYSTEMINITIALLOADDEVICE, "hrSystemInitialLoadDevice" },
    { 4, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSYSTEMINITIALLOADPARAMETERS, "hrSystemInitialLoadParameters" },
    { 5, G_SNMP_UNSIGNED32, HOST_RESOURCES_MIB_HRSYSTEMNUMUSERS, "hrSystemNumUsers" },
    { 6, G_SNMP_UNSIGNED32, HOST_RESOURCES_MIB_HRSYSTEMPROCESSES, "hrSystemProcesses" },
    { 7, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSYSTEMMAXPROCESSES, "hrSystemMaxProcesses" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrStorage[] = {1, 3, 6, 1, 2, 1, 25, 2};

static attribute_t attr_hrStorage[] = {
    { 2, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRMEMORYSIZE, "hrMemorySize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrStorageEntry[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1};

static attribute_t attr_hrStorageEntry[] = {
    { 2, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRSTORAGETYPE, "hrStorageType" },
    { 3, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSTORAGEDESCR, "hrStorageDescr" },
    { 4, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSTORAGEALLOCATIONUNITS, "hrStorageAllocationUnits" },
    { 5, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSTORAGESIZE, "hrStorageSize" },
    { 6, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSTORAGEUSED, "hrStorageUsed" },
    { 7, G_SNMP_COUNTER32, HOST_RESOURCES_MIB_HRSTORAGEALLOCATIONFAILURES, "hrStorageAllocationFailures" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrDeviceEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1};

static attribute_t attr_hrDeviceEntry[] = {
    { 2, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRDEVICETYPE, "hrDeviceType" },
    { 3, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRDEVICEDESCR, "hrDeviceDescr" },
    { 4, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRDEVICEID, "hrDeviceID" },
    { 5, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRDEVICESTATUS, "hrDeviceStatus" },
    { 6, G_SNMP_COUNTER32, HOST_RESOURCES_MIB_HRDEVICEERRORS, "hrDeviceErrors" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrProcessorEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 3, 1};

static attribute_t attr_hrProcessorEntry[] = {
    { 1, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRPROCESSORFRWID, "hrProcessorFrwID" },
    { 2, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRPROCESSORLOAD, "hrProcessorLoad" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrNetworkEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 4, 1};

static attribute_t attr_hrNetworkEntry[] = {
    { 1, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRNETWORKIFINDEX, "hrNetworkIfIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrPrinterEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 5, 1};

static attribute_t attr_hrPrinterEntry[] = {
    { 1, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRPRINTERSTATUS, "hrPrinterStatus" },
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRPRINTERDETECTEDERRORSTATE, "hrPrinterDetectedErrorState" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrDiskStorageEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1};

static attribute_t attr_hrDiskStorageEntry[] = {
    { 1, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRDISKSTORAGEACCESS, "hrDiskStorageAccess" },
    { 2, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRDISKSTORAGEMEDIA, "hrDiskStorageMedia" },
    { 3, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRDISKSTORAGEREMOVEBLE, "hrDiskStorageRemoveble" },
    { 4, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRDISKSTORAGECAPACITY, "hrDiskStorageCapacity" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrPartitionEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1};

static attribute_t attr_hrPartitionEntry[] = {
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRPARTITIONLABEL, "hrPartitionLabel" },
    { 3, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRPARTITIONID, "hrPartitionID" },
    { 4, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRPARTITIONSIZE, "hrPartitionSize" },
    { 5, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRPARTITIONFSINDEX, "hrPartitionFSIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrFSEntry[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1};

static attribute_t attr_hrFSEntry[] = {
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRFSMOUNTPOINT, "hrFSMountPoint" },
    { 3, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRFSREMOTEMOUNTPOINT, "hrFSRemoteMountPoint" },
    { 4, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRFSTYPE, "hrFSType" },
    { 5, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRFSACCESS, "hrFSAccess" },
    { 6, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRFSBOOTABLE, "hrFSBootable" },
    { 7, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRFSSTORAGEINDEX, "hrFSStorageIndex" },
    { 8, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRFSLASTFULLBACKUPDATE, "hrFSLastFullBackupDate" },
    { 9, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRFSLASTPARTIALBACKUPDATE, "hrFSLastPartialBackupDate" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrSWRun[] = {1, 3, 6, 1, 2, 1, 25, 4};

static attribute_t attr_hrSWRun[] = {
    { 1, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWOSINDEX, "hrSWOSIndex" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrSWRunEntry[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1};

static attribute_t attr_hrSWRunEntry[] = {
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSWRUNNAME, "hrSWRunName" },
    { 3, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRSWRUNID, "hrSWRunID" },
    { 4, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSWRUNPATH, "hrSWRunPath" },
    { 5, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSWRUNPARAMETERS, "hrSWRunParameters" },
    { 6, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWRUNTYPE, "hrSWRunType" },
    { 7, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWRUNSTATUS, "hrSWRunStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrSWRunPerfEntry[] = {1, 3, 6, 1, 2, 1, 25, 5, 1, 1};

static attribute_t attr_hrSWRunPerfEntry[] = {
    { 1, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWRUNPERFCPU, "hrSWRunPerfCPU" },
    { 2, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWRUNPERFMEM, "hrSWRunPerfMem" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrSWInstalled[] = {1, 3, 6, 1, 2, 1, 25, 6};

static attribute_t attr_hrSWInstalled[] = {
    { 1, G_SNMP_TIMETICKS, HOST_RESOURCES_MIB_HRSWINSTALLEDLASTCHANGE, "hrSWInstalledLastChange" },
    { 2, G_SNMP_TIMETICKS, HOST_RESOURCES_MIB_HRSWINSTALLEDLASTUPDATETIME, "hrSWInstalledLastUpdateTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_hrSWInstalledEntry[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1};

static attribute_t attr_hrSWInstalledEntry[] = {
    { 2, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSWINSTALLEDNAME, "hrSWInstalledName" },
    { 3, G_SNMP_OBJECT_ID, HOST_RESOURCES_MIB_HRSWINSTALLEDID, "hrSWInstalledID" },
    { 4, G_SNMP_INTEGER32, HOST_RESOURCES_MIB_HRSWINSTALLEDTYPE, "hrSWInstalledType" },
    { 5, G_SNMP_OCTET_STRING, HOST_RESOURCES_MIB_HRSWINSTALLEDDATE, "hrSWInstalledDate" },
    { 0, 0, 0, NULL }
};


host_resources_mib_hrSystem_t *
host_resources_mib_new_hrSystem()
{
    host_resources_mib_hrSystem_t *hrSystem;

    hrSystem = (host_resources_mib_hrSystem_t *) g_malloc0(sizeof(host_resources_mib_hrSystem_t) + sizeof(gpointer));
    return hrSystem;
}

static host_resources_mib_hrSystem_t *
assign_hrSystem(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSystem_t *hrSystem;
    guint32 idx;
    char *p;

    hrSystem = host_resources_mib_new_hrSystem();
    if (! hrSystem) {
        return NULL;
    }

    p = (char *) hrSystem + sizeof(host_resources_mib_hrSystem_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSystem, sizeof(oid_hrSystem)/sizeof(guint32),
                   attr_hrSystem, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrSystem->hrSystemUptime = &(vb->syntax.ui32[0]);
            break;
        case 2:
            hrSystem->_hrSystemDateLength = vb->syntax_len;
            hrSystem->hrSystemDate = vb->syntax.uc;
            break;
        case 3:
            hrSystem->hrSystemInitialLoadDevice = &(vb->syntax.i32[0]);
            break;
        case 4:
            hrSystem->_hrSystemInitialLoadParametersLength = vb->syntax_len;
            hrSystem->hrSystemInitialLoadParameters = vb->syntax.uc;
            break;
        case 5:
            hrSystem->hrSystemNumUsers = &(vb->syntax.ui32[0]);
            break;
        case 6:
            hrSystem->hrSystemProcesses = &(vb->syntax.ui32[0]);
            break;
        case 7:
            hrSystem->hrSystemMaxProcesses = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrSystem;
}

void
host_resources_mib_get_hrSystem(GSnmpSession *s, host_resources_mib_hrSystem_t **hrSystem, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 1, 0};

    *hrSystem = NULL;

    add_attributes(s, &in, base, 9, 8, attr_hrSystem, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSystem = assign_hrSystem(out);
    }
}

void
host_resources_mib_set_hrSystem(GSnmpSession *s, host_resources_mib_hrSystem_t *hrSystem, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 1, 0, 0};

    if (hrSystem->hrSystemDate) {
        base[8] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       hrSystem->hrSystemDate,
                       hrSystem->_hrSystemDateLength);
    }
    if (hrSystem->hrSystemInitialLoadDevice) {
        base[8] = 3;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       hrSystem->hrSystemInitialLoadDevice,
                       0);
    }
    if (hrSystem->hrSystemInitialLoadParameters) {
        base[8] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       hrSystem->hrSystemInitialLoadParameters,
                       hrSystem->_hrSystemInitialLoadParametersLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
host_resources_mib_free_hrSystem(host_resources_mib_hrSystem_t *hrSystem)
{
    GSList *vbl;
    char *p;

    if (hrSystem) {
        p = (char *) hrSystem + sizeof(host_resources_mib_hrSystem_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSystem);
    }
}

host_resources_mib_hrStorage_t *
host_resources_mib_new_hrStorage()
{
    host_resources_mib_hrStorage_t *hrStorage;

    hrStorage = (host_resources_mib_hrStorage_t *) g_malloc0(sizeof(host_resources_mib_hrStorage_t) + sizeof(gpointer));
    return hrStorage;
}

static host_resources_mib_hrStorage_t *
assign_hrStorage(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrStorage_t *hrStorage;
    guint32 idx;
    char *p;

    hrStorage = host_resources_mib_new_hrStorage();
    if (! hrStorage) {
        return NULL;
    }

    p = (char *) hrStorage + sizeof(host_resources_mib_hrStorage_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrStorage, sizeof(oid_hrStorage)/sizeof(guint32),
                   attr_hrStorage, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrStorage->hrMemorySize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrStorage;
}

void
host_resources_mib_get_hrStorage(GSnmpSession *s, host_resources_mib_hrStorage_t **hrStorage, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 2, 0};

    *hrStorage = NULL;

    add_attributes(s, &in, base, 9, 8, attr_hrStorage, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrStorage = assign_hrStorage(out);
    }
}

void
host_resources_mib_free_hrStorage(host_resources_mib_hrStorage_t *hrStorage)
{
    GSList *vbl;
    char *p;

    if (hrStorage) {
        p = (char *) hrStorage + sizeof(host_resources_mib_hrStorage_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrStorage);
    }
}

host_resources_mib_hrStorageEntry_t *
host_resources_mib_new_hrStorageEntry()
{
    host_resources_mib_hrStorageEntry_t *hrStorageEntry;

    hrStorageEntry = (host_resources_mib_hrStorageEntry_t *) g_malloc0(sizeof(host_resources_mib_hrStorageEntry_t) + sizeof(gpointer));
    return hrStorageEntry;
}

static int
unpack_hrStorageEntry(GSnmpVarBind *vb, host_resources_mib_hrStorageEntry_t *hrStorageEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrStorageEntry->hrStorageIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrStorageEntry(guint32 *base, gint32 hrStorageIndex)
{
    int idx = 11;

    base[idx++] = hrStorageIndex;
    return idx;
}

static host_resources_mib_hrStorageEntry_t *
assign_hrStorageEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrStorageEntry_t *hrStorageEntry;
    guint32 idx;
    char *p;

    hrStorageEntry = host_resources_mib_new_hrStorageEntry();
    if (! hrStorageEntry) {
        return NULL;
    }

    p = (char *) hrStorageEntry + sizeof(host_resources_mib_hrStorageEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrStorageEntry((GSnmpVarBind *) vbl->data, hrStorageEntry) < 0) {
        g_warning("illegal hrStorageEntry instance identifier");
        g_free(hrStorageEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrStorageEntry, sizeof(oid_hrStorageEntry)/sizeof(guint32),
                   attr_hrStorageEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrStorageEntry->_hrStorageTypeLength = vb->syntax_len / sizeof(guint32);
            hrStorageEntry->hrStorageType = vb->syntax.ui32;
            break;
        case 3:
            hrStorageEntry->_hrStorageDescrLength = vb->syntax_len;
            hrStorageEntry->hrStorageDescr = vb->syntax.uc;
            break;
        case 4:
            hrStorageEntry->hrStorageAllocationUnits = &(vb->syntax.i32[0]);
            break;
        case 5:
            hrStorageEntry->hrStorageSize = &(vb->syntax.i32[0]);
            break;
        case 6:
            hrStorageEntry->hrStorageUsed = &(vb->syntax.i32[0]);
            break;
        case 7:
            hrStorageEntry->hrStorageAllocationFailures = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return hrStorageEntry;
}

void
host_resources_mib_get_hrStorageTable(GSnmpSession *s, host_resources_mib_hrStorageEntry_t ***hrStorageEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 0};

    *hrStorageEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrStorageEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrStorageEntry = (host_resources_mib_hrStorageEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrStorageEntry_t *));
        if (! *hrStorageEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrStorageEntry)[i] = assign_hrStorageEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrStorageEntry(GSnmpSession *s, host_resources_mib_hrStorageEntry_t **hrStorageEntry, gint32 hrStorageIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrStorageEntry, sizeof(oid_hrStorageEntry));
    len = pack_hrStorageEntry(base, hrStorageIndex);
    if (len < 0) {
        g_warning("illegal hrStorageEntry index values");
        return;
    }

    *hrStorageEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrStorageEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrStorageEntry = assign_hrStorageEntry(out);
    }
}

void
host_resources_mib_set_hrStorageEntry(GSnmpSession *s, host_resources_mib_hrStorageEntry_t *hrStorageEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrStorageEntry, sizeof(oid_hrStorageEntry));
    len = pack_hrStorageEntry(base, hrStorageEntry->hrStorageIndex);
    if (len < 0) {
        g_warning("illegal hrStorageEntry index values");
        return;
    }

    if (hrStorageEntry->hrStorageSize) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       hrStorageEntry->hrStorageSize,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
host_resources_mib_free_hrStorageEntry(host_resources_mib_hrStorageEntry_t *hrStorageEntry)
{
    GSList *vbl;
    char *p;

    if (hrStorageEntry) {
        p = (char *) hrStorageEntry + sizeof(host_resources_mib_hrStorageEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrStorageEntry);
    }
}

void
host_resources_mib_free_hrStorageTable(host_resources_mib_hrStorageEntry_t **hrStorageEntry)
{
    int i;

    if (hrStorageEntry) {
        for (i = 0; hrStorageEntry[i]; i++) {
            host_resources_mib_free_hrStorageEntry(hrStorageEntry[i]);
        }
        g_free(hrStorageEntry);
    }
}

host_resources_mib_hrDeviceEntry_t *
host_resources_mib_new_hrDeviceEntry()
{
    host_resources_mib_hrDeviceEntry_t *hrDeviceEntry;

    hrDeviceEntry = (host_resources_mib_hrDeviceEntry_t *) g_malloc0(sizeof(host_resources_mib_hrDeviceEntry_t) + sizeof(gpointer));
    return hrDeviceEntry;
}

static int
unpack_hrDeviceEntry(GSnmpVarBind *vb, host_resources_mib_hrDeviceEntry_t *hrDeviceEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrDeviceEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrDeviceEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static host_resources_mib_hrDeviceEntry_t *
assign_hrDeviceEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrDeviceEntry_t *hrDeviceEntry;
    guint32 idx;
    char *p;

    hrDeviceEntry = host_resources_mib_new_hrDeviceEntry();
    if (! hrDeviceEntry) {
        return NULL;
    }

    p = (char *) hrDeviceEntry + sizeof(host_resources_mib_hrDeviceEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrDeviceEntry((GSnmpVarBind *) vbl->data, hrDeviceEntry) < 0) {
        g_warning("illegal hrDeviceEntry instance identifier");
        g_free(hrDeviceEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrDeviceEntry, sizeof(oid_hrDeviceEntry)/sizeof(guint32),
                   attr_hrDeviceEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrDeviceEntry->_hrDeviceTypeLength = vb->syntax_len / sizeof(guint32);
            hrDeviceEntry->hrDeviceType = vb->syntax.ui32;
            break;
        case 3:
            hrDeviceEntry->_hrDeviceDescrLength = vb->syntax_len;
            hrDeviceEntry->hrDeviceDescr = vb->syntax.uc;
            break;
        case 4:
            hrDeviceEntry->_hrDeviceIDLength = vb->syntax_len / sizeof(guint32);
            hrDeviceEntry->hrDeviceID = vb->syntax.ui32;
            break;
        case 5:
            hrDeviceEntry->hrDeviceStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            hrDeviceEntry->hrDeviceErrors = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return hrDeviceEntry;
}

void
host_resources_mib_get_hrDeviceTable(GSnmpSession *s, host_resources_mib_hrDeviceEntry_t ***hrDeviceEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 0};

    *hrDeviceEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrDeviceEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrDeviceEntry = (host_resources_mib_hrDeviceEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrDeviceEntry_t *));
        if (! *hrDeviceEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrDeviceEntry)[i] = assign_hrDeviceEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrDeviceEntry(GSnmpSession *s, host_resources_mib_hrDeviceEntry_t **hrDeviceEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrDeviceEntry, sizeof(oid_hrDeviceEntry));
    len = pack_hrDeviceEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal hrDeviceEntry index values");
        return;
    }

    *hrDeviceEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrDeviceEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrDeviceEntry = assign_hrDeviceEntry(out);
    }
}

void
host_resources_mib_free_hrDeviceEntry(host_resources_mib_hrDeviceEntry_t *hrDeviceEntry)
{
    GSList *vbl;
    char *p;

    if (hrDeviceEntry) {
        p = (char *) hrDeviceEntry + sizeof(host_resources_mib_hrDeviceEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrDeviceEntry);
    }
}

void
host_resources_mib_free_hrDeviceTable(host_resources_mib_hrDeviceEntry_t **hrDeviceEntry)
{
    int i;

    if (hrDeviceEntry) {
        for (i = 0; hrDeviceEntry[i]; i++) {
            host_resources_mib_free_hrDeviceEntry(hrDeviceEntry[i]);
        }
        g_free(hrDeviceEntry);
    }
}

host_resources_mib_hrProcessorEntry_t *
host_resources_mib_new_hrProcessorEntry()
{
    host_resources_mib_hrProcessorEntry_t *hrProcessorEntry;

    hrProcessorEntry = (host_resources_mib_hrProcessorEntry_t *) g_malloc0(sizeof(host_resources_mib_hrProcessorEntry_t) + sizeof(gpointer));
    return hrProcessorEntry;
}

static int
unpack_hrProcessorEntry(GSnmpVarBind *vb, host_resources_mib_hrProcessorEntry_t *hrProcessorEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrProcessorEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrProcessorEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static host_resources_mib_hrProcessorEntry_t *
assign_hrProcessorEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrProcessorEntry_t *hrProcessorEntry;
    guint32 idx;
    char *p;

    hrProcessorEntry = host_resources_mib_new_hrProcessorEntry();
    if (! hrProcessorEntry) {
        return NULL;
    }

    p = (char *) hrProcessorEntry + sizeof(host_resources_mib_hrProcessorEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrProcessorEntry((GSnmpVarBind *) vbl->data, hrProcessorEntry) < 0) {
        g_warning("illegal hrProcessorEntry instance identifier");
        g_free(hrProcessorEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrProcessorEntry, sizeof(oid_hrProcessorEntry)/sizeof(guint32),
                   attr_hrProcessorEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrProcessorEntry->_hrProcessorFrwIDLength = vb->syntax_len / sizeof(guint32);
            hrProcessorEntry->hrProcessorFrwID = vb->syntax.ui32;
            break;
        case 2:
            hrProcessorEntry->hrProcessorLoad = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrProcessorEntry;
}

void
host_resources_mib_get_hrProcessorTable(GSnmpSession *s, host_resources_mib_hrProcessorEntry_t ***hrProcessorEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 3, 1, 0};

    *hrProcessorEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrProcessorEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrProcessorEntry = (host_resources_mib_hrProcessorEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrProcessorEntry_t *));
        if (! *hrProcessorEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrProcessorEntry)[i] = assign_hrProcessorEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrProcessorEntry(GSnmpSession *s, host_resources_mib_hrProcessorEntry_t **hrProcessorEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrProcessorEntry, sizeof(oid_hrProcessorEntry));
    len = pack_hrProcessorEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal hrProcessorEntry index values");
        return;
    }

    *hrProcessorEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrProcessorEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrProcessorEntry = assign_hrProcessorEntry(out);
    }
}

void
host_resources_mib_free_hrProcessorEntry(host_resources_mib_hrProcessorEntry_t *hrProcessorEntry)
{
    GSList *vbl;
    char *p;

    if (hrProcessorEntry) {
        p = (char *) hrProcessorEntry + sizeof(host_resources_mib_hrProcessorEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrProcessorEntry);
    }
}

void
host_resources_mib_free_hrProcessorTable(host_resources_mib_hrProcessorEntry_t **hrProcessorEntry)
{
    int i;

    if (hrProcessorEntry) {
        for (i = 0; hrProcessorEntry[i]; i++) {
            host_resources_mib_free_hrProcessorEntry(hrProcessorEntry[i]);
        }
        g_free(hrProcessorEntry);
    }
}

host_resources_mib_hrNetworkEntry_t *
host_resources_mib_new_hrNetworkEntry()
{
    host_resources_mib_hrNetworkEntry_t *hrNetworkEntry;

    hrNetworkEntry = (host_resources_mib_hrNetworkEntry_t *) g_malloc0(sizeof(host_resources_mib_hrNetworkEntry_t) + sizeof(gpointer));
    return hrNetworkEntry;
}

static int
unpack_hrNetworkEntry(GSnmpVarBind *vb, host_resources_mib_hrNetworkEntry_t *hrNetworkEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrNetworkEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrNetworkEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static host_resources_mib_hrNetworkEntry_t *
assign_hrNetworkEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrNetworkEntry_t *hrNetworkEntry;
    guint32 idx;
    char *p;

    hrNetworkEntry = host_resources_mib_new_hrNetworkEntry();
    if (! hrNetworkEntry) {
        return NULL;
    }

    p = (char *) hrNetworkEntry + sizeof(host_resources_mib_hrNetworkEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrNetworkEntry((GSnmpVarBind *) vbl->data, hrNetworkEntry) < 0) {
        g_warning("illegal hrNetworkEntry instance identifier");
        g_free(hrNetworkEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrNetworkEntry, sizeof(oid_hrNetworkEntry)/sizeof(guint32),
                   attr_hrNetworkEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrNetworkEntry->hrNetworkIfIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrNetworkEntry;
}

void
host_resources_mib_get_hrNetworkTable(GSnmpSession *s, host_resources_mib_hrNetworkEntry_t ***hrNetworkEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 4, 1, 0};

    *hrNetworkEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrNetworkEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrNetworkEntry = (host_resources_mib_hrNetworkEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrNetworkEntry_t *));
        if (! *hrNetworkEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrNetworkEntry)[i] = assign_hrNetworkEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrNetworkEntry(GSnmpSession *s, host_resources_mib_hrNetworkEntry_t **hrNetworkEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrNetworkEntry, sizeof(oid_hrNetworkEntry));
    len = pack_hrNetworkEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal hrNetworkEntry index values");
        return;
    }

    *hrNetworkEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrNetworkEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrNetworkEntry = assign_hrNetworkEntry(out);
    }
}

void
host_resources_mib_free_hrNetworkEntry(host_resources_mib_hrNetworkEntry_t *hrNetworkEntry)
{
    GSList *vbl;
    char *p;

    if (hrNetworkEntry) {
        p = (char *) hrNetworkEntry + sizeof(host_resources_mib_hrNetworkEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrNetworkEntry);
    }
}

void
host_resources_mib_free_hrNetworkTable(host_resources_mib_hrNetworkEntry_t **hrNetworkEntry)
{
    int i;

    if (hrNetworkEntry) {
        for (i = 0; hrNetworkEntry[i]; i++) {
            host_resources_mib_free_hrNetworkEntry(hrNetworkEntry[i]);
        }
        g_free(hrNetworkEntry);
    }
}

host_resources_mib_hrPrinterEntry_t *
host_resources_mib_new_hrPrinterEntry()
{
    host_resources_mib_hrPrinterEntry_t *hrPrinterEntry;

    hrPrinterEntry = (host_resources_mib_hrPrinterEntry_t *) g_malloc0(sizeof(host_resources_mib_hrPrinterEntry_t) + sizeof(gpointer));
    return hrPrinterEntry;
}

static int
unpack_hrPrinterEntry(GSnmpVarBind *vb, host_resources_mib_hrPrinterEntry_t *hrPrinterEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrPrinterEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrPrinterEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static host_resources_mib_hrPrinterEntry_t *
assign_hrPrinterEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrPrinterEntry_t *hrPrinterEntry;
    guint32 idx;
    char *p;

    hrPrinterEntry = host_resources_mib_new_hrPrinterEntry();
    if (! hrPrinterEntry) {
        return NULL;
    }

    p = (char *) hrPrinterEntry + sizeof(host_resources_mib_hrPrinterEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrPrinterEntry((GSnmpVarBind *) vbl->data, hrPrinterEntry) < 0) {
        g_warning("illegal hrPrinterEntry instance identifier");
        g_free(hrPrinterEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrPrinterEntry, sizeof(oid_hrPrinterEntry)/sizeof(guint32),
                   attr_hrPrinterEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrPrinterEntry->hrPrinterStatus = &(vb->syntax.i32[0]);
            break;
        case 2:
            hrPrinterEntry->_hrPrinterDetectedErrorStateLength = vb->syntax_len;
            hrPrinterEntry->hrPrinterDetectedErrorState = vb->syntax.uc;
            break;
        };
    }

    return hrPrinterEntry;
}

void
host_resources_mib_get_hrPrinterTable(GSnmpSession *s, host_resources_mib_hrPrinterEntry_t ***hrPrinterEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 0};

    *hrPrinterEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrPrinterEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrPrinterEntry = (host_resources_mib_hrPrinterEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrPrinterEntry_t *));
        if (! *hrPrinterEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrPrinterEntry)[i] = assign_hrPrinterEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrPrinterEntry(GSnmpSession *s, host_resources_mib_hrPrinterEntry_t **hrPrinterEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrPrinterEntry, sizeof(oid_hrPrinterEntry));
    len = pack_hrPrinterEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal hrPrinterEntry index values");
        return;
    }

    *hrPrinterEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrPrinterEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrPrinterEntry = assign_hrPrinterEntry(out);
    }
}

void
host_resources_mib_free_hrPrinterEntry(host_resources_mib_hrPrinterEntry_t *hrPrinterEntry)
{
    GSList *vbl;
    char *p;

    if (hrPrinterEntry) {
        p = (char *) hrPrinterEntry + sizeof(host_resources_mib_hrPrinterEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrPrinterEntry);
    }
}

void
host_resources_mib_free_hrPrinterTable(host_resources_mib_hrPrinterEntry_t **hrPrinterEntry)
{
    int i;

    if (hrPrinterEntry) {
        for (i = 0; hrPrinterEntry[i]; i++) {
            host_resources_mib_free_hrPrinterEntry(hrPrinterEntry[i]);
        }
        g_free(hrPrinterEntry);
    }
}

host_resources_mib_hrDiskStorageEntry_t *
host_resources_mib_new_hrDiskStorageEntry()
{
    host_resources_mib_hrDiskStorageEntry_t *hrDiskStorageEntry;

    hrDiskStorageEntry = (host_resources_mib_hrDiskStorageEntry_t *) g_malloc0(sizeof(host_resources_mib_hrDiskStorageEntry_t) + sizeof(gpointer));
    return hrDiskStorageEntry;
}

static int
unpack_hrDiskStorageEntry(GSnmpVarBind *vb, host_resources_mib_hrDiskStorageEntry_t *hrDiskStorageEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrDiskStorageEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrDiskStorageEntry(guint32 *base, gint32 hrDeviceIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    return idx;
}

static host_resources_mib_hrDiskStorageEntry_t *
assign_hrDiskStorageEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrDiskStorageEntry_t *hrDiskStorageEntry;
    guint32 idx;
    char *p;

    hrDiskStorageEntry = host_resources_mib_new_hrDiskStorageEntry();
    if (! hrDiskStorageEntry) {
        return NULL;
    }

    p = (char *) hrDiskStorageEntry + sizeof(host_resources_mib_hrDiskStorageEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrDiskStorageEntry((GSnmpVarBind *) vbl->data, hrDiskStorageEntry) < 0) {
        g_warning("illegal hrDiskStorageEntry instance identifier");
        g_free(hrDiskStorageEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrDiskStorageEntry, sizeof(oid_hrDiskStorageEntry)/sizeof(guint32),
                   attr_hrDiskStorageEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrDiskStorageEntry->hrDiskStorageAccess = &(vb->syntax.i32[0]);
            break;
        case 2:
            hrDiskStorageEntry->hrDiskStorageMedia = &(vb->syntax.i32[0]);
            break;
        case 3:
            hrDiskStorageEntry->hrDiskStorageRemoveble = &(vb->syntax.i32[0]);
            break;
        case 4:
            hrDiskStorageEntry->hrDiskStorageCapacity = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrDiskStorageEntry;
}

void
host_resources_mib_get_hrDiskStorageTable(GSnmpSession *s, host_resources_mib_hrDiskStorageEntry_t ***hrDiskStorageEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 0};

    *hrDiskStorageEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrDiskStorageEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrDiskStorageEntry = (host_resources_mib_hrDiskStorageEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrDiskStorageEntry_t *));
        if (! *hrDiskStorageEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrDiskStorageEntry)[i] = assign_hrDiskStorageEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrDiskStorageEntry(GSnmpSession *s, host_resources_mib_hrDiskStorageEntry_t **hrDiskStorageEntry, gint32 hrDeviceIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrDiskStorageEntry, sizeof(oid_hrDiskStorageEntry));
    len = pack_hrDiskStorageEntry(base, hrDeviceIndex);
    if (len < 0) {
        g_warning("illegal hrDiskStorageEntry index values");
        return;
    }

    *hrDiskStorageEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrDiskStorageEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrDiskStorageEntry = assign_hrDiskStorageEntry(out);
    }
}

void
host_resources_mib_free_hrDiskStorageEntry(host_resources_mib_hrDiskStorageEntry_t *hrDiskStorageEntry)
{
    GSList *vbl;
    char *p;

    if (hrDiskStorageEntry) {
        p = (char *) hrDiskStorageEntry + sizeof(host_resources_mib_hrDiskStorageEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrDiskStorageEntry);
    }
}

void
host_resources_mib_free_hrDiskStorageTable(host_resources_mib_hrDiskStorageEntry_t **hrDiskStorageEntry)
{
    int i;

    if (hrDiskStorageEntry) {
        for (i = 0; hrDiskStorageEntry[i]; i++) {
            host_resources_mib_free_hrDiskStorageEntry(hrDiskStorageEntry[i]);
        }
        g_free(hrDiskStorageEntry);
    }
}

host_resources_mib_hrPartitionEntry_t *
host_resources_mib_new_hrPartitionEntry()
{
    host_resources_mib_hrPartitionEntry_t *hrPartitionEntry;

    hrPartitionEntry = (host_resources_mib_hrPartitionEntry_t *) g_malloc0(sizeof(host_resources_mib_hrPartitionEntry_t) + sizeof(gpointer));
    return hrPartitionEntry;
}

static int
unpack_hrPartitionEntry(GSnmpVarBind *vb, host_resources_mib_hrPartitionEntry_t *hrPartitionEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrPartitionEntry->hrDeviceIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    hrPartitionEntry->hrPartitionIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrPartitionEntry(guint32 *base, gint32 hrDeviceIndex, gint32 hrPartitionIndex)
{
    int idx = 11;

    base[idx++] = hrDeviceIndex;
    base[idx++] = hrPartitionIndex;
    return idx;
}

static host_resources_mib_hrPartitionEntry_t *
assign_hrPartitionEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrPartitionEntry_t *hrPartitionEntry;
    guint32 idx;
    char *p;

    hrPartitionEntry = host_resources_mib_new_hrPartitionEntry();
    if (! hrPartitionEntry) {
        return NULL;
    }

    p = (char *) hrPartitionEntry + sizeof(host_resources_mib_hrPartitionEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrPartitionEntry((GSnmpVarBind *) vbl->data, hrPartitionEntry) < 0) {
        g_warning("illegal hrPartitionEntry instance identifier");
        g_free(hrPartitionEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrPartitionEntry, sizeof(oid_hrPartitionEntry)/sizeof(guint32),
                   attr_hrPartitionEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrPartitionEntry->_hrPartitionLabelLength = vb->syntax_len;
            hrPartitionEntry->hrPartitionLabel = vb->syntax.uc;
            break;
        case 3:
            hrPartitionEntry->_hrPartitionIDLength = vb->syntax_len;
            hrPartitionEntry->hrPartitionID = vb->syntax.uc;
            break;
        case 4:
            hrPartitionEntry->hrPartitionSize = &(vb->syntax.i32[0]);
            break;
        case 5:
            hrPartitionEntry->hrPartitionFSIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrPartitionEntry;
}

void
host_resources_mib_get_hrPartitionTable(GSnmpSession *s, host_resources_mib_hrPartitionEntry_t ***hrPartitionEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 0};

    *hrPartitionEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrPartitionEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrPartitionEntry = (host_resources_mib_hrPartitionEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrPartitionEntry_t *));
        if (! *hrPartitionEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrPartitionEntry)[i] = assign_hrPartitionEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrPartitionEntry(GSnmpSession *s, host_resources_mib_hrPartitionEntry_t **hrPartitionEntry, gint32 hrDeviceIndex, gint32 hrPartitionIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrPartitionEntry, sizeof(oid_hrPartitionEntry));
    len = pack_hrPartitionEntry(base, hrDeviceIndex, hrPartitionIndex);
    if (len < 0) {
        g_warning("illegal hrPartitionEntry index values");
        return;
    }

    *hrPartitionEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrPartitionEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrPartitionEntry = assign_hrPartitionEntry(out);
    }
}

void
host_resources_mib_free_hrPartitionEntry(host_resources_mib_hrPartitionEntry_t *hrPartitionEntry)
{
    GSList *vbl;
    char *p;

    if (hrPartitionEntry) {
        p = (char *) hrPartitionEntry + sizeof(host_resources_mib_hrPartitionEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrPartitionEntry);
    }
}

void
host_resources_mib_free_hrPartitionTable(host_resources_mib_hrPartitionEntry_t **hrPartitionEntry)
{
    int i;

    if (hrPartitionEntry) {
        for (i = 0; hrPartitionEntry[i]; i++) {
            host_resources_mib_free_hrPartitionEntry(hrPartitionEntry[i]);
        }
        g_free(hrPartitionEntry);
    }
}

host_resources_mib_hrFSEntry_t *
host_resources_mib_new_hrFSEntry()
{
    host_resources_mib_hrFSEntry_t *hrFSEntry;

    hrFSEntry = (host_resources_mib_hrFSEntry_t *) g_malloc0(sizeof(host_resources_mib_hrFSEntry_t) + sizeof(gpointer));
    return hrFSEntry;
}

static int
unpack_hrFSEntry(GSnmpVarBind *vb, host_resources_mib_hrFSEntry_t *hrFSEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrFSEntry->hrFSIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrFSEntry(guint32 *base, gint32 hrFSIndex)
{
    int idx = 11;

    base[idx++] = hrFSIndex;
    return idx;
}

static host_resources_mib_hrFSEntry_t *
assign_hrFSEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrFSEntry_t *hrFSEntry;
    guint32 idx;
    char *p;

    hrFSEntry = host_resources_mib_new_hrFSEntry();
    if (! hrFSEntry) {
        return NULL;
    }

    p = (char *) hrFSEntry + sizeof(host_resources_mib_hrFSEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrFSEntry((GSnmpVarBind *) vbl->data, hrFSEntry) < 0) {
        g_warning("illegal hrFSEntry instance identifier");
        g_free(hrFSEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrFSEntry, sizeof(oid_hrFSEntry)/sizeof(guint32),
                   attr_hrFSEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrFSEntry->_hrFSMountPointLength = vb->syntax_len;
            hrFSEntry->hrFSMountPoint = vb->syntax.uc;
            break;
        case 3:
            hrFSEntry->_hrFSRemoteMountPointLength = vb->syntax_len;
            hrFSEntry->hrFSRemoteMountPoint = vb->syntax.uc;
            break;
        case 4:
            hrFSEntry->_hrFSTypeLength = vb->syntax_len / sizeof(guint32);
            hrFSEntry->hrFSType = vb->syntax.ui32;
            break;
        case 5:
            hrFSEntry->hrFSAccess = &(vb->syntax.i32[0]);
            break;
        case 6:
            hrFSEntry->hrFSBootable = &(vb->syntax.i32[0]);
            break;
        case 7:
            hrFSEntry->hrFSStorageIndex = &(vb->syntax.i32[0]);
            break;
        case 8:
            hrFSEntry->_hrFSLastFullBackupDateLength = vb->syntax_len;
            hrFSEntry->hrFSLastFullBackupDate = vb->syntax.uc;
            break;
        case 9:
            hrFSEntry->_hrFSLastPartialBackupDateLength = vb->syntax_len;
            hrFSEntry->hrFSLastPartialBackupDate = vb->syntax.uc;
            break;
        };
    }

    return hrFSEntry;
}

void
host_resources_mib_get_hrFSTable(GSnmpSession *s, host_resources_mib_hrFSEntry_t ***hrFSEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 0};

    *hrFSEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrFSEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrFSEntry = (host_resources_mib_hrFSEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrFSEntry_t *));
        if (! *hrFSEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrFSEntry)[i] = assign_hrFSEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrFSEntry(GSnmpSession *s, host_resources_mib_hrFSEntry_t **hrFSEntry, gint32 hrFSIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrFSEntry, sizeof(oid_hrFSEntry));
    len = pack_hrFSEntry(base, hrFSIndex);
    if (len < 0) {
        g_warning("illegal hrFSEntry index values");
        return;
    }

    *hrFSEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrFSEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrFSEntry = assign_hrFSEntry(out);
    }
}

void
host_resources_mib_set_hrFSEntry(GSnmpSession *s, host_resources_mib_hrFSEntry_t *hrFSEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrFSEntry, sizeof(oid_hrFSEntry));
    len = pack_hrFSEntry(base, hrFSEntry->hrFSIndex);
    if (len < 0) {
        g_warning("illegal hrFSEntry index values");
        return;
    }

    if (hrFSEntry->hrFSLastFullBackupDate) {
        base[10] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       hrFSEntry->hrFSLastFullBackupDate,
                       hrFSEntry->_hrFSLastFullBackupDateLength);
    }
    if (hrFSEntry->hrFSLastPartialBackupDate) {
        base[10] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       hrFSEntry->hrFSLastPartialBackupDate,
                       hrFSEntry->_hrFSLastPartialBackupDateLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
host_resources_mib_free_hrFSEntry(host_resources_mib_hrFSEntry_t *hrFSEntry)
{
    GSList *vbl;
    char *p;

    if (hrFSEntry) {
        p = (char *) hrFSEntry + sizeof(host_resources_mib_hrFSEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrFSEntry);
    }
}

void
host_resources_mib_free_hrFSTable(host_resources_mib_hrFSEntry_t **hrFSEntry)
{
    int i;

    if (hrFSEntry) {
        for (i = 0; hrFSEntry[i]; i++) {
            host_resources_mib_free_hrFSEntry(hrFSEntry[i]);
        }
        g_free(hrFSEntry);
    }
}

host_resources_mib_hrSWRun_t *
host_resources_mib_new_hrSWRun()
{
    host_resources_mib_hrSWRun_t *hrSWRun;

    hrSWRun = (host_resources_mib_hrSWRun_t *) g_malloc0(sizeof(host_resources_mib_hrSWRun_t) + sizeof(gpointer));
    return hrSWRun;
}

static host_resources_mib_hrSWRun_t *
assign_hrSWRun(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSWRun_t *hrSWRun;
    guint32 idx;
    char *p;

    hrSWRun = host_resources_mib_new_hrSWRun();
    if (! hrSWRun) {
        return NULL;
    }

    p = (char *) hrSWRun + sizeof(host_resources_mib_hrSWRun_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSWRun, sizeof(oid_hrSWRun)/sizeof(guint32),
                   attr_hrSWRun, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrSWRun->hrSWOSIndex = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrSWRun;
}

void
host_resources_mib_get_hrSWRun(GSnmpSession *s, host_resources_mib_hrSWRun_t **hrSWRun, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 4, 0};

    *hrSWRun = NULL;

    add_attributes(s, &in, base, 9, 8, attr_hrSWRun, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSWRun = assign_hrSWRun(out);
    }
}

void
host_resources_mib_free_hrSWRun(host_resources_mib_hrSWRun_t *hrSWRun)
{
    GSList *vbl;
    char *p;

    if (hrSWRun) {
        p = (char *) hrSWRun + sizeof(host_resources_mib_hrSWRun_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSWRun);
    }
}

host_resources_mib_hrSWRunEntry_t *
host_resources_mib_new_hrSWRunEntry()
{
    host_resources_mib_hrSWRunEntry_t *hrSWRunEntry;

    hrSWRunEntry = (host_resources_mib_hrSWRunEntry_t *) g_malloc0(sizeof(host_resources_mib_hrSWRunEntry_t) + sizeof(gpointer));
    return hrSWRunEntry;
}

static int
unpack_hrSWRunEntry(GSnmpVarBind *vb, host_resources_mib_hrSWRunEntry_t *hrSWRunEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrSWRunEntry->hrSWRunIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrSWRunEntry(guint32 *base, gint32 hrSWRunIndex)
{
    int idx = 11;

    base[idx++] = hrSWRunIndex;
    return idx;
}

static host_resources_mib_hrSWRunEntry_t *
assign_hrSWRunEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSWRunEntry_t *hrSWRunEntry;
    guint32 idx;
    char *p;

    hrSWRunEntry = host_resources_mib_new_hrSWRunEntry();
    if (! hrSWRunEntry) {
        return NULL;
    }

    p = (char *) hrSWRunEntry + sizeof(host_resources_mib_hrSWRunEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrSWRunEntry((GSnmpVarBind *) vbl->data, hrSWRunEntry) < 0) {
        g_warning("illegal hrSWRunEntry instance identifier");
        g_free(hrSWRunEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSWRunEntry, sizeof(oid_hrSWRunEntry)/sizeof(guint32),
                   attr_hrSWRunEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrSWRunEntry->_hrSWRunNameLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunName = vb->syntax.uc;
            break;
        case 3:
            hrSWRunEntry->_hrSWRunIDLength = vb->syntax_len / sizeof(guint32);
            hrSWRunEntry->hrSWRunID = vb->syntax.ui32;
            break;
        case 4:
            hrSWRunEntry->_hrSWRunPathLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunPath = vb->syntax.uc;
            break;
        case 5:
            hrSWRunEntry->_hrSWRunParametersLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunParameters = vb->syntax.uc;
            break;
        case 6:
            hrSWRunEntry->hrSWRunType = &(vb->syntax.i32[0]);
            break;
        case 7:
            hrSWRunEntry->hrSWRunStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrSWRunEntry;
}

void
host_resources_mib_get_hrSWRunTable(GSnmpSession *s, host_resources_mib_hrSWRunEntry_t ***hrSWRunEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 0};

    *hrSWRunEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrSWRunEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrSWRunEntry = (host_resources_mib_hrSWRunEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrSWRunEntry_t *));
        if (! *hrSWRunEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrSWRunEntry)[i] = assign_hrSWRunEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrSWRunEntry(GSnmpSession *s, host_resources_mib_hrSWRunEntry_t **hrSWRunEntry, gint32 hrSWRunIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrSWRunEntry, sizeof(oid_hrSWRunEntry));
    len = pack_hrSWRunEntry(base, hrSWRunIndex);
    if (len < 0) {
        g_warning("illegal hrSWRunEntry index values");
        return;
    }

    *hrSWRunEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrSWRunEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSWRunEntry = assign_hrSWRunEntry(out);
    }
}

void
host_resources_mib_set_hrSWRunEntry(GSnmpSession *s, host_resources_mib_hrSWRunEntry_t *hrSWRunEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrSWRunEntry, sizeof(oid_hrSWRunEntry));
    len = pack_hrSWRunEntry(base, hrSWRunEntry->hrSWRunIndex);
    if (len < 0) {
        g_warning("illegal hrSWRunEntry index values");
        return;
    }

    if (hrSWRunEntry->hrSWRunStatus) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       hrSWRunEntry->hrSWRunStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
host_resources_mib_free_hrSWRunEntry(host_resources_mib_hrSWRunEntry_t *hrSWRunEntry)
{
    GSList *vbl;
    char *p;

    if (hrSWRunEntry) {
        p = (char *) hrSWRunEntry + sizeof(host_resources_mib_hrSWRunEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSWRunEntry);
    }
}

void
host_resources_mib_free_hrSWRunTable(host_resources_mib_hrSWRunEntry_t **hrSWRunEntry)
{
    int i;

    if (hrSWRunEntry) {
        for (i = 0; hrSWRunEntry[i]; i++) {
            host_resources_mib_free_hrSWRunEntry(hrSWRunEntry[i]);
        }
        g_free(hrSWRunEntry);
    }
}

host_resources_mib_hrSWRunPerfEntry_t *
host_resources_mib_new_hrSWRunPerfEntry()
{
    host_resources_mib_hrSWRunPerfEntry_t *hrSWRunPerfEntry;

    hrSWRunPerfEntry = (host_resources_mib_hrSWRunPerfEntry_t *) g_malloc0(sizeof(host_resources_mib_hrSWRunPerfEntry_t) + sizeof(gpointer));
    return hrSWRunPerfEntry;
}

static int
unpack_hrSWRunPerfEntry(GSnmpVarBind *vb, host_resources_mib_hrSWRunPerfEntry_t *hrSWRunPerfEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrSWRunPerfEntry->hrSWRunIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrSWRunPerfEntry(guint32 *base, gint32 hrSWRunIndex)
{
    int idx = 11;

    base[idx++] = hrSWRunIndex;
    return idx;
}

static host_resources_mib_hrSWRunPerfEntry_t *
assign_hrSWRunPerfEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSWRunPerfEntry_t *hrSWRunPerfEntry;
    guint32 idx;
    char *p;

    hrSWRunPerfEntry = host_resources_mib_new_hrSWRunPerfEntry();
    if (! hrSWRunPerfEntry) {
        return NULL;
    }

    p = (char *) hrSWRunPerfEntry + sizeof(host_resources_mib_hrSWRunPerfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrSWRunPerfEntry((GSnmpVarBind *) vbl->data, hrSWRunPerfEntry) < 0) {
        g_warning("illegal hrSWRunPerfEntry instance identifier");
        g_free(hrSWRunPerfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSWRunPerfEntry, sizeof(oid_hrSWRunPerfEntry)/sizeof(guint32),
                   attr_hrSWRunPerfEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrSWRunPerfEntry->hrSWRunPerfCPU = &(vb->syntax.i32[0]);
            break;
        case 2:
            hrSWRunPerfEntry->hrSWRunPerfMem = &(vb->syntax.i32[0]);
            break;
        };
    }

    return hrSWRunPerfEntry;
}

void
host_resources_mib_get_hrSWRunPerfTable(GSnmpSession *s, host_resources_mib_hrSWRunPerfEntry_t ***hrSWRunPerfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 5, 1, 1, 0};

    *hrSWRunPerfEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrSWRunPerfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrSWRunPerfEntry = (host_resources_mib_hrSWRunPerfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrSWRunPerfEntry_t *));
        if (! *hrSWRunPerfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrSWRunPerfEntry)[i] = assign_hrSWRunPerfEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrSWRunPerfEntry(GSnmpSession *s, host_resources_mib_hrSWRunPerfEntry_t **hrSWRunPerfEntry, gint32 hrSWRunIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrSWRunPerfEntry, sizeof(oid_hrSWRunPerfEntry));
    len = pack_hrSWRunPerfEntry(base, hrSWRunIndex);
    if (len < 0) {
        g_warning("illegal hrSWRunPerfEntry index values");
        return;
    }

    *hrSWRunPerfEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrSWRunPerfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSWRunPerfEntry = assign_hrSWRunPerfEntry(out);
    }
}

void
host_resources_mib_free_hrSWRunPerfEntry(host_resources_mib_hrSWRunPerfEntry_t *hrSWRunPerfEntry)
{
    GSList *vbl;
    char *p;

    if (hrSWRunPerfEntry) {
        p = (char *) hrSWRunPerfEntry + sizeof(host_resources_mib_hrSWRunPerfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSWRunPerfEntry);
    }
}

void
host_resources_mib_free_hrSWRunPerfTable(host_resources_mib_hrSWRunPerfEntry_t **hrSWRunPerfEntry)
{
    int i;

    if (hrSWRunPerfEntry) {
        for (i = 0; hrSWRunPerfEntry[i]; i++) {
            host_resources_mib_free_hrSWRunPerfEntry(hrSWRunPerfEntry[i]);
        }
        g_free(hrSWRunPerfEntry);
    }
}

host_resources_mib_hrSWInstalled_t *
host_resources_mib_new_hrSWInstalled()
{
    host_resources_mib_hrSWInstalled_t *hrSWInstalled;

    hrSWInstalled = (host_resources_mib_hrSWInstalled_t *) g_malloc0(sizeof(host_resources_mib_hrSWInstalled_t) + sizeof(gpointer));
    return hrSWInstalled;
}

static host_resources_mib_hrSWInstalled_t *
assign_hrSWInstalled(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSWInstalled_t *hrSWInstalled;
    guint32 idx;
    char *p;

    hrSWInstalled = host_resources_mib_new_hrSWInstalled();
    if (! hrSWInstalled) {
        return NULL;
    }

    p = (char *) hrSWInstalled + sizeof(host_resources_mib_hrSWInstalled_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSWInstalled, sizeof(oid_hrSWInstalled)/sizeof(guint32),
                   attr_hrSWInstalled, &idx) < 0) continue;

        switch (idx) {
        case 1:
            hrSWInstalled->hrSWInstalledLastChange = &(vb->syntax.ui32[0]);
            break;
        case 2:
            hrSWInstalled->hrSWInstalledLastUpdateTime = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return hrSWInstalled;
}

void
host_resources_mib_get_hrSWInstalled(GSnmpSession *s, host_resources_mib_hrSWInstalled_t **hrSWInstalled, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 6, 0};

    *hrSWInstalled = NULL;

    add_attributes(s, &in, base, 9, 8, attr_hrSWInstalled, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSWInstalled = assign_hrSWInstalled(out);
    }
}

void
host_resources_mib_free_hrSWInstalled(host_resources_mib_hrSWInstalled_t *hrSWInstalled)
{
    GSList *vbl;
    char *p;

    if (hrSWInstalled) {
        p = (char *) hrSWInstalled + sizeof(host_resources_mib_hrSWInstalled_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSWInstalled);
    }
}

host_resources_mib_hrSWInstalledEntry_t *
host_resources_mib_new_hrSWInstalledEntry()
{
    host_resources_mib_hrSWInstalledEntry_t *hrSWInstalledEntry;

    hrSWInstalledEntry = (host_resources_mib_hrSWInstalledEntry_t *) g_malloc0(sizeof(host_resources_mib_hrSWInstalledEntry_t) + sizeof(gpointer));
    return hrSWInstalledEntry;
}

static int
unpack_hrSWInstalledEntry(GSnmpVarBind *vb, host_resources_mib_hrSWInstalledEntry_t *hrSWInstalledEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    hrSWInstalledEntry->hrSWInstalledIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_hrSWInstalledEntry(guint32 *base, gint32 hrSWInstalledIndex)
{
    int idx = 11;

    base[idx++] = hrSWInstalledIndex;
    return idx;
}

static host_resources_mib_hrSWInstalledEntry_t *
assign_hrSWInstalledEntry(GSList *vbl)
{
    GSList *elem;
    host_resources_mib_hrSWInstalledEntry_t *hrSWInstalledEntry;
    guint32 idx;
    char *p;

    hrSWInstalledEntry = host_resources_mib_new_hrSWInstalledEntry();
    if (! hrSWInstalledEntry) {
        return NULL;
    }

    p = (char *) hrSWInstalledEntry + sizeof(host_resources_mib_hrSWInstalledEntry_t);
    * (GSList **) p = vbl;

    if (unpack_hrSWInstalledEntry((GSnmpVarBind *) vbl->data, hrSWInstalledEntry) < 0) {
        g_warning("illegal hrSWInstalledEntry instance identifier");
        g_free(hrSWInstalledEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_hrSWInstalledEntry, sizeof(oid_hrSWInstalledEntry)/sizeof(guint32),
                   attr_hrSWInstalledEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            hrSWInstalledEntry->_hrSWInstalledNameLength = vb->syntax_len;
            hrSWInstalledEntry->hrSWInstalledName = vb->syntax.uc;
            break;
        case 3:
            hrSWInstalledEntry->_hrSWInstalledIDLength = vb->syntax_len / sizeof(guint32);
            hrSWInstalledEntry->hrSWInstalledID = vb->syntax.ui32;
            break;
        case 4:
            hrSWInstalledEntry->hrSWInstalledType = &(vb->syntax.i32[0]);
            break;
        case 5:
            hrSWInstalledEntry->_hrSWInstalledDateLength = vb->syntax_len;
            hrSWInstalledEntry->hrSWInstalledDate = vb->syntax.uc;
            break;
        };
    }

    return hrSWInstalledEntry;
}

void
host_resources_mib_get_hrSWInstalledTable(GSnmpSession *s, host_resources_mib_hrSWInstalledEntry_t ***hrSWInstalledEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 0};

    *hrSWInstalledEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_hrSWInstalledEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *hrSWInstalledEntry = (host_resources_mib_hrSWInstalledEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(host_resources_mib_hrSWInstalledEntry_t *));
        if (! *hrSWInstalledEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*hrSWInstalledEntry)[i] = assign_hrSWInstalledEntry(row->data);
        }
    }
}

void
host_resources_mib_get_hrSWInstalledEntry(GSnmpSession *s, host_resources_mib_hrSWInstalledEntry_t **hrSWInstalledEntry, gint32 hrSWInstalledIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_hrSWInstalledEntry, sizeof(oid_hrSWInstalledEntry));
    len = pack_hrSWInstalledEntry(base, hrSWInstalledIndex);
    if (len < 0) {
        g_warning("illegal hrSWInstalledEntry index values");
        return;
    }

    *hrSWInstalledEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_hrSWInstalledEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *hrSWInstalledEntry = assign_hrSWInstalledEntry(out);
    }
}

void
host_resources_mib_free_hrSWInstalledEntry(host_resources_mib_hrSWInstalledEntry_t *hrSWInstalledEntry)
{
    GSList *vbl;
    char *p;

    if (hrSWInstalledEntry) {
        p = (char *) hrSWInstalledEntry + sizeof(host_resources_mib_hrSWInstalledEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(hrSWInstalledEntry);
    }
}

void
host_resources_mib_free_hrSWInstalledTable(host_resources_mib_hrSWInstalledEntry_t **hrSWInstalledEntry)
{
    int i;

    if (hrSWInstalledEntry) {
        for (i = 0; hrSWInstalledEntry[i]; i++) {
            host_resources_mib_free_hrSWInstalledEntry(hrSWInstalledEntry[i]);
        }
        g_free(hrSWInstalledEntry);
    }
}


