/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from HOST-RESOURCES-MIB revision 2000-03-06 00:00.
 *
 * $Id$
 */

#include "host-resources-mib.h"

static guint32 const hrSystemUptime[] = {1, 3, 6, 1, 2, 1, 25, 1, 1};
static guint32 const hrSystemDate[] = {1, 3, 6, 1, 2, 1, 25, 1, 2};
static guint32 const hrSystemInitialLoadDevice[] = {1, 3, 6, 1, 2, 1, 25, 1, 3};
static guint32 const hrSystemInitialLoadParameters[] = {1, 3, 6, 1, 2, 1, 25, 1, 4};
static guint32 const hrSystemNumUsers[] = {1, 3, 6, 1, 2, 1, 25, 1, 5};
static guint32 const hrSystemProcesses[] = {1, 3, 6, 1, 2, 1, 25, 1, 6};
static guint32 const hrSystemMaxProcesses[] = {1, 3, 6, 1, 2, 1, 25, 1, 7};
static guint32 const hrMemorySize[] = {1, 3, 6, 1, 2, 1, 25, 2, 2};
static guint32 const hrStorageIndex[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 1};
static guint32 const hrStorageType[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 2};
static guint32 const hrStorageDescr[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 3};
static guint32 const hrStorageAllocationUnits[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 4};
static guint32 const hrStorageSize[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 5};
static guint32 const hrStorageUsed[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 6};
static guint32 const hrStorageAllocationFailures[] = {1, 3, 6, 1, 2, 1, 25, 2, 3, 1, 7};
static guint32 const hrDeviceIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 1};
static guint32 const hrDeviceType[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 2};
static guint32 const hrDeviceDescr[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 3};
static guint32 const hrDeviceID[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 4};
static guint32 const hrDeviceStatus[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 5};
static guint32 const hrDeviceErrors[] = {1, 3, 6, 1, 2, 1, 25, 3, 2, 1, 6};
static guint32 const hrProcessorFrwID[] = {1, 3, 6, 1, 2, 1, 25, 3, 3, 1, 1};
static guint32 const hrProcessorLoad[] = {1, 3, 6, 1, 2, 1, 25, 3, 3, 1, 2};
static guint32 const hrNetworkIfIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 4, 1, 1};
static guint32 const hrPrinterStatus[] = {1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 1};
static guint32 const hrPrinterDetectedErrorState[] = {1, 3, 6, 1, 2, 1, 25, 3, 5, 1, 2};
static guint32 const hrDiskStorageAccess[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 1};
static guint32 const hrDiskStorageMedia[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 2};
static guint32 const hrDiskStorageRemoveble[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 3};
static guint32 const hrDiskStorageCapacity[] = {1, 3, 6, 1, 2, 1, 25, 3, 6, 1, 4};
static guint32 const hrPartitionIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 1};
static guint32 const hrPartitionLabel[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 2};
static guint32 const hrPartitionID[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 3};
static guint32 const hrPartitionSize[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 4};
static guint32 const hrPartitionFSIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 7, 1, 5};
static guint32 const hrFSIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 1};
static guint32 const hrFSMountPoint[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 2};
static guint32 const hrFSRemoteMountPoint[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 3};
static guint32 const hrFSType[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 4};
static guint32 const hrFSAccess[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 5};
static guint32 const hrFSBootable[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 6};
static guint32 const hrFSStorageIndex[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 7};
static guint32 const hrFSLastFullBackupDate[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 8};
static guint32 const hrFSLastPartialBackupDate[] = {1, 3, 6, 1, 2, 1, 25, 3, 8, 1, 9};
static guint32 const hrSWOSIndex[] = {1, 3, 6, 1, 2, 1, 25, 4, 1};
static guint32 const hrSWRunIndex[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 1};
static guint32 const hrSWRunName[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 2};
static guint32 const hrSWRunID[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 3};
static guint32 const hrSWRunPath[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 4};
static guint32 const hrSWRunParameters[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 5};
static guint32 const hrSWRunType[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 6};
static guint32 const hrSWRunStatus[] = {1, 3, 6, 1, 2, 1, 25, 4, 2, 1, 7};
static guint32 const hrSWRunPerfCPU[] = {1, 3, 6, 1, 2, 1, 25, 5, 1, 1, 1};
static guint32 const hrSWRunPerfMem[] = {1, 3, 6, 1, 2, 1, 25, 5, 1, 1, 2};
static guint32 const hrSWInstalledLastChange[] = {1, 3, 6, 1, 2, 1, 25, 6, 1};
static guint32 const hrSWInstalledLastUpdateTime[] = {1, 3, 6, 1, 2, 1, 25, 6, 2};
static guint32 const hrSWInstalledIndex[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 1};
static guint32 const hrSWInstalledName[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 2};
static guint32 const hrSWInstalledID[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 3};
static guint32 const hrSWInstalledType[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 4};
static guint32 const hrSWInstalledDate[] = {1, 3, 6, 1, 2, 1, 25, 6, 3, 1, 5};

static gsize const _hrSystemUptimeLength = sizeof(hrSystemUptime)/sizeof(guint32);
static gsize const _hrSystemDateLength = sizeof(hrSystemDate)/sizeof(guint32);
static gsize const _hrSystemInitialLoadDeviceLength = sizeof(hrSystemInitialLoadDevice)/sizeof(guint32);
static gsize const _hrSystemInitialLoadParametersLength = sizeof(hrSystemInitialLoadParameters)/sizeof(guint32);
static gsize const _hrSystemNumUsersLength = sizeof(hrSystemNumUsers)/sizeof(guint32);
static gsize const _hrSystemProcessesLength = sizeof(hrSystemProcesses)/sizeof(guint32);
static gsize const _hrSystemMaxProcessesLength = sizeof(hrSystemMaxProcesses)/sizeof(guint32);
static gsize const _hrMemorySizeLength = sizeof(hrMemorySize)/sizeof(guint32);
static gsize const _hrStorageIndexLength = sizeof(hrStorageIndex)/sizeof(guint32);
static gsize const _hrStorageTypeLength = sizeof(hrStorageType)/sizeof(guint32);
static gsize const _hrStorageDescrLength = sizeof(hrStorageDescr)/sizeof(guint32);
static gsize const _hrStorageAllocationUnitsLength = sizeof(hrStorageAllocationUnits)/sizeof(guint32);
static gsize const _hrStorageSizeLength = sizeof(hrStorageSize)/sizeof(guint32);
static gsize const _hrStorageUsedLength = sizeof(hrStorageUsed)/sizeof(guint32);
static gsize const _hrStorageAllocationFailuresLength = sizeof(hrStorageAllocationFailures)/sizeof(guint32);
static gsize const _hrDeviceIndexLength = sizeof(hrDeviceIndex)/sizeof(guint32);
static gsize const _hrDeviceTypeLength = sizeof(hrDeviceType)/sizeof(guint32);
static gsize const _hrDeviceDescrLength = sizeof(hrDeviceDescr)/sizeof(guint32);
static gsize const _hrDeviceIDLength = sizeof(hrDeviceID)/sizeof(guint32);
static gsize const _hrDeviceStatusLength = sizeof(hrDeviceStatus)/sizeof(guint32);
static gsize const _hrDeviceErrorsLength = sizeof(hrDeviceErrors)/sizeof(guint32);
static gsize const _hrProcessorFrwIDLength = sizeof(hrProcessorFrwID)/sizeof(guint32);
static gsize const _hrProcessorLoadLength = sizeof(hrProcessorLoad)/sizeof(guint32);
static gsize const _hrNetworkIfIndexLength = sizeof(hrNetworkIfIndex)/sizeof(guint32);
static gsize const _hrPrinterStatusLength = sizeof(hrPrinterStatus)/sizeof(guint32);
static gsize const _hrPrinterDetectedErrorStateLength = sizeof(hrPrinterDetectedErrorState)/sizeof(guint32);
static gsize const _hrDiskStorageAccessLength = sizeof(hrDiskStorageAccess)/sizeof(guint32);
static gsize const _hrDiskStorageMediaLength = sizeof(hrDiskStorageMedia)/sizeof(guint32);
static gsize const _hrDiskStorageRemovebleLength = sizeof(hrDiskStorageRemoveble)/sizeof(guint32);
static gsize const _hrDiskStorageCapacityLength = sizeof(hrDiskStorageCapacity)/sizeof(guint32);
static gsize const _hrPartitionIndexLength = sizeof(hrPartitionIndex)/sizeof(guint32);
static gsize const _hrPartitionLabelLength = sizeof(hrPartitionLabel)/sizeof(guint32);
static gsize const _hrPartitionIDLength = sizeof(hrPartitionID)/sizeof(guint32);
static gsize const _hrPartitionSizeLength = sizeof(hrPartitionSize)/sizeof(guint32);
static gsize const _hrPartitionFSIndexLength = sizeof(hrPartitionFSIndex)/sizeof(guint32);
static gsize const _hrFSIndexLength = sizeof(hrFSIndex)/sizeof(guint32);
static gsize const _hrFSMountPointLength = sizeof(hrFSMountPoint)/sizeof(guint32);
static gsize const _hrFSRemoteMountPointLength = sizeof(hrFSRemoteMountPoint)/sizeof(guint32);
static gsize const _hrFSTypeLength = sizeof(hrFSType)/sizeof(guint32);
static gsize const _hrFSAccessLength = sizeof(hrFSAccess)/sizeof(guint32);
static gsize const _hrFSBootableLength = sizeof(hrFSBootable)/sizeof(guint32);
static gsize const _hrFSStorageIndexLength = sizeof(hrFSStorageIndex)/sizeof(guint32);
static gsize const _hrFSLastFullBackupDateLength = sizeof(hrFSLastFullBackupDate)/sizeof(guint32);
static gsize const _hrFSLastPartialBackupDateLength = sizeof(hrFSLastPartialBackupDate)/sizeof(guint32);
static gsize const _hrSWOSIndexLength = sizeof(hrSWOSIndex)/sizeof(guint32);
static gsize const _hrSWRunIndexLength = sizeof(hrSWRunIndex)/sizeof(guint32);
static gsize const _hrSWRunNameLength = sizeof(hrSWRunName)/sizeof(guint32);
static gsize const _hrSWRunIDLength = sizeof(hrSWRunID)/sizeof(guint32);
static gsize const _hrSWRunPathLength = sizeof(hrSWRunPath)/sizeof(guint32);
static gsize const _hrSWRunParametersLength = sizeof(hrSWRunParameters)/sizeof(guint32);
static gsize const _hrSWRunTypeLength = sizeof(hrSWRunType)/sizeof(guint32);
static gsize const _hrSWRunStatusLength = sizeof(hrSWRunStatus)/sizeof(guint32);
static gsize const _hrSWRunPerfCPULength = sizeof(hrSWRunPerfCPU)/sizeof(guint32);
static gsize const _hrSWRunPerfMemLength = sizeof(hrSWRunPerfMem)/sizeof(guint32);
static gsize const _hrSWInstalledLastChangeLength = sizeof(hrSWInstalledLastChange)/sizeof(guint32);
static gsize const _hrSWInstalledLastUpdateTimeLength = sizeof(hrSWInstalledLastUpdateTime)/sizeof(guint32);
static gsize const _hrSWInstalledIndexLength = sizeof(hrSWInstalledIndex)/sizeof(guint32);
static gsize const _hrSWInstalledNameLength = sizeof(hrSWInstalledName)/sizeof(guint32);
static gsize const _hrSWInstalledIDLength = sizeof(hrSWInstalledID)/sizeof(guint32);
static gsize const _hrSWInstalledTypeLength = sizeof(hrSWInstalledType)/sizeof(guint32);
static gsize const _hrSWInstalledDateLength = sizeof(hrSWInstalledDate)/sizeof(guint32);

stls_table_t host_resources_mib_enums_hrDeviceStatus[] = {
    { 1, "unknown" },
    { 2, "running" },
    { 3, "warning" },
    { 4, "testing" },
    { 5, "down" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrPrinterStatus[] = {
    { 1, "other" },
    { 2, "unknown" },
    { 3, "idle" },
    { 4, "printing" },
    { 5, "warmup" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrDiskStorageAccess[] = {
    { 1, "readWrite" },
    { 2, "readOnly" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrDiskStorageMedia[] = {
    { 1, "other" },
    { 2, "unknown" },
    { 3, "hardDisk" },
    { 4, "floppyDisk" },
    { 5, "opticalDiskROM" },
    { 6, "opticalDiskWORM" },
    { 7, "opticalDiskRW" },
    { 8, "ramDisk" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrDiskStorageRemoveble[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrFSAccess[] = {
    { 1, "readWrite" },
    { 2, "readOnly" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrFSBootable[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrSWRunType[] = {
    { 1, "unknown" },
    { 2, "operatingSystem" },
    { 3, "deviceDriver" },
    { 4, "application" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrSWRunStatus[] = {
    { 1, "running" },
    { 2, "runnable" },
    { 3, "notRunnable" },
    { 4, "invalid" },
    { 0, NULL }
};

stls_table_t host_resources_mib_enums_hrSWInstalledType[] = {
    { 1, "unknown" },
    { 2, "operatingSystem" },
    { 3, "deviceDriver" },
    { 4, "application" },
    { 0, NULL }
};


static hrSystem_t *
assign_hrSystem(GSList *vbl)
{
    GSList *elem;
    hrSystem_t *hrSystem;
    char *p;

    hrSystem = (hrSystem_t *) g_malloc0(sizeof(hrSystem_t) + sizeof(GSList *));
    if (! hrSystem) {
        return NULL;
    }

    p = (char *) hrSystem + sizeof(hrSystem_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSystemUptimeLength
            && memcmp(vb->id, hrSystemUptime, sizeof(hrSystemUptime)) == 0) {
            hrSystem->hrSystemUptime = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _hrSystemDateLength
            && memcmp(vb->id, hrSystemDate, sizeof(hrSystemDate)) == 0) {
            hrSystem->_hrSystemDateLength = vb->syntax_len;
            hrSystem->hrSystemDate = vb->syntax.uc;
        }
        if (vb->id_len > _hrSystemInitialLoadDeviceLength
            && memcmp(vb->id, hrSystemInitialLoadDevice, sizeof(hrSystemInitialLoadDevice)) == 0) {
            hrSystem->hrSystemInitialLoadDevice = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSystemInitialLoadParametersLength
            && memcmp(vb->id, hrSystemInitialLoadParameters, sizeof(hrSystemInitialLoadParameters)) == 0) {
            hrSystem->_hrSystemInitialLoadParametersLength = vb->syntax_len;
            hrSystem->hrSystemInitialLoadParameters = vb->syntax.uc;
        }
        if (vb->id_len > _hrSystemNumUsersLength
            && memcmp(vb->id, hrSystemNumUsers, sizeof(hrSystemNumUsers)) == 0) {
            hrSystem->hrSystemNumUsers = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _hrSystemProcessesLength
            && memcmp(vb->id, hrSystemProcesses, sizeof(hrSystemProcesses)) == 0) {
            hrSystem->hrSystemProcesses = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _hrSystemMaxProcessesLength
            && memcmp(vb->id, hrSystemMaxProcesses, sizeof(hrSystemMaxProcesses)) == 0) {
            hrSystem->hrSystemMaxProcesses = &(vb->syntax.i32[0]);
        }
    }

    return hrSystem;
}

int
host_resources_mib_get_hrSystem(host_snmp *s, hrSystem_t **hrSystem)
{
    GSList *in = NULL, *out = NULL;

    *hrSystem = NULL;

    stls_vbl_add_null(&in, hrSystemUptime, _hrSystemUptimeLength);
    stls_vbl_add_null(&in, hrSystemDate, _hrSystemDateLength);
    stls_vbl_add_null(&in, hrSystemInitialLoadDevice, _hrSystemInitialLoadDeviceLength);
    stls_vbl_add_null(&in, hrSystemInitialLoadParameters, _hrSystemInitialLoadParametersLength);
    stls_vbl_add_null(&in, hrSystemNumUsers, _hrSystemNumUsersLength);
    stls_vbl_add_null(&in, hrSystemProcesses, _hrSystemProcessesLength);
    stls_vbl_add_null(&in, hrSystemMaxProcesses, _hrSystemMaxProcessesLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *hrSystem = assign_hrSystem(out);

    return 0;
}

void
host_resources_mib_free_hrSystem(hrSystem_t *hrSystem)
{
    GSList *vbl;
    char *p;

    if (hrSystem) {
        p = (char *) hrSystem + sizeof(hrSystem_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(hrSystem);
    }
}

static hrStorage_t *
assign_hrStorage(GSList *vbl)
{
    GSList *elem;
    hrStorage_t *hrStorage;
    char *p;

    hrStorage = (hrStorage_t *) g_malloc0(sizeof(hrStorage_t) + sizeof(GSList *));
    if (! hrStorage) {
        return NULL;
    }

    p = (char *) hrStorage + sizeof(hrStorage_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrMemorySizeLength
            && memcmp(vb->id, hrMemorySize, sizeof(hrMemorySize)) == 0) {
            hrStorage->hrMemorySize = &(vb->syntax.i32[0]);
        }
    }

    return hrStorage;
}

int
host_resources_mib_get_hrStorage(host_snmp *s, hrStorage_t **hrStorage)
{
    GSList *in = NULL, *out = NULL;

    *hrStorage = NULL;

    stls_vbl_add_null(&in, hrMemorySize, _hrMemorySizeLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *hrStorage = assign_hrStorage(out);

    return 0;
}

void
host_resources_mib_free_hrStorage(hrStorage_t *hrStorage)
{
    GSList *vbl;
    char *p;

    if (hrStorage) {
        p = (char *) hrStorage + sizeof(hrStorage_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(hrStorage);
    }
}

static hrStorageEntry_t *
assign_hrStorageEntry(GSList *vbl)
{
    GSList *elem;
    hrStorageEntry_t *hrStorageEntry;
    char *p;

    hrStorageEntry = (hrStorageEntry_t *) g_malloc0(sizeof(hrStorageEntry_t) + sizeof(GSList *));
    if (! hrStorageEntry) {
        return NULL;
    }

    p = (char *) hrStorageEntry + sizeof(hrStorageEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrStorageIndexLength
            && memcmp(vb->id, hrStorageIndex, sizeof(hrStorageIndex)) == 0) {
            hrStorageEntry->hrStorageIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrStorageTypeLength
            && memcmp(vb->id, hrStorageType, sizeof(hrStorageType)) == 0) {
            hrStorageEntry->_hrStorageTypeLength = vb->syntax_len / sizeof(guint32);
            hrStorageEntry->hrStorageType = vb->syntax.ui32;
        }
        if (vb->id_len > _hrStorageDescrLength
            && memcmp(vb->id, hrStorageDescr, sizeof(hrStorageDescr)) == 0) {
            hrStorageEntry->_hrStorageDescrLength = vb->syntax_len;
            hrStorageEntry->hrStorageDescr = vb->syntax.uc;
        }
        if (vb->id_len > _hrStorageAllocationUnitsLength
            && memcmp(vb->id, hrStorageAllocationUnits, sizeof(hrStorageAllocationUnits)) == 0) {
            hrStorageEntry->hrStorageAllocationUnits = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrStorageSizeLength
            && memcmp(vb->id, hrStorageSize, sizeof(hrStorageSize)) == 0) {
            hrStorageEntry->hrStorageSize = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrStorageUsedLength
            && memcmp(vb->id, hrStorageUsed, sizeof(hrStorageUsed)) == 0) {
            hrStorageEntry->hrStorageUsed = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrStorageAllocationFailuresLength
            && memcmp(vb->id, hrStorageAllocationFailures, sizeof(hrStorageAllocationFailures)) == 0) {
            hrStorageEntry->hrStorageAllocationFailures = &(vb->syntax.ui32[0]);
        }
    }

    return hrStorageEntry;
}

int
host_resources_mib_get_hrStorageEntry(host_snmp *s, hrStorageEntry_t ***hrStorageEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrStorageEntry = NULL;

    stls_vbl_add_null(&in, hrStorageType, _hrStorageTypeLength);
    stls_vbl_add_null(&in, hrStorageDescr, _hrStorageDescrLength);
    stls_vbl_add_null(&in, hrStorageAllocationUnits, _hrStorageAllocationUnitsLength);
    stls_vbl_add_null(&in, hrStorageSize, _hrStorageSizeLength);
    stls_vbl_add_null(&in, hrStorageUsed, _hrStorageUsedLength);
    stls_vbl_add_null(&in, hrStorageAllocationFailures, _hrStorageAllocationFailuresLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrStorageEntry = (hrStorageEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrStorageEntry_t *));
    if (! *hrStorageEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrStorageEntry)[i] = assign_hrStorageEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrStorageEntry(hrStorageEntry_t **hrStorageEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrStorageEntry) {
        for (i = 0; hrStorageEntry[i]; i++) {
            p = (char *) hrStorageEntry[i] + sizeof(hrStorageEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrStorageEntry[i]);
        }
        g_free(hrStorageEntry);
    }
}

static hrDeviceEntry_t *
assign_hrDeviceEntry(GSList *vbl)
{
    GSList *elem;
    hrDeviceEntry_t *hrDeviceEntry;
    char *p;

    hrDeviceEntry = (hrDeviceEntry_t *) g_malloc0(sizeof(hrDeviceEntry_t) + sizeof(GSList *));
    if (! hrDeviceEntry) {
        return NULL;
    }

    p = (char *) hrDeviceEntry + sizeof(hrDeviceEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrDeviceIndexLength
            && memcmp(vb->id, hrDeviceIndex, sizeof(hrDeviceIndex)) == 0) {
            hrDeviceEntry->hrDeviceIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrDeviceTypeLength
            && memcmp(vb->id, hrDeviceType, sizeof(hrDeviceType)) == 0) {
            hrDeviceEntry->_hrDeviceTypeLength = vb->syntax_len / sizeof(guint32);
            hrDeviceEntry->hrDeviceType = vb->syntax.ui32;
        }
        if (vb->id_len > _hrDeviceDescrLength
            && memcmp(vb->id, hrDeviceDescr, sizeof(hrDeviceDescr)) == 0) {
            hrDeviceEntry->_hrDeviceDescrLength = vb->syntax_len;
            hrDeviceEntry->hrDeviceDescr = vb->syntax.uc;
        }
        if (vb->id_len > _hrDeviceIDLength
            && memcmp(vb->id, hrDeviceID, sizeof(hrDeviceID)) == 0) {
            hrDeviceEntry->_hrDeviceIDLength = vb->syntax_len / sizeof(guint32);
            hrDeviceEntry->hrDeviceID = vb->syntax.ui32;
        }
        if (vb->id_len > _hrDeviceStatusLength
            && memcmp(vb->id, hrDeviceStatus, sizeof(hrDeviceStatus)) == 0) {
            hrDeviceEntry->hrDeviceStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrDeviceErrorsLength
            && memcmp(vb->id, hrDeviceErrors, sizeof(hrDeviceErrors)) == 0) {
            hrDeviceEntry->hrDeviceErrors = &(vb->syntax.ui32[0]);
        }
    }

    return hrDeviceEntry;
}

int
host_resources_mib_get_hrDeviceEntry(host_snmp *s, hrDeviceEntry_t ***hrDeviceEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrDeviceEntry = NULL;

    stls_vbl_add_null(&in, hrDeviceType, _hrDeviceTypeLength);
    stls_vbl_add_null(&in, hrDeviceDescr, _hrDeviceDescrLength);
    stls_vbl_add_null(&in, hrDeviceID, _hrDeviceIDLength);
    stls_vbl_add_null(&in, hrDeviceStatus, _hrDeviceStatusLength);
    stls_vbl_add_null(&in, hrDeviceErrors, _hrDeviceErrorsLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrDeviceEntry = (hrDeviceEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrDeviceEntry_t *));
    if (! *hrDeviceEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrDeviceEntry)[i] = assign_hrDeviceEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrDeviceEntry(hrDeviceEntry_t **hrDeviceEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrDeviceEntry) {
        for (i = 0; hrDeviceEntry[i]; i++) {
            p = (char *) hrDeviceEntry[i] + sizeof(hrDeviceEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrDeviceEntry[i]);
        }
        g_free(hrDeviceEntry);
    }
}

static hrProcessorEntry_t *
assign_hrProcessorEntry(GSList *vbl)
{
    GSList *elem;
    hrProcessorEntry_t *hrProcessorEntry;
    char *p;

    hrProcessorEntry = (hrProcessorEntry_t *) g_malloc0(sizeof(hrProcessorEntry_t) + sizeof(GSList *));
    if (! hrProcessorEntry) {
        return NULL;
    }

    p = (char *) hrProcessorEntry + sizeof(hrProcessorEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrProcessorFrwIDLength
            && memcmp(vb->id, hrProcessorFrwID, sizeof(hrProcessorFrwID)) == 0) {
            hrProcessorEntry->_hrProcessorFrwIDLength = vb->syntax_len / sizeof(guint32);
            hrProcessorEntry->hrProcessorFrwID = vb->syntax.ui32;
        }
        if (vb->id_len > _hrProcessorLoadLength
            && memcmp(vb->id, hrProcessorLoad, sizeof(hrProcessorLoad)) == 0) {
            hrProcessorEntry->hrProcessorLoad = &(vb->syntax.i32[0]);
        }
    }

    return hrProcessorEntry;
}

int
host_resources_mib_get_hrProcessorEntry(host_snmp *s, hrProcessorEntry_t ***hrProcessorEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrProcessorEntry = NULL;

    stls_vbl_add_null(&in, hrProcessorFrwID, _hrProcessorFrwIDLength);
    stls_vbl_add_null(&in, hrProcessorLoad, _hrProcessorLoadLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrProcessorEntry = (hrProcessorEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrProcessorEntry_t *));
    if (! *hrProcessorEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrProcessorEntry)[i] = assign_hrProcessorEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrProcessorEntry(hrProcessorEntry_t **hrProcessorEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrProcessorEntry) {
        for (i = 0; hrProcessorEntry[i]; i++) {
            p = (char *) hrProcessorEntry[i] + sizeof(hrProcessorEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrProcessorEntry[i]);
        }
        g_free(hrProcessorEntry);
    }
}

static hrNetworkEntry_t *
assign_hrNetworkEntry(GSList *vbl)
{
    GSList *elem;
    hrNetworkEntry_t *hrNetworkEntry;
    char *p;

    hrNetworkEntry = (hrNetworkEntry_t *) g_malloc0(sizeof(hrNetworkEntry_t) + sizeof(GSList *));
    if (! hrNetworkEntry) {
        return NULL;
    }

    p = (char *) hrNetworkEntry + sizeof(hrNetworkEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrNetworkIfIndexLength
            && memcmp(vb->id, hrNetworkIfIndex, sizeof(hrNetworkIfIndex)) == 0) {
            hrNetworkEntry->hrNetworkIfIndex = &(vb->syntax.i32[0]);
        }
    }

    return hrNetworkEntry;
}

int
host_resources_mib_get_hrNetworkEntry(host_snmp *s, hrNetworkEntry_t ***hrNetworkEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrNetworkEntry = NULL;

    stls_vbl_add_null(&in, hrNetworkIfIndex, _hrNetworkIfIndexLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrNetworkEntry = (hrNetworkEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrNetworkEntry_t *));
    if (! *hrNetworkEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrNetworkEntry)[i] = assign_hrNetworkEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrNetworkEntry(hrNetworkEntry_t **hrNetworkEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrNetworkEntry) {
        for (i = 0; hrNetworkEntry[i]; i++) {
            p = (char *) hrNetworkEntry[i] + sizeof(hrNetworkEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrNetworkEntry[i]);
        }
        g_free(hrNetworkEntry);
    }
}

static hrPrinterEntry_t *
assign_hrPrinterEntry(GSList *vbl)
{
    GSList *elem;
    hrPrinterEntry_t *hrPrinterEntry;
    char *p;

    hrPrinterEntry = (hrPrinterEntry_t *) g_malloc0(sizeof(hrPrinterEntry_t) + sizeof(GSList *));
    if (! hrPrinterEntry) {
        return NULL;
    }

    p = (char *) hrPrinterEntry + sizeof(hrPrinterEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrPrinterStatusLength
            && memcmp(vb->id, hrPrinterStatus, sizeof(hrPrinterStatus)) == 0) {
            hrPrinterEntry->hrPrinterStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrPrinterDetectedErrorStateLength
            && memcmp(vb->id, hrPrinterDetectedErrorState, sizeof(hrPrinterDetectedErrorState)) == 0) {
            hrPrinterEntry->_hrPrinterDetectedErrorStateLength = vb->syntax_len;
            hrPrinterEntry->hrPrinterDetectedErrorState = vb->syntax.uc;
        }
    }

    return hrPrinterEntry;
}

int
host_resources_mib_get_hrPrinterEntry(host_snmp *s, hrPrinterEntry_t ***hrPrinterEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrPrinterEntry = NULL;

    stls_vbl_add_null(&in, hrPrinterStatus, _hrPrinterStatusLength);
    stls_vbl_add_null(&in, hrPrinterDetectedErrorState, _hrPrinterDetectedErrorStateLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrPrinterEntry = (hrPrinterEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrPrinterEntry_t *));
    if (! *hrPrinterEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrPrinterEntry)[i] = assign_hrPrinterEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrPrinterEntry(hrPrinterEntry_t **hrPrinterEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrPrinterEntry) {
        for (i = 0; hrPrinterEntry[i]; i++) {
            p = (char *) hrPrinterEntry[i] + sizeof(hrPrinterEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrPrinterEntry[i]);
        }
        g_free(hrPrinterEntry);
    }
}

static hrDiskStorageEntry_t *
assign_hrDiskStorageEntry(GSList *vbl)
{
    GSList *elem;
    hrDiskStorageEntry_t *hrDiskStorageEntry;
    char *p;

    hrDiskStorageEntry = (hrDiskStorageEntry_t *) g_malloc0(sizeof(hrDiskStorageEntry_t) + sizeof(GSList *));
    if (! hrDiskStorageEntry) {
        return NULL;
    }

    p = (char *) hrDiskStorageEntry + sizeof(hrDiskStorageEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrDiskStorageAccessLength
            && memcmp(vb->id, hrDiskStorageAccess, sizeof(hrDiskStorageAccess)) == 0) {
            hrDiskStorageEntry->hrDiskStorageAccess = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrDiskStorageMediaLength
            && memcmp(vb->id, hrDiskStorageMedia, sizeof(hrDiskStorageMedia)) == 0) {
            hrDiskStorageEntry->hrDiskStorageMedia = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrDiskStorageRemovebleLength
            && memcmp(vb->id, hrDiskStorageRemoveble, sizeof(hrDiskStorageRemoveble)) == 0) {
            hrDiskStorageEntry->hrDiskStorageRemoveble = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrDiskStorageCapacityLength
            && memcmp(vb->id, hrDiskStorageCapacity, sizeof(hrDiskStorageCapacity)) == 0) {
            hrDiskStorageEntry->hrDiskStorageCapacity = &(vb->syntax.i32[0]);
        }
    }

    return hrDiskStorageEntry;
}

int
host_resources_mib_get_hrDiskStorageEntry(host_snmp *s, hrDiskStorageEntry_t ***hrDiskStorageEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrDiskStorageEntry = NULL;

    stls_vbl_add_null(&in, hrDiskStorageAccess, _hrDiskStorageAccessLength);
    stls_vbl_add_null(&in, hrDiskStorageMedia, _hrDiskStorageMediaLength);
    stls_vbl_add_null(&in, hrDiskStorageRemoveble, _hrDiskStorageRemovebleLength);
    stls_vbl_add_null(&in, hrDiskStorageCapacity, _hrDiskStorageCapacityLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrDiskStorageEntry = (hrDiskStorageEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrDiskStorageEntry_t *));
    if (! *hrDiskStorageEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrDiskStorageEntry)[i] = assign_hrDiskStorageEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrDiskStorageEntry(hrDiskStorageEntry_t **hrDiskStorageEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrDiskStorageEntry) {
        for (i = 0; hrDiskStorageEntry[i]; i++) {
            p = (char *) hrDiskStorageEntry[i] + sizeof(hrDiskStorageEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrDiskStorageEntry[i]);
        }
        g_free(hrDiskStorageEntry);
    }
}

static hrPartitionEntry_t *
assign_hrPartitionEntry(GSList *vbl)
{
    GSList *elem;
    hrPartitionEntry_t *hrPartitionEntry;
    char *p;

    hrPartitionEntry = (hrPartitionEntry_t *) g_malloc0(sizeof(hrPartitionEntry_t) + sizeof(GSList *));
    if (! hrPartitionEntry) {
        return NULL;
    }

    p = (char *) hrPartitionEntry + sizeof(hrPartitionEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrPartitionIndexLength
            && memcmp(vb->id, hrPartitionIndex, sizeof(hrPartitionIndex)) == 0) {
            hrPartitionEntry->hrPartitionIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrPartitionLabelLength
            && memcmp(vb->id, hrPartitionLabel, sizeof(hrPartitionLabel)) == 0) {
            hrPartitionEntry->_hrPartitionLabelLength = vb->syntax_len;
            hrPartitionEntry->hrPartitionLabel = vb->syntax.uc;
        }
        if (vb->id_len > _hrPartitionIDLength
            && memcmp(vb->id, hrPartitionID, sizeof(hrPartitionID)) == 0) {
            hrPartitionEntry->_hrPartitionIDLength = vb->syntax_len;
            hrPartitionEntry->hrPartitionID = vb->syntax.uc;
        }
        if (vb->id_len > _hrPartitionSizeLength
            && memcmp(vb->id, hrPartitionSize, sizeof(hrPartitionSize)) == 0) {
            hrPartitionEntry->hrPartitionSize = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrPartitionFSIndexLength
            && memcmp(vb->id, hrPartitionFSIndex, sizeof(hrPartitionFSIndex)) == 0) {
            hrPartitionEntry->hrPartitionFSIndex = &(vb->syntax.i32[0]);
        }
    }

    return hrPartitionEntry;
}

int
host_resources_mib_get_hrPartitionEntry(host_snmp *s, hrPartitionEntry_t ***hrPartitionEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrPartitionEntry = NULL;

    stls_vbl_add_null(&in, hrPartitionLabel, _hrPartitionLabelLength);
    stls_vbl_add_null(&in, hrPartitionID, _hrPartitionIDLength);
    stls_vbl_add_null(&in, hrPartitionSize, _hrPartitionSizeLength);
    stls_vbl_add_null(&in, hrPartitionFSIndex, _hrPartitionFSIndexLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrPartitionEntry = (hrPartitionEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrPartitionEntry_t *));
    if (! *hrPartitionEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrPartitionEntry)[i] = assign_hrPartitionEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrPartitionEntry(hrPartitionEntry_t **hrPartitionEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrPartitionEntry) {
        for (i = 0; hrPartitionEntry[i]; i++) {
            p = (char *) hrPartitionEntry[i] + sizeof(hrPartitionEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrPartitionEntry[i]);
        }
        g_free(hrPartitionEntry);
    }
}

static hrFSEntry_t *
assign_hrFSEntry(GSList *vbl)
{
    GSList *elem;
    hrFSEntry_t *hrFSEntry;
    char *p;

    hrFSEntry = (hrFSEntry_t *) g_malloc0(sizeof(hrFSEntry_t) + sizeof(GSList *));
    if (! hrFSEntry) {
        return NULL;
    }

    p = (char *) hrFSEntry + sizeof(hrFSEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrFSIndexLength
            && memcmp(vb->id, hrFSIndex, sizeof(hrFSIndex)) == 0) {
            hrFSEntry->hrFSIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrFSMountPointLength
            && memcmp(vb->id, hrFSMountPoint, sizeof(hrFSMountPoint)) == 0) {
            hrFSEntry->_hrFSMountPointLength = vb->syntax_len;
            hrFSEntry->hrFSMountPoint = vb->syntax.uc;
        }
        if (vb->id_len > _hrFSRemoteMountPointLength
            && memcmp(vb->id, hrFSRemoteMountPoint, sizeof(hrFSRemoteMountPoint)) == 0) {
            hrFSEntry->_hrFSRemoteMountPointLength = vb->syntax_len;
            hrFSEntry->hrFSRemoteMountPoint = vb->syntax.uc;
        }
        if (vb->id_len > _hrFSTypeLength
            && memcmp(vb->id, hrFSType, sizeof(hrFSType)) == 0) {
            hrFSEntry->_hrFSTypeLength = vb->syntax_len / sizeof(guint32);
            hrFSEntry->hrFSType = vb->syntax.ui32;
        }
        if (vb->id_len > _hrFSAccessLength
            && memcmp(vb->id, hrFSAccess, sizeof(hrFSAccess)) == 0) {
            hrFSEntry->hrFSAccess = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrFSBootableLength
            && memcmp(vb->id, hrFSBootable, sizeof(hrFSBootable)) == 0) {
            hrFSEntry->hrFSBootable = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrFSStorageIndexLength
            && memcmp(vb->id, hrFSStorageIndex, sizeof(hrFSStorageIndex)) == 0) {
            hrFSEntry->hrFSStorageIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrFSLastFullBackupDateLength
            && memcmp(vb->id, hrFSLastFullBackupDate, sizeof(hrFSLastFullBackupDate)) == 0) {
            hrFSEntry->_hrFSLastFullBackupDateLength = vb->syntax_len;
            hrFSEntry->hrFSLastFullBackupDate = vb->syntax.uc;
        }
        if (vb->id_len > _hrFSLastPartialBackupDateLength
            && memcmp(vb->id, hrFSLastPartialBackupDate, sizeof(hrFSLastPartialBackupDate)) == 0) {
            hrFSEntry->_hrFSLastPartialBackupDateLength = vb->syntax_len;
            hrFSEntry->hrFSLastPartialBackupDate = vb->syntax.uc;
        }
    }

    return hrFSEntry;
}

int
host_resources_mib_get_hrFSEntry(host_snmp *s, hrFSEntry_t ***hrFSEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrFSEntry = NULL;

    stls_vbl_add_null(&in, hrFSMountPoint, _hrFSMountPointLength);
    stls_vbl_add_null(&in, hrFSRemoteMountPoint, _hrFSRemoteMountPointLength);
    stls_vbl_add_null(&in, hrFSType, _hrFSTypeLength);
    stls_vbl_add_null(&in, hrFSAccess, _hrFSAccessLength);
    stls_vbl_add_null(&in, hrFSBootable, _hrFSBootableLength);
    stls_vbl_add_null(&in, hrFSStorageIndex, _hrFSStorageIndexLength);
    stls_vbl_add_null(&in, hrFSLastFullBackupDate, _hrFSLastFullBackupDateLength);
    stls_vbl_add_null(&in, hrFSLastPartialBackupDate, _hrFSLastPartialBackupDateLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrFSEntry = (hrFSEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrFSEntry_t *));
    if (! *hrFSEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrFSEntry)[i] = assign_hrFSEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrFSEntry(hrFSEntry_t **hrFSEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrFSEntry) {
        for (i = 0; hrFSEntry[i]; i++) {
            p = (char *) hrFSEntry[i] + sizeof(hrFSEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrFSEntry[i]);
        }
        g_free(hrFSEntry);
    }
}

static hrSWRun_t *
assign_hrSWRun(GSList *vbl)
{
    GSList *elem;
    hrSWRun_t *hrSWRun;
    char *p;

    hrSWRun = (hrSWRun_t *) g_malloc0(sizeof(hrSWRun_t) + sizeof(GSList *));
    if (! hrSWRun) {
        return NULL;
    }

    p = (char *) hrSWRun + sizeof(hrSWRun_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSWOSIndexLength
            && memcmp(vb->id, hrSWOSIndex, sizeof(hrSWOSIndex)) == 0) {
            hrSWRun->hrSWOSIndex = &(vb->syntax.i32[0]);
        }
    }

    return hrSWRun;
}

int
host_resources_mib_get_hrSWRun(host_snmp *s, hrSWRun_t **hrSWRun)
{
    GSList *in = NULL, *out = NULL;

    *hrSWRun = NULL;

    stls_vbl_add_null(&in, hrSWOSIndex, _hrSWOSIndexLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *hrSWRun = assign_hrSWRun(out);

    return 0;
}

void
host_resources_mib_free_hrSWRun(hrSWRun_t *hrSWRun)
{
    GSList *vbl;
    char *p;

    if (hrSWRun) {
        p = (char *) hrSWRun + sizeof(hrSWRun_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(hrSWRun);
    }
}

static hrSWRunEntry_t *
assign_hrSWRunEntry(GSList *vbl)
{
    GSList *elem;
    hrSWRunEntry_t *hrSWRunEntry;
    char *p;

    hrSWRunEntry = (hrSWRunEntry_t *) g_malloc0(sizeof(hrSWRunEntry_t) + sizeof(GSList *));
    if (! hrSWRunEntry) {
        return NULL;
    }

    p = (char *) hrSWRunEntry + sizeof(hrSWRunEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSWRunIndexLength
            && memcmp(vb->id, hrSWRunIndex, sizeof(hrSWRunIndex)) == 0) {
            hrSWRunEntry->hrSWRunIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSWRunNameLength
            && memcmp(vb->id, hrSWRunName, sizeof(hrSWRunName)) == 0) {
            hrSWRunEntry->_hrSWRunNameLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunName = vb->syntax.uc;
        }
        if (vb->id_len > _hrSWRunIDLength
            && memcmp(vb->id, hrSWRunID, sizeof(hrSWRunID)) == 0) {
            hrSWRunEntry->_hrSWRunIDLength = vb->syntax_len / sizeof(guint32);
            hrSWRunEntry->hrSWRunID = vb->syntax.ui32;
        }
        if (vb->id_len > _hrSWRunPathLength
            && memcmp(vb->id, hrSWRunPath, sizeof(hrSWRunPath)) == 0) {
            hrSWRunEntry->_hrSWRunPathLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunPath = vb->syntax.uc;
        }
        if (vb->id_len > _hrSWRunParametersLength
            && memcmp(vb->id, hrSWRunParameters, sizeof(hrSWRunParameters)) == 0) {
            hrSWRunEntry->_hrSWRunParametersLength = vb->syntax_len;
            hrSWRunEntry->hrSWRunParameters = vb->syntax.uc;
        }
        if (vb->id_len > _hrSWRunTypeLength
            && memcmp(vb->id, hrSWRunType, sizeof(hrSWRunType)) == 0) {
            hrSWRunEntry->hrSWRunType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSWRunStatusLength
            && memcmp(vb->id, hrSWRunStatus, sizeof(hrSWRunStatus)) == 0) {
            hrSWRunEntry->hrSWRunStatus = &(vb->syntax.i32[0]);
        }
    }

    return hrSWRunEntry;
}

int
host_resources_mib_get_hrSWRunEntry(host_snmp *s, hrSWRunEntry_t ***hrSWRunEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrSWRunEntry = NULL;

    stls_vbl_add_null(&in, hrSWRunName, _hrSWRunNameLength);
    stls_vbl_add_null(&in, hrSWRunID, _hrSWRunIDLength);
    stls_vbl_add_null(&in, hrSWRunPath, _hrSWRunPathLength);
    stls_vbl_add_null(&in, hrSWRunParameters, _hrSWRunParametersLength);
    stls_vbl_add_null(&in, hrSWRunType, _hrSWRunTypeLength);
    stls_vbl_add_null(&in, hrSWRunStatus, _hrSWRunStatusLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrSWRunEntry = (hrSWRunEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrSWRunEntry_t *));
    if (! *hrSWRunEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrSWRunEntry)[i] = assign_hrSWRunEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrSWRunEntry(hrSWRunEntry_t **hrSWRunEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrSWRunEntry) {
        for (i = 0; hrSWRunEntry[i]; i++) {
            p = (char *) hrSWRunEntry[i] + sizeof(hrSWRunEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrSWRunEntry[i]);
        }
        g_free(hrSWRunEntry);
    }
}

static hrSWRunPerfEntry_t *
assign_hrSWRunPerfEntry(GSList *vbl)
{
    GSList *elem;
    hrSWRunPerfEntry_t *hrSWRunPerfEntry;
    char *p;

    hrSWRunPerfEntry = (hrSWRunPerfEntry_t *) g_malloc0(sizeof(hrSWRunPerfEntry_t) + sizeof(GSList *));
    if (! hrSWRunPerfEntry) {
        return NULL;
    }

    p = (char *) hrSWRunPerfEntry + sizeof(hrSWRunPerfEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSWRunPerfCPULength
            && memcmp(vb->id, hrSWRunPerfCPU, sizeof(hrSWRunPerfCPU)) == 0) {
            hrSWRunPerfEntry->hrSWRunPerfCPU = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSWRunPerfMemLength
            && memcmp(vb->id, hrSWRunPerfMem, sizeof(hrSWRunPerfMem)) == 0) {
            hrSWRunPerfEntry->hrSWRunPerfMem = &(vb->syntax.i32[0]);
        }
    }

    return hrSWRunPerfEntry;
}

int
host_resources_mib_get_hrSWRunPerfEntry(host_snmp *s, hrSWRunPerfEntry_t ***hrSWRunPerfEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrSWRunPerfEntry = NULL;

    stls_vbl_add_null(&in, hrSWRunPerfCPU, _hrSWRunPerfCPULength);
    stls_vbl_add_null(&in, hrSWRunPerfMem, _hrSWRunPerfMemLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrSWRunPerfEntry = (hrSWRunPerfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrSWRunPerfEntry_t *));
    if (! *hrSWRunPerfEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrSWRunPerfEntry)[i] = assign_hrSWRunPerfEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrSWRunPerfEntry(hrSWRunPerfEntry_t **hrSWRunPerfEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrSWRunPerfEntry) {
        for (i = 0; hrSWRunPerfEntry[i]; i++) {
            p = (char *) hrSWRunPerfEntry[i] + sizeof(hrSWRunPerfEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrSWRunPerfEntry[i]);
        }
        g_free(hrSWRunPerfEntry);
    }
}

static hrSWInstalled_t *
assign_hrSWInstalled(GSList *vbl)
{
    GSList *elem;
    hrSWInstalled_t *hrSWInstalled;
    char *p;

    hrSWInstalled = (hrSWInstalled_t *) g_malloc0(sizeof(hrSWInstalled_t) + sizeof(GSList *));
    if (! hrSWInstalled) {
        return NULL;
    }

    p = (char *) hrSWInstalled + sizeof(hrSWInstalled_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSWInstalledLastChangeLength
            && memcmp(vb->id, hrSWInstalledLastChange, sizeof(hrSWInstalledLastChange)) == 0) {
            hrSWInstalled->hrSWInstalledLastChange = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _hrSWInstalledLastUpdateTimeLength
            && memcmp(vb->id, hrSWInstalledLastUpdateTime, sizeof(hrSWInstalledLastUpdateTime)) == 0) {
            hrSWInstalled->hrSWInstalledLastUpdateTime = &(vb->syntax.ui32[0]);
        }
    }

    return hrSWInstalled;
}

int
host_resources_mib_get_hrSWInstalled(host_snmp *s, hrSWInstalled_t **hrSWInstalled)
{
    GSList *in = NULL, *out = NULL;

    *hrSWInstalled = NULL;

    stls_vbl_add_null(&in, hrSWInstalledLastChange, _hrSWInstalledLastChangeLength);
    stls_vbl_add_null(&in, hrSWInstalledLastUpdateTime, _hrSWInstalledLastUpdateTimeLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *hrSWInstalled = assign_hrSWInstalled(out);

    return 0;
}

void
host_resources_mib_free_hrSWInstalled(hrSWInstalled_t *hrSWInstalled)
{
    GSList *vbl;
    char *p;

    if (hrSWInstalled) {
        p = (char *) hrSWInstalled + sizeof(hrSWInstalled_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(hrSWInstalled);
    }
}

static hrSWInstalledEntry_t *
assign_hrSWInstalledEntry(GSList *vbl)
{
    GSList *elem;
    hrSWInstalledEntry_t *hrSWInstalledEntry;
    char *p;

    hrSWInstalledEntry = (hrSWInstalledEntry_t *) g_malloc0(sizeof(hrSWInstalledEntry_t) + sizeof(GSList *));
    if (! hrSWInstalledEntry) {
        return NULL;
    }

    p = (char *) hrSWInstalledEntry + sizeof(hrSWInstalledEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _hrSWInstalledIndexLength
            && memcmp(vb->id, hrSWInstalledIndex, sizeof(hrSWInstalledIndex)) == 0) {
            hrSWInstalledEntry->hrSWInstalledIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSWInstalledNameLength
            && memcmp(vb->id, hrSWInstalledName, sizeof(hrSWInstalledName)) == 0) {
            hrSWInstalledEntry->_hrSWInstalledNameLength = vb->syntax_len;
            hrSWInstalledEntry->hrSWInstalledName = vb->syntax.uc;
        }
        if (vb->id_len > _hrSWInstalledIDLength
            && memcmp(vb->id, hrSWInstalledID, sizeof(hrSWInstalledID)) == 0) {
            hrSWInstalledEntry->_hrSWInstalledIDLength = vb->syntax_len / sizeof(guint32);
            hrSWInstalledEntry->hrSWInstalledID = vb->syntax.ui32;
        }
        if (vb->id_len > _hrSWInstalledTypeLength
            && memcmp(vb->id, hrSWInstalledType, sizeof(hrSWInstalledType)) == 0) {
            hrSWInstalledEntry->hrSWInstalledType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _hrSWInstalledDateLength
            && memcmp(vb->id, hrSWInstalledDate, sizeof(hrSWInstalledDate)) == 0) {
            hrSWInstalledEntry->_hrSWInstalledDateLength = vb->syntax_len;
            hrSWInstalledEntry->hrSWInstalledDate = vb->syntax.uc;
        }
    }

    return hrSWInstalledEntry;
}

int
host_resources_mib_get_hrSWInstalledEntry(host_snmp *s, hrSWInstalledEntry_t ***hrSWInstalledEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *hrSWInstalledEntry = NULL;

    stls_vbl_add_null(&in, hrSWInstalledName, _hrSWInstalledNameLength);
    stls_vbl_add_null(&in, hrSWInstalledID, _hrSWInstalledIDLength);
    stls_vbl_add_null(&in, hrSWInstalledType, _hrSWInstalledTypeLength);
    stls_vbl_add_null(&in, hrSWInstalledDate, _hrSWInstalledDateLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *hrSWInstalledEntry = (hrSWInstalledEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(hrSWInstalledEntry_t *));
    if (! *hrSWInstalledEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*hrSWInstalledEntry)[i] = assign_hrSWInstalledEntry(row->data);
    }

    return 0;
}

void
host_resources_mib_free_hrSWInstalledEntry(hrSWInstalledEntry_t **hrSWInstalledEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (hrSWInstalledEntry) {
        for (i = 0; hrSWInstalledEntry[i]; i++) {
            p = (char *) hrSWInstalledEntry[i] + sizeof(hrSWInstalledEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(hrSWInstalledEntry[i]);
        }
        g_free(hrSWInstalledEntry);
    }
}


