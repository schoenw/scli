/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from IF-MIB revision 2000-06-14 00:00.
 *
 * $Id$
 */

#include "if-mib.h"

stls_table_t if_mib_enums_ifType[] = {
    { 1, "other" },
    { 2, "regular1822" },
    { 3, "hdh1822" },
    { 4, "ddnX25" },
    { 5, "rfc877x25" },
    { 6, "ethernetCsmacd" },
    { 7, "iso88023Csmacd" },
    { 8, "iso88024TokenBus" },
    { 9, "iso88025TokenRing" },
    { 10, "iso88026Man" },
    { 11, "starLan" },
    { 12, "proteon10Mbit" },
    { 13, "proteon80Mbit" },
    { 14, "hyperchannel" },
    { 15, "fddi" },
    { 16, "lapb" },
    { 17, "sdlc" },
    { 18, "ds1" },
    { 19, "e1" },
    { 20, "basicISDN" },
    { 21, "primaryISDN" },
    { 22, "propPointToPointSerial" },
    { 23, "ppp" },
    { 24, "softwareLoopback" },
    { 25, "eon" },
    { 26, "ethernet3Mbit" },
    { 27, "nsip" },
    { 28, "slip" },
    { 29, "ultra" },
    { 30, "ds3" },
    { 31, "sip" },
    { 32, "frameRelay" },
    { 33, "rs232" },
    { 34, "para" },
    { 35, "arcnet" },
    { 36, "arcnetPlus" },
    { 37, "atm" },
    { 38, "miox25" },
    { 39, "sonet" },
    { 40, "x25ple" },
    { 41, "iso88022llc" },
    { 42, "localTalk" },
    { 43, "smdsDxi" },
    { 44, "frameRelayService" },
    { 45, "v35" },
    { 46, "hssi" },
    { 47, "hippi" },
    { 48, "modem" },
    { 49, "aal5" },
    { 50, "sonetPath" },
    { 51, "sonetVT" },
    { 52, "smdsIcip" },
    { 53, "propVirtual" },
    { 54, "propMultiplexor" },
    { 55, "ieee80212" },
    { 56, "fibreChannel" },
    { 57, "hippiInterface" },
    { 58, "frameRelayInterconnect" },
    { 59, "aflane8023" },
    { 60, "aflane8025" },
    { 61, "cctEmul" },
    { 62, "fastEther" },
    { 63, "isdn" },
    { 64, "v11" },
    { 65, "v36" },
    { 66, "g703at64k" },
    { 67, "g703at2mb" },
    { 68, "qllc" },
    { 69, "fastEtherFX" },
    { 70, "channel" },
    { 71, "ieee80211" },
    { 72, "ibm370parChan" },
    { 73, "escon" },
    { 74, "dlsw" },
    { 75, "isdns" },
    { 76, "isdnu" },
    { 77, "lapd" },
    { 78, "ipSwitch" },
    { 79, "rsrb" },
    { 80, "atmLogical" },
    { 81, "ds0" },
    { 82, "ds0Bundle" },
    { 83, "bsc" },
    { 84, "async" },
    { 85, "cnr" },
    { 86, "iso88025Dtr" },
    { 87, "eplrs" },
    { 88, "arap" },
    { 89, "propCnls" },
    { 90, "hostPad" },
    { 91, "termPad" },
    { 92, "frameRelayMPI" },
    { 93, "x213" },
    { 94, "adsl" },
    { 95, "radsl" },
    { 96, "sdsl" },
    { 97, "vdsl" },
    { 98, "iso88025CRFPInt" },
    { 99, "myrinet" },
    { 100, "voiceEM" },
    { 101, "voiceFXO" },
    { 102, "voiceFXS" },
    { 103, "voiceEncap" },
    { 104, "voiceOverIp" },
    { 105, "atmDxi" },
    { 106, "atmFuni" },
    { 107, "atmIma" },
    { 108, "pppMultilinkBundle" },
    { 109, "ipOverCdlc" },
    { 110, "ipOverClaw" },
    { 111, "stackToStack" },
    { 112, "virtualIpAddress" },
    { 113, "mpc" },
    { 114, "ipOverAtm" },
    { 115, "iso88025Fiber" },
    { 116, "tdlc" },
    { 117, "gigabitEthernet" },
    { 118, "hdlc" },
    { 119, "lapf" },
    { 120, "v37" },
    { 121, "x25mlp" },
    { 122, "x25huntGroup" },
    { 123, "trasnpHdlc" },
    { 124, "interleave" },
    { 125, "fast" },
    { 126, "ip" },
    { 127, "docsCableMaclayer" },
    { 128, "docsCableDownstream" },
    { 129, "docsCableUpstream" },
    { 130, "a12MppSwitch" },
    { 131, "tunnel" },
    { 132, "coffee" },
    { 133, "ces" },
    { 134, "atmSubInterface" },
    { 135, "l2vlan" },
    { 136, "l3ipvlan" },
    { 137, "l3ipxvlan" },
    { 138, "digitalPowerline" },
    { 139, "mediaMailOverIp" },
    { 140, "dtm" },
    { 141, "dcn" },
    { 142, "ipForward" },
    { 143, "msdsl" },
    { 144, "ieee1394" },
    { 145, "if-gsn" },
    { 146, "dvbRccMacLayer" },
    { 147, "dvbRccDownstream" },
    { 148, "dvbRccUpstream" },
    { 149, "atmVirtual" },
    { 150, "mplsTunnel" },
    { 151, "srp" },
    { 152, "voiceOverAtm" },
    { 153, "voiceOverFrameRelay" },
    { 154, "idsl" },
    { 155, "compositeLink" },
    { 156, "ss7SigLink" },
    { 157, "propWirelessP2P" },
    { 158, "frForward" },
    { 159, "rfc1483" },
    { 160, "usb" },
    { 161, "ieee8023adLag" },
    { 162, "bgppolicyaccounting" },
    { 163, "frf16MfrBundle" },
    { 164, "h323Gatekeeper" },
    { 165, "h323Proxy" },
    { 166, "mpls" },
    { 167, "mfSigLink" },
    { 168, "hdsl2" },
    { 169, "shdsl" },
    { 170, "ds1FDL" },
    { 171, "pos" },
    { 172, "dvbAsiln" },
    { 173, "dvbAsiOut" },
    { 174, "plc" },
    { 175, "nfas" },
    { 176, "tr008" },
    { 177, "gr303RDT" },
    { 178, "gr303IDT" },
    { 179, "isup" },
    { 180, "propDocsWirelessMaclayer" },
    { 181, "propDocsWirelessDownstream" },
    { 182, "propDocsWirelessUpstream" },
    { 183, "hiperlan2" },
    { 184, "propBWAp2Mp" },
    { 185, "sonetOverheadChannel" },
    { 186, "digitalWrapperOverheadChannel" },
    { 187, "aal2" },
    { 188, "radioMAC" },
    { 189, "atmRadio" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifAdminStatus[] = {
    { 1, "up" },
    { 2, "down" },
    { 3, "testing" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifOperStatus[] = {
    { 1, "up" },
    { 2, "down" },
    { 3, "testing" },
    { 4, "unknown" },
    { 5, "dormant" },
    { 6, "notPresent" },
    { 7, "lowerLayerDown" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifLinkUpDownTrapEnable[] = {
    { 1, "enabled" },
    { 2, "disabled" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifPromiscuousMode[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifConnectorPresent[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifStackStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifTestStatus[] = {
    { 1, "notInUse" },
    { 2, "inUse" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifTestResult[] = {
    { 1, "none" },
    { 2, "success" },
    { 3, "inProgress" },
    { 4, "notSupported" },
    { 5, "unAbleToRun" },
    { 6, "aborted" },
    { 7, "failed" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifRcvAddressStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifRcvAddressType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 0, NULL }
};


static interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    interfaces_t *interfaces;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2};

    interfaces = (interfaces_t *) g_malloc0(sizeof(interfaces_t) + sizeof(GSList *));
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 8 && vb->id[7] == 1) {
            interfaces->ifNumber = &(vb->syntax.i32[0]);
        }
    }

    return interfaces;
}

int
if_mib_get_interfaces(host_snmp *s, interfaces_t **interfaces)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 0};

    *interfaces = NULL;

    base[7] = 1; stls_vbl_add_null(&in, base, 8);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *interfaces = assign_interfaces(out);

    return 0;
}

void
if_mib_free_interfaces(interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(interfaces_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(interfaces);
    }
}

static ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    ifEntry_t *ifEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1};

    ifEntry = (ifEntry_t *) g_malloc0(sizeof(ifEntry_t) + sizeof(GSList *));
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(ifEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 11) return NULL;
        ifEntry->ifIndex = (gint32 *) &(vb->id[10]);
        if (vb->id_len > 11) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 2) {
            ifEntry->_ifDescrLength = vb->syntax_len;
            ifEntry->ifDescr = vb->syntax.uc;
        }
        if (vb->id_len > 10 && vb->id[9] == 3) {
            ifEntry->ifType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 4) {
            ifEntry->ifMtu = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 5) {
            ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 6) {
            ifEntry->_ifPhysAddressLength = vb->syntax_len;
            ifEntry->ifPhysAddress = vb->syntax.uc;
        }
        if (vb->id_len > 10 && vb->id[9] == 7) {
            ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 8) {
            ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 9) {
            ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 10) {
            ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 11) {
            ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 12) {
            ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 13) {
            ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 14) {
            ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 15) {
            ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 16) {
            ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 17) {
            ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 18) {
            ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 19) {
            ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 20) {
            ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 21) {
            ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 10 && vb->id[9] == 22) {
            ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
            ifEntry->ifSpecific = vb->syntax.ui32;
        }
    }

    return ifEntry;
}

int
if_mib_get_ifEntry(host_snmp *s, ifEntry_t ***ifEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 0};

    *ifEntry = NULL;

    base[9] = 2; stls_vbl_add_null(&in, base, 10);
    base[9] = 3; stls_vbl_add_null(&in, base, 10);
    base[9] = 4; stls_vbl_add_null(&in, base, 10);
    base[9] = 5; stls_vbl_add_null(&in, base, 10);
    base[9] = 6; stls_vbl_add_null(&in, base, 10);
    base[9] = 7; stls_vbl_add_null(&in, base, 10);
    base[9] = 8; stls_vbl_add_null(&in, base, 10);
    base[9] = 9; stls_vbl_add_null(&in, base, 10);
    base[9] = 10; stls_vbl_add_null(&in, base, 10);
    base[9] = 11; stls_vbl_add_null(&in, base, 10);
    base[9] = 12; stls_vbl_add_null(&in, base, 10);
    base[9] = 13; stls_vbl_add_null(&in, base, 10);
    base[9] = 14; stls_vbl_add_null(&in, base, 10);
    base[9] = 15; stls_vbl_add_null(&in, base, 10);
    base[9] = 16; stls_vbl_add_null(&in, base, 10);
    base[9] = 17; stls_vbl_add_null(&in, base, 10);
    base[9] = 18; stls_vbl_add_null(&in, base, 10);
    base[9] = 19; stls_vbl_add_null(&in, base, 10);
    base[9] = 20; stls_vbl_add_null(&in, base, 10);
    base[9] = 21; stls_vbl_add_null(&in, base, 10);
    base[9] = 22; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifEntry = (ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifEntry_t *));
    if (! *ifEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifEntry)[i] = assign_ifEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifEntry(ifEntry_t **ifEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            p = (char *) ifEntry[i] + sizeof(ifEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

static ifMIBObjects_t *
assign_ifMIBObjects(GSList *vbl)
{
    GSList *elem;
    ifMIBObjects_t *ifMIBObjects;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1};

    ifMIBObjects = (ifMIBObjects_t *) g_malloc0(sizeof(ifMIBObjects_t) + sizeof(GSList *));
    if (! ifMIBObjects) {
        return NULL;
    }

    p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 9 && vb->id[8] == 5) {
            ifMIBObjects->ifTableLastChange = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 9 && vb->id[8] == 6) {
            ifMIBObjects->ifStackLastChange = &(vb->syntax.ui32[0]);
        }
    }

    return ifMIBObjects;
}

int
if_mib_get_ifMIBObjects(host_snmp *s, ifMIBObjects_t **ifMIBObjects)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 0};

    *ifMIBObjects = NULL;

    base[8] = 5; stls_vbl_add_null(&in, base, 9);
    base[8] = 6; stls_vbl_add_null(&in, base, 9);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ifMIBObjects = assign_ifMIBObjects(out);

    return 0;
}

void
if_mib_free_ifMIBObjects(ifMIBObjects_t *ifMIBObjects)
{
    GSList *vbl;
    char *p;

    if (ifMIBObjects) {
        p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifMIBObjects);
    }
}

static ifXEntry_t *
assign_ifXEntry(GSList *vbl)
{
    GSList *elem;
    ifXEntry_t *ifXEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1};

    ifXEntry = (ifXEntry_t *) g_malloc0(sizeof(ifXEntry_t) + sizeof(GSList *));
    if (! ifXEntry) {
        return NULL;
    }

    p = (char *) ifXEntry + sizeof(ifXEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        ifXEntry->ifIndex = (gint32 *) &(vb->id[11]);
        if (vb->id_len > 12) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 1) {
            ifXEntry->_ifNameLength = vb->syntax_len;
            ifXEntry->ifName = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            ifXEntry->ifInMulticastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            ifXEntry->ifInBroadcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            ifXEntry->ifOutMulticastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            ifXEntry->ifOutBroadcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 6) {
            ifXEntry->ifHCInOctets = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 7) {
            ifXEntry->ifHCInUcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 8) {
            ifXEntry->ifHCInMulticastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 9) {
            ifXEntry->ifHCInBroadcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 10) {
            ifXEntry->ifHCOutOctets = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 11) {
            ifXEntry->ifHCOutUcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 12) {
            ifXEntry->ifHCOutMulticastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 13) {
            ifXEntry->ifHCOutBroadcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 14) {
            ifXEntry->ifLinkUpDownTrapEnable = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 15) {
            ifXEntry->ifHighSpeed = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 16) {
            ifXEntry->ifPromiscuousMode = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 17) {
            ifXEntry->ifConnectorPresent = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 18) {
            ifXEntry->_ifAliasLength = vb->syntax_len;
            ifXEntry->ifAlias = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 19) {
            ifXEntry->ifCounterDiscontinuityTime = &(vb->syntax.ui32[0]);
        }
    }

    return ifXEntry;
}

int
if_mib_get_ifXEntry(host_snmp *s, ifXEntry_t ***ifXEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 0};

    *ifXEntry = NULL;

    base[10] = 1; stls_vbl_add_null(&in, base, 11);
    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);
    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);
    if (s->version > G_SNMP_V1) {
        base[10] = 6; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 7; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 8; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 9; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 10; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 11; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 12; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 13; stls_vbl_add_null(&in, base, 11);
    }
    base[10] = 14; stls_vbl_add_null(&in, base, 11);
    base[10] = 15; stls_vbl_add_null(&in, base, 11);
    base[10] = 16; stls_vbl_add_null(&in, base, 11);
    base[10] = 17; stls_vbl_add_null(&in, base, 11);
    base[10] = 18; stls_vbl_add_null(&in, base, 11);
    base[10] = 19; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifXEntry = (ifXEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifXEntry_t *));
    if (! *ifXEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifXEntry)[i] = assign_ifXEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifXEntry(ifXEntry_t **ifXEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifXEntry) {
        for (i = 0; ifXEntry[i]; i++) {
            p = (char *) ifXEntry[i] + sizeof(ifXEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifXEntry[i]);
        }
        g_free(ifXEntry);
    }
}

static ifStackEntry_t *
assign_ifStackEntry(GSList *vbl)
{
    GSList *elem;
    ifStackEntry_t *ifStackEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1};

    ifStackEntry = (ifStackEntry_t *) g_malloc0(sizeof(ifStackEntry_t) + sizeof(GSList *));
    if (! ifStackEntry) {
        return NULL;
    }

    p = (char *) ifStackEntry + sizeof(ifStackEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        ifStackEntry->ifStackHigherLayer = (gint32 *) &(vb->id[11]);
        ifStackEntry->ifStackLowerLayer = (gint32 *) &(vb->id[12]);
        if (vb->id_len > 13) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            ifStackEntry->ifStackStatus = &(vb->syntax.i32[0]);
        }
    }

    return ifStackEntry;
}

int
if_mib_get_ifStackEntry(host_snmp *s, ifStackEntry_t ***ifStackEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 0};

    *ifStackEntry = NULL;

    base[10] = 3; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifStackEntry = (ifStackEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifStackEntry_t *));
    if (! *ifStackEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifStackEntry)[i] = assign_ifStackEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifStackEntry(ifStackEntry_t **ifStackEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifStackEntry) {
        for (i = 0; ifStackEntry[i]; i++) {
            p = (char *) ifStackEntry[i] + sizeof(ifStackEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifStackEntry[i]);
        }
        g_free(ifStackEntry);
    }
}

static ifTestEntry_t *
assign_ifTestEntry(GSList *vbl)
{
    GSList *elem;
    ifTestEntry_t *ifTestEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1};

    ifTestEntry = (ifTestEntry_t *) g_malloc0(sizeof(ifTestEntry_t) + sizeof(GSList *));
    if (! ifTestEntry) {
        return NULL;
    }

    p = (char *) ifTestEntry + sizeof(ifTestEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        ifTestEntry->ifIndex = (gint32 *) &(vb->id[11]);
        if (vb->id_len > 12) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 1) {
            ifTestEntry->ifTestId = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            ifTestEntry->ifTestStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            ifTestEntry->_ifTestTypeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestType = vb->syntax.ui32;
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            ifTestEntry->ifTestResult = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            ifTestEntry->_ifTestCodeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestCode = vb->syntax.ui32;
        }
        if (vb->id_len > 11 && vb->id[10] == 6) {
            ifTestEntry->_ifTestOwnerLength = vb->syntax_len;
            ifTestEntry->ifTestOwner = vb->syntax.uc;
        }
    }

    return ifTestEntry;
}

int
if_mib_get_ifTestEntry(host_snmp *s, ifTestEntry_t ***ifTestEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 0};

    *ifTestEntry = NULL;

    base[10] = 1; stls_vbl_add_null(&in, base, 11);
    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);
    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);
    base[10] = 6; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifTestEntry = (ifTestEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifTestEntry_t *));
    if (! *ifTestEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifTestEntry)[i] = assign_ifTestEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifTestEntry(ifTestEntry_t **ifTestEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifTestEntry) {
        for (i = 0; ifTestEntry[i]; i++) {
            p = (char *) ifTestEntry[i] + sizeof(ifTestEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifTestEntry[i]);
        }
        g_free(ifTestEntry);
    }
}

static ifRcvAddressEntry_t *
assign_ifRcvAddressEntry(GSList *vbl)
{
    GSList *elem;
    ifRcvAddressEntry_t *ifRcvAddressEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1};

    ifRcvAddressEntry = (ifRcvAddressEntry_t *) g_malloc0(sizeof(ifRcvAddressEntry_t) + sizeof(GSList *));
    if (! ifRcvAddressEntry) {
        return NULL;
    }

    p = (char *) ifRcvAddressEntry + sizeof(ifRcvAddressEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        ifRcvAddressEntry->ifIndex = (gint32 *) &(vb->id[11]);
        /* XXX fix this ifRcvAddressEntry->ifRcvAddressAddress = ?; */
        if (vb->id_len > 12) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            ifRcvAddressEntry->ifRcvAddressStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            ifRcvAddressEntry->ifRcvAddressType = &(vb->syntax.i32[0]);
        }
    }

    return ifRcvAddressEntry;
}

int
if_mib_get_ifRcvAddressEntry(host_snmp *s, ifRcvAddressEntry_t ***ifRcvAddressEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 0};

    *ifRcvAddressEntry = NULL;

    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifRcvAddressEntry = (ifRcvAddressEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifRcvAddressEntry_t *));
    if (! *ifRcvAddressEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifRcvAddressEntry)[i] = assign_ifRcvAddressEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifRcvAddressEntry(ifRcvAddressEntry_t **ifRcvAddressEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifRcvAddressEntry) {
        for (i = 0; ifRcvAddressEntry[i]; i++) {
            p = (char *) ifRcvAddressEntry[i] + sizeof(ifRcvAddressEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifRcvAddressEntry[i]);
        }
        g_free(ifRcvAddressEntry);
    }
}


