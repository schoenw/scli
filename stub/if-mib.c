/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from IF-MIB revision 2000-06-14 00:00.
 *
 * $Id$
 */

#include "if-mib.h"

static guint32 const ifNumber[] = {1, 3, 6, 1, 2, 1, 2, 1};
static guint32 const ifIndex[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1};
static guint32 const ifDescr[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 2};
static guint32 const ifType[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 3};
static guint32 const ifMtu[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 4};
static guint32 const ifSpeed[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 5};
static guint32 const ifPhysAddress[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 6};
static guint32 const ifAdminStatus[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 7};
static guint32 const ifOperStatus[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 8};
static guint32 const ifLastChange[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 9};
static guint32 const ifInOctets[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 10};
static guint32 const ifInUcastPkts[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 11};
static guint32 const ifInNUcastPkts[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 12};
static guint32 const ifInDiscards[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 13};
static guint32 const ifInErrors[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 14};
static guint32 const ifInUnknownProtos[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 15};
static guint32 const ifOutOctets[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 16};
static guint32 const ifOutUcastPkts[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 17};
static guint32 const ifOutNUcastPkts[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 18};
static guint32 const ifOutDiscards[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 19};
static guint32 const ifOutErrors[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 20};
static guint32 const ifOutQLen[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 21};
static guint32 const ifSpecific[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 22};
static guint32 const ifName[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 1};
static guint32 const ifInMulticastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 2};
static guint32 const ifInBroadcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 3};
static guint32 const ifOutMulticastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 4};
static guint32 const ifOutBroadcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 5};
static guint32 const ifHCInOctets[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 6};
static guint32 const ifHCInUcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 7};
static guint32 const ifHCInMulticastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 8};
static guint32 const ifHCInBroadcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 9};
static guint32 const ifHCOutOctets[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 10};
static guint32 const ifHCOutUcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 11};
static guint32 const ifHCOutMulticastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 12};
static guint32 const ifHCOutBroadcastPkts[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 13};
static guint32 const ifLinkUpDownTrapEnable[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 14};
static guint32 const ifHighSpeed[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 15};
static guint32 const ifPromiscuousMode[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 16};
static guint32 const ifConnectorPresent[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 17};
static guint32 const ifAlias[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 18};
static guint32 const ifCounterDiscontinuityTime[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 19};
static guint32 const ifStackHigherLayer[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 1};
static guint32 const ifStackLowerLayer[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 2};
static guint32 const ifStackStatus[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 3};
static guint32 const ifTestId[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 1};
static guint32 const ifTestStatus[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 2};
static guint32 const ifTestType[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 3};
static guint32 const ifTestResult[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 4};
static guint32 const ifTestCode[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 5};
static guint32 const ifTestOwner[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 6};
static guint32 const ifRcvAddressAddress[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 1};
static guint32 const ifRcvAddressStatus[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 2};
static guint32 const ifRcvAddressType[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 3};
static guint32 const ifTableLastChange[] = {1, 3, 6, 1, 2, 1, 31, 1, 5};
static guint32 const ifStackLastChange[] = {1, 3, 6, 1, 2, 1, 31, 1, 6};

static gsize const _ifNumberLength = sizeof(ifNumber)/sizeof(guint32);
static gsize const _ifIndexLength = sizeof(ifIndex)/sizeof(guint32);
static gsize const _ifDescrLength = sizeof(ifDescr)/sizeof(guint32);
static gsize const _ifTypeLength = sizeof(ifType)/sizeof(guint32);
static gsize const _ifMtuLength = sizeof(ifMtu)/sizeof(guint32);
static gsize const _ifSpeedLength = sizeof(ifSpeed)/sizeof(guint32);
static gsize const _ifPhysAddressLength = sizeof(ifPhysAddress)/sizeof(guint32);
static gsize const _ifAdminStatusLength = sizeof(ifAdminStatus)/sizeof(guint32);
static gsize const _ifOperStatusLength = sizeof(ifOperStatus)/sizeof(guint32);
static gsize const _ifLastChangeLength = sizeof(ifLastChange)/sizeof(guint32);
static gsize const _ifInOctetsLength = sizeof(ifInOctets)/sizeof(guint32);
static gsize const _ifInUcastPktsLength = sizeof(ifInUcastPkts)/sizeof(guint32);
static gsize const _ifInNUcastPktsLength = sizeof(ifInNUcastPkts)/sizeof(guint32);
static gsize const _ifInDiscardsLength = sizeof(ifInDiscards)/sizeof(guint32);
static gsize const _ifInErrorsLength = sizeof(ifInErrors)/sizeof(guint32);
static gsize const _ifInUnknownProtosLength = sizeof(ifInUnknownProtos)/sizeof(guint32);
static gsize const _ifOutOctetsLength = sizeof(ifOutOctets)/sizeof(guint32);
static gsize const _ifOutUcastPktsLength = sizeof(ifOutUcastPkts)/sizeof(guint32);
static gsize const _ifOutNUcastPktsLength = sizeof(ifOutNUcastPkts)/sizeof(guint32);
static gsize const _ifOutDiscardsLength = sizeof(ifOutDiscards)/sizeof(guint32);
static gsize const _ifOutErrorsLength = sizeof(ifOutErrors)/sizeof(guint32);
static gsize const _ifOutQLenLength = sizeof(ifOutQLen)/sizeof(guint32);
static gsize const _ifSpecificLength = sizeof(ifSpecific)/sizeof(guint32);
static gsize const _ifNameLength = sizeof(ifName)/sizeof(guint32);
static gsize const _ifInMulticastPktsLength = sizeof(ifInMulticastPkts)/sizeof(guint32);
static gsize const _ifInBroadcastPktsLength = sizeof(ifInBroadcastPkts)/sizeof(guint32);
static gsize const _ifOutMulticastPktsLength = sizeof(ifOutMulticastPkts)/sizeof(guint32);
static gsize const _ifOutBroadcastPktsLength = sizeof(ifOutBroadcastPkts)/sizeof(guint32);
static gsize const _ifHCInOctetsLength = sizeof(ifHCInOctets)/sizeof(guint32);
static gsize const _ifHCInUcastPktsLength = sizeof(ifHCInUcastPkts)/sizeof(guint32);
static gsize const _ifHCInMulticastPktsLength = sizeof(ifHCInMulticastPkts)/sizeof(guint32);
static gsize const _ifHCInBroadcastPktsLength = sizeof(ifHCInBroadcastPkts)/sizeof(guint32);
static gsize const _ifHCOutOctetsLength = sizeof(ifHCOutOctets)/sizeof(guint32);
static gsize const _ifHCOutUcastPktsLength = sizeof(ifHCOutUcastPkts)/sizeof(guint32);
static gsize const _ifHCOutMulticastPktsLength = sizeof(ifHCOutMulticastPkts)/sizeof(guint32);
static gsize const _ifHCOutBroadcastPktsLength = sizeof(ifHCOutBroadcastPkts)/sizeof(guint32);
static gsize const _ifLinkUpDownTrapEnableLength = sizeof(ifLinkUpDownTrapEnable)/sizeof(guint32);
static gsize const _ifHighSpeedLength = sizeof(ifHighSpeed)/sizeof(guint32);
static gsize const _ifPromiscuousModeLength = sizeof(ifPromiscuousMode)/sizeof(guint32);
static gsize const _ifConnectorPresentLength = sizeof(ifConnectorPresent)/sizeof(guint32);
static gsize const _ifAliasLength = sizeof(ifAlias)/sizeof(guint32);
static gsize const _ifCounterDiscontinuityTimeLength = sizeof(ifCounterDiscontinuityTime)/sizeof(guint32);
static gsize const _ifStackHigherLayerLength = sizeof(ifStackHigherLayer)/sizeof(guint32);
static gsize const _ifStackLowerLayerLength = sizeof(ifStackLowerLayer)/sizeof(guint32);
static gsize const _ifStackStatusLength = sizeof(ifStackStatus)/sizeof(guint32);
static gsize const _ifTestIdLength = sizeof(ifTestId)/sizeof(guint32);
static gsize const _ifTestStatusLength = sizeof(ifTestStatus)/sizeof(guint32);
static gsize const _ifTestTypeLength = sizeof(ifTestType)/sizeof(guint32);
static gsize const _ifTestResultLength = sizeof(ifTestResult)/sizeof(guint32);
static gsize const _ifTestCodeLength = sizeof(ifTestCode)/sizeof(guint32);
static gsize const _ifTestOwnerLength = sizeof(ifTestOwner)/sizeof(guint32);
static gsize const _ifRcvAddressAddressLength = sizeof(ifRcvAddressAddress)/sizeof(guint32);
static gsize const _ifRcvAddressStatusLength = sizeof(ifRcvAddressStatus)/sizeof(guint32);
static gsize const _ifRcvAddressTypeLength = sizeof(ifRcvAddressType)/sizeof(guint32);
static gsize const _ifTableLastChangeLength = sizeof(ifTableLastChange)/sizeof(guint32);
static gsize const _ifStackLastChangeLength = sizeof(ifStackLastChange)/sizeof(guint32);

stls_table_t if_mib_enums_ifType[] = {
    { 1, "other" },
    { 2, "regular1822" },
    { 3, "hdh1822" },
    { 4, "ddnX25" },
    { 5, "rfc877x25" },
    { 6, "ethernetCsmacd" },
    { 7, "iso88023Csmacd" },
    { 8, "iso88024TokenBus" },
    { 9, "iso88025TokenRing" },
    { 10, "iso88026Man" },
    { 11, "starLan" },
    { 12, "proteon10Mbit" },
    { 13, "proteon80Mbit" },
    { 14, "hyperchannel" },
    { 15, "fddi" },
    { 16, "lapb" },
    { 17, "sdlc" },
    { 18, "ds1" },
    { 19, "e1" },
    { 20, "basicISDN" },
    { 21, "primaryISDN" },
    { 22, "propPointToPointSerial" },
    { 23, "ppp" },
    { 24, "softwareLoopback" },
    { 25, "eon" },
    { 26, "ethernet3Mbit" },
    { 27, "nsip" },
    { 28, "slip" },
    { 29, "ultra" },
    { 30, "ds3" },
    { 31, "sip" },
    { 32, "frameRelay" },
    { 33, "rs232" },
    { 34, "para" },
    { 35, "arcnet" },
    { 36, "arcnetPlus" },
    { 37, "atm" },
    { 38, "miox25" },
    { 39, "sonet" },
    { 40, "x25ple" },
    { 41, "iso88022llc" },
    { 42, "localTalk" },
    { 43, "smdsDxi" },
    { 44, "frameRelayService" },
    { 45, "v35" },
    { 46, "hssi" },
    { 47, "hippi" },
    { 48, "modem" },
    { 49, "aal5" },
    { 50, "sonetPath" },
    { 51, "sonetVT" },
    { 52, "smdsIcip" },
    { 53, "propVirtual" },
    { 54, "propMultiplexor" },
    { 55, "ieee80212" },
    { 56, "fibreChannel" },
    { 57, "hippiInterface" },
    { 58, "frameRelayInterconnect" },
    { 59, "aflane8023" },
    { 60, "aflane8025" },
    { 61, "cctEmul" },
    { 62, "fastEther" },
    { 63, "isdn" },
    { 64, "v11" },
    { 65, "v36" },
    { 66, "g703at64k" },
    { 67, "g703at2mb" },
    { 68, "qllc" },
    { 69, "fastEtherFX" },
    { 70, "channel" },
    { 71, "ieee80211" },
    { 72, "ibm370parChan" },
    { 73, "escon" },
    { 74, "dlsw" },
    { 75, "isdns" },
    { 76, "isdnu" },
    { 77, "lapd" },
    { 78, "ipSwitch" },
    { 79, "rsrb" },
    { 80, "atmLogical" },
    { 81, "ds0" },
    { 82, "ds0Bundle" },
    { 83, "bsc" },
    { 84, "async" },
    { 85, "cnr" },
    { 86, "iso88025Dtr" },
    { 87, "eplrs" },
    { 88, "arap" },
    { 89, "propCnls" },
    { 90, "hostPad" },
    { 91, "termPad" },
    { 92, "frameRelayMPI" },
    { 93, "x213" },
    { 94, "adsl" },
    { 95, "radsl" },
    { 96, "sdsl" },
    { 97, "vdsl" },
    { 98, "iso88025CRFPInt" },
    { 99, "myrinet" },
    { 100, "voiceEM" },
    { 101, "voiceFXO" },
    { 102, "voiceFXS" },
    { 103, "voiceEncap" },
    { 104, "voiceOverIp" },
    { 105, "atmDxi" },
    { 106, "atmFuni" },
    { 107, "atmIma" },
    { 108, "pppMultilinkBundle" },
    { 109, "ipOverCdlc" },
    { 110, "ipOverClaw" },
    { 111, "stackToStack" },
    { 112, "virtualIpAddress" },
    { 113, "mpc" },
    { 114, "ipOverAtm" },
    { 115, "iso88025Fiber" },
    { 116, "tdlc" },
    { 117, "gigabitEthernet" },
    { 118, "hdlc" },
    { 119, "lapf" },
    { 120, "v37" },
    { 121, "x25mlp" },
    { 122, "x25huntGroup" },
    { 123, "trasnpHdlc" },
    { 124, "interleave" },
    { 125, "fast" },
    { 126, "ip" },
    { 127, "docsCableMaclayer" },
    { 128, "docsCableDownstream" },
    { 129, "docsCableUpstream" },
    { 130, "a12MppSwitch" },
    { 131, "tunnel" },
    { 132, "coffee" },
    { 133, "ces" },
    { 134, "atmSubInterface" },
    { 135, "l2vlan" },
    { 136, "l3ipvlan" },
    { 137, "l3ipxvlan" },
    { 138, "digitalPowerline" },
    { 139, "mediaMailOverIp" },
    { 140, "dtm" },
    { 141, "dcn" },
    { 142, "ipForward" },
    { 143, "msdsl" },
    { 144, "ieee1394" },
    { 145, "if-gsn" },
    { 146, "dvbRccMacLayer" },
    { 147, "dvbRccDownstream" },
    { 148, "dvbRccUpstream" },
    { 149, "atmVirtual" },
    { 150, "mplsTunnel" },
    { 151, "srp" },
    { 152, "voiceOverAtm" },
    { 153, "voiceOverFrameRelay" },
    { 154, "idsl" },
    { 155, "compositeLink" },
    { 156, "ss7SigLink" },
    { 157, "propWirelessP2P" },
    { 158, "frForward" },
    { 159, "rfc1483" },
    { 160, "usb" },
    { 161, "ieee8023adLag" },
    { 162, "bgppolicyaccounting" },
    { 163, "frf16MfrBundle" },
    { 164, "h323Gatekeeper" },
    { 165, "h323Proxy" },
    { 166, "mpls" },
    { 167, "mfSigLink" },
    { 168, "hdsl2" },
    { 169, "shdsl" },
    { 170, "ds1FDL" },
    { 171, "pos" },
    { 172, "dvbAsiln" },
    { 173, "dvbAsiOut" },
    { 174, "plc" },
    { 175, "nfas" },
    { 176, "tr008" },
    { 177, "gr303RDT" },
    { 178, "gr303IDT" },
    { 179, "isup" },
    { 180, "propDocsWirelessMaclayer" },
    { 181, "propDocsWirelessDownstream" },
    { 182, "propDocsWirelessUpstream" },
    { 183, "hiperlan2" },
    { 184, "propBWAp2Mp" },
    { 185, "sonetOverheadChannel" },
    { 186, "digitalWrapperOverheadChannel" },
    { 187, "aal2" },
    { 188, "radioMAC" },
    { 189, "atmRadio" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifAdminStatus[] = {
    { 1, "up" },
    { 2, "down" },
    { 3, "testing" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifOperStatus[] = {
    { 1, "up" },
    { 2, "down" },
    { 3, "testing" },
    { 4, "unknown" },
    { 5, "dormant" },
    { 6, "notPresent" },
    { 7, "lowerLayerDown" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifLinkUpDownTrapEnable[] = {
    { 1, "enabled" },
    { 2, "disabled" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifPromiscuousMode[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifConnectorPresent[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifStackStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifTestStatus[] = {
    { 1, "notInUse" },
    { 2, "inUse" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifTestResult[] = {
    { 1, "none" },
    { 2, "success" },
    { 3, "inProgress" },
    { 4, "notSupported" },
    { 5, "unAbleToRun" },
    { 6, "aborted" },
    { 7, "failed" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifRcvAddressStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t if_mib_enums_ifRcvAddressType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 0, NULL }
};


static interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    interfaces_t *interfaces;
    char *p;

    interfaces = (interfaces_t *) g_malloc0(sizeof(interfaces_t) + sizeof(GSList *));
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifNumberLength
            && memcmp(vb->id, ifNumber, sizeof(ifNumber)) == 0) {
            interfaces->ifNumber = &(vb->syntax.i32[0]);
        }
    }

    return interfaces;
}

int
if_mib_get_interfaces(host_snmp *s, interfaces_t **interfaces)
{
    GSList *in = NULL, *out = NULL;

    *interfaces = NULL;

    stls_vbl_add_null(&in, ifNumber, _ifNumberLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *interfaces = assign_interfaces(out);

    return 0;
}

void
if_mib_free_interfaces(interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(interfaces_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(interfaces);
    }
}

static ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    ifEntry_t *ifEntry;
    char *p;

    ifEntry = (ifEntry_t *) g_malloc0(sizeof(ifEntry_t) + sizeof(GSList *));
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(ifEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifIndexLength
            && memcmp(vb->id, ifIndex, sizeof(ifIndex)) == 0) {
            ifEntry->ifIndex = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifDescrLength
            && memcmp(vb->id, ifDescr, sizeof(ifDescr)) == 0) {
            ifEntry->_ifDescrLength = vb->syntax_len;
            ifEntry->ifDescr = vb->syntax.uc;
        }
        if (vb->id_len > _ifTypeLength
            && memcmp(vb->id, ifType, sizeof(ifType)) == 0) {
            ifEntry->ifType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifMtuLength
            && memcmp(vb->id, ifMtu, sizeof(ifMtu)) == 0) {
            ifEntry->ifMtu = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifSpeedLength
            && memcmp(vb->id, ifSpeed, sizeof(ifSpeed)) == 0) {
            ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifPhysAddressLength
            && memcmp(vb->id, ifPhysAddress, sizeof(ifPhysAddress)) == 0) {
            ifEntry->_ifPhysAddressLength = vb->syntax_len;
            ifEntry->ifPhysAddress = vb->syntax.uc;
        }
        if (vb->id_len > _ifAdminStatusLength
            && memcmp(vb->id, ifAdminStatus, sizeof(ifAdminStatus)) == 0) {
            ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifOperStatusLength
            && memcmp(vb->id, ifOperStatus, sizeof(ifOperStatus)) == 0) {
            ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifLastChangeLength
            && memcmp(vb->id, ifLastChange, sizeof(ifLastChange)) == 0) {
            ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInOctetsLength
            && memcmp(vb->id, ifInOctets, sizeof(ifInOctets)) == 0) {
            ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInUcastPktsLength
            && memcmp(vb->id, ifInUcastPkts, sizeof(ifInUcastPkts)) == 0) {
            ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInNUcastPktsLength
            && memcmp(vb->id, ifInNUcastPkts, sizeof(ifInNUcastPkts)) == 0) {
            ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInDiscardsLength
            && memcmp(vb->id, ifInDiscards, sizeof(ifInDiscards)) == 0) {
            ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInErrorsLength
            && memcmp(vb->id, ifInErrors, sizeof(ifInErrors)) == 0) {
            ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInUnknownProtosLength
            && memcmp(vb->id, ifInUnknownProtos, sizeof(ifInUnknownProtos)) == 0) {
            ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutOctetsLength
            && memcmp(vb->id, ifOutOctets, sizeof(ifOutOctets)) == 0) {
            ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutUcastPktsLength
            && memcmp(vb->id, ifOutUcastPkts, sizeof(ifOutUcastPkts)) == 0) {
            ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutNUcastPktsLength
            && memcmp(vb->id, ifOutNUcastPkts, sizeof(ifOutNUcastPkts)) == 0) {
            ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutDiscardsLength
            && memcmp(vb->id, ifOutDiscards, sizeof(ifOutDiscards)) == 0) {
            ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutErrorsLength
            && memcmp(vb->id, ifOutErrors, sizeof(ifOutErrors)) == 0) {
            ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutQLenLength
            && memcmp(vb->id, ifOutQLen, sizeof(ifOutQLen)) == 0) {
            ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifSpecificLength
            && memcmp(vb->id, ifSpecific, sizeof(ifSpecific)) == 0) {
            ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
            ifEntry->ifSpecific = vb->syntax.ui32;
        }
    }

    return ifEntry;
}

int
if_mib_get_ifEntry(host_snmp *s, ifEntry_t ***ifEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *ifEntry = NULL;

    stls_vbl_add_null(&in, ifDescr, _ifDescrLength);
    stls_vbl_add_null(&in, ifType, _ifTypeLength);
    stls_vbl_add_null(&in, ifMtu, _ifMtuLength);
    stls_vbl_add_null(&in, ifSpeed, _ifSpeedLength);
    stls_vbl_add_null(&in, ifPhysAddress, _ifPhysAddressLength);
    stls_vbl_add_null(&in, ifAdminStatus, _ifAdminStatusLength);
    stls_vbl_add_null(&in, ifOperStatus, _ifOperStatusLength);
    stls_vbl_add_null(&in, ifLastChange, _ifLastChangeLength);
    stls_vbl_add_null(&in, ifInOctets, _ifInOctetsLength);
    stls_vbl_add_null(&in, ifInUcastPkts, _ifInUcastPktsLength);
    stls_vbl_add_null(&in, ifInNUcastPkts, _ifInNUcastPktsLength);
    stls_vbl_add_null(&in, ifInDiscards, _ifInDiscardsLength);
    stls_vbl_add_null(&in, ifInErrors, _ifInErrorsLength);
    stls_vbl_add_null(&in, ifInUnknownProtos, _ifInUnknownProtosLength);
    stls_vbl_add_null(&in, ifOutOctets, _ifOutOctetsLength);
    stls_vbl_add_null(&in, ifOutUcastPkts, _ifOutUcastPktsLength);
    stls_vbl_add_null(&in, ifOutNUcastPkts, _ifOutNUcastPktsLength);
    stls_vbl_add_null(&in, ifOutDiscards, _ifOutDiscardsLength);
    stls_vbl_add_null(&in, ifOutErrors, _ifOutErrorsLength);
    stls_vbl_add_null(&in, ifOutQLen, _ifOutQLenLength);
    stls_vbl_add_null(&in, ifSpecific, _ifSpecificLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifEntry = (ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifEntry_t *));
    if (! *ifEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifEntry)[i] = assign_ifEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifEntry(ifEntry_t **ifEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            p = (char *) ifEntry[i] + sizeof(ifEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

static ifMIBObjects_t *
assign_ifMIBObjects(GSList *vbl)
{
    GSList *elem;
    ifMIBObjects_t *ifMIBObjects;
    char *p;

    ifMIBObjects = (ifMIBObjects_t *) g_malloc0(sizeof(ifMIBObjects_t) + sizeof(GSList *));
    if (! ifMIBObjects) {
        return NULL;
    }

    p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifTableLastChangeLength
            && memcmp(vb->id, ifTableLastChange, sizeof(ifTableLastChange)) == 0) {
            ifMIBObjects->ifTableLastChange = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifStackLastChangeLength
            && memcmp(vb->id, ifStackLastChange, sizeof(ifStackLastChange)) == 0) {
            ifMIBObjects->ifStackLastChange = &(vb->syntax.ui32[0]);
        }
    }

    return ifMIBObjects;
}

int
if_mib_get_ifMIBObjects(host_snmp *s, ifMIBObjects_t **ifMIBObjects)
{
    GSList *in = NULL, *out = NULL;

    *ifMIBObjects = NULL;

    stls_vbl_add_null(&in, ifTableLastChange, _ifTableLastChangeLength);
    stls_vbl_add_null(&in, ifStackLastChange, _ifStackLastChangeLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ifMIBObjects = assign_ifMIBObjects(out);

    return 0;
}

void
if_mib_free_ifMIBObjects(ifMIBObjects_t *ifMIBObjects)
{
    GSList *vbl;
    char *p;

    if (ifMIBObjects) {
        p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifMIBObjects);
    }
}

static ifXEntry_t *
assign_ifXEntry(GSList *vbl)
{
    GSList *elem;
    ifXEntry_t *ifXEntry;
    char *p;

    ifXEntry = (ifXEntry_t *) g_malloc0(sizeof(ifXEntry_t) + sizeof(GSList *));
    if (! ifXEntry) {
        return NULL;
    }

    p = (char *) ifXEntry + sizeof(ifXEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifNameLength
            && memcmp(vb->id, ifName, sizeof(ifName)) == 0) {
            ifXEntry->_ifNameLength = vb->syntax_len;
            ifXEntry->ifName = vb->syntax.uc;
        }
        if (vb->id_len > _ifInMulticastPktsLength
            && memcmp(vb->id, ifInMulticastPkts, sizeof(ifInMulticastPkts)) == 0) {
            ifXEntry->ifInMulticastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifInBroadcastPktsLength
            && memcmp(vb->id, ifInBroadcastPkts, sizeof(ifInBroadcastPkts)) == 0) {
            ifXEntry->ifInBroadcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutMulticastPktsLength
            && memcmp(vb->id, ifOutMulticastPkts, sizeof(ifOutMulticastPkts)) == 0) {
            ifXEntry->ifOutMulticastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifOutBroadcastPktsLength
            && memcmp(vb->id, ifOutBroadcastPkts, sizeof(ifOutBroadcastPkts)) == 0) {
            ifXEntry->ifOutBroadcastPkts = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifHCInOctetsLength
            && memcmp(vb->id, ifHCInOctets, sizeof(ifHCInOctets)) == 0) {
            ifXEntry->ifHCInOctets = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCInUcastPktsLength
            && memcmp(vb->id, ifHCInUcastPkts, sizeof(ifHCInUcastPkts)) == 0) {
            ifXEntry->ifHCInUcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCInMulticastPktsLength
            && memcmp(vb->id, ifHCInMulticastPkts, sizeof(ifHCInMulticastPkts)) == 0) {
            ifXEntry->ifHCInMulticastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCInBroadcastPktsLength
            && memcmp(vb->id, ifHCInBroadcastPkts, sizeof(ifHCInBroadcastPkts)) == 0) {
            ifXEntry->ifHCInBroadcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCOutOctetsLength
            && memcmp(vb->id, ifHCOutOctets, sizeof(ifHCOutOctets)) == 0) {
            ifXEntry->ifHCOutOctets = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCOutUcastPktsLength
            && memcmp(vb->id, ifHCOutUcastPkts, sizeof(ifHCOutUcastPkts)) == 0) {
            ifXEntry->ifHCOutUcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCOutMulticastPktsLength
            && memcmp(vb->id, ifHCOutMulticastPkts, sizeof(ifHCOutMulticastPkts)) == 0) {
            ifXEntry->ifHCOutMulticastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifHCOutBroadcastPktsLength
            && memcmp(vb->id, ifHCOutBroadcastPkts, sizeof(ifHCOutBroadcastPkts)) == 0) {
            ifXEntry->ifHCOutBroadcastPkts = &(vb->syntax.ui64[0]);
        }
        if (vb->id_len > _ifLinkUpDownTrapEnableLength
            && memcmp(vb->id, ifLinkUpDownTrapEnable, sizeof(ifLinkUpDownTrapEnable)) == 0) {
            ifXEntry->ifLinkUpDownTrapEnable = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifHighSpeedLength
            && memcmp(vb->id, ifHighSpeed, sizeof(ifHighSpeed)) == 0) {
            ifXEntry->ifHighSpeed = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _ifPromiscuousModeLength
            && memcmp(vb->id, ifPromiscuousMode, sizeof(ifPromiscuousMode)) == 0) {
            ifXEntry->ifPromiscuousMode = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifConnectorPresentLength
            && memcmp(vb->id, ifConnectorPresent, sizeof(ifConnectorPresent)) == 0) {
            ifXEntry->ifConnectorPresent = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifAliasLength
            && memcmp(vb->id, ifAlias, sizeof(ifAlias)) == 0) {
            ifXEntry->_ifAliasLength = vb->syntax_len;
            ifXEntry->ifAlias = vb->syntax.uc;
        }
        if (vb->id_len > _ifCounterDiscontinuityTimeLength
            && memcmp(vb->id, ifCounterDiscontinuityTime, sizeof(ifCounterDiscontinuityTime)) == 0) {
            ifXEntry->ifCounterDiscontinuityTime = &(vb->syntax.ui32[0]);
        }
    }

    return ifXEntry;
}

int
if_mib_get_ifXEntry(host_snmp *s, ifXEntry_t ***ifXEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *ifXEntry = NULL;

    stls_vbl_add_null(&in, ifName, _ifNameLength);
    stls_vbl_add_null(&in, ifInMulticastPkts, _ifInMulticastPktsLength);
    stls_vbl_add_null(&in, ifInBroadcastPkts, _ifInBroadcastPktsLength);
    stls_vbl_add_null(&in, ifOutMulticastPkts, _ifOutMulticastPktsLength);
    stls_vbl_add_null(&in, ifOutBroadcastPkts, _ifOutBroadcastPktsLength);
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCInOctets, _ifHCInOctetsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCInUcastPkts, _ifHCInUcastPktsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCInMulticastPkts, _ifHCInMulticastPktsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCInBroadcastPkts, _ifHCInBroadcastPktsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCOutOctets, _ifHCOutOctetsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCOutUcastPkts, _ifHCOutUcastPktsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCOutMulticastPkts, _ifHCOutMulticastPktsLength);
}
    if (s->version > G_SNMP_V1) {
        stls_vbl_add_null(&in, ifHCOutBroadcastPkts, _ifHCOutBroadcastPktsLength);
}
    stls_vbl_add_null(&in, ifLinkUpDownTrapEnable, _ifLinkUpDownTrapEnableLength);
    stls_vbl_add_null(&in, ifHighSpeed, _ifHighSpeedLength);
    stls_vbl_add_null(&in, ifPromiscuousMode, _ifPromiscuousModeLength);
    stls_vbl_add_null(&in, ifConnectorPresent, _ifConnectorPresentLength);
    stls_vbl_add_null(&in, ifAlias, _ifAliasLength);
    stls_vbl_add_null(&in, ifCounterDiscontinuityTime, _ifCounterDiscontinuityTimeLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifXEntry = (ifXEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifXEntry_t *));
    if (! *ifXEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifXEntry)[i] = assign_ifXEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifXEntry(ifXEntry_t **ifXEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifXEntry) {
        for (i = 0; ifXEntry[i]; i++) {
            p = (char *) ifXEntry[i] + sizeof(ifXEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifXEntry[i]);
        }
        g_free(ifXEntry);
    }
}

static ifStackEntry_t *
assign_ifStackEntry(GSList *vbl)
{
    GSList *elem;
    ifStackEntry_t *ifStackEntry;
    char *p;

    ifStackEntry = (ifStackEntry_t *) g_malloc0(sizeof(ifStackEntry_t) + sizeof(GSList *));
    if (! ifStackEntry) {
        return NULL;
    }

    p = (char *) ifStackEntry + sizeof(ifStackEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifStackStatusLength
            && memcmp(vb->id, ifStackStatus, sizeof(ifStackStatus)) == 0) {
            ifStackEntry->ifStackStatus = &(vb->syntax.i32[0]);
        }
    }

    return ifStackEntry;
}

int
if_mib_get_ifStackEntry(host_snmp *s, ifStackEntry_t ***ifStackEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *ifStackEntry = NULL;

    stls_vbl_add_null(&in, ifStackStatus, _ifStackStatusLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifStackEntry = (ifStackEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifStackEntry_t *));
    if (! *ifStackEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifStackEntry)[i] = assign_ifStackEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifStackEntry(ifStackEntry_t **ifStackEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifStackEntry) {
        for (i = 0; ifStackEntry[i]; i++) {
            p = (char *) ifStackEntry[i] + sizeof(ifStackEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifStackEntry[i]);
        }
        g_free(ifStackEntry);
    }
}

static ifTestEntry_t *
assign_ifTestEntry(GSList *vbl)
{
    GSList *elem;
    ifTestEntry_t *ifTestEntry;
    char *p;

    ifTestEntry = (ifTestEntry_t *) g_malloc0(sizeof(ifTestEntry_t) + sizeof(GSList *));
    if (! ifTestEntry) {
        return NULL;
    }

    p = (char *) ifTestEntry + sizeof(ifTestEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifTestIdLength
            && memcmp(vb->id, ifTestId, sizeof(ifTestId)) == 0) {
            ifTestEntry->ifTestId = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifTestStatusLength
            && memcmp(vb->id, ifTestStatus, sizeof(ifTestStatus)) == 0) {
            ifTestEntry->ifTestStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifTestTypeLength
            && memcmp(vb->id, ifTestType, sizeof(ifTestType)) == 0) {
            ifTestEntry->_ifTestTypeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestType = vb->syntax.ui32;
        }
        if (vb->id_len > _ifTestResultLength
            && memcmp(vb->id, ifTestResult, sizeof(ifTestResult)) == 0) {
            ifTestEntry->ifTestResult = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifTestCodeLength
            && memcmp(vb->id, ifTestCode, sizeof(ifTestCode)) == 0) {
            ifTestEntry->_ifTestCodeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestCode = vb->syntax.ui32;
        }
        if (vb->id_len > _ifTestOwnerLength
            && memcmp(vb->id, ifTestOwner, sizeof(ifTestOwner)) == 0) {
            ifTestEntry->_ifTestOwnerLength = vb->syntax_len;
            ifTestEntry->ifTestOwner = vb->syntax.uc;
        }
    }

    return ifTestEntry;
}

int
if_mib_get_ifTestEntry(host_snmp *s, ifTestEntry_t ***ifTestEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *ifTestEntry = NULL;

    stls_vbl_add_null(&in, ifTestId, _ifTestIdLength);
    stls_vbl_add_null(&in, ifTestStatus, _ifTestStatusLength);
    stls_vbl_add_null(&in, ifTestType, _ifTestTypeLength);
    stls_vbl_add_null(&in, ifTestResult, _ifTestResultLength);
    stls_vbl_add_null(&in, ifTestCode, _ifTestCodeLength);
    stls_vbl_add_null(&in, ifTestOwner, _ifTestOwnerLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifTestEntry = (ifTestEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifTestEntry_t *));
    if (! *ifTestEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifTestEntry)[i] = assign_ifTestEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifTestEntry(ifTestEntry_t **ifTestEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifTestEntry) {
        for (i = 0; ifTestEntry[i]; i++) {
            p = (char *) ifTestEntry[i] + sizeof(ifTestEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifTestEntry[i]);
        }
        g_free(ifTestEntry);
    }
}

static ifRcvAddressEntry_t *
assign_ifRcvAddressEntry(GSList *vbl)
{
    GSList *elem;
    ifRcvAddressEntry_t *ifRcvAddressEntry;
    char *p;

    ifRcvAddressEntry = (ifRcvAddressEntry_t *) g_malloc0(sizeof(ifRcvAddressEntry_t) + sizeof(GSList *));
    if (! ifRcvAddressEntry) {
        return NULL;
    }

    p = (char *) ifRcvAddressEntry + sizeof(ifRcvAddressEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _ifRcvAddressStatusLength
            && memcmp(vb->id, ifRcvAddressStatus, sizeof(ifRcvAddressStatus)) == 0) {
            ifRcvAddressEntry->ifRcvAddressStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _ifRcvAddressTypeLength
            && memcmp(vb->id, ifRcvAddressType, sizeof(ifRcvAddressType)) == 0) {
            ifRcvAddressEntry->ifRcvAddressType = &(vb->syntax.i32[0]);
        }
    }

    return ifRcvAddressEntry;
}

int
if_mib_get_ifRcvAddressEntry(host_snmp *s, ifRcvAddressEntry_t ***ifRcvAddressEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *ifRcvAddressEntry = NULL;

    stls_vbl_add_null(&in, ifRcvAddressStatus, _ifRcvAddressStatusLength);
    stls_vbl_add_null(&in, ifRcvAddressType, _ifRcvAddressTypeLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifRcvAddressEntry = (ifRcvAddressEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifRcvAddressEntry_t *));
    if (! *ifRcvAddressEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifRcvAddressEntry)[i] = assign_ifRcvAddressEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifRcvAddressEntry(ifRcvAddressEntry_t **ifRcvAddressEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (ifRcvAddressEntry) {
        for (i = 0; ifRcvAddressEntry[i]; i++) {
            p = (char *) ifRcvAddressEntry[i] + sizeof(ifRcvAddressEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(ifRcvAddressEntry[i]);
        }
        g_free(ifRcvAddressEntry);
    }
}


