/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.14 for the stools package.
 *
 * Derived from IF-MIB:
 *   The MIB module to describe generic objects for network
 *   interface sub-layers.  This MIB is an updated version of
 *   MIB-II's ifTable, and incorporates the extensions defined in
 *   RFC 1229.
 *
 * Revision 2000-06-14 00:00:
 *   Clarifications agreed upon by the Interfaces MIB WG, and
 *   published as RFC 2863.
 *
 * Revision 1996-02-28 21:55:
 *   Revisions made by the Interfaces MIB WG, and published in
 *   RFC 2233.
 *
 * Revision 1993-11-08 21:55:
 *   Initial revision, published as part of RFC 1573.
 *
 * $Id$
 */

#include "if-mib.h"

stls_table_t const if_mib_enums_ifType[] = {
    { IF_MIB_IFTYPE_OTHER,	"other" },
    { IF_MIB_IFTYPE_REGULAR1822,	"regular1822" },
    { IF_MIB_IFTYPE_HDH1822,	"hdh1822" },
    { IF_MIB_IFTYPE_DDNX25,	"ddnX25" },
    { IF_MIB_IFTYPE_RFC877X25,	"rfc877x25" },
    { IF_MIB_IFTYPE_ETHERNETCSMACD,	"ethernetCsmacd" },
    { IF_MIB_IFTYPE_ISO88023CSMACD,	"iso88023Csmacd" },
    { IF_MIB_IFTYPE_ISO88024TOKENBUS,	"iso88024TokenBus" },
    { IF_MIB_IFTYPE_ISO88025TOKENRING,	"iso88025TokenRing" },
    { IF_MIB_IFTYPE_ISO88026MAN,	"iso88026Man" },
    { IF_MIB_IFTYPE_STARLAN,	"starLan" },
    { IF_MIB_IFTYPE_PROTEON10MBIT,	"proteon10Mbit" },
    { IF_MIB_IFTYPE_PROTEON80MBIT,	"proteon80Mbit" },
    { IF_MIB_IFTYPE_HYPERCHANNEL,	"hyperchannel" },
    { IF_MIB_IFTYPE_FDDI,	"fddi" },
    { IF_MIB_IFTYPE_LAPB,	"lapb" },
    { IF_MIB_IFTYPE_SDLC,	"sdlc" },
    { IF_MIB_IFTYPE_DS1,	"ds1" },
    { IF_MIB_IFTYPE_E1,	"e1" },
    { IF_MIB_IFTYPE_BASICISDN,	"basicISDN" },
    { IF_MIB_IFTYPE_PRIMARYISDN,	"primaryISDN" },
    { IF_MIB_IFTYPE_PROPPOINTTOPOINTSERIAL,	"propPointToPointSerial" },
    { IF_MIB_IFTYPE_PPP,	"ppp" },
    { IF_MIB_IFTYPE_SOFTWARELOOPBACK,	"softwareLoopback" },
    { IF_MIB_IFTYPE_EON,	"eon" },
    { IF_MIB_IFTYPE_ETHERNET3MBIT,	"ethernet3Mbit" },
    { IF_MIB_IFTYPE_NSIP,	"nsip" },
    { IF_MIB_IFTYPE_SLIP,	"slip" },
    { IF_MIB_IFTYPE_ULTRA,	"ultra" },
    { IF_MIB_IFTYPE_DS3,	"ds3" },
    { IF_MIB_IFTYPE_SIP,	"sip" },
    { IF_MIB_IFTYPE_FRAMERELAY,	"frameRelay" },
    { IF_MIB_IFTYPE_RS232,	"rs232" },
    { IF_MIB_IFTYPE_PARA,	"para" },
    { IF_MIB_IFTYPE_ARCNET,	"arcnet" },
    { IF_MIB_IFTYPE_ARCNETPLUS,	"arcnetPlus" },
    { IF_MIB_IFTYPE_ATM,	"atm" },
    { IF_MIB_IFTYPE_MIOX25,	"miox25" },
    { IF_MIB_IFTYPE_SONET,	"sonet" },
    { IF_MIB_IFTYPE_X25PLE,	"x25ple" },
    { IF_MIB_IFTYPE_ISO88022LLC,	"iso88022llc" },
    { IF_MIB_IFTYPE_LOCALTALK,	"localTalk" },
    { IF_MIB_IFTYPE_SMDSDXI,	"smdsDxi" },
    { IF_MIB_IFTYPE_FRAMERELAYSERVICE,	"frameRelayService" },
    { IF_MIB_IFTYPE_V35,	"v35" },
    { IF_MIB_IFTYPE_HSSI,	"hssi" },
    { IF_MIB_IFTYPE_HIPPI,	"hippi" },
    { IF_MIB_IFTYPE_MODEM,	"modem" },
    { IF_MIB_IFTYPE_AAL5,	"aal5" },
    { IF_MIB_IFTYPE_SONETPATH,	"sonetPath" },
    { IF_MIB_IFTYPE_SONETVT,	"sonetVT" },
    { IF_MIB_IFTYPE_SMDSICIP,	"smdsIcip" },
    { IF_MIB_IFTYPE_PROPVIRTUAL,	"propVirtual" },
    { IF_MIB_IFTYPE_PROPMULTIPLEXOR,	"propMultiplexor" },
    { IF_MIB_IFTYPE_IEEE80212,	"ieee80212" },
    { IF_MIB_IFTYPE_FIBRECHANNEL,	"fibreChannel" },
    { IF_MIB_IFTYPE_HIPPIINTERFACE,	"hippiInterface" },
    { IF_MIB_IFTYPE_FRAMERELAYINTERCONNECT,	"frameRelayInterconnect" },
    { IF_MIB_IFTYPE_AFLANE8023,	"aflane8023" },
    { IF_MIB_IFTYPE_AFLANE8025,	"aflane8025" },
    { IF_MIB_IFTYPE_CCTEMUL,	"cctEmul" },
    { IF_MIB_IFTYPE_FASTETHER,	"fastEther" },
    { IF_MIB_IFTYPE_ISDN,	"isdn" },
    { IF_MIB_IFTYPE_V11,	"v11" },
    { IF_MIB_IFTYPE_V36,	"v36" },
    { IF_MIB_IFTYPE_G703AT64K,	"g703at64k" },
    { IF_MIB_IFTYPE_G703AT2MB,	"g703at2mb" },
    { IF_MIB_IFTYPE_QLLC,	"qllc" },
    { IF_MIB_IFTYPE_FASTETHERFX,	"fastEtherFX" },
    { IF_MIB_IFTYPE_CHANNEL,	"channel" },
    { IF_MIB_IFTYPE_IEEE80211,	"ieee80211" },
    { IF_MIB_IFTYPE_IBM370PARCHAN,	"ibm370parChan" },
    { IF_MIB_IFTYPE_ESCON,	"escon" },
    { IF_MIB_IFTYPE_DLSW,	"dlsw" },
    { IF_MIB_IFTYPE_ISDNS,	"isdns" },
    { IF_MIB_IFTYPE_ISDNU,	"isdnu" },
    { IF_MIB_IFTYPE_LAPD,	"lapd" },
    { IF_MIB_IFTYPE_IPSWITCH,	"ipSwitch" },
    { IF_MIB_IFTYPE_RSRB,	"rsrb" },
    { IF_MIB_IFTYPE_ATMLOGICAL,	"atmLogical" },
    { IF_MIB_IFTYPE_DS0,	"ds0" },
    { IF_MIB_IFTYPE_DS0BUNDLE,	"ds0Bundle" },
    { IF_MIB_IFTYPE_BSC,	"bsc" },
    { IF_MIB_IFTYPE_ASYNC,	"async" },
    { IF_MIB_IFTYPE_CNR,	"cnr" },
    { IF_MIB_IFTYPE_ISO88025DTR,	"iso88025Dtr" },
    { IF_MIB_IFTYPE_EPLRS,	"eplrs" },
    { IF_MIB_IFTYPE_ARAP,	"arap" },
    { IF_MIB_IFTYPE_PROPCNLS,	"propCnls" },
    { IF_MIB_IFTYPE_HOSTPAD,	"hostPad" },
    { IF_MIB_IFTYPE_TERMPAD,	"termPad" },
    { IF_MIB_IFTYPE_FRAMERELAYMPI,	"frameRelayMPI" },
    { IF_MIB_IFTYPE_X213,	"x213" },
    { IF_MIB_IFTYPE_ADSL,	"adsl" },
    { IF_MIB_IFTYPE_RADSL,	"radsl" },
    { IF_MIB_IFTYPE_SDSL,	"sdsl" },
    { IF_MIB_IFTYPE_VDSL,	"vdsl" },
    { IF_MIB_IFTYPE_ISO88025CRFPINT,	"iso88025CRFPInt" },
    { IF_MIB_IFTYPE_MYRINET,	"myrinet" },
    { IF_MIB_IFTYPE_VOICEEM,	"voiceEM" },
    { IF_MIB_IFTYPE_VOICEFXO,	"voiceFXO" },
    { IF_MIB_IFTYPE_VOICEFXS,	"voiceFXS" },
    { IF_MIB_IFTYPE_VOICEENCAP,	"voiceEncap" },
    { IF_MIB_IFTYPE_VOICEOVERIP,	"voiceOverIp" },
    { IF_MIB_IFTYPE_ATMDXI,	"atmDxi" },
    { IF_MIB_IFTYPE_ATMFUNI,	"atmFuni" },
    { IF_MIB_IFTYPE_ATMIMA,	"atmIma" },
    { IF_MIB_IFTYPE_PPPMULTILINKBUNDLE,	"pppMultilinkBundle" },
    { IF_MIB_IFTYPE_IPOVERCDLC,	"ipOverCdlc" },
    { IF_MIB_IFTYPE_IPOVERCLAW,	"ipOverClaw" },
    { IF_MIB_IFTYPE_STACKTOSTACK,	"stackToStack" },
    { IF_MIB_IFTYPE_VIRTUALIPADDRESS,	"virtualIpAddress" },
    { IF_MIB_IFTYPE_MPC,	"mpc" },
    { IF_MIB_IFTYPE_IPOVERATM,	"ipOverAtm" },
    { IF_MIB_IFTYPE_ISO88025FIBER,	"iso88025Fiber" },
    { IF_MIB_IFTYPE_TDLC,	"tdlc" },
    { IF_MIB_IFTYPE_GIGABITETHERNET,	"gigabitEthernet" },
    { IF_MIB_IFTYPE_HDLC,	"hdlc" },
    { IF_MIB_IFTYPE_LAPF,	"lapf" },
    { IF_MIB_IFTYPE_V37,	"v37" },
    { IF_MIB_IFTYPE_X25MLP,	"x25mlp" },
    { IF_MIB_IFTYPE_X25HUNTGROUP,	"x25huntGroup" },
    { IF_MIB_IFTYPE_TRASNPHDLC,	"trasnpHdlc" },
    { IF_MIB_IFTYPE_INTERLEAVE,	"interleave" },
    { IF_MIB_IFTYPE_FAST,	"fast" },
    { IF_MIB_IFTYPE_IP,	"ip" },
    { IF_MIB_IFTYPE_DOCSCABLEMACLAYER,	"docsCableMaclayer" },
    { IF_MIB_IFTYPE_DOCSCABLEDOWNSTREAM,	"docsCableDownstream" },
    { IF_MIB_IFTYPE_DOCSCABLEUPSTREAM,	"docsCableUpstream" },
    { IF_MIB_IFTYPE_A12MPPSWITCH,	"a12MppSwitch" },
    { IF_MIB_IFTYPE_TUNNEL,	"tunnel" },
    { IF_MIB_IFTYPE_COFFEE,	"coffee" },
    { IF_MIB_IFTYPE_CES,	"ces" },
    { IF_MIB_IFTYPE_ATMSUBINTERFACE,	"atmSubInterface" },
    { IF_MIB_IFTYPE_L2VLAN,	"l2vlan" },
    { IF_MIB_IFTYPE_L3IPVLAN,	"l3ipvlan" },
    { IF_MIB_IFTYPE_L3IPXVLAN,	"l3ipxvlan" },
    { IF_MIB_IFTYPE_DIGITALPOWERLINE,	"digitalPowerline" },
    { IF_MIB_IFTYPE_MEDIAMAILOVERIP,	"mediaMailOverIp" },
    { IF_MIB_IFTYPE_DTM,	"dtm" },
    { IF_MIB_IFTYPE_DCN,	"dcn" },
    { IF_MIB_IFTYPE_IPFORWARD,	"ipForward" },
    { IF_MIB_IFTYPE_MSDSL,	"msdsl" },
    { IF_MIB_IFTYPE_IEEE1394,	"ieee1394" },
    { IF_MIB_IFTYPE_IF_GSN,	"if-gsn" },
    { IF_MIB_IFTYPE_DVBRCCMACLAYER,	"dvbRccMacLayer" },
    { IF_MIB_IFTYPE_DVBRCCDOWNSTREAM,	"dvbRccDownstream" },
    { IF_MIB_IFTYPE_DVBRCCUPSTREAM,	"dvbRccUpstream" },
    { IF_MIB_IFTYPE_ATMVIRTUAL,	"atmVirtual" },
    { IF_MIB_IFTYPE_MPLSTUNNEL,	"mplsTunnel" },
    { IF_MIB_IFTYPE_SRP,	"srp" },
    { IF_MIB_IFTYPE_VOICEOVERATM,	"voiceOverAtm" },
    { IF_MIB_IFTYPE_VOICEOVERFRAMERELAY,	"voiceOverFrameRelay" },
    { IF_MIB_IFTYPE_IDSL,	"idsl" },
    { IF_MIB_IFTYPE_COMPOSITELINK,	"compositeLink" },
    { IF_MIB_IFTYPE_SS7SIGLINK,	"ss7SigLink" },
    { IF_MIB_IFTYPE_PROPWIRELESSP2P,	"propWirelessP2P" },
    { IF_MIB_IFTYPE_FRFORWARD,	"frForward" },
    { IF_MIB_IFTYPE_RFC1483,	"rfc1483" },
    { IF_MIB_IFTYPE_USB,	"usb" },
    { IF_MIB_IFTYPE_IEEE8023ADLAG,	"ieee8023adLag" },
    { IF_MIB_IFTYPE_BGPPOLICYACCOUNTING,	"bgppolicyaccounting" },
    { IF_MIB_IFTYPE_FRF16MFRBUNDLE,	"frf16MfrBundle" },
    { IF_MIB_IFTYPE_H323GATEKEEPER,	"h323Gatekeeper" },
    { IF_MIB_IFTYPE_H323PROXY,	"h323Proxy" },
    { IF_MIB_IFTYPE_MPLS,	"mpls" },
    { IF_MIB_IFTYPE_MFSIGLINK,	"mfSigLink" },
    { IF_MIB_IFTYPE_HDSL2,	"hdsl2" },
    { IF_MIB_IFTYPE_SHDSL,	"shdsl" },
    { IF_MIB_IFTYPE_DS1FDL,	"ds1FDL" },
    { IF_MIB_IFTYPE_POS,	"pos" },
    { IF_MIB_IFTYPE_DVBASILN,	"dvbAsiln" },
    { IF_MIB_IFTYPE_DVBASIOUT,	"dvbAsiOut" },
    { IF_MIB_IFTYPE_PLC,	"plc" },
    { IF_MIB_IFTYPE_NFAS,	"nfas" },
    { IF_MIB_IFTYPE_TR008,	"tr008" },
    { IF_MIB_IFTYPE_GR303RDT,	"gr303RDT" },
    { IF_MIB_IFTYPE_GR303IDT,	"gr303IDT" },
    { IF_MIB_IFTYPE_ISUP,	"isup" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSMACLAYER,	"propDocsWirelessMaclayer" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSDOWNSTREAM,	"propDocsWirelessDownstream" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSUPSTREAM,	"propDocsWirelessUpstream" },
    { IF_MIB_IFTYPE_HIPERLAN2,	"hiperlan2" },
    { IF_MIB_IFTYPE_PROPBWAP2MP,	"propBWAp2Mp" },
    { IF_MIB_IFTYPE_SONETOVERHEADCHANNEL,	"sonetOverheadChannel" },
    { IF_MIB_IFTYPE_DIGITALWRAPPEROVERHEADCHANNEL,	"digitalWrapperOverheadChannel" },
    { IF_MIB_IFTYPE_AAL2,	"aal2" },
    { IF_MIB_IFTYPE_RADIOMAC,	"radioMAC" },
    { IF_MIB_IFTYPE_ATMRADIO,	"atmRadio" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifAdminStatus[] = {
    { IF_MIB_IFADMINSTATUS_UP,	"up" },
    { IF_MIB_IFADMINSTATUS_DOWN,	"down" },
    { IF_MIB_IFADMINSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifOperStatus[] = {
    { IF_MIB_IFOPERSTATUS_UP,	"up" },
    { IF_MIB_IFOPERSTATUS_DOWN,	"down" },
    { IF_MIB_IFOPERSTATUS_TESTING,	"testing" },
    { IF_MIB_IFOPERSTATUS_UNKNOWN,	"unknown" },
    { IF_MIB_IFOPERSTATUS_DORMANT,	"dormant" },
    { IF_MIB_IFOPERSTATUS_NOTPRESENT,	"notPresent" },
    { IF_MIB_IFOPERSTATUS_LOWERLAYERDOWN,	"lowerLayerDown" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifLinkUpDownTrapEnable[] = {
    { IF_MIB_IFLINKUPDOWNTRAPENABLE_ENABLED,	"enabled" },
    { IF_MIB_IFLINKUPDOWNTRAPENABLE_DISABLED,	"disabled" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifPromiscuousMode[] = {
    { IF_MIB_IFPROMISCUOUSMODE_TRUE,	"true" },
    { IF_MIB_IFPROMISCUOUSMODE_FALSE,	"false" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifConnectorPresent[] = {
    { IF_MIB_IFCONNECTORPRESENT_TRUE,	"true" },
    { IF_MIB_IFCONNECTORPRESENT_FALSE,	"false" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifStackStatus[] = {
    { IF_MIB_IFSTACKSTATUS_ACTIVE,	"active" },
    { IF_MIB_IFSTACKSTATUS_NOTINSERVICE,	"notInService" },
    { IF_MIB_IFSTACKSTATUS_NOTREADY,	"notReady" },
    { IF_MIB_IFSTACKSTATUS_CREATEANDGO,	"createAndGo" },
    { IF_MIB_IFSTACKSTATUS_CREATEANDWAIT,	"createAndWait" },
    { IF_MIB_IFSTACKSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifTestStatus[] = {
    { IF_MIB_IFTESTSTATUS_NOTINUSE,	"notInUse" },
    { IF_MIB_IFTESTSTATUS_INUSE,	"inUse" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifTestResult[] = {
    { IF_MIB_IFTESTRESULT_NONE,	"none" },
    { IF_MIB_IFTESTRESULT_SUCCESS,	"success" },
    { IF_MIB_IFTESTRESULT_INPROGRESS,	"inProgress" },
    { IF_MIB_IFTESTRESULT_NOTSUPPORTED,	"notSupported" },
    { IF_MIB_IFTESTRESULT_UNABLETORUN,	"unAbleToRun" },
    { IF_MIB_IFTESTRESULT_ABORTED,	"aborted" },
    { IF_MIB_IFTESTRESULT_FAILED,	"failed" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifRcvAddressStatus[] = {
    { IF_MIB_IFRCVADDRESSSTATUS_ACTIVE,	"active" },
    { IF_MIB_IFRCVADDRESSSTATUS_NOTINSERVICE,	"notInService" },
    { IF_MIB_IFRCVADDRESSSTATUS_NOTREADY,	"notReady" },
    { IF_MIB_IFRCVADDRESSSTATUS_CREATEANDGO,	"createAndGo" },
    { IF_MIB_IFRCVADDRESSSTATUS_CREATEANDWAIT,	"createAndWait" },
    { IF_MIB_IFRCVADDRESSSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_table_t const if_mib_enums_ifRcvAddressType[] = {
    { IF_MIB_IFRCVADDRESSTYPE_OTHER,	"other" },
    { IF_MIB_IFRCVADDRESSTYPE_VOLATILE,	"volatile" },
    { IF_MIB_IFRCVADDRESSTYPE_NONVOLATILE,	"nonVolatile" },
    { 0, NULL }
};


interfaces_t *
if_mib_new_interfaces()
{
    interfaces_t *interfaces;

    interfaces = (interfaces_t *) g_malloc0(sizeof(interfaces_t) + sizeof(gpointer));
    return interfaces;
}

static interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    interfaces_t *interfaces;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2};

    interfaces = if_mib_new_interfaces();
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 8 && vb->id[7] == 1) {
            if (vb->type == G_SNMP_INTEGER32) {
                interfaces->ifNumber = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifNumber");
            }
        }
    }

    return interfaces;
}

int
if_mib_get_interfaces(host_snmp *s, interfaces_t **interfaces)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 0};

    *interfaces = NULL;

    base[7] = 1; stls_vbl_add_null(&in, base, 8);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *interfaces = assign_interfaces(out);

    return 0;
}

void
if_mib_free_interfaces(interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(interfaces_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(interfaces);
    }
}

ifEntry_t *
if_mib_new_ifEntry()
{
    ifEntry_t *ifEntry;

    ifEntry = (ifEntry_t *) g_malloc0(sizeof(ifEntry_t) + sizeof(gpointer));
    return ifEntry;
}

static int
unpack_ifEntry(GSnmpVarBind *vb, ifEntry_t *ifEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    ifEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    ifEntry_t *ifEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1};

    ifEntry = if_mib_new_ifEntry();
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(ifEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifEntry((GSnmpVarBind *) vbl->data, ifEntry) < 0) {
        g_warning("illegal ifEntry instance identifier");
        g_free(ifEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 2) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                ifEntry->_ifDescrLength = vb->syntax_len;
                ifEntry->ifDescr = vb->syntax.uc;
            } else {
                g_warning("illegal type for ifDescr");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 3) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifEntry->ifType = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifType");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 4) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifEntry->ifMtu = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifMtu");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 5) {
            if (vb->type == G_SNMP_UNSIGNED32) {
                ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifSpeed");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 6) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                ifEntry->_ifPhysAddressLength = vb->syntax_len;
                ifEntry->ifPhysAddress = vb->syntax.uc;
            } else {
                g_warning("illegal type for ifPhysAddress");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 7) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifAdminStatus");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 8) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifOperStatus");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 9) {
            if (vb->type == G_SNMP_TIMETICKS) {
                ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifLastChange");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 10) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInOctets");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 11) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInUcastPkts");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 12) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInNUcastPkts");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 13) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInDiscards");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 14) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInErrors");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 15) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInUnknownProtos");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 16) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutOctets");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 17) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutUcastPkts");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 18) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutNUcastPkts");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 19) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutDiscards");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 20) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutErrors");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 21) {
            if (vb->type == G_SNMP_UNSIGNED32) {
                ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutQLen");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 22) {
            if (vb->type == G_SNMP_OBJECT_ID) {
                ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
                ifEntry->ifSpecific = vb->syntax.ui32;
            } else {
                g_warning("illegal type for ifSpecific");
            }
        }
    }

    return ifEntry;
}

int
if_mib_get_ifTable(host_snmp *s, ifEntry_t ***ifEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 0};

    *ifEntry = NULL;

    base[9] = 2; stls_vbl_add_null(&in, base, 10);
    base[9] = 3; stls_vbl_add_null(&in, base, 10);
    base[9] = 4; stls_vbl_add_null(&in, base, 10);
    base[9] = 5; stls_vbl_add_null(&in, base, 10);
    base[9] = 6; stls_vbl_add_null(&in, base, 10);
    base[9] = 7; stls_vbl_add_null(&in, base, 10);
    base[9] = 8; stls_vbl_add_null(&in, base, 10);
    base[9] = 9; stls_vbl_add_null(&in, base, 10);
    base[9] = 10; stls_vbl_add_null(&in, base, 10);
    base[9] = 11; stls_vbl_add_null(&in, base, 10);
    base[9] = 12; stls_vbl_add_null(&in, base, 10);
    base[9] = 13; stls_vbl_add_null(&in, base, 10);
    base[9] = 14; stls_vbl_add_null(&in, base, 10);
    base[9] = 15; stls_vbl_add_null(&in, base, 10);
    base[9] = 16; stls_vbl_add_null(&in, base, 10);
    base[9] = 17; stls_vbl_add_null(&in, base, 10);
    base[9] = 18; stls_vbl_add_null(&in, base, 10);
    base[9] = 19; stls_vbl_add_null(&in, base, 10);
    base[9] = 20; stls_vbl_add_null(&in, base, 10);
    base[9] = 21; stls_vbl_add_null(&in, base, 10);
    base[9] = 22; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifEntry = (ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifEntry_t *));
    if (! *ifEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifEntry)[i] = assign_ifEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifEntry(ifEntry_t *ifEntry)
{
    GSList *vbl;
    char *p;

    if (ifEntry) {
        p = (char *) ifEntry + sizeof(ifEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifEntry);
    }
}

void
if_mib_free_ifTable(ifEntry_t **ifEntry)
{
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            if_mib_free_ifEntry(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

ifMIBObjects_t *
if_mib_new_ifMIBObjects()
{
    ifMIBObjects_t *ifMIBObjects;

    ifMIBObjects = (ifMIBObjects_t *) g_malloc0(sizeof(ifMIBObjects_t) + sizeof(gpointer));
    return ifMIBObjects;
}

static ifMIBObjects_t *
assign_ifMIBObjects(GSList *vbl)
{
    GSList *elem;
    ifMIBObjects_t *ifMIBObjects;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1};

    ifMIBObjects = if_mib_new_ifMIBObjects();
    if (! ifMIBObjects) {
        return NULL;
    }

    p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 9 && vb->id[8] == 5) {
            if (vb->type == G_SNMP_TIMETICKS) {
                ifMIBObjects->ifTableLastChange = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifTableLastChange");
            }
        }
        if (vb->id_len > 9 && vb->id[8] == 6) {
            if (vb->type == G_SNMP_TIMETICKS) {
                ifMIBObjects->ifStackLastChange = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifStackLastChange");
            }
        }
    }

    return ifMIBObjects;
}

int
if_mib_get_ifMIBObjects(host_snmp *s, ifMIBObjects_t **ifMIBObjects)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 0};

    *ifMIBObjects = NULL;

    base[8] = 5; stls_vbl_add_null(&in, base, 9);
    base[8] = 6; stls_vbl_add_null(&in, base, 9);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ifMIBObjects = assign_ifMIBObjects(out);

    return 0;
}

void
if_mib_free_ifMIBObjects(ifMIBObjects_t *ifMIBObjects)
{
    GSList *vbl;
    char *p;

    if (ifMIBObjects) {
        p = (char *) ifMIBObjects + sizeof(ifMIBObjects_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifMIBObjects);
    }
}

ifXEntry_t *
if_mib_new_ifXEntry()
{
    ifXEntry_t *ifXEntry;

    ifXEntry = (ifXEntry_t *) g_malloc0(sizeof(ifXEntry_t) + sizeof(gpointer));
    return ifXEntry;
}

static int
unpack_ifXEntry(GSnmpVarBind *vb, ifXEntry_t *ifXEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifXEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ifXEntry_t *
assign_ifXEntry(GSList *vbl)
{
    GSList *elem;
    ifXEntry_t *ifXEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1};

    ifXEntry = if_mib_new_ifXEntry();
    if (! ifXEntry) {
        return NULL;
    }

    p = (char *) ifXEntry + sizeof(ifXEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifXEntry((GSnmpVarBind *) vbl->data, ifXEntry) < 0) {
        g_warning("illegal ifXEntry instance identifier");
        g_free(ifXEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 1) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                ifXEntry->_ifNameLength = vb->syntax_len;
                ifXEntry->ifName = vb->syntax.uc;
            } else {
                g_warning("illegal type for ifName");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifXEntry->ifInMulticastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInMulticastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifXEntry->ifInBroadcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifInBroadcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifXEntry->ifOutMulticastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutMulticastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            if (vb->type == G_SNMP_COUNTER32) {
                ifXEntry->ifOutBroadcastPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifOutBroadcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 6) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCInOctets = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCInOctets");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 7) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCInUcastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCInUcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 8) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCInMulticastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCInMulticastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 9) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCInBroadcastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCInBroadcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 10) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCOutOctets = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCOutOctets");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 11) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCOutUcastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCOutUcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 12) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCOutMulticastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCOutMulticastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 13) {
            if (vb->type == G_SNMP_COUNTER64) {
                ifXEntry->ifHCOutBroadcastPkts = &(vb->syntax.ui64[0]);
            } else {
                g_warning("illegal type for ifHCOutBroadcastPkts");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 14) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifXEntry->ifLinkUpDownTrapEnable = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifLinkUpDownTrapEnable");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 15) {
            if (vb->type == G_SNMP_UNSIGNED32) {
                ifXEntry->ifHighSpeed = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifHighSpeed");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 16) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifXEntry->ifPromiscuousMode = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifPromiscuousMode");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 17) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifXEntry->ifConnectorPresent = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifConnectorPresent");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 18) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                ifXEntry->_ifAliasLength = vb->syntax_len;
                ifXEntry->ifAlias = vb->syntax.uc;
            } else {
                g_warning("illegal type for ifAlias");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 19) {
            if (vb->type == G_SNMP_TIMETICKS) {
                ifXEntry->ifCounterDiscontinuityTime = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for ifCounterDiscontinuityTime");
            }
        }
    }

    return ifXEntry;
}

int
if_mib_get_ifXTable(host_snmp *s, ifXEntry_t ***ifXEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 0};

    *ifXEntry = NULL;

    base[10] = 1; stls_vbl_add_null(&in, base, 11);
    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);
    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);
    if (s->version > G_SNMP_V1) {
        base[10] = 6; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 7; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 8; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 9; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 10; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 11; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 12; stls_vbl_add_null(&in, base, 11);
    }
    if (s->version > G_SNMP_V1) {
        base[10] = 13; stls_vbl_add_null(&in, base, 11);
    }
    base[10] = 14; stls_vbl_add_null(&in, base, 11);
    base[10] = 15; stls_vbl_add_null(&in, base, 11);
    base[10] = 16; stls_vbl_add_null(&in, base, 11);
    base[10] = 17; stls_vbl_add_null(&in, base, 11);
    base[10] = 18; stls_vbl_add_null(&in, base, 11);
    base[10] = 19; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifXEntry = (ifXEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifXEntry_t *));
    if (! *ifXEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifXEntry)[i] = assign_ifXEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifXEntry(ifXEntry_t *ifXEntry)
{
    GSList *vbl;
    char *p;

    if (ifXEntry) {
        p = (char *) ifXEntry + sizeof(ifXEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifXEntry);
    }
}

void
if_mib_free_ifXTable(ifXEntry_t **ifXEntry)
{
    int i;

    if (ifXEntry) {
        for (i = 0; ifXEntry[i]; i++) {
            if_mib_free_ifXEntry(ifXEntry[i]);
        }
        g_free(ifXEntry);
    }
}

ifStackEntry_t *
if_mib_new_ifStackEntry()
{
    ifStackEntry_t *ifStackEntry;

    ifStackEntry = (ifStackEntry_t *) g_malloc0(sizeof(ifStackEntry_t) + sizeof(gpointer));
    return ifStackEntry;
}

static int
unpack_ifStackEntry(GSnmpVarBind *vb, ifStackEntry_t *ifStackEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifStackEntry->ifStackHigherLayer = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    ifStackEntry->ifStackLowerLayer = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ifStackEntry_t *
assign_ifStackEntry(GSList *vbl)
{
    GSList *elem;
    ifStackEntry_t *ifStackEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1};

    ifStackEntry = if_mib_new_ifStackEntry();
    if (! ifStackEntry) {
        return NULL;
    }

    p = (char *) ifStackEntry + sizeof(ifStackEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifStackEntry((GSnmpVarBind *) vbl->data, ifStackEntry) < 0) {
        g_warning("illegal ifStackEntry instance identifier");
        g_free(ifStackEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifStackEntry->ifStackStatus = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifStackStatus");
            }
        }
    }

    return ifStackEntry;
}

int
if_mib_get_ifStackTable(host_snmp *s, ifStackEntry_t ***ifStackEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 0};

    *ifStackEntry = NULL;

    base[10] = 3; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifStackEntry = (ifStackEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifStackEntry_t *));
    if (! *ifStackEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifStackEntry)[i] = assign_ifStackEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifStackEntry(ifStackEntry_t *ifStackEntry)
{
    GSList *vbl;
    char *p;

    if (ifStackEntry) {
        p = (char *) ifStackEntry + sizeof(ifStackEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifStackEntry);
    }
}

void
if_mib_free_ifStackTable(ifStackEntry_t **ifStackEntry)
{
    int i;

    if (ifStackEntry) {
        for (i = 0; ifStackEntry[i]; i++) {
            if_mib_free_ifStackEntry(ifStackEntry[i]);
        }
        g_free(ifStackEntry);
    }
}

ifTestEntry_t *
if_mib_new_ifTestEntry()
{
    ifTestEntry_t *ifTestEntry;

    ifTestEntry = (ifTestEntry_t *) g_malloc0(sizeof(ifTestEntry_t) + sizeof(gpointer));
    return ifTestEntry;
}

static int
unpack_ifTestEntry(GSnmpVarBind *vb, ifTestEntry_t *ifTestEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifTestEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ifTestEntry_t *
assign_ifTestEntry(GSList *vbl)
{
    GSList *elem;
    ifTestEntry_t *ifTestEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1};

    ifTestEntry = if_mib_new_ifTestEntry();
    if (! ifTestEntry) {
        return NULL;
    }

    p = (char *) ifTestEntry + sizeof(ifTestEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifTestEntry((GSnmpVarBind *) vbl->data, ifTestEntry) < 0) {
        g_warning("illegal ifTestEntry instance identifier");
        g_free(ifTestEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 1) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifTestEntry->ifTestId = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifTestId");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifTestEntry->ifTestStatus = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifTestStatus");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            if (vb->type == G_SNMP_OBJECT_ID) {
                ifTestEntry->_ifTestTypeLength = vb->syntax_len / sizeof(guint32);
                ifTestEntry->ifTestType = vb->syntax.ui32;
            } else {
                g_warning("illegal type for ifTestType");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifTestEntry->ifTestResult = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifTestResult");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            if (vb->type == G_SNMP_OBJECT_ID) {
                ifTestEntry->_ifTestCodeLength = vb->syntax_len / sizeof(guint32);
                ifTestEntry->ifTestCode = vb->syntax.ui32;
            } else {
                g_warning("illegal type for ifTestCode");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 6) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                ifTestEntry->_ifTestOwnerLength = vb->syntax_len;
                ifTestEntry->ifTestOwner = vb->syntax.uc;
            } else {
                g_warning("illegal type for ifTestOwner");
            }
        }
    }

    return ifTestEntry;
}

int
if_mib_get_ifTestTable(host_snmp *s, ifTestEntry_t ***ifTestEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 0};

    *ifTestEntry = NULL;

    base[10] = 1; stls_vbl_add_null(&in, base, 11);
    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);
    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);
    base[10] = 6; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifTestEntry = (ifTestEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifTestEntry_t *));
    if (! *ifTestEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifTestEntry)[i] = assign_ifTestEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifTestEntry(ifTestEntry_t *ifTestEntry)
{
    GSList *vbl;
    char *p;

    if (ifTestEntry) {
        p = (char *) ifTestEntry + sizeof(ifTestEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifTestEntry);
    }
}

void
if_mib_free_ifTestTable(ifTestEntry_t **ifTestEntry)
{
    int i;

    if (ifTestEntry) {
        for (i = 0; ifTestEntry[i]; i++) {
            if_mib_free_ifTestEntry(ifTestEntry[i]);
        }
        g_free(ifTestEntry);
    }
}

ifRcvAddressEntry_t *
if_mib_new_ifRcvAddressEntry()
{
    ifRcvAddressEntry_t *ifRcvAddressEntry;

    ifRcvAddressEntry = (ifRcvAddressEntry_t *) g_malloc0(sizeof(ifRcvAddressEntry_t) + sizeof(gpointer));
    return ifRcvAddressEntry;
}

static int
unpack_ifRcvAddressEntry(GSnmpVarBind *vb, ifRcvAddressEntry_t *ifRcvAddressEntry)
{
    int i, len, idx = 11;

    if (vb->id_len < idx) return -1;
    ifRcvAddressEntry->ifIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ifRcvAddressEntry->ifRcvAddressAddress[i] = vb->id[idx++];
    }
    ifRcvAddressEntry->_ifRcvAddressAddressLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static ifRcvAddressEntry_t *
assign_ifRcvAddressEntry(GSList *vbl)
{
    GSList *elem;
    ifRcvAddressEntry_t *ifRcvAddressEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1};

    ifRcvAddressEntry = if_mib_new_ifRcvAddressEntry();
    if (! ifRcvAddressEntry) {
        return NULL;
    }

    p = (char *) ifRcvAddressEntry + sizeof(ifRcvAddressEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifRcvAddressEntry((GSnmpVarBind *) vbl->data, ifRcvAddressEntry) < 0) {
        g_warning("illegal ifRcvAddressEntry instance identifier");
        g_free(ifRcvAddressEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 2) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifRcvAddressEntry->ifRcvAddressStatus = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifRcvAddressStatus");
            }
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            if (vb->type == G_SNMP_INTEGER32) {
                ifRcvAddressEntry->ifRcvAddressType = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for ifRcvAddressType");
            }
        }
    }

    return ifRcvAddressEntry;
}

int
if_mib_get_ifRcvAddressTable(host_snmp *s, ifRcvAddressEntry_t ***ifRcvAddressEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 0};

    *ifRcvAddressEntry = NULL;

    base[10] = 2; stls_vbl_add_null(&in, base, 11);
    base[10] = 3; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifRcvAddressEntry = (ifRcvAddressEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ifRcvAddressEntry_t *));
    if (! *ifRcvAddressEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifRcvAddressEntry)[i] = assign_ifRcvAddressEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifRcvAddressEntry(ifRcvAddressEntry_t *ifRcvAddressEntry)
{
    GSList *vbl;
    char *p;

    if (ifRcvAddressEntry) {
        p = (char *) ifRcvAddressEntry + sizeof(ifRcvAddressEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifRcvAddressEntry);
    }
}

void
if_mib_free_ifRcvAddressTable(ifRcvAddressEntry_t **ifRcvAddressEntry)
{
    int i;

    if (ifRcvAddressEntry) {
        for (i = 0; ifRcvAddressEntry[i]; i++) {
            if_mib_free_ifRcvAddressEntry(ifRcvAddressEntry[i]);
        }
        g_free(ifRcvAddressEntry);
    }
}


