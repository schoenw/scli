/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.17 for the scli package.
 *
 * Derived from IF-MIB:
 *   The MIB module to describe generic objects for network
 *   interface sub-layers.  This MIB is an updated version of
 *   MIB-II's ifTable, and incorporates the extensions defined in
 *   RFC 1229.
 *
 * Revision 2000-06-14 00:00:
 *   Clarifications agreed upon by the Interfaces MIB WG, and
 *   published as RFC 2863.
 *
 * Revision 1996-02-28 21:55:
 *   Revisions made by the Interfaces MIB WG, and published in
 *   RFC 2233.
 *
 * Revision 1993-11-08 21:55:
 *   Initial revision, published as part of RFC 1573.
 *
 * $Id$
 */

#include "if-mib.h"

GSnmpEnum const if_mib_enums_ifType[] = {
    { IF_MIB_IFTYPE_OTHER,	"other" },
    { IF_MIB_IFTYPE_REGULAR1822,	"regular1822" },
    { IF_MIB_IFTYPE_HDH1822,	"hdh1822" },
    { IF_MIB_IFTYPE_DDNX25,	"ddnX25" },
    { IF_MIB_IFTYPE_RFC877X25,	"rfc877x25" },
    { IF_MIB_IFTYPE_ETHERNETCSMACD,	"ethernetCsmacd" },
    { IF_MIB_IFTYPE_ISO88023CSMACD,	"iso88023Csmacd" },
    { IF_MIB_IFTYPE_ISO88024TOKENBUS,	"iso88024TokenBus" },
    { IF_MIB_IFTYPE_ISO88025TOKENRING,	"iso88025TokenRing" },
    { IF_MIB_IFTYPE_ISO88026MAN,	"iso88026Man" },
    { IF_MIB_IFTYPE_STARLAN,	"starLan" },
    { IF_MIB_IFTYPE_PROTEON10MBIT,	"proteon10Mbit" },
    { IF_MIB_IFTYPE_PROTEON80MBIT,	"proteon80Mbit" },
    { IF_MIB_IFTYPE_HYPERCHANNEL,	"hyperchannel" },
    { IF_MIB_IFTYPE_FDDI,	"fddi" },
    { IF_MIB_IFTYPE_LAPB,	"lapb" },
    { IF_MIB_IFTYPE_SDLC,	"sdlc" },
    { IF_MIB_IFTYPE_DS1,	"ds1" },
    { IF_MIB_IFTYPE_E1,	"e1" },
    { IF_MIB_IFTYPE_BASICISDN,	"basicISDN" },
    { IF_MIB_IFTYPE_PRIMARYISDN,	"primaryISDN" },
    { IF_MIB_IFTYPE_PROPPOINTTOPOINTSERIAL,	"propPointToPointSerial" },
    { IF_MIB_IFTYPE_PPP,	"ppp" },
    { IF_MIB_IFTYPE_SOFTWARELOOPBACK,	"softwareLoopback" },
    { IF_MIB_IFTYPE_EON,	"eon" },
    { IF_MIB_IFTYPE_ETHERNET3MBIT,	"ethernet3Mbit" },
    { IF_MIB_IFTYPE_NSIP,	"nsip" },
    { IF_MIB_IFTYPE_SLIP,	"slip" },
    { IF_MIB_IFTYPE_ULTRA,	"ultra" },
    { IF_MIB_IFTYPE_DS3,	"ds3" },
    { IF_MIB_IFTYPE_SIP,	"sip" },
    { IF_MIB_IFTYPE_FRAMERELAY,	"frameRelay" },
    { IF_MIB_IFTYPE_RS232,	"rs232" },
    { IF_MIB_IFTYPE_PARA,	"para" },
    { IF_MIB_IFTYPE_ARCNET,	"arcnet" },
    { IF_MIB_IFTYPE_ARCNETPLUS,	"arcnetPlus" },
    { IF_MIB_IFTYPE_ATM,	"atm" },
    { IF_MIB_IFTYPE_MIOX25,	"miox25" },
    { IF_MIB_IFTYPE_SONET,	"sonet" },
    { IF_MIB_IFTYPE_X25PLE,	"x25ple" },
    { IF_MIB_IFTYPE_ISO88022LLC,	"iso88022llc" },
    { IF_MIB_IFTYPE_LOCALTALK,	"localTalk" },
    { IF_MIB_IFTYPE_SMDSDXI,	"smdsDxi" },
    { IF_MIB_IFTYPE_FRAMERELAYSERVICE,	"frameRelayService" },
    { IF_MIB_IFTYPE_V35,	"v35" },
    { IF_MIB_IFTYPE_HSSI,	"hssi" },
    { IF_MIB_IFTYPE_HIPPI,	"hippi" },
    { IF_MIB_IFTYPE_MODEM,	"modem" },
    { IF_MIB_IFTYPE_AAL5,	"aal5" },
    { IF_MIB_IFTYPE_SONETPATH,	"sonetPath" },
    { IF_MIB_IFTYPE_SONETVT,	"sonetVT" },
    { IF_MIB_IFTYPE_SMDSICIP,	"smdsIcip" },
    { IF_MIB_IFTYPE_PROPVIRTUAL,	"propVirtual" },
    { IF_MIB_IFTYPE_PROPMULTIPLEXOR,	"propMultiplexor" },
    { IF_MIB_IFTYPE_IEEE80212,	"ieee80212" },
    { IF_MIB_IFTYPE_FIBRECHANNEL,	"fibreChannel" },
    { IF_MIB_IFTYPE_HIPPIINTERFACE,	"hippiInterface" },
    { IF_MIB_IFTYPE_FRAMERELAYINTERCONNECT,	"frameRelayInterconnect" },
    { IF_MIB_IFTYPE_AFLANE8023,	"aflane8023" },
    { IF_MIB_IFTYPE_AFLANE8025,	"aflane8025" },
    { IF_MIB_IFTYPE_CCTEMUL,	"cctEmul" },
    { IF_MIB_IFTYPE_FASTETHER,	"fastEther" },
    { IF_MIB_IFTYPE_ISDN,	"isdn" },
    { IF_MIB_IFTYPE_V11,	"v11" },
    { IF_MIB_IFTYPE_V36,	"v36" },
    { IF_MIB_IFTYPE_G703AT64K,	"g703at64k" },
    { IF_MIB_IFTYPE_G703AT2MB,	"g703at2mb" },
    { IF_MIB_IFTYPE_QLLC,	"qllc" },
    { IF_MIB_IFTYPE_FASTETHERFX,	"fastEtherFX" },
    { IF_MIB_IFTYPE_CHANNEL,	"channel" },
    { IF_MIB_IFTYPE_IEEE80211,	"ieee80211" },
    { IF_MIB_IFTYPE_IBM370PARCHAN,	"ibm370parChan" },
    { IF_MIB_IFTYPE_ESCON,	"escon" },
    { IF_MIB_IFTYPE_DLSW,	"dlsw" },
    { IF_MIB_IFTYPE_ISDNS,	"isdns" },
    { IF_MIB_IFTYPE_ISDNU,	"isdnu" },
    { IF_MIB_IFTYPE_LAPD,	"lapd" },
    { IF_MIB_IFTYPE_IPSWITCH,	"ipSwitch" },
    { IF_MIB_IFTYPE_RSRB,	"rsrb" },
    { IF_MIB_IFTYPE_ATMLOGICAL,	"atmLogical" },
    { IF_MIB_IFTYPE_DS0,	"ds0" },
    { IF_MIB_IFTYPE_DS0BUNDLE,	"ds0Bundle" },
    { IF_MIB_IFTYPE_BSC,	"bsc" },
    { IF_MIB_IFTYPE_ASYNC,	"async" },
    { IF_MIB_IFTYPE_CNR,	"cnr" },
    { IF_MIB_IFTYPE_ISO88025DTR,	"iso88025Dtr" },
    { IF_MIB_IFTYPE_EPLRS,	"eplrs" },
    { IF_MIB_IFTYPE_ARAP,	"arap" },
    { IF_MIB_IFTYPE_PROPCNLS,	"propCnls" },
    { IF_MIB_IFTYPE_HOSTPAD,	"hostPad" },
    { IF_MIB_IFTYPE_TERMPAD,	"termPad" },
    { IF_MIB_IFTYPE_FRAMERELAYMPI,	"frameRelayMPI" },
    { IF_MIB_IFTYPE_X213,	"x213" },
    { IF_MIB_IFTYPE_ADSL,	"adsl" },
    { IF_MIB_IFTYPE_RADSL,	"radsl" },
    { IF_MIB_IFTYPE_SDSL,	"sdsl" },
    { IF_MIB_IFTYPE_VDSL,	"vdsl" },
    { IF_MIB_IFTYPE_ISO88025CRFPINT,	"iso88025CRFPInt" },
    { IF_MIB_IFTYPE_MYRINET,	"myrinet" },
    { IF_MIB_IFTYPE_VOICEEM,	"voiceEM" },
    { IF_MIB_IFTYPE_VOICEFXO,	"voiceFXO" },
    { IF_MIB_IFTYPE_VOICEFXS,	"voiceFXS" },
    { IF_MIB_IFTYPE_VOICEENCAP,	"voiceEncap" },
    { IF_MIB_IFTYPE_VOICEOVERIP,	"voiceOverIp" },
    { IF_MIB_IFTYPE_ATMDXI,	"atmDxi" },
    { IF_MIB_IFTYPE_ATMFUNI,	"atmFuni" },
    { IF_MIB_IFTYPE_ATMIMA,	"atmIma" },
    { IF_MIB_IFTYPE_PPPMULTILINKBUNDLE,	"pppMultilinkBundle" },
    { IF_MIB_IFTYPE_IPOVERCDLC,	"ipOverCdlc" },
    { IF_MIB_IFTYPE_IPOVERCLAW,	"ipOverClaw" },
    { IF_MIB_IFTYPE_STACKTOSTACK,	"stackToStack" },
    { IF_MIB_IFTYPE_VIRTUALIPADDRESS,	"virtualIpAddress" },
    { IF_MIB_IFTYPE_MPC,	"mpc" },
    { IF_MIB_IFTYPE_IPOVERATM,	"ipOverAtm" },
    { IF_MIB_IFTYPE_ISO88025FIBER,	"iso88025Fiber" },
    { IF_MIB_IFTYPE_TDLC,	"tdlc" },
    { IF_MIB_IFTYPE_GIGABITETHERNET,	"gigabitEthernet" },
    { IF_MIB_IFTYPE_HDLC,	"hdlc" },
    { IF_MIB_IFTYPE_LAPF,	"lapf" },
    { IF_MIB_IFTYPE_V37,	"v37" },
    { IF_MIB_IFTYPE_X25MLP,	"x25mlp" },
    { IF_MIB_IFTYPE_X25HUNTGROUP,	"x25huntGroup" },
    { IF_MIB_IFTYPE_TRASNPHDLC,	"trasnpHdlc" },
    { IF_MIB_IFTYPE_INTERLEAVE,	"interleave" },
    { IF_MIB_IFTYPE_FAST,	"fast" },
    { IF_MIB_IFTYPE_IP,	"ip" },
    { IF_MIB_IFTYPE_DOCSCABLEMACLAYER,	"docsCableMaclayer" },
    { IF_MIB_IFTYPE_DOCSCABLEDOWNSTREAM,	"docsCableDownstream" },
    { IF_MIB_IFTYPE_DOCSCABLEUPSTREAM,	"docsCableUpstream" },
    { IF_MIB_IFTYPE_A12MPPSWITCH,	"a12MppSwitch" },
    { IF_MIB_IFTYPE_TUNNEL,	"tunnel" },
    { IF_MIB_IFTYPE_COFFEE,	"coffee" },
    { IF_MIB_IFTYPE_CES,	"ces" },
    { IF_MIB_IFTYPE_ATMSUBINTERFACE,	"atmSubInterface" },
    { IF_MIB_IFTYPE_L2VLAN,	"l2vlan" },
    { IF_MIB_IFTYPE_L3IPVLAN,	"l3ipvlan" },
    { IF_MIB_IFTYPE_L3IPXVLAN,	"l3ipxvlan" },
    { IF_MIB_IFTYPE_DIGITALPOWERLINE,	"digitalPowerline" },
    { IF_MIB_IFTYPE_MEDIAMAILOVERIP,	"mediaMailOverIp" },
    { IF_MIB_IFTYPE_DTM,	"dtm" },
    { IF_MIB_IFTYPE_DCN,	"dcn" },
    { IF_MIB_IFTYPE_IPFORWARD,	"ipForward" },
    { IF_MIB_IFTYPE_MSDSL,	"msdsl" },
    { IF_MIB_IFTYPE_IEEE1394,	"ieee1394" },
    { IF_MIB_IFTYPE_IF_GSN,	"if-gsn" },
    { IF_MIB_IFTYPE_DVBRCCMACLAYER,	"dvbRccMacLayer" },
    { IF_MIB_IFTYPE_DVBRCCDOWNSTREAM,	"dvbRccDownstream" },
    { IF_MIB_IFTYPE_DVBRCCUPSTREAM,	"dvbRccUpstream" },
    { IF_MIB_IFTYPE_ATMVIRTUAL,	"atmVirtual" },
    { IF_MIB_IFTYPE_MPLSTUNNEL,	"mplsTunnel" },
    { IF_MIB_IFTYPE_SRP,	"srp" },
    { IF_MIB_IFTYPE_VOICEOVERATM,	"voiceOverAtm" },
    { IF_MIB_IFTYPE_VOICEOVERFRAMERELAY,	"voiceOverFrameRelay" },
    { IF_MIB_IFTYPE_IDSL,	"idsl" },
    { IF_MIB_IFTYPE_COMPOSITELINK,	"compositeLink" },
    { IF_MIB_IFTYPE_SS7SIGLINK,	"ss7SigLink" },
    { IF_MIB_IFTYPE_PROPWIRELESSP2P,	"propWirelessP2P" },
    { IF_MIB_IFTYPE_FRFORWARD,	"frForward" },
    { IF_MIB_IFTYPE_RFC1483,	"rfc1483" },
    { IF_MIB_IFTYPE_USB,	"usb" },
    { IF_MIB_IFTYPE_IEEE8023ADLAG,	"ieee8023adLag" },
    { IF_MIB_IFTYPE_BGPPOLICYACCOUNTING,	"bgppolicyaccounting" },
    { IF_MIB_IFTYPE_FRF16MFRBUNDLE,	"frf16MfrBundle" },
    { IF_MIB_IFTYPE_H323GATEKEEPER,	"h323Gatekeeper" },
    { IF_MIB_IFTYPE_H323PROXY,	"h323Proxy" },
    { IF_MIB_IFTYPE_MPLS,	"mpls" },
    { IF_MIB_IFTYPE_MFSIGLINK,	"mfSigLink" },
    { IF_MIB_IFTYPE_HDSL2,	"hdsl2" },
    { IF_MIB_IFTYPE_SHDSL,	"shdsl" },
    { IF_MIB_IFTYPE_DS1FDL,	"ds1FDL" },
    { IF_MIB_IFTYPE_POS,	"pos" },
    { IF_MIB_IFTYPE_DVBASILN,	"dvbAsiln" },
    { IF_MIB_IFTYPE_DVBASIOUT,	"dvbAsiOut" },
    { IF_MIB_IFTYPE_PLC,	"plc" },
    { IF_MIB_IFTYPE_NFAS,	"nfas" },
    { IF_MIB_IFTYPE_TR008,	"tr008" },
    { IF_MIB_IFTYPE_GR303RDT,	"gr303RDT" },
    { IF_MIB_IFTYPE_GR303IDT,	"gr303IDT" },
    { IF_MIB_IFTYPE_ISUP,	"isup" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSMACLAYER,	"propDocsWirelessMaclayer" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSDOWNSTREAM,	"propDocsWirelessDownstream" },
    { IF_MIB_IFTYPE_PROPDOCSWIRELESSUPSTREAM,	"propDocsWirelessUpstream" },
    { IF_MIB_IFTYPE_HIPERLAN2,	"hiperlan2" },
    { IF_MIB_IFTYPE_PROPBWAP2MP,	"propBWAp2Mp" },
    { IF_MIB_IFTYPE_SONETOVERHEADCHANNEL,	"sonetOverheadChannel" },
    { IF_MIB_IFTYPE_DIGITALWRAPPEROVERHEADCHANNEL,	"digitalWrapperOverheadChannel" },
    { IF_MIB_IFTYPE_AAL2,	"aal2" },
    { IF_MIB_IFTYPE_RADIOMAC,	"radioMAC" },
    { IF_MIB_IFTYPE_ATMRADIO,	"atmRadio" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifAdminStatus[] = {
    { IF_MIB_IFADMINSTATUS_UP,	"up" },
    { IF_MIB_IFADMINSTATUS_DOWN,	"down" },
    { IF_MIB_IFADMINSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifOperStatus[] = {
    { IF_MIB_IFOPERSTATUS_UP,	"up" },
    { IF_MIB_IFOPERSTATUS_DOWN,	"down" },
    { IF_MIB_IFOPERSTATUS_TESTING,	"testing" },
    { IF_MIB_IFOPERSTATUS_UNKNOWN,	"unknown" },
    { IF_MIB_IFOPERSTATUS_DORMANT,	"dormant" },
    { IF_MIB_IFOPERSTATUS_NOTPRESENT,	"notPresent" },
    { IF_MIB_IFOPERSTATUS_LOWERLAYERDOWN,	"lowerLayerDown" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifLinkUpDownTrapEnable[] = {
    { IF_MIB_IFLINKUPDOWNTRAPENABLE_ENABLED,	"enabled" },
    { IF_MIB_IFLINKUPDOWNTRAPENABLE_DISABLED,	"disabled" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifPromiscuousMode[] = {
    { IF_MIB_IFPROMISCUOUSMODE_TRUE,	"true" },
    { IF_MIB_IFPROMISCUOUSMODE_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifConnectorPresent[] = {
    { IF_MIB_IFCONNECTORPRESENT_TRUE,	"true" },
    { IF_MIB_IFCONNECTORPRESENT_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifStackStatus[] = {
    { IF_MIB_IFSTACKSTATUS_ACTIVE,	"active" },
    { IF_MIB_IFSTACKSTATUS_NOTINSERVICE,	"notInService" },
    { IF_MIB_IFSTACKSTATUS_NOTREADY,	"notReady" },
    { IF_MIB_IFSTACKSTATUS_CREATEANDGO,	"createAndGo" },
    { IF_MIB_IFSTACKSTATUS_CREATEANDWAIT,	"createAndWait" },
    { IF_MIB_IFSTACKSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifTestStatus[] = {
    { IF_MIB_IFTESTSTATUS_NOTINUSE,	"notInUse" },
    { IF_MIB_IFTESTSTATUS_INUSE,	"inUse" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifTestResult[] = {
    { IF_MIB_IFTESTRESULT_NONE,	"none" },
    { IF_MIB_IFTESTRESULT_SUCCESS,	"success" },
    { IF_MIB_IFTESTRESULT_INPROGRESS,	"inProgress" },
    { IF_MIB_IFTESTRESULT_NOTSUPPORTED,	"notSupported" },
    { IF_MIB_IFTESTRESULT_UNABLETORUN,	"unAbleToRun" },
    { IF_MIB_IFTESTRESULT_ABORTED,	"aborted" },
    { IF_MIB_IFTESTRESULT_FAILED,	"failed" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifRcvAddressStatus[] = {
    { IF_MIB_IFRCVADDRESSSTATUS_ACTIVE,	"active" },
    { IF_MIB_IFRCVADDRESSSTATUS_NOTINSERVICE,	"notInService" },
    { IF_MIB_IFRCVADDRESSSTATUS_NOTREADY,	"notReady" },
    { IF_MIB_IFRCVADDRESSSTATUS_CREATEANDGO,	"createAndGo" },
    { IF_MIB_IFRCVADDRESSSTATUS_CREATEANDWAIT,	"createAndWait" },
    { IF_MIB_IFRCVADDRESSSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const if_mib_enums_ifRcvAddressType[] = {
    { IF_MIB_IFRCVADDRESSTYPE_OTHER,	"other" },
    { IF_MIB_IFRCVADDRESSTYPE_VOLATILE,	"volatile" },
    { IF_MIB_IFRCVADDRESSTYPE_NONVOLATILE,	"nonVolatile" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gchar            *label;
} stls_stub_attr_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint idx,
               stls_stub_attr_t *attributes)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (attributes[i].type != G_SNMP_COUNTER64 || s->version > G_SNMP_V1) {
            base[idx] = attributes[i].subid;
            g_snmp_vbl_add_null(vbl, base, idx + 1);
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, gsize const base_len,
	    stls_stub_attr_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
	|| (vb->type == G_SNMP_NOSUCHOBJECT)
	|| (vb->type == G_SNMP_NOSUCHINSTANCE)) {
	return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		g_warning("type tag 0x%02x does not match 0x%02x (%s)",
			  vb->type, attributes[i].type, attributes[i].label);
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static stls_stub_attr_t _interfaces[] = {
    { 1, G_SNMP_INTEGER32, "ifNumber" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifEntry[] = {
    { 2, G_SNMP_OCTET_STRING, "ifDescr" },
    { 3, G_SNMP_INTEGER32, "ifType" },
    { 4, G_SNMP_INTEGER32, "ifMtu" },
    { 5, G_SNMP_UNSIGNED32, "ifSpeed" },
    { 6, G_SNMP_OCTET_STRING, "ifPhysAddress" },
    { 7, G_SNMP_INTEGER32, "ifAdminStatus" },
    { 8, G_SNMP_INTEGER32, "ifOperStatus" },
    { 9, G_SNMP_TIMETICKS, "ifLastChange" },
    { 10, G_SNMP_COUNTER32, "ifInOctets" },
    { 11, G_SNMP_COUNTER32, "ifInUcastPkts" },
    { 12, G_SNMP_COUNTER32, "ifInNUcastPkts" },
    { 13, G_SNMP_COUNTER32, "ifInDiscards" },
    { 14, G_SNMP_COUNTER32, "ifInErrors" },
    { 15, G_SNMP_COUNTER32, "ifInUnknownProtos" },
    { 16, G_SNMP_COUNTER32, "ifOutOctets" },
    { 17, G_SNMP_COUNTER32, "ifOutUcastPkts" },
    { 18, G_SNMP_COUNTER32, "ifOutNUcastPkts" },
    { 19, G_SNMP_COUNTER32, "ifOutDiscards" },
    { 20, G_SNMP_COUNTER32, "ifOutErrors" },
    { 21, G_SNMP_UNSIGNED32, "ifOutQLen" },
    { 22, G_SNMP_OBJECT_ID, "ifSpecific" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifMIBObjects[] = {
    { 5, G_SNMP_TIMETICKS, "ifTableLastChange" },
    { 6, G_SNMP_TIMETICKS, "ifStackLastChange" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifXEntry[] = {
    { 1, G_SNMP_OCTET_STRING, "ifName" },
    { 2, G_SNMP_COUNTER32, "ifInMulticastPkts" },
    { 3, G_SNMP_COUNTER32, "ifInBroadcastPkts" },
    { 4, G_SNMP_COUNTER32, "ifOutMulticastPkts" },
    { 5, G_SNMP_COUNTER32, "ifOutBroadcastPkts" },
    { 6, G_SNMP_COUNTER64, "ifHCInOctets" },
    { 7, G_SNMP_COUNTER64, "ifHCInUcastPkts" },
    { 8, G_SNMP_COUNTER64, "ifHCInMulticastPkts" },
    { 9, G_SNMP_COUNTER64, "ifHCInBroadcastPkts" },
    { 10, G_SNMP_COUNTER64, "ifHCOutOctets" },
    { 11, G_SNMP_COUNTER64, "ifHCOutUcastPkts" },
    { 12, G_SNMP_COUNTER64, "ifHCOutMulticastPkts" },
    { 13, G_SNMP_COUNTER64, "ifHCOutBroadcastPkts" },
    { 14, G_SNMP_INTEGER32, "ifLinkUpDownTrapEnable" },
    { 15, G_SNMP_UNSIGNED32, "ifHighSpeed" },
    { 16, G_SNMP_INTEGER32, "ifPromiscuousMode" },
    { 17, G_SNMP_INTEGER32, "ifConnectorPresent" },
    { 18, G_SNMP_OCTET_STRING, "ifAlias" },
    { 19, G_SNMP_TIMETICKS, "ifCounterDiscontinuityTime" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifStackEntry[] = {
    { 3, G_SNMP_INTEGER32, "ifStackStatus" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifTestEntry[] = {
    { 1, G_SNMP_INTEGER32, "ifTestId" },
    { 2, G_SNMP_INTEGER32, "ifTestStatus" },
    { 3, G_SNMP_OBJECT_ID, "ifTestType" },
    { 4, G_SNMP_INTEGER32, "ifTestResult" },
    { 5, G_SNMP_OBJECT_ID, "ifTestCode" },
    { 6, G_SNMP_OCTET_STRING, "ifTestOwner" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifRcvAddressEntry[] = {
    { 2, G_SNMP_INTEGER32, "ifRcvAddressStatus" },
    { 3, G_SNMP_INTEGER32, "ifRcvAddressType" },
    { 0, 0, NULL }
};


if_mib_interfaces_t *
if_mib_new_interfaces()
{
    if_mib_interfaces_t *interfaces;

    interfaces = (if_mib_interfaces_t *) g_malloc0(sizeof(if_mib_interfaces_t) + sizeof(gpointer));
    return interfaces;
}

static if_mib_interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    if_mib_interfaces_t *interfaces;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2};

    interfaces = if_mib_new_interfaces();
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(if_mib_interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _interfaces, &idx) < 0) continue;

        switch (idx) {
        case 1:
            interfaces->ifNumber = &(vb->syntax.i32[0]);
            break;
        };
    }

    return interfaces;
}

int
if_mib_get_interfaces(GSnmpSession *s, if_mib_interfaces_t **interfaces)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 0};

    *interfaces = NULL;

    add_attributes(s, &in, base, 7, _interfaces);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (! out) {
        return -2;
    }

    *interfaces = assign_interfaces(out);

    return 0;
}

void
if_mib_free_interfaces(if_mib_interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(if_mib_interfaces_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(interfaces);
    }
}

if_mib_ifEntry_t *
if_mib_new_ifEntry()
{
    if_mib_ifEntry_t *ifEntry;

    ifEntry = (if_mib_ifEntry_t *) g_malloc0(sizeof(if_mib_ifEntry_t) + sizeof(gpointer));
    return ifEntry;
}

static int
unpack_ifEntry(GSnmpVarBind *vb, if_mib_ifEntry_t *ifEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    ifEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static if_mib_ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    if_mib_ifEntry_t *ifEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1};

    ifEntry = if_mib_new_ifEntry();
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(if_mib_ifEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifEntry((GSnmpVarBind *) vbl->data, ifEntry) < 0) {
        g_warning("illegal ifEntry instance identifier");
        g_free(ifEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ifEntry->_ifDescrLength = vb->syntax_len;
            ifEntry->ifDescr = vb->syntax.uc;
            break;
        case 3:
            ifEntry->ifType = &(vb->syntax.i32[0]);
            break;
        case 4:
            ifEntry->ifMtu = &(vb->syntax.i32[0]);
            break;
        case 5:
            ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ifEntry->_ifPhysAddressLength = vb->syntax_len;
            ifEntry->ifPhysAddress = vb->syntax.uc;
            break;
        case 7:
            ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 14:
            ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 20:
            ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 21:
            ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
            break;
        case 22:
            ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
            ifEntry->ifSpecific = vb->syntax.ui32;
            break;
        };
    }

    return ifEntry;
}

int
if_mib_get_ifTable(GSnmpSession *s, if_mib_ifEntry_t ***ifEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 0};

    *ifEntry = NULL;

    add_attributes(s, &in, base, 9, _ifEntry);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifEntry = (if_mib_ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(if_mib_ifEntry_t *));
    if (! *ifEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifEntry)[i] = assign_ifEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifEntry(if_mib_ifEntry_t *ifEntry)
{
    GSList *vbl;
    char *p;

    if (ifEntry) {
        p = (char *) ifEntry + sizeof(if_mib_ifEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifEntry);
    }
}

void
if_mib_free_ifTable(if_mib_ifEntry_t **ifEntry)
{
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            if_mib_free_ifEntry(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

if_mib_ifMIBObjects_t *
if_mib_new_ifMIBObjects()
{
    if_mib_ifMIBObjects_t *ifMIBObjects;

    ifMIBObjects = (if_mib_ifMIBObjects_t *) g_malloc0(sizeof(if_mib_ifMIBObjects_t) + sizeof(gpointer));
    return ifMIBObjects;
}

static if_mib_ifMIBObjects_t *
assign_ifMIBObjects(GSList *vbl)
{
    GSList *elem;
    if_mib_ifMIBObjects_t *ifMIBObjects;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1};

    ifMIBObjects = if_mib_new_ifMIBObjects();
    if (! ifMIBObjects) {
        return NULL;
    }

    p = (char *) ifMIBObjects + sizeof(if_mib_ifMIBObjects_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifMIBObjects, &idx) < 0) continue;

        switch (idx) {
        case 5:
            ifMIBObjects->ifTableLastChange = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ifMIBObjects->ifStackLastChange = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return ifMIBObjects;
}

int
if_mib_get_ifMIBObjects(GSnmpSession *s, if_mib_ifMIBObjects_t **ifMIBObjects)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 0};

    *ifMIBObjects = NULL;

    add_attributes(s, &in, base, 8, _ifMIBObjects);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ifMIBObjects = assign_ifMIBObjects(out);

    return 0;
}

void
if_mib_free_ifMIBObjects(if_mib_ifMIBObjects_t *ifMIBObjects)
{
    GSList *vbl;
    char *p;

    if (ifMIBObjects) {
        p = (char *) ifMIBObjects + sizeof(if_mib_ifMIBObjects_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifMIBObjects);
    }
}

if_mib_ifXEntry_t *
if_mib_new_ifXEntry()
{
    if_mib_ifXEntry_t *ifXEntry;

    ifXEntry = (if_mib_ifXEntry_t *) g_malloc0(sizeof(if_mib_ifXEntry_t) + sizeof(gpointer));
    return ifXEntry;
}

static int
unpack_ifXEntry(GSnmpVarBind *vb, if_mib_ifXEntry_t *ifXEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifXEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static if_mib_ifXEntry_t *
assign_ifXEntry(GSList *vbl)
{
    GSList *elem;
    if_mib_ifXEntry_t *ifXEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1};

    ifXEntry = if_mib_new_ifXEntry();
    if (! ifXEntry) {
        return NULL;
    }

    p = (char *) ifXEntry + sizeof(if_mib_ifXEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifXEntry((GSnmpVarBind *) vbl->data, ifXEntry) < 0) {
        g_warning("illegal ifXEntry instance identifier");
        g_free(ifXEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifXEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ifXEntry->_ifNameLength = vb->syntax_len;
            ifXEntry->ifName = vb->syntax.uc;
            break;
        case 2:
            ifXEntry->ifInMulticastPkts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            ifXEntry->ifInBroadcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 4:
            ifXEntry->ifOutMulticastPkts = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ifXEntry->ifOutBroadcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ifXEntry->ifHCInOctets = &(vb->syntax.ui64[0]);
            break;
        case 7:
            ifXEntry->ifHCInUcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 8:
            ifXEntry->ifHCInMulticastPkts = &(vb->syntax.ui64[0]);
            break;
        case 9:
            ifXEntry->ifHCInBroadcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 10:
            ifXEntry->ifHCOutOctets = &(vb->syntax.ui64[0]);
            break;
        case 11:
            ifXEntry->ifHCOutUcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 12:
            ifXEntry->ifHCOutMulticastPkts = &(vb->syntax.ui64[0]);
            break;
        case 13:
            ifXEntry->ifHCOutBroadcastPkts = &(vb->syntax.ui64[0]);
            break;
        case 14:
            ifXEntry->ifLinkUpDownTrapEnable = &(vb->syntax.i32[0]);
            break;
        case 15:
            ifXEntry->ifHighSpeed = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ifXEntry->ifPromiscuousMode = &(vb->syntax.i32[0]);
            break;
        case 17:
            ifXEntry->ifConnectorPresent = &(vb->syntax.i32[0]);
            break;
        case 18:
            ifXEntry->_ifAliasLength = vb->syntax_len;
            ifXEntry->ifAlias = vb->syntax.uc;
            break;
        case 19:
            ifXEntry->ifCounterDiscontinuityTime = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return ifXEntry;
}

int
if_mib_get_ifXTable(GSnmpSession *s, if_mib_ifXEntry_t ***ifXEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 1, 1, 0};

    *ifXEntry = NULL;

    add_attributes(s, &in, base, 10, _ifXEntry);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifXEntry = (if_mib_ifXEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(if_mib_ifXEntry_t *));
    if (! *ifXEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifXEntry)[i] = assign_ifXEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifXEntry(if_mib_ifXEntry_t *ifXEntry)
{
    GSList *vbl;
    char *p;

    if (ifXEntry) {
        p = (char *) ifXEntry + sizeof(if_mib_ifXEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifXEntry);
    }
}

void
if_mib_free_ifXTable(if_mib_ifXEntry_t **ifXEntry)
{
    int i;

    if (ifXEntry) {
        for (i = 0; ifXEntry[i]; i++) {
            if_mib_free_ifXEntry(ifXEntry[i]);
        }
        g_free(ifXEntry);
    }
}

if_mib_ifStackEntry_t *
if_mib_new_ifStackEntry()
{
    if_mib_ifStackEntry_t *ifStackEntry;

    ifStackEntry = (if_mib_ifStackEntry_t *) g_malloc0(sizeof(if_mib_ifStackEntry_t) + sizeof(gpointer));
    return ifStackEntry;
}

static int
unpack_ifStackEntry(GSnmpVarBind *vb, if_mib_ifStackEntry_t *ifStackEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifStackEntry->ifStackHigherLayer = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    ifStackEntry->ifStackLowerLayer = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static if_mib_ifStackEntry_t *
assign_ifStackEntry(GSList *vbl)
{
    GSList *elem;
    if_mib_ifStackEntry_t *ifStackEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1};

    ifStackEntry = if_mib_new_ifStackEntry();
    if (! ifStackEntry) {
        return NULL;
    }

    p = (char *) ifStackEntry + sizeof(if_mib_ifStackEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifStackEntry((GSnmpVarBind *) vbl->data, ifStackEntry) < 0) {
        g_warning("illegal ifStackEntry instance identifier");
        g_free(ifStackEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifStackEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ifStackEntry->ifStackStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ifStackEntry;
}

int
if_mib_get_ifStackTable(GSnmpSession *s, if_mib_ifStackEntry_t ***ifStackEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 2, 1, 0};

    *ifStackEntry = NULL;

    add_attributes(s, &in, base, 10, _ifStackEntry);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifStackEntry = (if_mib_ifStackEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(if_mib_ifStackEntry_t *));
    if (! *ifStackEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifStackEntry)[i] = assign_ifStackEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifStackEntry(if_mib_ifStackEntry_t *ifStackEntry)
{
    GSList *vbl;
    char *p;

    if (ifStackEntry) {
        p = (char *) ifStackEntry + sizeof(if_mib_ifStackEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifStackEntry);
    }
}

void
if_mib_free_ifStackTable(if_mib_ifStackEntry_t **ifStackEntry)
{
    int i;

    if (ifStackEntry) {
        for (i = 0; ifStackEntry[i]; i++) {
            if_mib_free_ifStackEntry(ifStackEntry[i]);
        }
        g_free(ifStackEntry);
    }
}

if_mib_ifTestEntry_t *
if_mib_new_ifTestEntry()
{
    if_mib_ifTestEntry_t *ifTestEntry;

    ifTestEntry = (if_mib_ifTestEntry_t *) g_malloc0(sizeof(if_mib_ifTestEntry_t) + sizeof(gpointer));
    return ifTestEntry;
}

static int
unpack_ifTestEntry(GSnmpVarBind *vb, if_mib_ifTestEntry_t *ifTestEntry)
{
    int idx = 11;

    if (vb->id_len < idx) return -1;
    ifTestEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static if_mib_ifTestEntry_t *
assign_ifTestEntry(GSList *vbl)
{
    GSList *elem;
    if_mib_ifTestEntry_t *ifTestEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1};

    ifTestEntry = if_mib_new_ifTestEntry();
    if (! ifTestEntry) {
        return NULL;
    }

    p = (char *) ifTestEntry + sizeof(if_mib_ifTestEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifTestEntry((GSnmpVarBind *) vbl->data, ifTestEntry) < 0) {
        g_warning("illegal ifTestEntry instance identifier");
        g_free(ifTestEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifTestEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ifTestEntry->ifTestId = &(vb->syntax.i32[0]);
            break;
        case 2:
            ifTestEntry->ifTestStatus = &(vb->syntax.i32[0]);
            break;
        case 3:
            ifTestEntry->_ifTestTypeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestType = vb->syntax.ui32;
            break;
        case 4:
            ifTestEntry->ifTestResult = &(vb->syntax.i32[0]);
            break;
        case 5:
            ifTestEntry->_ifTestCodeLength = vb->syntax_len / sizeof(guint32);
            ifTestEntry->ifTestCode = vb->syntax.ui32;
            break;
        case 6:
            ifTestEntry->_ifTestOwnerLength = vb->syntax_len;
            ifTestEntry->ifTestOwner = vb->syntax.uc;
            break;
        };
    }

    return ifTestEntry;
}

int
if_mib_get_ifTestTable(GSnmpSession *s, if_mib_ifTestEntry_t ***ifTestEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 3, 1, 0};

    *ifTestEntry = NULL;

    add_attributes(s, &in, base, 10, _ifTestEntry);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifTestEntry = (if_mib_ifTestEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(if_mib_ifTestEntry_t *));
    if (! *ifTestEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifTestEntry)[i] = assign_ifTestEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifTestEntry(if_mib_ifTestEntry_t *ifTestEntry)
{
    GSList *vbl;
    char *p;

    if (ifTestEntry) {
        p = (char *) ifTestEntry + sizeof(if_mib_ifTestEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifTestEntry);
    }
}

void
if_mib_free_ifTestTable(if_mib_ifTestEntry_t **ifTestEntry)
{
    int i;

    if (ifTestEntry) {
        for (i = 0; ifTestEntry[i]; i++) {
            if_mib_free_ifTestEntry(ifTestEntry[i]);
        }
        g_free(ifTestEntry);
    }
}

if_mib_ifRcvAddressEntry_t *
if_mib_new_ifRcvAddressEntry()
{
    if_mib_ifRcvAddressEntry_t *ifRcvAddressEntry;

    ifRcvAddressEntry = (if_mib_ifRcvAddressEntry_t *) g_malloc0(sizeof(if_mib_ifRcvAddressEntry_t) + sizeof(gpointer));
    return ifRcvAddressEntry;
}

static int
unpack_ifRcvAddressEntry(GSnmpVarBind *vb, if_mib_ifRcvAddressEntry_t *ifRcvAddressEntry)
{
    int i, len, idx = 11;

    if (vb->id_len < idx) return -1;
    ifRcvAddressEntry->ifIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ifRcvAddressEntry->ifRcvAddressAddress[i] = vb->id[idx++];
    }
    ifRcvAddressEntry->_ifRcvAddressAddressLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static if_mib_ifRcvAddressEntry_t *
assign_ifRcvAddressEntry(GSList *vbl)
{
    GSList *elem;
    if_mib_ifRcvAddressEntry_t *ifRcvAddressEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1};

    ifRcvAddressEntry = if_mib_new_ifRcvAddressEntry();
    if (! ifRcvAddressEntry) {
        return NULL;
    }

    p = (char *) ifRcvAddressEntry + sizeof(if_mib_ifRcvAddressEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifRcvAddressEntry((GSnmpVarBind *) vbl->data, ifRcvAddressEntry) < 0) {
        g_warning("illegal ifRcvAddressEntry instance identifier");
        g_free(ifRcvAddressEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, base, sizeof(base)/sizeof(guint32),
                   _ifRcvAddressEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ifRcvAddressEntry->ifRcvAddressStatus = &(vb->syntax.i32[0]);
            break;
        case 3:
            ifRcvAddressEntry->ifRcvAddressType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ifRcvAddressEntry;
}

int
if_mib_get_ifRcvAddressTable(GSnmpSession *s, if_mib_ifRcvAddressEntry_t ***ifRcvAddressEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 31, 1, 4, 1, 0};

    *ifRcvAddressEntry = NULL;

    add_attributes(s, &in, base, 10, _ifRcvAddressEntry);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifRcvAddressEntry = (if_mib_ifRcvAddressEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(if_mib_ifRcvAddressEntry_t *));
    if (! *ifRcvAddressEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifRcvAddressEntry)[i] = assign_ifRcvAddressEntry(row->data);
    }

    return 0;
}

void
if_mib_free_ifRcvAddressEntry(if_mib_ifRcvAddressEntry_t *ifRcvAddressEntry)
{
    GSList *vbl;
    char *p;

    if (ifRcvAddressEntry) {
        p = (char *) ifRcvAddressEntry + sizeof(if_mib_ifRcvAddressEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifRcvAddressEntry);
    }
}

void
if_mib_free_ifRcvAddressTable(if_mib_ifRcvAddressEntry_t **ifRcvAddressEntry)
{
    int i;

    if (ifRcvAddressEntry) {
        for (i = 0; ifRcvAddressEntry[i]; i++) {
            if_mib_free_ifRcvAddressEntry(ifRcvAddressEntry[i]);
        }
        g_free(ifRcvAddressEntry);
    }
}


