/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.14 for the stools package.
 *
 * Derived from SNMPv2-MIB:
 *   The MIB module for SNMPv2 entities.
 *
 * Revision 1995-11-09 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 1993-04-01 00:00:
 *   The initial revision of this MIB module was published as
 *   RFC 1450.
 *
 * $Id$
 */

#include "snmpv2-mib.h"

stls_table_t const snmpv2_mib_enums_snmpEnableAuthenTraps[] = {
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_ENABLED,	"enabled" },
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_DISABLED,	"disabled" },
    { 0, NULL }
};


system_t *
snmpv2_mib_new_system()
{
    system_t *system;

    system = (system_t *) g_malloc0(sizeof(system_t) + sizeof(gpointer));
    return system;
}

static system_t *
assign_system(GSList *vbl)
{
    GSList *elem;
    system_t *system;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 1};

    system = snmpv2_mib_new_system();
    if (! system) {
        return NULL;
    }

    p = (char *) system + sizeof(system_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 8 && vb->id[7] == 1) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                system->_sysDescrLength = vb->syntax_len;
                system->sysDescr = vb->syntax.uc;
            } else {
                g_warning("illegal type for sysDescr");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 2) {
            if (vb->type == G_SNMP_OBJECT_ID) {
                system->_sysObjectIDLength = vb->syntax_len / sizeof(guint32);
                system->sysObjectID = vb->syntax.ui32;
            } else {
                g_warning("illegal type for sysObjectID");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 3) {
            if (vb->type == G_SNMP_TIMETICKS) {
                system->sysUpTime = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for sysUpTime");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 4) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                system->_sysContactLength = vb->syntax_len;
                system->sysContact = vb->syntax.uc;
            } else {
                g_warning("illegal type for sysContact");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 5) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                system->_sysNameLength = vb->syntax_len;
                system->sysName = vb->syntax.uc;
            } else {
                g_warning("illegal type for sysName");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 6) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                system->_sysLocationLength = vb->syntax_len;
                system->sysLocation = vb->syntax.uc;
            } else {
                g_warning("illegal type for sysLocation");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 7) {
            if (vb->type == G_SNMP_INTEGER32) {
                system->sysServices = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for sysServices");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 8) {
            if (vb->type == G_SNMP_TIMETICKS) {
                system->sysORLastChange = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for sysORLastChange");
            }
        }
    }

    return system;
}

int
snmpv2_mib_get_system(host_snmp *s, system_t **system)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0};

    *system = NULL;

    base[7] = 1; stls_vbl_add_null(&in, base, 8);
    base[7] = 2; stls_vbl_add_null(&in, base, 8);
    base[7] = 3; stls_vbl_add_null(&in, base, 8);
    base[7] = 4; stls_vbl_add_null(&in, base, 8);
    base[7] = 5; stls_vbl_add_null(&in, base, 8);
    base[7] = 6; stls_vbl_add_null(&in, base, 8);
    base[7] = 7; stls_vbl_add_null(&in, base, 8);
    base[7] = 8; stls_vbl_add_null(&in, base, 8);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *system = assign_system(out);

    return 0;
}

void
snmpv2_mib_free_system(system_t *system)
{
    GSList *vbl;
    char *p;

    if (system) {
        p = (char *) system + sizeof(system_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(system);
    }
}

sysOREntry_t *
snmpv2_mib_new_sysOREntry()
{
    sysOREntry_t *sysOREntry;

    sysOREntry = (sysOREntry_t *) g_malloc0(sizeof(sysOREntry_t) + sizeof(gpointer));
    return sysOREntry;
}

static int
unpack_sysOREntry(GSnmpVarBind *vb, sysOREntry_t *sysOREntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    sysOREntry->sysORIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static sysOREntry_t *
assign_sysOREntry(GSList *vbl)
{
    GSList *elem;
    sysOREntry_t *sysOREntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 1, 9, 1};

    sysOREntry = snmpv2_mib_new_sysOREntry();
    if (! sysOREntry) {
        return NULL;
    }

    p = (char *) sysOREntry + sizeof(sysOREntry_t);
    * (GSList **) p = vbl;

    if (unpack_sysOREntry((GSnmpVarBind *) vbl->data, sysOREntry) < 0) {
        g_warning("illegal sysOREntry instance identifier");
        g_free(sysOREntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 2) {
            if (vb->type == G_SNMP_OBJECT_ID) {
                sysOREntry->_sysORIDLength = vb->syntax_len / sizeof(guint32);
                sysOREntry->sysORID = vb->syntax.ui32;
            } else {
                g_warning("illegal type for sysORID");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 3) {
            if (vb->type == G_SNMP_OCTET_STRING) {
                sysOREntry->_sysORDescrLength = vb->syntax_len;
                sysOREntry->sysORDescr = vb->syntax.uc;
            } else {
                g_warning("illegal type for sysORDescr");
            }
        }
        if (vb->id_len > 10 && vb->id[9] == 4) {
            if (vb->type == G_SNMP_TIMETICKS) {
                sysOREntry->sysORUpTime = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for sysORUpTime");
            }
        }
    }

    return sysOREntry;
}

int
snmpv2_mib_get_sysORTable(host_snmp *s, sysOREntry_t ***sysOREntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 9, 1, 0};

    *sysOREntry = NULL;

    base[9] = 2; stls_vbl_add_null(&in, base, 10);
    base[9] = 3; stls_vbl_add_null(&in, base, 10);
    base[9] = 4; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *sysOREntry = (sysOREntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(sysOREntry_t *));
    if (! *sysOREntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*sysOREntry)[i] = assign_sysOREntry(row->data);
    }

    return 0;
}

void
snmpv2_mib_free_sysOREntry(sysOREntry_t *sysOREntry)
{
    GSList *vbl;
    char *p;

    if (sysOREntry) {
        p = (char *) sysOREntry + sizeof(sysOREntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(sysOREntry);
    }
}

void
snmpv2_mib_free_sysORTable(sysOREntry_t **sysOREntry)
{
    int i;

    if (sysOREntry) {
        for (i = 0; sysOREntry[i]; i++) {
            snmpv2_mib_free_sysOREntry(sysOREntry[i]);
        }
        g_free(sysOREntry);
    }
}

snmp_t *
snmpv2_mib_new_snmp()
{
    snmp_t *snmp;

    snmp = (snmp_t *) g_malloc0(sizeof(snmp_t) + sizeof(gpointer));
    return snmp;
}

static snmp_t *
assign_snmp(GSList *vbl)
{
    GSList *elem;
    snmp_t *snmp;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 11};

    snmp = snmpv2_mib_new_snmp();
    if (! snmp) {
        return NULL;
    }

    p = (char *) snmp + sizeof(snmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 8 && vb->id[7] == 1) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInPkts");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 2) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutPkts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutPkts");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 3) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInBadVersions = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInBadVersions");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 4) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInBadCommunityNames = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInBadCommunityNames");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 5) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInBadCommunityUses = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInBadCommunityUses");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 6) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInASNParseErrs = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInASNParseErrs");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 8) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInTooBigs = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInTooBigs");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 9) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInNoSuchNames = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInNoSuchNames");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 10) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInBadValues = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInBadValues");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 11) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInReadOnlys = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInReadOnlys");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 12) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInGenErrs = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInGenErrs");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 13) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInTotalReqVars = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInTotalReqVars");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 14) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInTotalSetVars = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInTotalSetVars");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 15) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInGetRequests = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInGetRequests");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 16) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInGetNexts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInGetNexts");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 17) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInSetRequests = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInSetRequests");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 18) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInGetResponses = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInGetResponses");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 19) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpInTraps = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpInTraps");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 20) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutTooBigs = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutTooBigs");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 21) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutNoSuchNames = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutNoSuchNames");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 22) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutBadValues = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutBadValues");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 24) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutGenErrs = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutGenErrs");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 25) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutGetRequests = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutGetRequests");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 26) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutGetNexts = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutGetNexts");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 27) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutSetRequests = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutSetRequests");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 28) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutGetResponses = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutGetResponses");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 29) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpOutTraps = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpOutTraps");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 30) {
            if (vb->type == G_SNMP_INTEGER32) {
                snmp->snmpEnableAuthenTraps = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for snmpEnableAuthenTraps");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 31) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpSilentDrops = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpSilentDrops");
            }
        }
        if (vb->id_len > 8 && vb->id[7] == 32) {
            if (vb->type == G_SNMP_COUNTER32) {
                snmp->snmpProxyDrops = &(vb->syntax.ui32[0]);
            } else {
                g_warning("illegal type for snmpProxyDrops");
            }
        }
    }

    return snmp;
}

int
snmpv2_mib_get_snmp(host_snmp *s, snmp_t **snmp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0};

    *snmp = NULL;

    base[7] = 1; stls_vbl_add_null(&in, base, 8);
    base[7] = 2; stls_vbl_add_null(&in, base, 8);
    base[7] = 3; stls_vbl_add_null(&in, base, 8);
    base[7] = 4; stls_vbl_add_null(&in, base, 8);
    base[7] = 5; stls_vbl_add_null(&in, base, 8);
    base[7] = 6; stls_vbl_add_null(&in, base, 8);
    base[7] = 8; stls_vbl_add_null(&in, base, 8);
    base[7] = 9; stls_vbl_add_null(&in, base, 8);
    base[7] = 10; stls_vbl_add_null(&in, base, 8);
    base[7] = 11; stls_vbl_add_null(&in, base, 8);
    base[7] = 12; stls_vbl_add_null(&in, base, 8);
    base[7] = 13; stls_vbl_add_null(&in, base, 8);
    base[7] = 14; stls_vbl_add_null(&in, base, 8);
    base[7] = 15; stls_vbl_add_null(&in, base, 8);
    base[7] = 16; stls_vbl_add_null(&in, base, 8);
    base[7] = 17; stls_vbl_add_null(&in, base, 8);
    base[7] = 18; stls_vbl_add_null(&in, base, 8);
    base[7] = 19; stls_vbl_add_null(&in, base, 8);
    base[7] = 20; stls_vbl_add_null(&in, base, 8);
    base[7] = 21; stls_vbl_add_null(&in, base, 8);
    base[7] = 22; stls_vbl_add_null(&in, base, 8);
    base[7] = 24; stls_vbl_add_null(&in, base, 8);
    base[7] = 25; stls_vbl_add_null(&in, base, 8);
    base[7] = 26; stls_vbl_add_null(&in, base, 8);
    base[7] = 27; stls_vbl_add_null(&in, base, 8);
    base[7] = 28; stls_vbl_add_null(&in, base, 8);
    base[7] = 29; stls_vbl_add_null(&in, base, 8);
    base[7] = 30; stls_vbl_add_null(&in, base, 8);
    base[7] = 31; stls_vbl_add_null(&in, base, 8);
    base[7] = 32; stls_vbl_add_null(&in, base, 8);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *snmp = assign_snmp(out);

    return 0;
}

void
snmpv2_mib_free_snmp(snmp_t *snmp)
{
    GSList *vbl;
    char *p;

    if (snmp) {
        p = (char *) snmp + sizeof(snmp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(snmp);
    }
}

snmpSet_t *
snmpv2_mib_new_snmpSet()
{
    snmpSet_t *snmpSet;

    snmpSet = (snmpSet_t *) g_malloc0(sizeof(snmpSet_t) + sizeof(gpointer));
    return snmpSet;
}

static snmpSet_t *
assign_snmpSet(GSList *vbl)
{
    GSList *elem;
    snmpSet_t *snmpSet;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6};

    snmpSet = snmpv2_mib_new_snmpSet();
    if (! snmpSet) {
        return NULL;
    }

    p = (char *) snmpSet + sizeof(snmpSet_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 1) {
            if (vb->type == G_SNMP_INTEGER32) {
                snmpSet->snmpSetSerialNo = &(vb->syntax.i32[0]);
            } else {
                g_warning("illegal type for snmpSetSerialNo");
            }
        }
    }

    return snmpSet;
}

int
snmpv2_mib_get_snmpSet(host_snmp *s, snmpSet_t **snmpSet)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6, 0};

    *snmpSet = NULL;

    base[9] = 1; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *snmpSet = assign_snmpSet(out);

    return 0;
}

void
snmpv2_mib_free_snmpSet(snmpSet_t *snmpSet)
{
    GSList *vbl;
    char *p;

    if (snmpSet) {
        p = (char *) snmpSet + sizeof(snmpSet_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(snmpSet);
    }
}


