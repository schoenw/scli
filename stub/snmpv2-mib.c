/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from SNMPv2-MIB:
 *   The MIB module for SNMPv2 entities.
 *
 * Revision 1995-11-09 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 1993-04-01 00:00:
 *   The initial revision of this MIB module was published as
 *   RFC 1450.
 *
 * $Id$
 */

#include "snmpv2-mib.h"

GSnmpEnum const snmpv2_mib_enums_snmpEnableAuthenTraps[] = {
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_ENABLED,  "enabled" },
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_DISABLED, "disabled" },
    { 0, NULL }
};


static guint16 sysDescr_constraints[] = {0, 255, 0, 0};
static guint16 sysContact_constraints[] = {0, 255, 0, 0};
static guint16 sysName_constraints[] = {0, 255, 0, 0};
static guint16 sysLocation_constraints[] = {0, 255, 0, 0};
static guint32 sysServices_constraints[] = {0L, 127L, 0, 0};
static guint16 sysORDescr_constraints[] = {0, 255, 0, 0};
static guint32 snmpSetSerialNo_constraints[] = {0L, 2147483647L, 0, 0};


static guint32 const system_oid[] = {1, 3, 6, 1, 2, 1, 1};

static GSnmpAttribute system_attr[] = {
    { 1, G_SNMP_OCTETSTRING,
      SNMPV2_MIB_SYSDESCR, "sysDescr",
       sysDescr_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysDescr),
      G_STRUCT_OFFSET(snmpv2_mib_system_t, _sysDescrLength),
      0 },
    { 2, G_SNMP_OBJECTID,
      SNMPV2_MIB_SYSOBJECTID, "sysObjectID",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysObjectID),
      G_STRUCT_OFFSET(snmpv2_mib_system_t, _sysObjectIDLength),
      0 },
    { 3, G_SNMP_TIMETICKS,
      SNMPV2_MIB_SYSUPTIME, "sysUpTime",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysUpTime),
      0,
      0 },
    { 4, G_SNMP_OCTETSTRING,
      SNMPV2_MIB_SYSCONTACT, "sysContact",
       sysContact_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysContact),
      G_STRUCT_OFFSET(snmpv2_mib_system_t, _sysContactLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_OCTETSTRING,
      SNMPV2_MIB_SYSNAME, "sysName",
       sysName_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysName),
      G_STRUCT_OFFSET(snmpv2_mib_system_t, _sysNameLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_OCTETSTRING,
      SNMPV2_MIB_SYSLOCATION, "sysLocation",
       sysLocation_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysLocation),
      G_STRUCT_OFFSET(snmpv2_mib_system_t, _sysLocationLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      SNMPV2_MIB_SYSSERVICES, "sysServices",
       sysServices_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysServices),
      0,
      0 },
    { 8, G_SNMP_TIMETICKS,
      SNMPV2_MIB_SYSORLASTCHANGE, "sysORLastChange",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_system_t, sysORLastChange),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const sysOREntry_oid[] = {1, 3, 6, 1, 2, 1, 1, 9, 1};

static GSnmpAttribute sysOREntry_attr[] = {
    { 2, G_SNMP_OBJECTID,
      SNMPV2_MIB_SYSORID, "sysORID",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_sysOREntry_t, sysORID),
      G_STRUCT_OFFSET(snmpv2_mib_sysOREntry_t, _sysORIDLength),
      0 },
    { 3, G_SNMP_OCTETSTRING,
      SNMPV2_MIB_SYSORDESCR, "sysORDescr",
       sysORDescr_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_sysOREntry_t, sysORDescr),
      G_STRUCT_OFFSET(snmpv2_mib_sysOREntry_t, _sysORDescrLength),
      0 },
    { 4, G_SNMP_TIMETICKS,
      SNMPV2_MIB_SYSORUPTIME, "sysORUpTime",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_sysOREntry_t, sysORUpTime),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const snmp_oid[] = {1, 3, 6, 1, 2, 1, 11};

static GSnmpAttribute snmp_attr[] = {
    { 1, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINPKTS, "snmpInPkts",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInPkts),
      0,
      0 },
    { 2, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTPKTS, "snmpOutPkts",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutPkts),
      0,
      0 },
    { 3, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINBADVERSIONS, "snmpInBadVersions",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInBadVersions),
      0,
      0 },
    { 4, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINBADCOMMUNITYNAMES, "snmpInBadCommunityNames",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInBadCommunityNames),
      0,
      0 },
    { 5, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINBADCOMMUNITYUSES, "snmpInBadCommunityUses",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInBadCommunityUses),
      0,
      0 },
    { 6, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINASNPARSEERRS, "snmpInASNParseErrs",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInASNParseErrs),
      0,
      0 },
    { 8, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINTOOBIGS, "snmpInTooBigs",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInTooBigs),
      0,
      0 },
    { 9, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINNOSUCHNAMES, "snmpInNoSuchNames",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInNoSuchNames),
      0,
      0 },
    { 10, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINBADVALUES, "snmpInBadValues",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInBadValues),
      0,
      0 },
    { 11, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINREADONLYS, "snmpInReadOnlys",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInReadOnlys),
      0,
      0 },
    { 12, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINGENERRS, "snmpInGenErrs",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInGenErrs),
      0,
      0 },
    { 13, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINTOTALREQVARS, "snmpInTotalReqVars",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInTotalReqVars),
      0,
      0 },
    { 14, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINTOTALSETVARS, "snmpInTotalSetVars",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInTotalSetVars),
      0,
      0 },
    { 15, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINGETREQUESTS, "snmpInGetRequests",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInGetRequests),
      0,
      0 },
    { 16, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINGETNEXTS, "snmpInGetNexts",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInGetNexts),
      0,
      0 },
    { 17, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINSETREQUESTS, "snmpInSetRequests",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInSetRequests),
      0,
      0 },
    { 18, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINGETRESPONSES, "snmpInGetResponses",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInGetResponses),
      0,
      0 },
    { 19, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPINTRAPS, "snmpInTraps",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpInTraps),
      0,
      0 },
    { 20, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTTOOBIGS, "snmpOutTooBigs",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutTooBigs),
      0,
      0 },
    { 21, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTNOSUCHNAMES, "snmpOutNoSuchNames",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutNoSuchNames),
      0,
      0 },
    { 22, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTBADVALUES, "snmpOutBadValues",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutBadValues),
      0,
      0 },
    { 24, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTGENERRS, "snmpOutGenErrs",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutGenErrs),
      0,
      0 },
    { 25, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTGETREQUESTS, "snmpOutGetRequests",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutGetRequests),
      0,
      0 },
    { 26, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTGETNEXTS, "snmpOutGetNexts",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutGetNexts),
      0,
      0 },
    { 27, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTSETREQUESTS, "snmpOutSetRequests",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutSetRequests),
      0,
      0 },
    { 28, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTGETRESPONSES, "snmpOutGetResponses",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutGetResponses),
      0,
      0 },
    { 29, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPOUTTRAPS, "snmpOutTraps",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpOutTraps),
      0,
      0 },
    { 30, G_SNMP_INTEGER32,
      SNMPV2_MIB_SNMPENABLEAUTHENTRAPS, "snmpEnableAuthenTraps",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpEnableAuthenTraps),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 31, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPSILENTDROPS, "snmpSilentDrops",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpSilentDrops),
      0,
      0 },
    { 32, G_SNMP_COUNTER32,
      SNMPV2_MIB_SNMPPROXYDROPS, "snmpProxyDrops",
       NULL,
      G_STRUCT_OFFSET(snmpv2_mib_snmp_t, snmpProxyDrops),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const snmpSet_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 6};

static GSnmpAttribute snmpSet_attr[] = {
    { 1, G_SNMP_INTEGER32,
      SNMPV2_MIB_SNMPSETSERIALNO, "snmpSetSerialNo",
       snmpSetSerialNo_constraints,
      G_STRUCT_OFFSET(snmpv2_mib_snmpSet_t, snmpSetSerialNo),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


snmpv2_mib_system_t *
snmpv2_mib_new_system()
{
    snmpv2_mib_system_t *system;

    system = (snmpv2_mib_system_t *) g_malloc0(sizeof(snmpv2_mib_system_t) + sizeof(gpointer));
    return system;
}

static snmpv2_mib_system_t *
assign_system(GSList *vbl)
{
    snmpv2_mib_system_t *system;
    char *p;

    system = snmpv2_mib_new_system();
    if (! system) {
        return NULL;
    }

    p = (char *) system + sizeof(snmpv2_mib_system_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, system_oid, sizeof(system_oid)/sizeof(guint32),
                      system_attr, system);

    return system;
}

void
snmpv2_mib_get_system(GSnmpSession *s, snmpv2_mib_system_t **system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0};

    *system = NULL;

    gsnmp_attr_get(s, &in, base, 8, 7, system_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *system = assign_system(out);
    }
}

void
snmpv2_mib_set_system(GSnmpSession *s, snmpv2_mib_system_t *system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0, 0};

    gsnmp_attr_set(s, &in, base, 9, 7, system_attr, mask, system);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_system(snmpv2_mib_system_t *system)
{
    GSList *vbl;
    char *p;

    if (system) {
        p = (char *) system + sizeof(snmpv2_mib_system_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(system);
    }
}

snmpv2_mib_sysOREntry_t *
snmpv2_mib_new_sysOREntry()
{
    snmpv2_mib_sysOREntry_t *sysOREntry;

    sysOREntry = (snmpv2_mib_sysOREntry_t *) g_malloc0(sizeof(snmpv2_mib_sysOREntry_t) + sizeof(gpointer));
    return sysOREntry;
}

static int
unpack_sysOREntry(GSnmpVarBind *vb, snmpv2_mib_sysOREntry_t *sysOREntry)
{
    guint8 idx = 10;

    if (vb->id_len < idx) return -1;
    sysOREntry->sysORIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_sysOREntry(guint32 *base, gint32 sysORIndex)
{
    guint8 idx = 10;

    base[idx++] = sysORIndex;
    return idx;
}

static snmpv2_mib_sysOREntry_t *
assign_sysOREntry(GSList *vbl)
{
    snmpv2_mib_sysOREntry_t *sysOREntry;
    char *p;

    sysOREntry = snmpv2_mib_new_sysOREntry();
    if (! sysOREntry) {
        return NULL;
    }

    p = (char *) sysOREntry + sizeof(snmpv2_mib_sysOREntry_t);
    * (GSList **) p = vbl;

    if (unpack_sysOREntry((GSnmpVarBind *) vbl->data, sysOREntry) < 0) {
        g_warning("%s: invalid instance identifier", "sysOREntry");
        g_free(sysOREntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, sysOREntry_oid, sizeof(sysOREntry_oid)/sizeof(guint32),
                      sysOREntry_attr, sysOREntry);

    return sysOREntry;
}

void
snmpv2_mib_get_sysORTable(GSnmpSession *s, snmpv2_mib_sysOREntry_t ***sysOREntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 9, 1, 0};

    *sysOREntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, sysOREntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *sysOREntry = (snmpv2_mib_sysOREntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmpv2_mib_sysOREntry_t *));
        if (! *sysOREntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*sysOREntry)[i] = assign_sysOREntry(row->data);
        }
    }
}

void
snmpv2_mib_get_sysOREntry(GSnmpSession *s, snmpv2_mib_sysOREntry_t **sysOREntry, gint32 sysORIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, sysOREntry_oid, sizeof(sysOREntry_oid));
    len = pack_sysOREntry(base, sysORIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "sysOREntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *sysOREntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, sysOREntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *sysOREntry = assign_sysOREntry(out);
    }
}

void
snmpv2_mib_free_sysOREntry(snmpv2_mib_sysOREntry_t *sysOREntry)
{
    GSList *vbl;
    char *p;

    if (sysOREntry) {
        p = (char *) sysOREntry + sizeof(snmpv2_mib_sysOREntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(sysOREntry);
    }
}

void
snmpv2_mib_free_sysORTable(snmpv2_mib_sysOREntry_t **sysOREntry)
{
    int i;

    if (sysOREntry) {
        for (i = 0; sysOREntry[i]; i++) {
            snmpv2_mib_free_sysOREntry(sysOREntry[i]);
        }
        g_free(sysOREntry);
    }
}

snmpv2_mib_snmp_t *
snmpv2_mib_new_snmp()
{
    snmpv2_mib_snmp_t *snmp;

    snmp = (snmpv2_mib_snmp_t *) g_malloc0(sizeof(snmpv2_mib_snmp_t) + sizeof(gpointer));
    return snmp;
}

static snmpv2_mib_snmp_t *
assign_snmp(GSList *vbl)
{
    snmpv2_mib_snmp_t *snmp;
    char *p;

    snmp = snmpv2_mib_new_snmp();
    if (! snmp) {
        return NULL;
    }

    p = (char *) snmp + sizeof(snmpv2_mib_snmp_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, snmp_oid, sizeof(snmp_oid)/sizeof(guint32),
                      snmp_attr, snmp);

    return snmp;
}

void
snmpv2_mib_get_snmp(GSnmpSession *s, snmpv2_mib_snmp_t **snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0};

    *snmp = NULL;

    gsnmp_attr_get(s, &in, base, 8, 7, snmp_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *snmp = assign_snmp(out);
    }
}

void
snmpv2_mib_set_snmp(GSnmpSession *s, snmpv2_mib_snmp_t *snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0, 0};

    gsnmp_attr_set(s, &in, base, 9, 7, snmp_attr, mask, snmp);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_snmp(snmpv2_mib_snmp_t *snmp)
{
    GSList *vbl;
    char *p;

    if (snmp) {
        p = (char *) snmp + sizeof(snmpv2_mib_snmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmp);
    }
}

snmpv2_mib_snmpSet_t *
snmpv2_mib_new_snmpSet()
{
    snmpv2_mib_snmpSet_t *snmpSet;

    snmpSet = (snmpv2_mib_snmpSet_t *) g_malloc0(sizeof(snmpv2_mib_snmpSet_t) + sizeof(gpointer));
    return snmpSet;
}

static snmpv2_mib_snmpSet_t *
assign_snmpSet(GSList *vbl)
{
    snmpv2_mib_snmpSet_t *snmpSet;
    char *p;

    snmpSet = snmpv2_mib_new_snmpSet();
    if (! snmpSet) {
        return NULL;
    }

    p = (char *) snmpSet + sizeof(snmpv2_mib_snmpSet_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, snmpSet_oid, sizeof(snmpSet_oid)/sizeof(guint32),
                      snmpSet_attr, snmpSet);

    return snmpSet;
}

void
snmpv2_mib_get_snmpSet(GSnmpSession *s, snmpv2_mib_snmpSet_t **snmpSet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6, 0};

    *snmpSet = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, snmpSet_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *snmpSet = assign_snmpSet(out);
    }
}

void
snmpv2_mib_set_snmpSet(GSnmpSession *s, snmpv2_mib_snmpSet_t *snmpSet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6, 0, 0};

    gsnmp_attr_set(s, &in, base, 11, 9, snmpSet_attr, mask, snmpSet);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_snmpSet(snmpv2_mib_snmpSet_t *snmpSet)
{
    GSList *vbl;
    char *p;

    if (snmpSet) {
        p = (char *) snmpSet + sizeof(snmpv2_mib_snmpSet_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmpSet);
    }
}


