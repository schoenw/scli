/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.17 for the scli package.
 *
 * Derived from SNMPv2-MIB:
 *   The MIB module for SNMPv2 entities.
 *
 * Revision 1995-11-09 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 1993-04-01 00:00:
 *   The initial revision of this MIB module was published as
 *   RFC 1450.
 *
 * $Id$
 */

#include "snmpv2-mib.h"

GSnmpEnum const snmpv2_mib_enums_snmpEnableAuthenTraps[] = {
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_ENABLED,	"enabled" },
    { SNMPV2_MIB_SNMPENABLEAUTHENTRAPS_DISABLED,	"disabled" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, gsize len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, gsize const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		g_warning("type tag 0x%02x does not match 0x%02x (%s)",
			  vb->type, attributes[i].type, attributes[i].label);
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_system[] = {1, 3, 6, 1, 2, 1, 1};

static attribute_t attr_system[] = {
    { 1, G_SNMP_OCTET_STRING, SNMPV2_MIB_SYSDESCR, "sysDescr" },
    { 2, G_SNMP_OBJECT_ID, SNMPV2_MIB_SYSOBJECTID, "sysObjectID" },
    { 3, G_SNMP_TIMETICKS, SNMPV2_MIB_SYSUPTIME, "sysUpTime" },
    { 4, G_SNMP_OCTET_STRING, SNMPV2_MIB_SYSCONTACT, "sysContact" },
    { 5, G_SNMP_OCTET_STRING, SNMPV2_MIB_SYSNAME, "sysName" },
    { 6, G_SNMP_OCTET_STRING, SNMPV2_MIB_SYSLOCATION, "sysLocation" },
    { 7, G_SNMP_INTEGER32, SNMPV2_MIB_SYSSERVICES, "sysServices" },
    { 8, G_SNMP_TIMETICKS, SNMPV2_MIB_SYSORLASTCHANGE, "sysORLastChange" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_sysOREntry[] = {1, 3, 6, 1, 2, 1, 1, 9, 1};

static attribute_t attr_sysOREntry[] = {
    { 2, G_SNMP_OBJECT_ID, SNMPV2_MIB_SYSORID, "sysORID" },
    { 3, G_SNMP_OCTET_STRING, SNMPV2_MIB_SYSORDESCR, "sysORDescr" },
    { 4, G_SNMP_TIMETICKS, SNMPV2_MIB_SYSORUPTIME, "sysORUpTime" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_snmp[] = {1, 3, 6, 1, 2, 1, 11};

static attribute_t attr_snmp[] = {
    { 1, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINPKTS, "snmpInPkts" },
    { 2, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTPKTS, "snmpOutPkts" },
    { 3, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINBADVERSIONS, "snmpInBadVersions" },
    { 4, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINBADCOMMUNITYNAMES, "snmpInBadCommunityNames" },
    { 5, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINBADCOMMUNITYUSES, "snmpInBadCommunityUses" },
    { 6, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINASNPARSEERRS, "snmpInASNParseErrs" },
    { 8, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINTOOBIGS, "snmpInTooBigs" },
    { 9, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINNOSUCHNAMES, "snmpInNoSuchNames" },
    { 10, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINBADVALUES, "snmpInBadValues" },
    { 11, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINREADONLYS, "snmpInReadOnlys" },
    { 12, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINGENERRS, "snmpInGenErrs" },
    { 13, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINTOTALREQVARS, "snmpInTotalReqVars" },
    { 14, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINTOTALSETVARS, "snmpInTotalSetVars" },
    { 15, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINGETREQUESTS, "snmpInGetRequests" },
    { 16, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINGETNEXTS, "snmpInGetNexts" },
    { 17, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINSETREQUESTS, "snmpInSetRequests" },
    { 18, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINGETRESPONSES, "snmpInGetResponses" },
    { 19, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPINTRAPS, "snmpInTraps" },
    { 20, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTTOOBIGS, "snmpOutTooBigs" },
    { 21, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTNOSUCHNAMES, "snmpOutNoSuchNames" },
    { 22, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTBADVALUES, "snmpOutBadValues" },
    { 24, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTGENERRS, "snmpOutGenErrs" },
    { 25, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTGETREQUESTS, "snmpOutGetRequests" },
    { 26, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTGETNEXTS, "snmpOutGetNexts" },
    { 27, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTSETREQUESTS, "snmpOutSetRequests" },
    { 28, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTGETRESPONSES, "snmpOutGetResponses" },
    { 29, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPOUTTRAPS, "snmpOutTraps" },
    { 30, G_SNMP_INTEGER32, SNMPV2_MIB_SNMPENABLEAUTHENTRAPS, "snmpEnableAuthenTraps" },
    { 31, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPSILENTDROPS, "snmpSilentDrops" },
    { 32, G_SNMP_COUNTER32, SNMPV2_MIB_SNMPPROXYDROPS, "snmpProxyDrops" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_snmpSet[] = {1, 3, 6, 1, 6, 3, 1, 1, 6};

static attribute_t attr_snmpSet[] = {
    { 1, G_SNMP_INTEGER32, SNMPV2_MIB_SNMPSETSERIALNO, "snmpSetSerialNo" },
    { 0, 0, 0, NULL }
};


snmpv2_mib_system_t *
snmpv2_mib_new_system()
{
    snmpv2_mib_system_t *system;

    system = (snmpv2_mib_system_t *) g_malloc0(sizeof(snmpv2_mib_system_t) + sizeof(gpointer));
    return system;
}

static snmpv2_mib_system_t *
assign_system(GSList *vbl)
{
    GSList *elem;
    snmpv2_mib_system_t *system;
    guint32 idx;
    char *p;

    system = snmpv2_mib_new_system();
    if (! system) {
        return NULL;
    }

    p = (char *) system + sizeof(snmpv2_mib_system_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_system, sizeof(oid_system)/sizeof(guint32),
                   attr_system, &idx) < 0) continue;

        switch (idx) {
        case 1:
            system->_sysDescrLength = vb->syntax_len;
            system->sysDescr = vb->syntax.uc;
            break;
        case 2:
            system->_sysObjectIDLength = vb->syntax_len / sizeof(guint32);
            system->sysObjectID = vb->syntax.ui32;
            break;
        case 3:
            system->sysUpTime = &(vb->syntax.ui32[0]);
            break;
        case 4:
            system->_sysContactLength = vb->syntax_len;
            system->sysContact = vb->syntax.uc;
            break;
        case 5:
            system->_sysNameLength = vb->syntax_len;
            system->sysName = vb->syntax.uc;
            break;
        case 6:
            system->_sysLocationLength = vb->syntax_len;
            system->sysLocation = vb->syntax.uc;
            break;
        case 7:
            system->sysServices = &(vb->syntax.i32[0]);
            break;
        case 8:
            system->sysORLastChange = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return system;
}

void
snmpv2_mib_get_system(GSnmpSession *s, snmpv2_mib_system_t **system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0};

    *system = NULL;

    add_attributes(s, &in, base, 8, 7, attr_system, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *system = assign_system(out);
    }
}

void
snmpv2_mib_set_system(GSnmpSession *s, snmpv2_mib_system_t *system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0, 0};

    if (system->sysContact) {
        base[7] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysContact,
                       system->_sysContactLength);
    }
    if (system->sysName) {
        base[7] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysName,
                       system->_sysNameLength);
    }
    if (system->sysLocation) {
        base[7] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysLocation,
                       system->_sysLocationLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_system(snmpv2_mib_system_t *system)
{
    GSList *vbl;
    char *p;

    if (system) {
        p = (char *) system + sizeof(snmpv2_mib_system_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(system);
    }
}

snmpv2_mib_sysOREntry_t *
snmpv2_mib_new_sysOREntry()
{
    snmpv2_mib_sysOREntry_t *sysOREntry;

    sysOREntry = (snmpv2_mib_sysOREntry_t *) g_malloc0(sizeof(snmpv2_mib_sysOREntry_t) + sizeof(gpointer));
    return sysOREntry;
}

static int
unpack_sysOREntry(GSnmpVarBind *vb, snmpv2_mib_sysOREntry_t *sysOREntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    sysOREntry->sysORIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_sysOREntry(guint32 *base, gint32 sysORIndex)
{
    int idx = 10;

    base[idx++] = sysORIndex;
    return idx;
}

static snmpv2_mib_sysOREntry_t *
assign_sysOREntry(GSList *vbl)
{
    GSList *elem;
    snmpv2_mib_sysOREntry_t *sysOREntry;
    guint32 idx;
    char *p;

    sysOREntry = snmpv2_mib_new_sysOREntry();
    if (! sysOREntry) {
        return NULL;
    }

    p = (char *) sysOREntry + sizeof(snmpv2_mib_sysOREntry_t);
    * (GSList **) p = vbl;

    if (unpack_sysOREntry((GSnmpVarBind *) vbl->data, sysOREntry) < 0) {
        g_warning("illegal sysOREntry instance identifier");
        g_free(sysOREntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_sysOREntry, sizeof(oid_sysOREntry)/sizeof(guint32),
                   attr_sysOREntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            sysOREntry->_sysORIDLength = vb->syntax_len / sizeof(guint32);
            sysOREntry->sysORID = vb->syntax.ui32;
            break;
        case 3:
            sysOREntry->_sysORDescrLength = vb->syntax_len;
            sysOREntry->sysORDescr = vb->syntax.uc;
            break;
        case 4:
            sysOREntry->sysORUpTime = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return sysOREntry;
}

void
snmpv2_mib_get_sysORTable(GSnmpSession *s, snmpv2_mib_sysOREntry_t ***sysOREntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 9, 1, 0};

    *sysOREntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_sysOREntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *sysOREntry = (snmpv2_mib_sysOREntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmpv2_mib_sysOREntry_t *));
        if (! *sysOREntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*sysOREntry)[i] = assign_sysOREntry(row->data);
        }
    }
}

void
snmpv2_mib_get_sysOREntry(GSnmpSession *s, snmpv2_mib_sysOREntry_t **sysOREntry, gint32 sysORIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_sysOREntry, sizeof(oid_sysOREntry));
    len = pack_sysOREntry(base, sysORIndex);
    if (len < 0) {
        g_warning("illegal sysOREntry index values");
        return;
    }

    *sysOREntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_sysOREntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *sysOREntry = assign_sysOREntry(out);
    }
}

void
snmpv2_mib_free_sysOREntry(snmpv2_mib_sysOREntry_t *sysOREntry)
{
    GSList *vbl;
    char *p;

    if (sysOREntry) {
        p = (char *) sysOREntry + sizeof(snmpv2_mib_sysOREntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(sysOREntry);
    }
}

void
snmpv2_mib_free_sysORTable(snmpv2_mib_sysOREntry_t **sysOREntry)
{
    int i;

    if (sysOREntry) {
        for (i = 0; sysOREntry[i]; i++) {
            snmpv2_mib_free_sysOREntry(sysOREntry[i]);
        }
        g_free(sysOREntry);
    }
}

snmpv2_mib_snmp_t *
snmpv2_mib_new_snmp()
{
    snmpv2_mib_snmp_t *snmp;

    snmp = (snmpv2_mib_snmp_t *) g_malloc0(sizeof(snmpv2_mib_snmp_t) + sizeof(gpointer));
    return snmp;
}

static snmpv2_mib_snmp_t *
assign_snmp(GSList *vbl)
{
    GSList *elem;
    snmpv2_mib_snmp_t *snmp;
    guint32 idx;
    char *p;

    snmp = snmpv2_mib_new_snmp();
    if (! snmp) {
        return NULL;
    }

    p = (char *) snmp + sizeof(snmpv2_mib_snmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_snmp, sizeof(oid_snmp)/sizeof(guint32),
                   attr_snmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            snmp->snmpInPkts = &(vb->syntax.ui32[0]);
            break;
        case 2:
            snmp->snmpOutPkts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            snmp->snmpInBadVersions = &(vb->syntax.ui32[0]);
            break;
        case 4:
            snmp->snmpInBadCommunityNames = &(vb->syntax.ui32[0]);
            break;
        case 5:
            snmp->snmpInBadCommunityUses = &(vb->syntax.ui32[0]);
            break;
        case 6:
            snmp->snmpInASNParseErrs = &(vb->syntax.ui32[0]);
            break;
        case 8:
            snmp->snmpInTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            snmp->snmpInNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 10:
            snmp->snmpInBadValues = &(vb->syntax.ui32[0]);
            break;
        case 11:
            snmp->snmpInReadOnlys = &(vb->syntax.ui32[0]);
            break;
        case 12:
            snmp->snmpInGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 13:
            snmp->snmpInTotalReqVars = &(vb->syntax.ui32[0]);
            break;
        case 14:
            snmp->snmpInTotalSetVars = &(vb->syntax.ui32[0]);
            break;
        case 15:
            snmp->snmpInGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 16:
            snmp->snmpInGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 17:
            snmp->snmpInSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 18:
            snmp->snmpInGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 19:
            snmp->snmpInTraps = &(vb->syntax.ui32[0]);
            break;
        case 20:
            snmp->snmpOutTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 21:
            snmp->snmpOutNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 22:
            snmp->snmpOutBadValues = &(vb->syntax.ui32[0]);
            break;
        case 24:
            snmp->snmpOutGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 25:
            snmp->snmpOutGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 26:
            snmp->snmpOutGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 27:
            snmp->snmpOutSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 28:
            snmp->snmpOutGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 29:
            snmp->snmpOutTraps = &(vb->syntax.ui32[0]);
            break;
        case 30:
            snmp->snmpEnableAuthenTraps = &(vb->syntax.i32[0]);
            break;
        case 31:
            snmp->snmpSilentDrops = &(vb->syntax.ui32[0]);
            break;
        case 32:
            snmp->snmpProxyDrops = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return snmp;
}

void
snmpv2_mib_get_snmp(GSnmpSession *s, snmpv2_mib_snmp_t **snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0};

    *snmp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_snmp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *snmp = assign_snmp(out);
    }
}

void
snmpv2_mib_set_snmp(GSnmpSession *s, snmpv2_mib_snmp_t *snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0, 0};

    if (snmp->snmpEnableAuthenTraps) {
        base[7] = 30;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       snmp->snmpEnableAuthenTraps,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_snmp(snmpv2_mib_snmp_t *snmp)
{
    GSList *vbl;
    char *p;

    if (snmp) {
        p = (char *) snmp + sizeof(snmpv2_mib_snmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmp);
    }
}

snmpv2_mib_snmpSet_t *
snmpv2_mib_new_snmpSet()
{
    snmpv2_mib_snmpSet_t *snmpSet;

    snmpSet = (snmpv2_mib_snmpSet_t *) g_malloc0(sizeof(snmpv2_mib_snmpSet_t) + sizeof(gpointer));
    return snmpSet;
}

static snmpv2_mib_snmpSet_t *
assign_snmpSet(GSList *vbl)
{
    GSList *elem;
    snmpv2_mib_snmpSet_t *snmpSet;
    guint32 idx;
    char *p;

    snmpSet = snmpv2_mib_new_snmpSet();
    if (! snmpSet) {
        return NULL;
    }

    p = (char *) snmpSet + sizeof(snmpv2_mib_snmpSet_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_snmpSet, sizeof(oid_snmpSet)/sizeof(guint32),
                   attr_snmpSet, &idx) < 0) continue;

        switch (idx) {
        case 1:
            snmpSet->snmpSetSerialNo = &(vb->syntax.i32[0]);
            break;
        };
    }

    return snmpSet;
}

void
snmpv2_mib_get_snmpSet(GSnmpSession *s, snmpv2_mib_snmpSet_t **snmpSet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6, 0};

    *snmpSet = NULL;

    add_attributes(s, &in, base, 10, 9, attr_snmpSet, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *snmpSet = assign_snmpSet(out);
    }
}

void
snmpv2_mib_set_snmpSet(GSnmpSession *s, snmpv2_mib_snmpSet_t *snmpSet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 1, 1, 6, 0, 0};

    if (snmpSet->snmpSetSerialNo) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       snmpSet->snmpSetSerialNo,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmpv2_mib_free_snmpSet(snmpv2_mib_snmpSet_t *snmpSet)
{
    GSList *vbl;
    char *p;

    if (snmpSet) {
        p = (char *) snmpSet + sizeof(snmpv2_mib_snmpSet_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmpSet);
    }
}


