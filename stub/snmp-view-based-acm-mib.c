/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from SNMP-VIEW-BASED-ACM-MIB revision 1999-01-20 00:00.
 *
 * $Id$
 */

#include "snmp-view-based-acm-mib.h"

stls_table_t snmp_view_based_acm_mib_enums_vacmSecurityToGroupStorageType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 4, "permanent" },
    { 5, "readOnly" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmSecurityToGroupStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmAccessSecurityLevel[] = {
    { 1, "noAuthNoPriv" },
    { 2, "authNoPriv" },
    { 3, "authPriv" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmAccessContextMatch[] = {
    { 1, "exact" },
    { 2, "prefix" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmAccessStorageType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 4, "permanent" },
    { 5, "readOnly" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmAccessStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmViewTreeFamilyType[] = {
    { 1, "included" },
    { 2, "excluded" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmViewTreeFamilyStorageType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 4, "permanent" },
    { 5, "readOnly" },
    { 0, NULL }
};

stls_table_t snmp_view_based_acm_mib_enums_vacmViewTreeFamilyStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};


static vacmContextEntry_t *
assign_vacmContextEntry(GSList *vbl)
{
    GSList *elem;
    vacmContextEntry_t *vacmContextEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 16, 1, 1, 1};

    vacmContextEntry = (vacmContextEntry_t *) g_malloc0(sizeof(vacmContextEntry_t) + sizeof(GSList *));
    if (! vacmContextEntry) {
        return NULL;
    }

    p = (char *) vacmContextEntry + sizeof(vacmContextEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        /* XXX fix this vacmContextEntry->vacmContextName = ?; */
        if (vb->id_len > 11) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
    }

    return vacmContextEntry;
}

int
snmp_view_based_acm_mib_get_vacmContextEntry(host_snmp *s, vacmContextEntry_t ***vacmContextEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 1, 1, 0};

    *vacmContextEntry = NULL;


    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *vacmContextEntry = (vacmContextEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(vacmContextEntry_t *));
    if (! *vacmContextEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*vacmContextEntry)[i] = assign_vacmContextEntry(row->data);
    }

    return 0;
}

void
snmp_view_based_acm_mib_free_vacmContextEntry(vacmContextEntry_t **vacmContextEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (vacmContextEntry) {
        for (i = 0; vacmContextEntry[i]; i++) {
            p = (char *) vacmContextEntry[i] + sizeof(vacmContextEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(vacmContextEntry[i]);
        }
        g_free(vacmContextEntry);
    }
}

static vacmSecurityToGroupEntry_t *
assign_vacmSecurityToGroupEntry(GSList *vbl)
{
    GSList *elem;
    vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 16, 1, 2, 1};

    vacmSecurityToGroupEntry = (vacmSecurityToGroupEntry_t *) g_malloc0(sizeof(vacmSecurityToGroupEntry_t) + sizeof(GSList *));
    if (! vacmSecurityToGroupEntry) {
        return NULL;
    }

    p = (char *) vacmSecurityToGroupEntry + sizeof(vacmSecurityToGroupEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        vacmSecurityToGroupEntry->vacmSecurityModel = (gint32 *) &(vb->id[11]);
        /* XXX fix this vacmSecurityToGroupEntry->vacmSecurityName = ?; */
        if (vb->id_len > 12) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 3) {
            vacmSecurityToGroupEntry->_vacmGroupNameLength = vb->syntax_len;
            vacmSecurityToGroupEntry->vacmGroupName = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            vacmSecurityToGroupEntry->vacmSecurityToGroupStorageType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            vacmSecurityToGroupEntry->vacmSecurityToGroupStatus = &(vb->syntax.i32[0]);
        }
    }

    return vacmSecurityToGroupEntry;
}

int
snmp_view_based_acm_mib_get_vacmSecurityToGroupEntry(host_snmp *s, vacmSecurityToGroupEntry_t ***vacmSecurityToGroupEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 2, 1, 0};

    *vacmSecurityToGroupEntry = NULL;

    base[10] = 3; stls_vbl_add_null(&in, base, 11);
    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *vacmSecurityToGroupEntry = (vacmSecurityToGroupEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(vacmSecurityToGroupEntry_t *));
    if (! *vacmSecurityToGroupEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*vacmSecurityToGroupEntry)[i] = assign_vacmSecurityToGroupEntry(row->data);
    }

    return 0;
}

void
snmp_view_based_acm_mib_free_vacmSecurityToGroupEntry(vacmSecurityToGroupEntry_t **vacmSecurityToGroupEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (vacmSecurityToGroupEntry) {
        for (i = 0; vacmSecurityToGroupEntry[i]; i++) {
            p = (char *) vacmSecurityToGroupEntry[i] + sizeof(vacmSecurityToGroupEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(vacmSecurityToGroupEntry[i]);
        }
        g_free(vacmSecurityToGroupEntry);
    }
}

static vacmAccessEntry_t *
assign_vacmAccessEntry(GSList *vbl)
{
    GSList *elem;
    vacmAccessEntry_t *vacmAccessEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 16, 1, 4, 1};

    vacmAccessEntry = (vacmAccessEntry_t *) g_malloc0(sizeof(vacmAccessEntry_t) + sizeof(GSList *));
    if (! vacmAccessEntry) {
        return NULL;
    }

    p = (char *) vacmAccessEntry + sizeof(vacmAccessEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 12) return NULL;
        /* XXX fix this vacmAccessEntry->vacmGroupName = ?; */
        /* XXX fix this vacmAccessEntry->vacmAccessContextPrefix = ?; */
        vacmAccessEntry->vacmAccessSecurityModel = (gint32 *) &(vb->id[11]);
        vacmAccessEntry->vacmAccessSecurityLevel = (gint32 *) &(vb->id[12]);
        if (vb->id_len > 13) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 11 && vb->id[10] == 4) {
            vacmAccessEntry->vacmAccessContextMatch = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 5) {
            vacmAccessEntry->_vacmAccessReadViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessReadViewName = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 6) {
            vacmAccessEntry->_vacmAccessWriteViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessWriteViewName = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 7) {
            vacmAccessEntry->_vacmAccessNotifyViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessNotifyViewName = vb->syntax.uc;
        }
        if (vb->id_len > 11 && vb->id[10] == 8) {
            vacmAccessEntry->vacmAccessStorageType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 11 && vb->id[10] == 9) {
            vacmAccessEntry->vacmAccessStatus = &(vb->syntax.i32[0]);
        }
    }

    return vacmAccessEntry;
}

int
snmp_view_based_acm_mib_get_vacmAccessEntry(host_snmp *s, vacmAccessEntry_t ***vacmAccessEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 4, 1, 0};

    *vacmAccessEntry = NULL;

    base[10] = 4; stls_vbl_add_null(&in, base, 11);
    base[10] = 5; stls_vbl_add_null(&in, base, 11);
    base[10] = 6; stls_vbl_add_null(&in, base, 11);
    base[10] = 7; stls_vbl_add_null(&in, base, 11);
    base[10] = 8; stls_vbl_add_null(&in, base, 11);
    base[10] = 9; stls_vbl_add_null(&in, base, 11);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *vacmAccessEntry = (vacmAccessEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(vacmAccessEntry_t *));
    if (! *vacmAccessEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*vacmAccessEntry)[i] = assign_vacmAccessEntry(row->data);
    }

    return 0;
}

void
snmp_view_based_acm_mib_free_vacmAccessEntry(vacmAccessEntry_t **vacmAccessEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (vacmAccessEntry) {
        for (i = 0; vacmAccessEntry[i]; i++) {
            p = (char *) vacmAccessEntry[i] + sizeof(vacmAccessEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(vacmAccessEntry[i]);
        }
        g_free(vacmAccessEntry);
    }
}

static vacmMIBViews_t *
assign_vacmMIBViews(GSList *vbl)
{
    GSList *elem;
    vacmMIBViews_t *vacmMIBViews;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5};

    vacmMIBViews = (vacmMIBViews_t *) g_malloc0(sizeof(vacmMIBViews_t) + sizeof(GSList *));
    if (! vacmMIBViews) {
        return NULL;
    }

    p = (char *) vacmMIBViews + sizeof(vacmMIBViews_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 1) {
            vacmMIBViews->vacmViewSpinLock = &(vb->syntax.i32[0]);
        }
    }

    return vacmMIBViews;
}

int
snmp_view_based_acm_mib_get_vacmMIBViews(host_snmp *s, vacmMIBViews_t **vacmMIBViews)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 0};

    *vacmMIBViews = NULL;

    base[9] = 1; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *vacmMIBViews = assign_vacmMIBViews(out);

    return 0;
}

void
snmp_view_based_acm_mib_free_vacmMIBViews(vacmMIBViews_t *vacmMIBViews)
{
    GSList *vbl;
    char *p;

    if (vacmMIBViews) {
        p = (char *) vacmMIBViews + sizeof(vacmMIBViews_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(vacmMIBViews);
    }
}

static vacmViewTreeFamilyEntry_t *
assign_vacmViewTreeFamilyEntry(GSList *vbl)
{
    GSList *elem;
    vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 2, 1};

    vacmViewTreeFamilyEntry = (vacmViewTreeFamilyEntry_t *) g_malloc0(sizeof(vacmViewTreeFamilyEntry_t) + sizeof(GSList *));
    if (! vacmViewTreeFamilyEntry) {
        return NULL;
    }

    p = (char *) vacmViewTreeFamilyEntry + sizeof(vacmViewTreeFamilyEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        if (vb->id_len < 13) return NULL;
        /* XXX fix this vacmViewTreeFamilyEntry->vacmViewTreeFamilyViewName = ?; */
        /* XXX fix this vacmViewTreeFamilyEntry->vacmViewTreeFamilySubtree = ?; */
        if (vb->id_len > 12) return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 12 && vb->id[11] == 3) {
            vacmViewTreeFamilyEntry->_vacmViewTreeFamilyMaskLength = vb->syntax_len;
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyMask = vb->syntax.uc;
        }
        if (vb->id_len > 12 && vb->id[11] == 4) {
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 12 && vb->id[11] == 5) {
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyStorageType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 12 && vb->id[11] == 6) {
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyStatus = &(vb->syntax.i32[0]);
        }
    }

    return vacmViewTreeFamilyEntry;
}

int
snmp_view_based_acm_mib_get_vacmViewTreeFamilyEntry(host_snmp *s, vacmViewTreeFamilyEntry_t ***vacmViewTreeFamilyEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 2, 1, 0};

    *vacmViewTreeFamilyEntry = NULL;

    base[11] = 3; stls_vbl_add_null(&in, base, 12);
    base[11] = 4; stls_vbl_add_null(&in, base, 12);
    base[11] = 5; stls_vbl_add_null(&in, base, 12);
    base[11] = 6; stls_vbl_add_null(&in, base, 12);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *vacmViewTreeFamilyEntry = (vacmViewTreeFamilyEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(vacmViewTreeFamilyEntry_t *));
    if (! *vacmViewTreeFamilyEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*vacmViewTreeFamilyEntry)[i] = assign_vacmViewTreeFamilyEntry(row->data);
    }

    return 0;
}

void
snmp_view_based_acm_mib_free_vacmViewTreeFamilyEntry(vacmViewTreeFamilyEntry_t **vacmViewTreeFamilyEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (vacmViewTreeFamilyEntry) {
        for (i = 0; vacmViewTreeFamilyEntry[i]; i++) {
            p = (char *) vacmViewTreeFamilyEntry[i] + sizeof(vacmViewTreeFamilyEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(vacmViewTreeFamilyEntry[i]);
        }
        g_free(vacmViewTreeFamilyEntry);
    }
}


