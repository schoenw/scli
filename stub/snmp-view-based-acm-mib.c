/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from SNMP-VIEW-BASED-ACM-MIB:
 *   The management information definitions for the
 *   View-based Access Control Model for SNMP.
 *   
 *
 * Revision 1999-01-20 00:00:
 *   Clarifications, published as RFC2575
 *
 * Revision 1997-11-20 00:00:
 *   Initial version, published as RFC2275
 *
 * $Id$
 */

#include "snmp-view-based-acm-mib.h"

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmSecurityToGroupStorageType[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE_OTHER,	"other" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE_VOLATILE,	"volatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE_NONVOLATILE,	"nonVolatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE_PERMANENT,	"permanent" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmSecurityToGroupStatus[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_ACTIVE,	"active" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_NOTINSERVICE,	"notInService" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_NOTREADY,	"notReady" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_CREATEANDGO,	"createAndGo" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_CREATEANDWAIT,	"createAndWait" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmAccessSecurityLevel[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSECURITYLEVEL_NOAUTHNOPRIV,	"noAuthNoPriv" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSECURITYLEVEL_AUTHNOPRIV,	"authNoPriv" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSECURITYLEVEL_AUTHPRIV,	"authPriv" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmAccessContextMatch[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSCONTEXTMATCH_EXACT,	"exact" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSCONTEXTMATCH_PREFIX,	"prefix" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmAccessStorageType[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE_OTHER,	"other" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE_VOLATILE,	"volatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE_NONVOLATILE,	"nonVolatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE_PERMANENT,	"permanent" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmAccessStatus[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_ACTIVE,	"active" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_NOTINSERVICE,	"notInService" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_NOTREADY,	"notReady" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_CREATEANDGO,	"createAndGo" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_CREATEANDWAIT,	"createAndWait" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmViewTreeFamilyType[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYTYPE_INCLUDED,	"included" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYTYPE_EXCLUDED,	"excluded" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmViewTreeFamilyStorageType[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE_OTHER,	"other" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE_VOLATILE,	"volatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE_NONVOLATILE,	"nonVolatile" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE_PERMANENT,	"permanent" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE_READONLY,	"readOnly" },
    { 0, NULL }
};

GSnmpEnum const snmp_view_based_acm_mib_enums_vacmViewTreeFamilyStatus[] = {
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_ACTIVE,	"active" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_NOTINSERVICE,	"notInService" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_NOTREADY,	"notReady" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_CREATEANDGO,	"createAndGo" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_CREATEANDWAIT,	"createAndWait" },
    { SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_vacmContextEntry[] = {1, 3, 6, 1, 6, 3, 16, 1, 1, 1};

static attribute_t attr_vacmContextEntry[] = {
    { 1, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMCONTEXTNAME, "vacmContextName" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_vacmSecurityToGroupEntry[] = {1, 3, 6, 1, 6, 3, 16, 1, 2, 1};

static attribute_t attr_vacmSecurityToGroupEntry[] = {
    { 3, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMGROUPNAME, "vacmGroupName" },
    { 4, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTORAGETYPE, "vacmSecurityToGroupStorageType" },
    { 5, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMSECURITYTOGROUPSTATUS, "vacmSecurityToGroupStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_vacmAccessEntry[] = {1, 3, 6, 1, 6, 3, 16, 1, 4, 1};

static attribute_t attr_vacmAccessEntry[] = {
    { 4, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSCONTEXTMATCH, "vacmAccessContextMatch" },
    { 5, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSREADVIEWNAME, "vacmAccessReadViewName" },
    { 6, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSWRITEVIEWNAME, "vacmAccessWriteViewName" },
    { 7, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSNOTIFYVIEWNAME, "vacmAccessNotifyViewName" },
    { 8, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTORAGETYPE, "vacmAccessStorageType" },
    { 9, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMACCESSSTATUS, "vacmAccessStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_vacmMIBViews[] = {1, 3, 6, 1, 6, 3, 16, 1, 5};

static attribute_t attr_vacmMIBViews[] = {
    { 1, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMVIEWSPINLOCK, "vacmViewSpinLock" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_vacmViewTreeFamilyEntry[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 2, 1};

static attribute_t attr_vacmViewTreeFamilyEntry[] = {
    { 3, G_SNMP_OCTETSTRING, SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYMASK, "vacmViewTreeFamilyMask" },
    { 4, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYTYPE, "vacmViewTreeFamilyType" },
    { 5, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTORAGETYPE, "vacmViewTreeFamilyStorageType" },
    { 6, G_SNMP_INTEGER32, SNMP_VIEW_BASED_ACM_MIB_VACMVIEWTREEFAMILYSTATUS, "vacmViewTreeFamilyStatus" },
    { 0, 0, 0, NULL }
};


snmp_view_based_acm_mib_vacmContextEntry_t *
snmp_view_based_acm_mib_new_vacmContextEntry()
{
    snmp_view_based_acm_mib_vacmContextEntry_t *vacmContextEntry;

    vacmContextEntry = (snmp_view_based_acm_mib_vacmContextEntry_t *) g_malloc0(sizeof(snmp_view_based_acm_mib_vacmContextEntry_t) + sizeof(gpointer));
    return vacmContextEntry;
}

static int
unpack_vacmContextEntry(GSnmpVarBind *vb, snmp_view_based_acm_mib_vacmContextEntry_t *vacmContextEntry)
{
    int idx = 11;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        vacmContextEntry->vacmContextName[i] = vb->id[idx++];
    }
    vacmContextEntry->_vacmContextNameLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_vacmContextEntry(guint32 *base, guchar *vacmContextName, guint16 _vacmContextNameLength)
{
    int idx = 11;
    guint16 i, len;

    len = _vacmContextNameLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmContextName[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static snmp_view_based_acm_mib_vacmContextEntry_t *
assign_vacmContextEntry(GSList *vbl)
{
    GSList *elem;
    snmp_view_based_acm_mib_vacmContextEntry_t *vacmContextEntry;
    guint32 idx;
    char *p;

    vacmContextEntry = snmp_view_based_acm_mib_new_vacmContextEntry();
    if (! vacmContextEntry) {
        return NULL;
    }

    p = (char *) vacmContextEntry + sizeof(snmp_view_based_acm_mib_vacmContextEntry_t);
    * (GSList **) p = vbl;

    if (unpack_vacmContextEntry((GSnmpVarBind *) vbl->data, vacmContextEntry) < 0) {
        g_warning("illegal vacmContextEntry instance identifier");
        g_free(vacmContextEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_vacmContextEntry, sizeof(oid_vacmContextEntry)/sizeof(guint32),
                   attr_vacmContextEntry, &idx) < 0) continue;

        switch (idx) {
        };
    }

    return vacmContextEntry;
}

void
snmp_view_based_acm_mib_get_vacmContextTable(GSnmpSession *s, snmp_view_based_acm_mib_vacmContextEntry_t ***vacmContextEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 1, 1, 0};

    *vacmContextEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_vacmContextEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *vacmContextEntry = (snmp_view_based_acm_mib_vacmContextEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmp_view_based_acm_mib_vacmContextEntry_t *));
        if (! *vacmContextEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*vacmContextEntry)[i] = assign_vacmContextEntry(row->data);
        }
    }
}

void
snmp_view_based_acm_mib_get_vacmContextEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmContextEntry_t **vacmContextEntry, guchar *vacmContextName, guint16 _vacmContextNameLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmContextEntry, sizeof(oid_vacmContextEntry));
    len = pack_vacmContextEntry(base, vacmContextName, _vacmContextNameLength);
    if (len < 0) {
        g_warning("illegal vacmContextEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *vacmContextEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_vacmContextEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *vacmContextEntry = assign_vacmContextEntry(out);
    }
}

void
snmp_view_based_acm_mib_free_vacmContextEntry(snmp_view_based_acm_mib_vacmContextEntry_t *vacmContextEntry)
{
    GSList *vbl;
    char *p;

    if (vacmContextEntry) {
        p = (char *) vacmContextEntry + sizeof(snmp_view_based_acm_mib_vacmContextEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(vacmContextEntry);
    }
}

void
snmp_view_based_acm_mib_free_vacmContextTable(snmp_view_based_acm_mib_vacmContextEntry_t **vacmContextEntry)
{
    int i;

    if (vacmContextEntry) {
        for (i = 0; vacmContextEntry[i]; i++) {
            snmp_view_based_acm_mib_free_vacmContextEntry(vacmContextEntry[i]);
        }
        g_free(vacmContextEntry);
    }
}

snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *
snmp_view_based_acm_mib_new_vacmSecurityToGroupEntry()
{
    snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry;

    vacmSecurityToGroupEntry = (snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *) g_malloc0(sizeof(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t) + sizeof(gpointer));
    return vacmSecurityToGroupEntry;
}

static int
unpack_vacmSecurityToGroupEntry(GSnmpVarBind *vb, snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry)
{
    int idx = 11;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    vacmSecurityToGroupEntry->vacmSecurityModel = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        vacmSecurityToGroupEntry->vacmSecurityName[i] = vb->id[idx++];
    }
    vacmSecurityToGroupEntry->_vacmSecurityNameLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_vacmSecurityToGroupEntry(guint32 *base, gint32 vacmSecurityModel, guchar *vacmSecurityName, guint16 _vacmSecurityNameLength)
{
    int idx = 11;
    guint16 i, len;

    base[idx++] = vacmSecurityModel;
    len = _vacmSecurityNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmSecurityName[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *
assign_vacmSecurityToGroupEntry(GSList *vbl)
{
    GSList *elem;
    snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry;
    guint32 idx;
    char *p;

    vacmSecurityToGroupEntry = snmp_view_based_acm_mib_new_vacmSecurityToGroupEntry();
    if (! vacmSecurityToGroupEntry) {
        return NULL;
    }

    p = (char *) vacmSecurityToGroupEntry + sizeof(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t);
    * (GSList **) p = vbl;

    if (unpack_vacmSecurityToGroupEntry((GSnmpVarBind *) vbl->data, vacmSecurityToGroupEntry) < 0) {
        g_warning("illegal vacmSecurityToGroupEntry instance identifier");
        g_free(vacmSecurityToGroupEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_vacmSecurityToGroupEntry, sizeof(oid_vacmSecurityToGroupEntry)/sizeof(guint32),
                   attr_vacmSecurityToGroupEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len < 1 || vb->syntax_len > 32) break;
            vacmSecurityToGroupEntry->_vacmGroupNameLength = vb->syntax_len;
            vacmSecurityToGroupEntry->vacmGroupName = vb->syntax.uc;
            break;
        case 4:
            vacmSecurityToGroupEntry->vacmSecurityToGroupStorageType = &(vb->syntax.i32[0]);
            break;
        case 5:
            vacmSecurityToGroupEntry->vacmSecurityToGroupStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return vacmSecurityToGroupEntry;
}

void
snmp_view_based_acm_mib_get_vacmSecurityToGroupTable(GSnmpSession *s, snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t ***vacmSecurityToGroupEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 2, 1, 0};

    *vacmSecurityToGroupEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_vacmSecurityToGroupEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *vacmSecurityToGroupEntry = (snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *));
        if (! *vacmSecurityToGroupEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*vacmSecurityToGroupEntry)[i] = assign_vacmSecurityToGroupEntry(row->data);
        }
    }
}

void
snmp_view_based_acm_mib_get_vacmSecurityToGroupEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t **vacmSecurityToGroupEntry, gint32 vacmSecurityModel, guchar *vacmSecurityName, guint16 _vacmSecurityNameLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmSecurityToGroupEntry, sizeof(oid_vacmSecurityToGroupEntry));
    len = pack_vacmSecurityToGroupEntry(base, vacmSecurityModel, vacmSecurityName, _vacmSecurityNameLength);
    if (len < 0) {
        g_warning("illegal vacmSecurityToGroupEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *vacmSecurityToGroupEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_vacmSecurityToGroupEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *vacmSecurityToGroupEntry = assign_vacmSecurityToGroupEntry(out);
    }
}

void
snmp_view_based_acm_mib_set_vacmSecurityToGroupEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmSecurityToGroupEntry, sizeof(oid_vacmSecurityToGroupEntry));
    len = pack_vacmSecurityToGroupEntry(base, vacmSecurityToGroupEntry->vacmSecurityModel, vacmSecurityToGroupEntry->vacmSecurityName, vacmSecurityToGroupEntry->_vacmSecurityNameLength);
    if (len < 0) {
        g_warning("illegal vacmSecurityToGroupEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (vacmSecurityToGroupEntry->vacmGroupName) {
        base[10] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       vacmSecurityToGroupEntry->vacmGroupName,
                       vacmSecurityToGroupEntry->_vacmGroupNameLength);
    }
    if (vacmSecurityToGroupEntry->vacmSecurityToGroupStorageType) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmSecurityToGroupEntry->vacmSecurityToGroupStorageType,
                       0);
    }
    if (vacmSecurityToGroupEntry->vacmSecurityToGroupStatus) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmSecurityToGroupEntry->vacmSecurityToGroupStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmp_view_based_acm_mib_free_vacmSecurityToGroupEntry(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t *vacmSecurityToGroupEntry)
{
    GSList *vbl;
    char *p;

    if (vacmSecurityToGroupEntry) {
        p = (char *) vacmSecurityToGroupEntry + sizeof(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(vacmSecurityToGroupEntry);
    }
}

void
snmp_view_based_acm_mib_free_vacmSecurityToGroupTable(snmp_view_based_acm_mib_vacmSecurityToGroupEntry_t **vacmSecurityToGroupEntry)
{
    int i;

    if (vacmSecurityToGroupEntry) {
        for (i = 0; vacmSecurityToGroupEntry[i]; i++) {
            snmp_view_based_acm_mib_free_vacmSecurityToGroupEntry(vacmSecurityToGroupEntry[i]);
        }
        g_free(vacmSecurityToGroupEntry);
    }
}

snmp_view_based_acm_mib_vacmAccessEntry_t *
snmp_view_based_acm_mib_new_vacmAccessEntry()
{
    snmp_view_based_acm_mib_vacmAccessEntry_t *vacmAccessEntry;

    vacmAccessEntry = (snmp_view_based_acm_mib_vacmAccessEntry_t *) g_malloc0(sizeof(snmp_view_based_acm_mib_vacmAccessEntry_t) + sizeof(gpointer));
    return vacmAccessEntry;
}

static int
unpack_vacmAccessEntry(GSnmpVarBind *vb, snmp_view_based_acm_mib_vacmAccessEntry_t *vacmAccessEntry)
{
    int idx = 11;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        vacmAccessEntry->vacmGroupName[i] = vb->id[idx++];
    }
    vacmAccessEntry->_vacmGroupNameLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        vacmAccessEntry->vacmAccessContextPrefix[i] = vb->id[idx++];
    }
    vacmAccessEntry->_vacmAccessContextPrefixLength = len;
    if (vb->id_len < idx) return -1;
    vacmAccessEntry->vacmAccessSecurityModel = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    vacmAccessEntry->vacmAccessSecurityLevel = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_vacmAccessEntry(guint32 *base, guchar *vacmGroupName, guint16 _vacmGroupNameLength, guchar *vacmAccessContextPrefix, guint16 _vacmAccessContextPrefixLength, gint32 vacmAccessSecurityModel, gint32 vacmAccessSecurityLevel)
{
    int idx = 11;
    guint16 i, len;

    len = _vacmGroupNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmGroupName[i];
        if (idx >= 128) return -1;
    }
    len = _vacmAccessContextPrefixLength;
    base[idx++] = len;
    if (len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmAccessContextPrefix[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = vacmAccessSecurityModel;
    base[idx++] = vacmAccessSecurityLevel;
    return idx;
}

static snmp_view_based_acm_mib_vacmAccessEntry_t *
assign_vacmAccessEntry(GSList *vbl)
{
    GSList *elem;
    snmp_view_based_acm_mib_vacmAccessEntry_t *vacmAccessEntry;
    guint32 idx;
    char *p;

    vacmAccessEntry = snmp_view_based_acm_mib_new_vacmAccessEntry();
    if (! vacmAccessEntry) {
        return NULL;
    }

    p = (char *) vacmAccessEntry + sizeof(snmp_view_based_acm_mib_vacmAccessEntry_t);
    * (GSList **) p = vbl;

    if (unpack_vacmAccessEntry((GSnmpVarBind *) vbl->data, vacmAccessEntry) < 0) {
        g_warning("illegal vacmAccessEntry instance identifier");
        g_free(vacmAccessEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_vacmAccessEntry, sizeof(oid_vacmAccessEntry)/sizeof(guint32),
                   attr_vacmAccessEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            vacmAccessEntry->vacmAccessContextMatch = &(vb->syntax.i32[0]);
            break;
        case 5:
            if (vb->syntax_len > 32) break;
            vacmAccessEntry->_vacmAccessReadViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessReadViewName = vb->syntax.uc;
            break;
        case 6:
            if (vb->syntax_len > 32) break;
            vacmAccessEntry->_vacmAccessWriteViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessWriteViewName = vb->syntax.uc;
            break;
        case 7:
            if (vb->syntax_len > 32) break;
            vacmAccessEntry->_vacmAccessNotifyViewNameLength = vb->syntax_len;
            vacmAccessEntry->vacmAccessNotifyViewName = vb->syntax.uc;
            break;
        case 8:
            vacmAccessEntry->vacmAccessStorageType = &(vb->syntax.i32[0]);
            break;
        case 9:
            vacmAccessEntry->vacmAccessStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return vacmAccessEntry;
}

void
snmp_view_based_acm_mib_get_vacmAccessTable(GSnmpSession *s, snmp_view_based_acm_mib_vacmAccessEntry_t ***vacmAccessEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 4, 1, 0};

    *vacmAccessEntry = NULL;

    add_attributes(s, &in, base, 11, 10, attr_vacmAccessEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *vacmAccessEntry = (snmp_view_based_acm_mib_vacmAccessEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmp_view_based_acm_mib_vacmAccessEntry_t *));
        if (! *vacmAccessEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*vacmAccessEntry)[i] = assign_vacmAccessEntry(row->data);
        }
    }
}

void
snmp_view_based_acm_mib_get_vacmAccessEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmAccessEntry_t **vacmAccessEntry, guchar *vacmGroupName, guint16 _vacmGroupNameLength, guchar *vacmAccessContextPrefix, guint16 _vacmAccessContextPrefixLength, gint32 vacmAccessSecurityModel, gint32 vacmAccessSecurityLevel, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmAccessEntry, sizeof(oid_vacmAccessEntry));
    len = pack_vacmAccessEntry(base, vacmGroupName, _vacmGroupNameLength, vacmAccessContextPrefix, _vacmAccessContextPrefixLength, vacmAccessSecurityModel, vacmAccessSecurityLevel);
    if (len < 0) {
        g_warning("illegal vacmAccessEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *vacmAccessEntry = NULL;

    add_attributes(s, &in, base, len, 10, attr_vacmAccessEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *vacmAccessEntry = assign_vacmAccessEntry(out);
    }
}

void
snmp_view_based_acm_mib_set_vacmAccessEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmAccessEntry_t *vacmAccessEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmAccessEntry, sizeof(oid_vacmAccessEntry));
    len = pack_vacmAccessEntry(base, vacmAccessEntry->vacmGroupName, vacmAccessEntry->_vacmGroupNameLength, vacmAccessEntry->vacmAccessContextPrefix, vacmAccessEntry->_vacmAccessContextPrefixLength, vacmAccessEntry->vacmAccessSecurityModel, vacmAccessEntry->vacmAccessSecurityLevel);
    if (len < 0) {
        g_warning("illegal vacmAccessEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (vacmAccessEntry->vacmAccessContextMatch) {
        base[10] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmAccessEntry->vacmAccessContextMatch,
                       0);
    }
    if (vacmAccessEntry->vacmAccessReadViewName) {
        base[10] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       vacmAccessEntry->vacmAccessReadViewName,
                       vacmAccessEntry->_vacmAccessReadViewNameLength);
    }
    if (vacmAccessEntry->vacmAccessWriteViewName) {
        base[10] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       vacmAccessEntry->vacmAccessWriteViewName,
                       vacmAccessEntry->_vacmAccessWriteViewNameLength);
    }
    if (vacmAccessEntry->vacmAccessNotifyViewName) {
        base[10] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       vacmAccessEntry->vacmAccessNotifyViewName,
                       vacmAccessEntry->_vacmAccessNotifyViewNameLength);
    }
    if (vacmAccessEntry->vacmAccessStorageType) {
        base[10] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmAccessEntry->vacmAccessStorageType,
                       0);
    }
    if (vacmAccessEntry->vacmAccessStatus) {
        base[10] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmAccessEntry->vacmAccessStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmp_view_based_acm_mib_free_vacmAccessEntry(snmp_view_based_acm_mib_vacmAccessEntry_t *vacmAccessEntry)
{
    GSList *vbl;
    char *p;

    if (vacmAccessEntry) {
        p = (char *) vacmAccessEntry + sizeof(snmp_view_based_acm_mib_vacmAccessEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(vacmAccessEntry);
    }
}

void
snmp_view_based_acm_mib_free_vacmAccessTable(snmp_view_based_acm_mib_vacmAccessEntry_t **vacmAccessEntry)
{
    int i;

    if (vacmAccessEntry) {
        for (i = 0; vacmAccessEntry[i]; i++) {
            snmp_view_based_acm_mib_free_vacmAccessEntry(vacmAccessEntry[i]);
        }
        g_free(vacmAccessEntry);
    }
}

snmp_view_based_acm_mib_vacmMIBViews_t *
snmp_view_based_acm_mib_new_vacmMIBViews()
{
    snmp_view_based_acm_mib_vacmMIBViews_t *vacmMIBViews;

    vacmMIBViews = (snmp_view_based_acm_mib_vacmMIBViews_t *) g_malloc0(sizeof(snmp_view_based_acm_mib_vacmMIBViews_t) + sizeof(gpointer));
    return vacmMIBViews;
}

static snmp_view_based_acm_mib_vacmMIBViews_t *
assign_vacmMIBViews(GSList *vbl)
{
    GSList *elem;
    snmp_view_based_acm_mib_vacmMIBViews_t *vacmMIBViews;
    guint32 idx;
    char *p;

    vacmMIBViews = snmp_view_based_acm_mib_new_vacmMIBViews();
    if (! vacmMIBViews) {
        return NULL;
    }

    p = (char *) vacmMIBViews + sizeof(snmp_view_based_acm_mib_vacmMIBViews_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_vacmMIBViews, sizeof(oid_vacmMIBViews)/sizeof(guint32),
                   attr_vacmMIBViews, &idx) < 0) continue;

        switch (idx) {
        case 1:
            vacmMIBViews->vacmViewSpinLock = &(vb->syntax.i32[0]);
            break;
        };
    }

    return vacmMIBViews;
}

void
snmp_view_based_acm_mib_get_vacmMIBViews(GSnmpSession *s, snmp_view_based_acm_mib_vacmMIBViews_t **vacmMIBViews, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 0};

    *vacmMIBViews = NULL;

    add_attributes(s, &in, base, 10, 9, attr_vacmMIBViews, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *vacmMIBViews = assign_vacmMIBViews(out);
    }
}

void
snmp_view_based_acm_mib_set_vacmMIBViews(GSnmpSession *s, snmp_view_based_acm_mib_vacmMIBViews_t *vacmMIBViews, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 0, 0};

    if (vacmMIBViews->vacmViewSpinLock) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       vacmMIBViews->vacmViewSpinLock,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmp_view_based_acm_mib_free_vacmMIBViews(snmp_view_based_acm_mib_vacmMIBViews_t *vacmMIBViews)
{
    GSList *vbl;
    char *p;

    if (vacmMIBViews) {
        p = (char *) vacmMIBViews + sizeof(snmp_view_based_acm_mib_vacmMIBViews_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(vacmMIBViews);
    }
}

snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *
snmp_view_based_acm_mib_new_vacmViewTreeFamilyEntry()
{
    snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry;

    vacmViewTreeFamilyEntry = (snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *) g_malloc0(sizeof(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t) + sizeof(gpointer));
    return vacmViewTreeFamilyEntry;
}

static int
unpack_vacmViewTreeFamilyEntry(GSnmpVarBind *vb, snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry)
{
    int idx = 12;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (len < 1 || len > 32) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        vacmViewTreeFamilyEntry->vacmViewTreeFamilyViewName[i] = vb->id[idx++];
    }
    vacmViewTreeFamilyEntry->_vacmViewTreeFamilyViewNameLength = len;
    if (vb->id_len < idx) return -1;
    len = vb->id[idx++];
    if (vb->id_len < idx + len) return -1;
    if (len > 116) return -1;
    for (i = 0; i < len; i++) {
        vacmViewTreeFamilyEntry->vacmViewTreeFamilySubtree[i] = vb->id[idx++];
    }
    vacmViewTreeFamilyEntry->_vacmViewTreeFamilySubtreeLength = len;
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_vacmViewTreeFamilyEntry(guint32 *base, guchar *vacmViewTreeFamilyViewName, guint16 _vacmViewTreeFamilyViewNameLength, guint32 *vacmViewTreeFamilySubtree, guint16 _vacmViewTreeFamilySubtreeLength)
{
    int idx = 12;
    guint16 i, len;

    len = _vacmViewTreeFamilyViewNameLength;
    base[idx++] = len;
    if (len < 1 || len > 32) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmViewTreeFamilyViewName[i];
        if (idx >= 128) return -1;
    }
    len = _vacmViewTreeFamilySubtreeLength;
    base[idx++] = len;
    if (len > 116) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = vacmViewTreeFamilySubtree[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *
assign_vacmViewTreeFamilyEntry(GSList *vbl)
{
    GSList *elem;
    snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry;
    guint32 idx;
    char *p;

    vacmViewTreeFamilyEntry = snmp_view_based_acm_mib_new_vacmViewTreeFamilyEntry();
    if (! vacmViewTreeFamilyEntry) {
        return NULL;
    }

    p = (char *) vacmViewTreeFamilyEntry + sizeof(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t);
    * (GSList **) p = vbl;

    if (unpack_vacmViewTreeFamilyEntry((GSnmpVarBind *) vbl->data, vacmViewTreeFamilyEntry) < 0) {
        g_warning("illegal vacmViewTreeFamilyEntry instance identifier");
        g_free(vacmViewTreeFamilyEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_vacmViewTreeFamilyEntry, sizeof(oid_vacmViewTreeFamilyEntry)/sizeof(guint32),
                   attr_vacmViewTreeFamilyEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len > 16) break;
            vacmViewTreeFamilyEntry->_vacmViewTreeFamilyMaskLength = vb->syntax_len;
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyMask = vb->syntax.uc;
            break;
        case 4:
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyType = &(vb->syntax.i32[0]);
            break;
        case 5:
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyStorageType = &(vb->syntax.i32[0]);
            break;
        case 6:
            vacmViewTreeFamilyEntry->vacmViewTreeFamilyStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return vacmViewTreeFamilyEntry;
}

void
snmp_view_based_acm_mib_get_vacmViewTreeFamilyTable(GSnmpSession *s, snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t ***vacmViewTreeFamilyEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 6, 3, 16, 1, 5, 2, 1, 0};

    *vacmViewTreeFamilyEntry = NULL;

    add_attributes(s, &in, base, 12, 11, attr_vacmViewTreeFamilyEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *vacmViewTreeFamilyEntry = (snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *));
        if (! *vacmViewTreeFamilyEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*vacmViewTreeFamilyEntry)[i] = assign_vacmViewTreeFamilyEntry(row->data);
        }
    }
}

void
snmp_view_based_acm_mib_get_vacmViewTreeFamilyEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t **vacmViewTreeFamilyEntry, guchar *vacmViewTreeFamilyViewName, guint16 _vacmViewTreeFamilyViewNameLength, guint32 *vacmViewTreeFamilySubtree, guint16 _vacmViewTreeFamilySubtreeLength, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmViewTreeFamilyEntry, sizeof(oid_vacmViewTreeFamilyEntry));
    len = pack_vacmViewTreeFamilyEntry(base, vacmViewTreeFamilyViewName, _vacmViewTreeFamilyViewNameLength, vacmViewTreeFamilySubtree, _vacmViewTreeFamilySubtreeLength);
    if (len < 0) {
        g_warning("illegal vacmViewTreeFamilyEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *vacmViewTreeFamilyEntry = NULL;

    add_attributes(s, &in, base, len, 11, attr_vacmViewTreeFamilyEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *vacmViewTreeFamilyEntry = assign_vacmViewTreeFamilyEntry(out);
    }
}

void
snmp_view_based_acm_mib_set_vacmViewTreeFamilyEntry(GSnmpSession *s, snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_vacmViewTreeFamilyEntry, sizeof(oid_vacmViewTreeFamilyEntry));
    len = pack_vacmViewTreeFamilyEntry(base, vacmViewTreeFamilyEntry->vacmViewTreeFamilyViewName, vacmViewTreeFamilyEntry->_vacmViewTreeFamilyViewNameLength, vacmViewTreeFamilyEntry->vacmViewTreeFamilySubtree, vacmViewTreeFamilyEntry->_vacmViewTreeFamilySubtreeLength);
    if (len < 0) {
        g_warning("illegal vacmViewTreeFamilyEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (vacmViewTreeFamilyEntry->vacmViewTreeFamilyMask) {
        base[11] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       vacmViewTreeFamilyEntry->vacmViewTreeFamilyMask,
                       vacmViewTreeFamilyEntry->_vacmViewTreeFamilyMaskLength);
    }
    if (vacmViewTreeFamilyEntry->vacmViewTreeFamilyType) {
        base[11] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmViewTreeFamilyEntry->vacmViewTreeFamilyType,
                       0);
    }
    if (vacmViewTreeFamilyEntry->vacmViewTreeFamilyStorageType) {
        base[11] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmViewTreeFamilyEntry->vacmViewTreeFamilyStorageType,
                       0);
    }
    if (vacmViewTreeFamilyEntry->vacmViewTreeFamilyStatus) {
        base[11] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       vacmViewTreeFamilyEntry->vacmViewTreeFamilyStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
snmp_view_based_acm_mib_free_vacmViewTreeFamilyEntry(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t *vacmViewTreeFamilyEntry)
{
    GSList *vbl;
    char *p;

    if (vacmViewTreeFamilyEntry) {
        p = (char *) vacmViewTreeFamilyEntry + sizeof(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(vacmViewTreeFamilyEntry);
    }
}

void
snmp_view_based_acm_mib_free_vacmViewTreeFamilyTable(snmp_view_based_acm_mib_vacmViewTreeFamilyEntry_t **vacmViewTreeFamilyEntry)
{
    int i;

    if (vacmViewTreeFamilyEntry) {
        for (i = 0; vacmViewTreeFamilyEntry[i]; i++) {
            snmp_view_based_acm_mib_free_vacmViewTreeFamilyEntry(vacmViewTreeFamilyEntry[i]);
        }
        g_free(vacmViewTreeFamilyEntry);
    }
}


