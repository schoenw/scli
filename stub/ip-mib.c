/*							-- DO NOT EDIT --
 * Generated by smidump version 0.4.8:
 *   smidump -f scli \
 *     --scli-exclude='icmp' IP-MIB
 *
 * Derived from IP-MIB:
 *   The MIB module for managing IP and ICMP implementations, but
 *   excluding their management of IP routes.
 *   
 *   Copyright (C) The Internet Society (2006).  This version of
 *   this MIB module is part of RFC 4293; see the RFC itself for
 *   full legal notices.
 *
 * Revision 2006-02-02 00:00:
 *   The IP version neutral revision with added IPv6 objects for
 *   ND, default routers, and router advertisements.  As well as
 *   being the successor to RFC 2011, this MIB is also the
 *   successor to RFCs 2465 and 2466.  Published as RFC 4293.
 *
 * Revision 1994-11-01 00:00:
 *   A separate MIB module (IP-MIB) for IP and ICMP management
 *   objects.  Published as RFC 2011.
 *
 * Revision 1991-03-31 00:00:
 *   The initial revision of this MIB module was part of MIB-II,
 *   which was published as RFC 1213.
 *
 * $Id$
 */

#include "ip-mib.h"

GNetSnmpEnum const ip_mib_enums_ipForwarding[] = {
    { IP_MIB_IPFORWARDING_FORWARDING,    "forwarding" },
    { IP_MIB_IPFORWARDING_NOTFORWARDING, "notForwarding" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipNetToMediaType[] = {
    { IP_MIB_IPNETTOMEDIATYPE_OTHER,   "other" },
    { IP_MIB_IPNETTOMEDIATYPE_INVALID, "invalid" },
    { IP_MIB_IPNETTOMEDIATYPE_DYNAMIC, "dynamic" },
    { IP_MIB_IPNETTOMEDIATYPE_STATIC,  "static" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipv6IpForwarding[] = {
    { IP_MIB_IPV6IPFORWARDING_FORWARDING,    "forwarding" },
    { IP_MIB_IPV6IPFORWARDING_NOTFORWARDING, "notForwarding" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipv4InterfaceEnableStatus[] = {
    { IP_MIB_IPV4INTERFACEENABLESTATUS_UP,   "up" },
    { IP_MIB_IPV4INTERFACEENABLESTATUS_DOWN, "down" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipv6InterfaceEnableStatus[] = {
    { IP_MIB_IPV6INTERFACEENABLESTATUS_UP,   "up" },
    { IP_MIB_IPV6INTERFACEENABLESTATUS_DOWN, "down" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipv6InterfaceForwarding[] = {
    { IP_MIB_IPV6INTERFACEFORWARDING_FORWARDING,    "forwarding" },
    { IP_MIB_IPV6INTERFACEFORWARDING_NOTFORWARDING, "notForwarding" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipAddressType[] = {
    { IP_MIB_IPADDRESSTYPE_UNICAST,   "unicast" },
    { IP_MIB_IPADDRESSTYPE_ANYCAST,   "anycast" },
    { IP_MIB_IPADDRESSTYPE_BROADCAST, "broadcast" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipNetToPhysicalType[] = {
    { IP_MIB_IPNETTOPHYSICALTYPE_OTHER,   "other" },
    { IP_MIB_IPNETTOPHYSICALTYPE_INVALID, "invalid" },
    { IP_MIB_IPNETTOPHYSICALTYPE_DYNAMIC, "dynamic" },
    { IP_MIB_IPNETTOPHYSICALTYPE_STATIC,  "static" },
    { IP_MIB_IPNETTOPHYSICALTYPE_LOCAL,   "local" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipNetToPhysicalState[] = {
    { IP_MIB_IPNETTOPHYSICALSTATE_REACHABLE,  "reachable" },
    { IP_MIB_IPNETTOPHYSICALSTATE_STALE,      "stale" },
    { IP_MIB_IPNETTOPHYSICALSTATE_DELAY,      "delay" },
    { IP_MIB_IPNETTOPHYSICALSTATE_PROBE,      "probe" },
    { IP_MIB_IPNETTOPHYSICALSTATE_INVALID,    "invalid" },
    { IP_MIB_IPNETTOPHYSICALSTATE_UNKNOWN,    "unknown" },
    { IP_MIB_IPNETTOPHYSICALSTATE_INCOMPLETE, "incomplete" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_ipDefaultRouterPreference[] = {
    { IP_MIB_IPDEFAULTROUTERPREFERENCE_RESERVED, "reserved" },
    { IP_MIB_IPDEFAULTROUTERPREFERENCE_LOW,      "low" },
    { IP_MIB_IPDEFAULTROUTERPREFERENCE_MEDIUM,   "medium" },
    { IP_MIB_IPDEFAULTROUTERPREFERENCE_HIGH,     "high" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_IpAddressOriginTC[] = {
    { IP_MIB_IPADDRESSORIGINTC_OTHER,     "other" },
    { IP_MIB_IPADDRESSORIGINTC_MANUAL,    "manual" },
    { IP_MIB_IPADDRESSORIGINTC_DHCP,      "dhcp" },
    { IP_MIB_IPADDRESSORIGINTC_LINKLAYER, "linklayer" },
    { IP_MIB_IPADDRESSORIGINTC_RANDOM,    "random" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_IpAddressStatusTC[] = {
    { IP_MIB_IPADDRESSSTATUSTC_PREFERRED,    "preferred" },
    { IP_MIB_IPADDRESSSTATUSTC_DEPRECATED,   "deprecated" },
    { IP_MIB_IPADDRESSSTATUSTC_INVALID,      "invalid" },
    { IP_MIB_IPADDRESSSTATUSTC_INACCESSIBLE, "inaccessible" },
    { IP_MIB_IPADDRESSSTATUSTC_UNKNOWN,      "unknown" },
    { IP_MIB_IPADDRESSSTATUSTC_TENTATIVE,    "tentative" },
    { IP_MIB_IPADDRESSSTATUSTC_DUPLICATE,    "duplicate" },
    { IP_MIB_IPADDRESSSTATUSTC_OPTIMISTIC,   "optimistic" },
    { 0, NULL }
};

GNetSnmpEnum const ip_mib_enums_IpAddressPrefixOriginTC[] = {
    { IP_MIB_IPADDRESSPREFIXORIGINTC_OTHER,     "other" },
    { IP_MIB_IPADDRESSPREFIXORIGINTC_MANUAL,    "manual" },
    { IP_MIB_IPADDRESSPREFIXORIGINTC_WELLKNOWN, "wellknown" },
    { IP_MIB_IPADDRESSPREFIXORIGINTC_DHCP,      "dhcp" },
    { IP_MIB_IPADDRESSPREFIXORIGINTC_ROUTERADV, "routeradv" },
    { 0, NULL }
};


static gint32 ipDefaultTTL_constraints[] = {1L, 255L, 0, 0};
static gint32 ipv6IpDefaultHopLimit_constraints[] = {0L, 255L, 0, 0};
static gint32 ipAddressSpinLock_constraints[] = {0L, 2147483647L, 0, 0};
static gint32 ipv6RouterAdvertSpinLock_constraints[] = {0L, 2147483647L, 0, 0};
static gint32 ipAdEntIfIndex_constraints[] = {1L, 2147483647L, 0, 0};
static guint16 ipAdEntNetMask_constraints[] = {4U, 4U, 0, 0};
static gint32 ipAdEntBcastAddr_constraints[] = {0L, 1L, 0, 0};
static gint32 ipAdEntReasmMaxSize_constraints[] = {0L, 65535L, 0, 0};
static gint32 ipv4InterfaceReasmMaxSize_constraints[] = {0L, 65535L, 0, 0};
static guint32 ipv6InterfaceReasmMaxSize_constraints[] = {1500UL, 65535UL, 0, 0};
static guint16 ipv6InterfaceIdentifier_constraints[] = {0U, 8U, 0, 0};
static gint32 ipAddressIfIndex_constraints[] = {1L, 2147483647L, 0, 0};
static guint32 ipDefaultRouterLifetime_constraints[] = {0UL, 65535UL, 0, 0};
static guint32 ipv6RouterAdvertMaxInterval_constraints[] = {4UL, 1800UL, 0, 0};
static guint32 ipv6RouterAdvertMinInterval_constraints[] = {3UL, 1350UL, 0, 0};
static guint32 ipv6RouterAdvertReachableTime_constraints[] = {0UL, 3600000UL, 0, 0};
static guint32 ipv6RouterAdvertCurHopLimit_constraints[] = {0UL, 255UL, 0, 0};
static guint32 ipv6RouterAdvertDefaultLifetime_constraints[] = {0UL, 0UL, 4UL, 9000UL, 0, 0};


static guint32 const ip_oid[] = {1, 3, 6, 1, 2, 1, 4};

static GNetSnmpAttribute ip_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPFORWARDING, "ipForwarding",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipForwarding),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPDEFAULTTTL, "ipDefaultTTL",
       ipDefaultTTL_constraints,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipDefaultTTL),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINRECEIVES, "ipInReceives",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInReceives),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINHDRERRORS, "ipInHdrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInHdrErrors),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINADDRERRORS, "ipInAddrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInAddrErrors),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPFORWDATAGRAMS, "ipForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipForwDatagrams),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINUNKNOWNPROTOS, "ipInUnknownProtos",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInUnknownProtos),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINDISCARDS, "ipInDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInDiscards),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPINDELIVERS, "ipInDelivers",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipInDelivers),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPOUTREQUESTS, "ipOutRequests",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipOutRequests),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPOUTDISCARDS, "ipOutDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipOutDiscards),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPOUTNOROUTES, "ipOutNoRoutes",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipOutNoRoutes),
      0,
      0 },
    { 13, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPREASMTIMEOUT, "ipReasmTimeout",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipReasmTimeout),
      0,
      0 },
    { 14, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPREASMREQDS, "ipReasmReqds",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipReasmReqds),
      0,
      0 },
    { 15, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPREASMOKS, "ipReasmOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipReasmOKs),
      0,
      0 },
    { 16, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPREASMFAILS, "ipReasmFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipReasmFails),
      0,
      0 },
    { 17, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPFRAGOKS, "ipFragOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipFragOKs),
      0,
      0 },
    { 18, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPFRAGFAILS, "ipFragFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipFragFails),
      0,
      0 },
    { 19, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPFRAGCREATES, "ipFragCreates",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipFragCreates),
      0,
      0 },
    { 23, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPROUTINGDISCARDS, "ipRoutingDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipRoutingDiscards),
      0,
      0 },
    { 25, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6IPFORWARDING, "ipv6IpForwarding",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipv6IpForwarding),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 26, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6IPDEFAULTHOPLIMIT, "ipv6IpDefaultHopLimit",
       ipv6IpDefaultHopLimit_constraints,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipv6IpDefaultHopLimit),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 27, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPV4INTERFACETABLELASTCHANGE, "ipv4InterfaceTableLastChange",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipv4InterfaceTableLastChange),
      0,
      0 },
    { 29, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPV6INTERFACETABLELASTCHANGE, "ipv6InterfaceTableLastChange",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipv6InterfaceTableLastChange),
      0,
      0 },
    { 33, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSSPINLOCK, "ipAddressSpinLock",
       ipAddressSpinLock_constraints,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipAddressSpinLock),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 38, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6ROUTERADVERTSPINLOCK, "ipv6RouterAdvertSpinLock",
       ipv6RouterAdvertSpinLock_constraints,
      G_STRUCT_OFFSET(ip_mib_ip_t, ipv6RouterAdvertSpinLock),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ipAddrEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 20, 1};

static GNetSnmpAttribute ipAddrEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADENTIFINDEX, "ipAdEntIfIndex",
       ipAdEntIfIndex_constraints,
      G_STRUCT_OFFSET(ip_mib_ipAddrEntry_t, ipAdEntIfIndex),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_IPADDRESS,
      IP_MIB_IPADENTNETMASK, "ipAdEntNetMask",
       ipAdEntNetMask_constraints,
      G_STRUCT_OFFSET(ip_mib_ipAddrEntry_t, ipAdEntNetMask),
      4,
      GSNMP_ATTR_FLAG_FIXED_LENGTH },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADENTBCASTADDR, "ipAdEntBcastAddr",
       ipAdEntBcastAddr_constraints,
      G_STRUCT_OFFSET(ip_mib_ipAddrEntry_t, ipAdEntBcastAddr),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADENTREASMMAXSIZE, "ipAdEntReasmMaxSize",
       ipAdEntReasmMaxSize_constraints,
      G_STRUCT_OFFSET(ip_mib_ipAddrEntry_t, ipAdEntReasmMaxSize),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipNetToMediaEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 22, 1};

static GNetSnmpAttribute ipNetToMediaEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      IP_MIB_IPNETTOMEDIAPHYSADDRESS, "ipNetToMediaPhysAddress",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToMediaEntry_t, ipNetToMediaPhysAddress),
      G_STRUCT_OFFSET(ip_mib_ipNetToMediaEntry_t, _ipNetToMediaPhysAddressLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPNETTOMEDIATYPE, "ipNetToMediaType",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToMediaEntry_t, ipNetToMediaType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ipv4InterfaceEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 28, 1};

static GNetSnmpAttribute ipv4InterfaceEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV4INTERFACEREASMMAXSIZE, "ipv4InterfaceReasmMaxSize",
       ipv4InterfaceReasmMaxSize_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv4InterfaceEntry_t, ipv4InterfaceReasmMaxSize),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV4INTERFACEENABLESTATUS, "ipv4InterfaceEnableStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv4InterfaceEntry_t, ipv4InterfaceEnableStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV4INTERFACERETRANSMITTIME, "ipv4InterfaceRetransmitTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv4InterfaceEntry_t, ipv4InterfaceRetransmitTime),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipv6InterfaceEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 30, 1};

static GNetSnmpAttribute ipv6InterfaceEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6INTERFACEREASMMAXSIZE, "ipv6InterfaceReasmMaxSize",
       ipv6InterfaceReasmMaxSize_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceReasmMaxSize),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      IP_MIB_IPV6INTERFACEIDENTIFIER, "ipv6InterfaceIdentifier",
       ipv6InterfaceIdentifier_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceIdentifier),
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, _ipv6InterfaceIdentifierLength),
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6INTERFACEENABLESTATUS, "ipv6InterfaceEnableStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceEnableStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6INTERFACEREACHABLETIME, "ipv6InterfaceReachableTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceReachableTime),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6INTERFACERETRANSMITTIME, "ipv6InterfaceRetransmitTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceRetransmitTime),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6INTERFACEFORWARDING, "ipv6InterfaceForwarding",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6InterfaceEntry_t, ipv6InterfaceForwarding),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ipTrafficStats_oid[] = {1, 3, 6, 1, 2, 1, 4, 31};

static GNetSnmpAttribute ipTrafficStats_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPIFSTATSTABLELASTCHANGE, "ipIfStatsTableLastChange",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipTrafficStats_t, ipIfStatsTableLastChange),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipSystemStatsEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 31, 1, 1};

static GNetSnmpAttribute ipSystemStatsEntry_attr[] = {
    { 3, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINRECEIVES, "ipSystemStatsInReceives",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInReceives),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINRECEIVES, "ipSystemStatsHCInReceives",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInReceives),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINOCTETS, "ipSystemStatsInOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInOctets),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINOCTETS, "ipSystemStatsHCInOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInOctets),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINHDRERRORS, "ipSystemStatsInHdrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInHdrErrors),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINNOROUTES, "ipSystemStatsInNoRoutes",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInNoRoutes),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINADDRERRORS, "ipSystemStatsInAddrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInAddrErrors),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINUNKNOWNPROTOS, "ipSystemStatsInUnknownProtos",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInUnknownProtos),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINTRUNCATEDPKTS, "ipSystemStatsInTruncatedPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInTruncatedPkts),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINFORWDATAGRAMS, "ipSystemStatsInForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInForwDatagrams),
      0,
      0 },
    { 13, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINFORWDATAGRAMS, "ipSystemStatsHCInForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInForwDatagrams),
      0,
      0 },
    { 14, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSREASMREQDS, "ipSystemStatsReasmReqds",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsReasmReqds),
      0,
      0 },
    { 15, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSREASMOKS, "ipSystemStatsReasmOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsReasmOKs),
      0,
      0 },
    { 16, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSREASMFAILS, "ipSystemStatsReasmFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsReasmFails),
      0,
      0 },
    { 17, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINDISCARDS, "ipSystemStatsInDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInDiscards),
      0,
      0 },
    { 18, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINDELIVERS, "ipSystemStatsInDelivers",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInDelivers),
      0,
      0 },
    { 19, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINDELIVERS, "ipSystemStatsHCInDelivers",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInDelivers),
      0,
      0 },
    { 20, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTREQUESTS, "ipSystemStatsOutRequests",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutRequests),
      0,
      0 },
    { 21, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTREQUESTS, "ipSystemStatsHCOutRequests",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutRequests),
      0,
      0 },
    { 22, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTNOROUTES, "ipSystemStatsOutNoRoutes",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutNoRoutes),
      0,
      0 },
    { 23, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTFORWDATAGRAMS, "ipSystemStatsOutForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutForwDatagrams),
      0,
      0 },
    { 24, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTFORWDATAGRAMS, "ipSystemStatsHCOutForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutForwDatagrams),
      0,
      0 },
    { 25, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTDISCARDS, "ipSystemStatsOutDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutDiscards),
      0,
      0 },
    { 26, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTFRAGREQDS, "ipSystemStatsOutFragReqds",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutFragReqds),
      0,
      0 },
    { 27, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTFRAGOKS, "ipSystemStatsOutFragOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutFragOKs),
      0,
      0 },
    { 28, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTFRAGFAILS, "ipSystemStatsOutFragFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutFragFails),
      0,
      0 },
    { 29, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTFRAGCREATES, "ipSystemStatsOutFragCreates",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutFragCreates),
      0,
      0 },
    { 30, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTTRANSMITS, "ipSystemStatsOutTransmits",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutTransmits),
      0,
      0 },
    { 31, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTTRANSMITS, "ipSystemStatsHCOutTransmits",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutTransmits),
      0,
      0 },
    { 32, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTOCTETS, "ipSystemStatsOutOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutOctets),
      0,
      0 },
    { 33, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTOCTETS, "ipSystemStatsHCOutOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutOctets),
      0,
      0 },
    { 34, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINMCASTPKTS, "ipSystemStatsInMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInMcastPkts),
      0,
      0 },
    { 35, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINMCASTPKTS, "ipSystemStatsHCInMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInMcastPkts),
      0,
      0 },
    { 36, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINMCASTOCTETS, "ipSystemStatsInMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInMcastOctets),
      0,
      0 },
    { 37, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINMCASTOCTETS, "ipSystemStatsHCInMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInMcastOctets),
      0,
      0 },
    { 38, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTMCASTPKTS, "ipSystemStatsOutMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutMcastPkts),
      0,
      0 },
    { 39, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTMCASTPKTS, "ipSystemStatsHCOutMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutMcastPkts),
      0,
      0 },
    { 40, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTMCASTOCTETS, "ipSystemStatsOutMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutMcastOctets),
      0,
      0 },
    { 41, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTMCASTOCTETS, "ipSystemStatsHCOutMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutMcastOctets),
      0,
      0 },
    { 42, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSINBCASTPKTS, "ipSystemStatsInBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsInBcastPkts),
      0,
      0 },
    { 43, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCINBCASTPKTS, "ipSystemStatsHCInBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCInBcastPkts),
      0,
      0 },
    { 44, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPSYSTEMSTATSOUTBCASTPKTS, "ipSystemStatsOutBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsOutBcastPkts),
      0,
      0 },
    { 45, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPSYSTEMSTATSHCOUTBCASTPKTS, "ipSystemStatsHCOutBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsHCOutBcastPkts),
      0,
      0 },
    { 46, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPSYSTEMSTATSDISCONTINUITYTIME, "ipSystemStatsDiscontinuityTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsDiscontinuityTime),
      0,
      0 },
    { 47, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPSYSTEMSTATSREFRESHRATE, "ipSystemStatsRefreshRate",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipSystemStatsEntry_t, ipSystemStatsRefreshRate),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipIfStatsEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 31, 3, 1};

static GNetSnmpAttribute ipIfStatsEntry_attr[] = {
    { 3, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINRECEIVES, "ipIfStatsInReceives",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInReceives),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINRECEIVES, "ipIfStatsHCInReceives",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInReceives),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINOCTETS, "ipIfStatsInOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInOctets),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINOCTETS, "ipIfStatsHCInOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInOctets),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINHDRERRORS, "ipIfStatsInHdrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInHdrErrors),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINNOROUTES, "ipIfStatsInNoRoutes",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInNoRoutes),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINADDRERRORS, "ipIfStatsInAddrErrors",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInAddrErrors),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINUNKNOWNPROTOS, "ipIfStatsInUnknownProtos",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInUnknownProtos),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINTRUNCATEDPKTS, "ipIfStatsInTruncatedPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInTruncatedPkts),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINFORWDATAGRAMS, "ipIfStatsInForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInForwDatagrams),
      0,
      0 },
    { 13, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINFORWDATAGRAMS, "ipIfStatsHCInForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInForwDatagrams),
      0,
      0 },
    { 14, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSREASMREQDS, "ipIfStatsReasmReqds",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsReasmReqds),
      0,
      0 },
    { 15, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSREASMOKS, "ipIfStatsReasmOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsReasmOKs),
      0,
      0 },
    { 16, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSREASMFAILS, "ipIfStatsReasmFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsReasmFails),
      0,
      0 },
    { 17, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINDISCARDS, "ipIfStatsInDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInDiscards),
      0,
      0 },
    { 18, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINDELIVERS, "ipIfStatsInDelivers",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInDelivers),
      0,
      0 },
    { 19, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINDELIVERS, "ipIfStatsHCInDelivers",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInDelivers),
      0,
      0 },
    { 20, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTREQUESTS, "ipIfStatsOutRequests",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutRequests),
      0,
      0 },
    { 21, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTREQUESTS, "ipIfStatsHCOutRequests",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutRequests),
      0,
      0 },
    { 23, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTFORWDATAGRAMS, "ipIfStatsOutForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutForwDatagrams),
      0,
      0 },
    { 24, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTFORWDATAGRAMS, "ipIfStatsHCOutForwDatagrams",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutForwDatagrams),
      0,
      0 },
    { 25, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTDISCARDS, "ipIfStatsOutDiscards",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutDiscards),
      0,
      0 },
    { 26, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTFRAGREQDS, "ipIfStatsOutFragReqds",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutFragReqds),
      0,
      0 },
    { 27, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTFRAGOKS, "ipIfStatsOutFragOKs",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutFragOKs),
      0,
      0 },
    { 28, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTFRAGFAILS, "ipIfStatsOutFragFails",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutFragFails),
      0,
      0 },
    { 29, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTFRAGCREATES, "ipIfStatsOutFragCreates",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutFragCreates),
      0,
      0 },
    { 30, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTTRANSMITS, "ipIfStatsOutTransmits",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutTransmits),
      0,
      0 },
    { 31, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTTRANSMITS, "ipIfStatsHCOutTransmits",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutTransmits),
      0,
      0 },
    { 32, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTOCTETS, "ipIfStatsOutOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutOctets),
      0,
      0 },
    { 33, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTOCTETS, "ipIfStatsHCOutOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutOctets),
      0,
      0 },
    { 34, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINMCASTPKTS, "ipIfStatsInMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInMcastPkts),
      0,
      0 },
    { 35, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINMCASTPKTS, "ipIfStatsHCInMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInMcastPkts),
      0,
      0 },
    { 36, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINMCASTOCTETS, "ipIfStatsInMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInMcastOctets),
      0,
      0 },
    { 37, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINMCASTOCTETS, "ipIfStatsHCInMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInMcastOctets),
      0,
      0 },
    { 38, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTMCASTPKTS, "ipIfStatsOutMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutMcastPkts),
      0,
      0 },
    { 39, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTMCASTPKTS, "ipIfStatsHCOutMcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutMcastPkts),
      0,
      0 },
    { 40, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTMCASTOCTETS, "ipIfStatsOutMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutMcastOctets),
      0,
      0 },
    { 41, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTMCASTOCTETS, "ipIfStatsHCOutMcastOctets",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutMcastOctets),
      0,
      0 },
    { 42, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSINBCASTPKTS, "ipIfStatsInBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsInBcastPkts),
      0,
      0 },
    { 43, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCINBCASTPKTS, "ipIfStatsHCInBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCInBcastPkts),
      0,
      0 },
    { 44, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      IP_MIB_IPIFSTATSOUTBCASTPKTS, "ipIfStatsOutBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsOutBcastPkts),
      0,
      0 },
    { 45, GNET_SNMP_VARBIND_TYPE_COUNTER64,
      IP_MIB_IPIFSTATSHCOUTBCASTPKTS, "ipIfStatsHCOutBcastPkts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsHCOutBcastPkts),
      0,
      0 },
    { 46, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPIFSTATSDISCONTINUITYTIME, "ipIfStatsDiscontinuityTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsDiscontinuityTime),
      0,
      0 },
    { 47, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPIFSTATSREFRESHRATE, "ipIfStatsRefreshRate",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipIfStatsEntry_t, ipIfStatsRefreshRate),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipAddressPrefixEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 32, 1};

static GNetSnmpAttribute ipAddressPrefixEntry_attr[] = {
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSPREFIXORIGIN, "ipAddressPrefixOrigin",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressPrefixEntry_t, ipAddressPrefixOrigin),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSPREFIXONLINKFLAG, "ipAddressPrefixOnLinkFlag",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressPrefixEntry_t, ipAddressPrefixOnLinkFlag),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSPREFIXAUTONOMOUSFLAG, "ipAddressPrefixAutonomousFlag",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressPrefixEntry_t, ipAddressPrefixAutonomousFlag),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPADDRESSPREFIXADVPREFERREDLIFETIME, "ipAddressPrefixAdvPreferredLifetime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressPrefixEntry_t, ipAddressPrefixAdvPreferredLifetime),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPADDRESSPREFIXADVVALIDLIFETIME, "ipAddressPrefixAdvValidLifetime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressPrefixEntry_t, ipAddressPrefixAdvValidLifetime),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipAddressEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 34, 1};

static GNetSnmpAttribute ipAddressEntry_attr[] = {
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSIFINDEX, "ipAddressIfIndex",
       ipAddressIfIndex_constraints,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressIfIndex),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSTYPE, "ipAddressType",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, GNET_SNMP_VARBIND_TYPE_OBJECTID,
      IP_MIB_IPADDRESSPREFIX, "ipAddressPrefix",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressPrefix),
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, _ipAddressPrefixLength),
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSORIGIN, "ipAddressOrigin",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressOrigin),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSSTATUS, "ipAddressStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPADDRESSCREATED, "ipAddressCreated",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressCreated),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPADDRESSLASTCHANGED, "ipAddressLastChanged",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressLastChanged),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSROWSTATUS, "ipAddressRowStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressRowStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPADDRESSSTORAGETYPE, "ipAddressStorageType",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipAddressEntry_t, ipAddressStorageType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ipNetToPhysicalEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 35, 1};

static GNetSnmpAttribute ipNetToPhysicalEntry_attr[] = {
    { 4, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      IP_MIB_IPNETTOPHYSICALPHYSADDRESS, "ipNetToPhysicalPhysAddress",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, ipNetToPhysicalPhysAddress),
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, _ipNetToPhysicalPhysAddressLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, GNET_SNMP_VARBIND_TYPE_TIMETICKS,
      IP_MIB_IPNETTOPHYSICALLASTUPDATED, "ipNetToPhysicalLastUpdated",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, ipNetToPhysicalLastUpdated),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPNETTOPHYSICALTYPE, "ipNetToPhysicalType",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, ipNetToPhysicalType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPNETTOPHYSICALSTATE, "ipNetToPhysicalState",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, ipNetToPhysicalState),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPNETTOPHYSICALROWSTATUS, "ipNetToPhysicalRowStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipNetToPhysicalEntry_t, ipNetToPhysicalRowStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ipv6ScopeZoneIndexEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 36, 1};

static GNetSnmpAttribute ipv6ScopeZoneIndexEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXLINKLOCAL, "ipv6ScopeZoneIndexLinkLocal",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexLinkLocal),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEX3, "ipv6ScopeZoneIndex3",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndex3),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXADMINLOCAL, "ipv6ScopeZoneIndexAdminLocal",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexAdminLocal),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXSITELOCAL, "ipv6ScopeZoneIndexSiteLocal",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexSiteLocal),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEX6, "ipv6ScopeZoneIndex6",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndex6),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEX7, "ipv6ScopeZoneIndex7",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndex7),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXORGANIZATIONLOCAL, "ipv6ScopeZoneIndexOrganizationLocal",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexOrganizationLocal),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEX9, "ipv6ScopeZoneIndex9",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndex9),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXA, "ipv6ScopeZoneIndexA",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexA),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXB, "ipv6ScopeZoneIndexB",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexB),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXC, "ipv6ScopeZoneIndexC",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexC),
      0,
      0 },
    { 13, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6SCOPEZONEINDEXD, "ipv6ScopeZoneIndexD",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6ScopeZoneIndexEntry_t, ipv6ScopeZoneIndexD),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipDefaultRouterEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 37, 1};

static GNetSnmpAttribute ipDefaultRouterEntry_attr[] = {
    { 4, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPDEFAULTROUTERLIFETIME, "ipDefaultRouterLifetime",
       ipDefaultRouterLifetime_constraints,
      G_STRUCT_OFFSET(ip_mib_ipDefaultRouterEntry_t, ipDefaultRouterLifetime),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPDEFAULTROUTERPREFERENCE, "ipDefaultRouterPreference",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipDefaultRouterEntry_t, ipDefaultRouterPreference),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ipv6RouterAdvertEntry_oid[] = {1, 3, 6, 1, 2, 1, 4, 39, 1};

static GNetSnmpAttribute ipv6RouterAdvertEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6ROUTERADVERTSENDADVERTS, "ipv6RouterAdvertSendAdverts",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertSendAdverts),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTMAXINTERVAL, "ipv6RouterAdvertMaxInterval",
       ipv6RouterAdvertMaxInterval_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertMaxInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTMININTERVAL, "ipv6RouterAdvertMinInterval",
       ipv6RouterAdvertMinInterval_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertMinInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6ROUTERADVERTMANAGEDFLAG, "ipv6RouterAdvertManagedFlag",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertManagedFlag),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6ROUTERADVERTOTHERCONFIGFLAG, "ipv6RouterAdvertOtherConfigFlag",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertOtherConfigFlag),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTLINKMTU, "ipv6RouterAdvertLinkMTU",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertLinkMTU),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTREACHABLETIME, "ipv6RouterAdvertReachableTime",
       ipv6RouterAdvertReachableTime_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertReachableTime),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 9, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTRETRANSMITTIME, "ipv6RouterAdvertRetransmitTime",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertRetransmitTime),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTCURHOPLIMIT, "ipv6RouterAdvertCurHopLimit",
       ipv6RouterAdvertCurHopLimit_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertCurHopLimit),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      IP_MIB_IPV6ROUTERADVERTDEFAULTLIFETIME, "ipv6RouterAdvertDefaultLifetime",
       ipv6RouterAdvertDefaultLifetime_constraints,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertDefaultLifetime),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      IP_MIB_IPV6ROUTERADVERTROWSTATUS, "ipv6RouterAdvertRowStatus",
       NULL,
      G_STRUCT_OFFSET(ip_mib_ipv6RouterAdvertEntry_t, ipv6RouterAdvertRowStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


ip_mib_ip_t *
ip_mib_new_ip()
{
    ip_mib_ip_t *ip;

    ip = (ip_mib_ip_t *) g_malloc0(sizeof(ip_mib_ip_t) + sizeof(gpointer));
    return ip;
}

static inline ip_mib_ip_t *
assign_ip(GList *vbl)
{
    ip_mib_ip_t *ip;
    char *p;

    ip = ip_mib_new_ip();
    p = (char *) ip + sizeof(ip_mib_ip_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, ip_oid, G_N_ELEMENTS(ip_oid),
                      ip_attr, ip);

    return ip;
}

void
ip_mib_get_ip(GNetSnmp *s, ip_mib_ip_t **ip, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {1, 3, 6, 1, 2, 1, 4, 0};
    guint32 base[128];

    *ip = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 8, 7, ip_attr, mask);

    out = gnet_snmp_sync_getnext(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if ((error && *error) || s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ip = assign_ip(out);
    }
}

void
ip_mib_set_ip(GNetSnmp *s, ip_mib_ip_t *ip, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0, 0};

    gnet_snmp_attr_set(s, &in, base, 9, 7, ip_attr, mask, ip);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ip(ip_mib_ip_t *ip)
{
    GList *vbl;
    char *p;

    if (ip) {
        p = (char *) ip + sizeof(ip_mib_ip_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ip);
    }
}

ip_mib_ipAddrEntry_t *
ip_mib_new_ipAddrEntry()
{
    ip_mib_ipAddrEntry_t *ipAddrEntry;

    ipAddrEntry = (ip_mib_ipAddrEntry_t *) g_malloc0(sizeof(ip_mib_ipAddrEntry_t) + sizeof(gpointer));
    return ipAddrEntry;
}

static inline int
unpack_ipAddrEntry(GNetSnmpVarBind *vb, ip_mib_ipAddrEntry_t *ipAddrEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddrEntry->ipAdEntAddr[i] = vb->oid[idx++];
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipAddrEntry(guint32 *base, guchar *ipAdEntAddr)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipAdEntAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ip_mib_ipAddrEntry_t *
assign_ipAddrEntry(GList *vbl)
{
    ip_mib_ipAddrEntry_t *ipAddrEntry;
    char *p;

    ipAddrEntry = ip_mib_new_ipAddrEntry();
    p = (char *) ipAddrEntry + sizeof(ip_mib_ipAddrEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipAddrEntry((GNetSnmpVarBind *) vbl->data, ipAddrEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipAddrEntry");
        g_free(ipAddrEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipAddrEntry_oid, G_N_ELEMENTS(ipAddrEntry_oid),
                      ipAddrEntry_attr, ipAddrEntry);

    return ipAddrEntry;
}

void
ip_mib_get_ipAddrTable(GNetSnmp *s, ip_mib_ipAddrEntry_t ***ipAddrEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 20, 1, 0};
    guint32 base[128];

    *ipAddrEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipAddrEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipAddrEntry = (ip_mib_ipAddrEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipAddrEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipAddrEntry)[i] = assign_ipAddrEntry(row->data);
        }
    }
}

void
ip_mib_get_ipAddrEntry(GNetSnmp *s, ip_mib_ipAddrEntry_t **ipAddrEntry, guchar *ipAdEntAddr, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipAddrEntry_oid, sizeof(ipAddrEntry_oid));
    len = pack_ipAddrEntry(base, ipAdEntAddr);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipAddrEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipAddrEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipAddrEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipAddrEntry = assign_ipAddrEntry(out);
    }
}

void
ip_mib_free_ipAddrEntry(ip_mib_ipAddrEntry_t *ipAddrEntry)
{
    GList *vbl;
    char *p;

    if (ipAddrEntry) {
        p = (char *) ipAddrEntry + sizeof(ip_mib_ipAddrEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipAddrEntry);
    }
}

void
ip_mib_free_ipAddrTable(ip_mib_ipAddrEntry_t **ipAddrEntry)
{
    int i;

    if (ipAddrEntry) {
        for (i = 0; ipAddrEntry[i]; i++) {
            ip_mib_free_ipAddrEntry(ipAddrEntry[i]);
        }
        g_free(ipAddrEntry);
    }
}

ip_mib_ipNetToMediaEntry_t *
ip_mib_new_ipNetToMediaEntry()
{
    ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;

    ipNetToMediaEntry = (ip_mib_ipNetToMediaEntry_t *) g_malloc0(sizeof(ip_mib_ipNetToMediaEntry_t) + sizeof(gpointer));
    return ipNetToMediaEntry;
}

static inline int
unpack_ipNetToMediaEntry(GNetSnmpVarBind *vb, ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    ipNetToMediaEntry->ipNetToMediaIfIndex = vb->oid[idx++];
    if ((ipNetToMediaEntry->ipNetToMediaIfIndex < 1)) {
         return -1;
    }
    len = 4;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipNetToMediaEntry->ipNetToMediaNetAddress[i] = vb->oid[idx++];
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipNetToMediaEntry(guint32 *base, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ipNetToMediaIfIndex;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipNetToMediaNetAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ip_mib_ipNetToMediaEntry_t *
assign_ipNetToMediaEntry(GList *vbl)
{
    ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;
    char *p;

    ipNetToMediaEntry = ip_mib_new_ipNetToMediaEntry();
    p = (char *) ipNetToMediaEntry + sizeof(ip_mib_ipNetToMediaEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipNetToMediaEntry((GNetSnmpVarBind *) vbl->data, ipNetToMediaEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipNetToMediaEntry");
        g_free(ipNetToMediaEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipNetToMediaEntry_oid, G_N_ELEMENTS(ipNetToMediaEntry_oid),
                      ipNetToMediaEntry_attr, ipNetToMediaEntry);

    return ipNetToMediaEntry;
}

void
ip_mib_get_ipNetToMediaTable(GNetSnmp *s, ip_mib_ipNetToMediaEntry_t ***ipNetToMediaEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 22, 1, 0};
    guint32 base[128];

    *ipNetToMediaEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipNetToMediaEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipNetToMediaEntry = (ip_mib_ipNetToMediaEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipNetToMediaEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipNetToMediaEntry)[i] = assign_ipNetToMediaEntry(row->data);
        }
    }
}

void
ip_mib_get_ipNetToMediaEntry(GNetSnmp *s, ip_mib_ipNetToMediaEntry_t **ipNetToMediaEntry, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipNetToMediaEntry_oid, sizeof(ipNetToMediaEntry_oid));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaIfIndex, ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipNetToMediaEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipNetToMediaEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipNetToMediaEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipNetToMediaEntry = assign_ipNetToMediaEntry(out);
    }
}

void
ip_mib_set_ipNetToMediaEntry(GNetSnmp *s, ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipNetToMediaEntry_oid, sizeof(ipNetToMediaEntry_oid));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaEntry->ipNetToMediaIfIndex, ipNetToMediaEntry->ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipNetToMediaEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipNetToMediaEntry_attr, mask, ipNetToMediaEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipNetToMediaEntry(ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    GList *vbl;
    char *p;

    if (ipNetToMediaEntry) {
        p = (char *) ipNetToMediaEntry + sizeof(ip_mib_ipNetToMediaEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipNetToMediaEntry);
    }
}

void
ip_mib_free_ipNetToMediaTable(ip_mib_ipNetToMediaEntry_t **ipNetToMediaEntry)
{
    int i;

    if (ipNetToMediaEntry) {
        for (i = 0; ipNetToMediaEntry[i]; i++) {
            ip_mib_free_ipNetToMediaEntry(ipNetToMediaEntry[i]);
        }
        g_free(ipNetToMediaEntry);
    }
}

ip_mib_ipv4InterfaceEntry_t *
ip_mib_new_ipv4InterfaceEntry()
{
    ip_mib_ipv4InterfaceEntry_t *ipv4InterfaceEntry;

    ipv4InterfaceEntry = (ip_mib_ipv4InterfaceEntry_t *) g_malloc0(sizeof(ip_mib_ipv4InterfaceEntry_t) + sizeof(gpointer));
    return ipv4InterfaceEntry;
}

static inline int
unpack_ipv4InterfaceEntry(GNetSnmpVarBind *vb, ip_mib_ipv4InterfaceEntry_t *ipv4InterfaceEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    ipv4InterfaceEntry->ipv4InterfaceIfIndex = vb->oid[idx++];
    if ((ipv4InterfaceEntry->ipv4InterfaceIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipv4InterfaceEntry(guint32 *base, gint32 ipv4InterfaceIfIndex)
{
    guint8 idx = 10;

    base[idx++] = ipv4InterfaceIfIndex;
    return idx;
}

static inline ip_mib_ipv4InterfaceEntry_t *
assign_ipv4InterfaceEntry(GList *vbl)
{
    ip_mib_ipv4InterfaceEntry_t *ipv4InterfaceEntry;
    char *p;

    ipv4InterfaceEntry = ip_mib_new_ipv4InterfaceEntry();
    p = (char *) ipv4InterfaceEntry + sizeof(ip_mib_ipv4InterfaceEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipv4InterfaceEntry((GNetSnmpVarBind *) vbl->data, ipv4InterfaceEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipv4InterfaceEntry");
        g_free(ipv4InterfaceEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipv4InterfaceEntry_oid, G_N_ELEMENTS(ipv4InterfaceEntry_oid),
                      ipv4InterfaceEntry_attr, ipv4InterfaceEntry);

    return ipv4InterfaceEntry;
}

void
ip_mib_get_ipv4InterfaceTable(GNetSnmp *s, ip_mib_ipv4InterfaceEntry_t ***ipv4InterfaceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 28, 1, 0};
    guint32 base[128];

    *ipv4InterfaceEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipv4InterfaceEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipv4InterfaceEntry = (ip_mib_ipv4InterfaceEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipv4InterfaceEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipv4InterfaceEntry)[i] = assign_ipv4InterfaceEntry(row->data);
        }
    }
}

void
ip_mib_get_ipv4InterfaceEntry(GNetSnmp *s, ip_mib_ipv4InterfaceEntry_t **ipv4InterfaceEntry, gint32 ipv4InterfaceIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv4InterfaceEntry_oid, sizeof(ipv4InterfaceEntry_oid));
    len = pack_ipv4InterfaceEntry(base, ipv4InterfaceIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv4InterfaceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipv4InterfaceEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipv4InterfaceEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipv4InterfaceEntry = assign_ipv4InterfaceEntry(out);
    }
}

void
ip_mib_set_ipv4InterfaceEntry(GNetSnmp *s, ip_mib_ipv4InterfaceEntry_t *ipv4InterfaceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv4InterfaceEntry_oid, sizeof(ipv4InterfaceEntry_oid));
    len = pack_ipv4InterfaceEntry(base, ipv4InterfaceEntry->ipv4InterfaceIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv4InterfaceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipv4InterfaceEntry_attr, mask, ipv4InterfaceEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipv4InterfaceEntry(ip_mib_ipv4InterfaceEntry_t *ipv4InterfaceEntry)
{
    GList *vbl;
    char *p;

    if (ipv4InterfaceEntry) {
        p = (char *) ipv4InterfaceEntry + sizeof(ip_mib_ipv4InterfaceEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipv4InterfaceEntry);
    }
}

void
ip_mib_free_ipv4InterfaceTable(ip_mib_ipv4InterfaceEntry_t **ipv4InterfaceEntry)
{
    int i;

    if (ipv4InterfaceEntry) {
        for (i = 0; ipv4InterfaceEntry[i]; i++) {
            ip_mib_free_ipv4InterfaceEntry(ipv4InterfaceEntry[i]);
        }
        g_free(ipv4InterfaceEntry);
    }
}

ip_mib_ipv6InterfaceEntry_t *
ip_mib_new_ipv6InterfaceEntry()
{
    ip_mib_ipv6InterfaceEntry_t *ipv6InterfaceEntry;

    ipv6InterfaceEntry = (ip_mib_ipv6InterfaceEntry_t *) g_malloc0(sizeof(ip_mib_ipv6InterfaceEntry_t) + sizeof(gpointer));
    return ipv6InterfaceEntry;
}

static inline int
unpack_ipv6InterfaceEntry(GNetSnmpVarBind *vb, ip_mib_ipv6InterfaceEntry_t *ipv6InterfaceEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    ipv6InterfaceEntry->ipv6InterfaceIfIndex = vb->oid[idx++];
    if ((ipv6InterfaceEntry->ipv6InterfaceIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipv6InterfaceEntry(guint32 *base, gint32 ipv6InterfaceIfIndex)
{
    guint8 idx = 10;

    base[idx++] = ipv6InterfaceIfIndex;
    return idx;
}

static inline ip_mib_ipv6InterfaceEntry_t *
assign_ipv6InterfaceEntry(GList *vbl)
{
    ip_mib_ipv6InterfaceEntry_t *ipv6InterfaceEntry;
    char *p;

    ipv6InterfaceEntry = ip_mib_new_ipv6InterfaceEntry();
    p = (char *) ipv6InterfaceEntry + sizeof(ip_mib_ipv6InterfaceEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipv6InterfaceEntry((GNetSnmpVarBind *) vbl->data, ipv6InterfaceEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipv6InterfaceEntry");
        g_free(ipv6InterfaceEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipv6InterfaceEntry_oid, G_N_ELEMENTS(ipv6InterfaceEntry_oid),
                      ipv6InterfaceEntry_attr, ipv6InterfaceEntry);

    return ipv6InterfaceEntry;
}

void
ip_mib_get_ipv6InterfaceTable(GNetSnmp *s, ip_mib_ipv6InterfaceEntry_t ***ipv6InterfaceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 30, 1, 0};
    guint32 base[128];

    *ipv6InterfaceEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipv6InterfaceEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipv6InterfaceEntry = (ip_mib_ipv6InterfaceEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipv6InterfaceEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipv6InterfaceEntry)[i] = assign_ipv6InterfaceEntry(row->data);
        }
    }
}

void
ip_mib_get_ipv6InterfaceEntry(GNetSnmp *s, ip_mib_ipv6InterfaceEntry_t **ipv6InterfaceEntry, gint32 ipv6InterfaceIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv6InterfaceEntry_oid, sizeof(ipv6InterfaceEntry_oid));
    len = pack_ipv6InterfaceEntry(base, ipv6InterfaceIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv6InterfaceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipv6InterfaceEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipv6InterfaceEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipv6InterfaceEntry = assign_ipv6InterfaceEntry(out);
    }
}

void
ip_mib_set_ipv6InterfaceEntry(GNetSnmp *s, ip_mib_ipv6InterfaceEntry_t *ipv6InterfaceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv6InterfaceEntry_oid, sizeof(ipv6InterfaceEntry_oid));
    len = pack_ipv6InterfaceEntry(base, ipv6InterfaceEntry->ipv6InterfaceIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv6InterfaceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipv6InterfaceEntry_attr, mask, ipv6InterfaceEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipv6InterfaceEntry(ip_mib_ipv6InterfaceEntry_t *ipv6InterfaceEntry)
{
    GList *vbl;
    char *p;

    if (ipv6InterfaceEntry) {
        p = (char *) ipv6InterfaceEntry + sizeof(ip_mib_ipv6InterfaceEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipv6InterfaceEntry);
    }
}

void
ip_mib_free_ipv6InterfaceTable(ip_mib_ipv6InterfaceEntry_t **ipv6InterfaceEntry)
{
    int i;

    if (ipv6InterfaceEntry) {
        for (i = 0; ipv6InterfaceEntry[i]; i++) {
            ip_mib_free_ipv6InterfaceEntry(ipv6InterfaceEntry[i]);
        }
        g_free(ipv6InterfaceEntry);
    }
}

ip_mib_ipTrafficStats_t *
ip_mib_new_ipTrafficStats()
{
    ip_mib_ipTrafficStats_t *ipTrafficStats;

    ipTrafficStats = (ip_mib_ipTrafficStats_t *) g_malloc0(sizeof(ip_mib_ipTrafficStats_t) + sizeof(gpointer));
    return ipTrafficStats;
}

static inline ip_mib_ipTrafficStats_t *
assign_ipTrafficStats(GList *vbl)
{
    ip_mib_ipTrafficStats_t *ipTrafficStats;
    char *p;

    ipTrafficStats = ip_mib_new_ipTrafficStats();
    p = (char *) ipTrafficStats + sizeof(ip_mib_ipTrafficStats_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, ipTrafficStats_oid, G_N_ELEMENTS(ipTrafficStats_oid),
                      ipTrafficStats_attr, ipTrafficStats);

    return ipTrafficStats;
}

void
ip_mib_get_ipTrafficStats(GNetSnmp *s, ip_mib_ipTrafficStats_t **ipTrafficStats, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {1, 3, 6, 1, 2, 1, 4, 31, 0};
    guint32 base[128];

    *ipTrafficStats = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 9, 8, ipTrafficStats_attr, mask);

    out = gnet_snmp_sync_getnext(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if ((error && *error) || s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipTrafficStats = assign_ipTrafficStats(out);
    }
}

void
ip_mib_free_ipTrafficStats(ip_mib_ipTrafficStats_t *ipTrafficStats)
{
    GList *vbl;
    char *p;

    if (ipTrafficStats) {
        p = (char *) ipTrafficStats + sizeof(ip_mib_ipTrafficStats_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipTrafficStats);
    }
}

ip_mib_ipSystemStatsEntry_t *
ip_mib_new_ipSystemStatsEntry()
{
    ip_mib_ipSystemStatsEntry_t *ipSystemStatsEntry;

    ipSystemStatsEntry = (ip_mib_ipSystemStatsEntry_t *) g_malloc0(sizeof(ip_mib_ipSystemStatsEntry_t) + sizeof(gpointer));
    return ipSystemStatsEntry;
}

static inline int
unpack_ipSystemStatsEntry(GNetSnmpVarBind *vb, ip_mib_ipSystemStatsEntry_t *ipSystemStatsEntry)
{
    guint8 idx = 11;

    if (vb->oid_len < idx) return -1;
    ipSystemStatsEntry->ipSystemStatsIPVersion = vb->oid[idx++];
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipSystemStatsEntry(guint32 *base, gint32 ipSystemStatsIPVersion)
{
    guint8 idx = 11;

    base[idx++] = ipSystemStatsIPVersion;
    return idx;
}

static inline ip_mib_ipSystemStatsEntry_t *
assign_ipSystemStatsEntry(GList *vbl)
{
    ip_mib_ipSystemStatsEntry_t *ipSystemStatsEntry;
    char *p;

    ipSystemStatsEntry = ip_mib_new_ipSystemStatsEntry();
    p = (char *) ipSystemStatsEntry + sizeof(ip_mib_ipSystemStatsEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipSystemStatsEntry((GNetSnmpVarBind *) vbl->data, ipSystemStatsEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipSystemStatsEntry");
        g_free(ipSystemStatsEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipSystemStatsEntry_oid, G_N_ELEMENTS(ipSystemStatsEntry_oid),
                      ipSystemStatsEntry_attr, ipSystemStatsEntry);

    return ipSystemStatsEntry;
}

void
ip_mib_get_ipSystemStatsTable(GNetSnmp *s, ip_mib_ipSystemStatsEntry_t ***ipSystemStatsEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 31, 1, 1, 0};
    guint32 base[128];

    *ipSystemStatsEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 11, 10, ipSystemStatsEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipSystemStatsEntry = (ip_mib_ipSystemStatsEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipSystemStatsEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipSystemStatsEntry)[i] = assign_ipSystemStatsEntry(row->data);
        }
    }
}

void
ip_mib_get_ipSystemStatsEntry(GNetSnmp *s, ip_mib_ipSystemStatsEntry_t **ipSystemStatsEntry, gint32 ipSystemStatsIPVersion, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipSystemStatsEntry_oid, sizeof(ipSystemStatsEntry_oid));
    len = pack_ipSystemStatsEntry(base, ipSystemStatsIPVersion);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipSystemStatsEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipSystemStatsEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 10, ipSystemStatsEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipSystemStatsEntry = assign_ipSystemStatsEntry(out);
    }
}

void
ip_mib_free_ipSystemStatsEntry(ip_mib_ipSystemStatsEntry_t *ipSystemStatsEntry)
{
    GList *vbl;
    char *p;

    if (ipSystemStatsEntry) {
        p = (char *) ipSystemStatsEntry + sizeof(ip_mib_ipSystemStatsEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipSystemStatsEntry);
    }
}

void
ip_mib_free_ipSystemStatsTable(ip_mib_ipSystemStatsEntry_t **ipSystemStatsEntry)
{
    int i;

    if (ipSystemStatsEntry) {
        for (i = 0; ipSystemStatsEntry[i]; i++) {
            ip_mib_free_ipSystemStatsEntry(ipSystemStatsEntry[i]);
        }
        g_free(ipSystemStatsEntry);
    }
}

ip_mib_ipIfStatsEntry_t *
ip_mib_new_ipIfStatsEntry()
{
    ip_mib_ipIfStatsEntry_t *ipIfStatsEntry;

    ipIfStatsEntry = (ip_mib_ipIfStatsEntry_t *) g_malloc0(sizeof(ip_mib_ipIfStatsEntry_t) + sizeof(gpointer));
    return ipIfStatsEntry;
}

static inline int
unpack_ipIfStatsEntry(GNetSnmpVarBind *vb, ip_mib_ipIfStatsEntry_t *ipIfStatsEntry)
{
    guint8 idx = 11;

    if (vb->oid_len < idx) return -1;
    ipIfStatsEntry->ipIfStatsIPVersion = vb->oid[idx++];
    if (vb->oid_len < idx) return -1;
    ipIfStatsEntry->ipIfStatsIfIndex = vb->oid[idx++];
    if ((ipIfStatsEntry->ipIfStatsIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipIfStatsEntry(guint32 *base, gint32 ipIfStatsIPVersion, gint32 ipIfStatsIfIndex)
{
    guint8 idx = 11;

    base[idx++] = ipIfStatsIPVersion;
    base[idx++] = ipIfStatsIfIndex;
    return idx;
}

static inline ip_mib_ipIfStatsEntry_t *
assign_ipIfStatsEntry(GList *vbl)
{
    ip_mib_ipIfStatsEntry_t *ipIfStatsEntry;
    char *p;

    ipIfStatsEntry = ip_mib_new_ipIfStatsEntry();
    p = (char *) ipIfStatsEntry + sizeof(ip_mib_ipIfStatsEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipIfStatsEntry((GNetSnmpVarBind *) vbl->data, ipIfStatsEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipIfStatsEntry");
        g_free(ipIfStatsEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipIfStatsEntry_oid, G_N_ELEMENTS(ipIfStatsEntry_oid),
                      ipIfStatsEntry_attr, ipIfStatsEntry);

    return ipIfStatsEntry;
}

void
ip_mib_get_ipIfStatsTable(GNetSnmp *s, ip_mib_ipIfStatsEntry_t ***ipIfStatsEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 31, 3, 1, 0};
    guint32 base[128];

    *ipIfStatsEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 11, 10, ipIfStatsEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipIfStatsEntry = (ip_mib_ipIfStatsEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipIfStatsEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipIfStatsEntry)[i] = assign_ipIfStatsEntry(row->data);
        }
    }
}

void
ip_mib_get_ipIfStatsEntry(GNetSnmp *s, ip_mib_ipIfStatsEntry_t **ipIfStatsEntry, gint32 ipIfStatsIPVersion, gint32 ipIfStatsIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipIfStatsEntry_oid, sizeof(ipIfStatsEntry_oid));
    len = pack_ipIfStatsEntry(base, ipIfStatsIPVersion, ipIfStatsIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipIfStatsEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipIfStatsEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 10, ipIfStatsEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipIfStatsEntry = assign_ipIfStatsEntry(out);
    }
}

void
ip_mib_free_ipIfStatsEntry(ip_mib_ipIfStatsEntry_t *ipIfStatsEntry)
{
    GList *vbl;
    char *p;

    if (ipIfStatsEntry) {
        p = (char *) ipIfStatsEntry + sizeof(ip_mib_ipIfStatsEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipIfStatsEntry);
    }
}

void
ip_mib_free_ipIfStatsTable(ip_mib_ipIfStatsEntry_t **ipIfStatsEntry)
{
    int i;

    if (ipIfStatsEntry) {
        for (i = 0; ipIfStatsEntry[i]; i++) {
            ip_mib_free_ipIfStatsEntry(ipIfStatsEntry[i]);
        }
        g_free(ipIfStatsEntry);
    }
}

ip_mib_ipAddressPrefixEntry_t *
ip_mib_new_ipAddressPrefixEntry()
{
    ip_mib_ipAddressPrefixEntry_t *ipAddressPrefixEntry;

    ipAddressPrefixEntry = (ip_mib_ipAddressPrefixEntry_t *) g_malloc0(sizeof(ip_mib_ipAddressPrefixEntry_t) + sizeof(gpointer));
    return ipAddressPrefixEntry;
}

static inline int
unpack_ipAddressPrefixEntry(GNetSnmpVarBind *vb, ip_mib_ipAddressPrefixEntry_t *ipAddressPrefixEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    ipAddressPrefixEntry->ipAddressPrefixIfIndex = vb->oid[idx++];
    if ((ipAddressPrefixEntry->ipAddressPrefixIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len < idx) return -1;
    ipAddressPrefixEntry->ipAddressPrefixType = vb->oid[idx++];
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (len > 118) return -1;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddressPrefixEntry->ipAddressPrefixPrefix[i] = vb->oid[idx++];
    }
    ipAddressPrefixEntry->_ipAddressPrefixPrefixLength = len;
    if (vb->oid_len < idx) return -1;
    ipAddressPrefixEntry->ipAddressPrefixLength = vb->oid[idx++];
     if ((ipAddressPrefixEntry->ipAddressPrefixLength > 2040)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipAddressPrefixEntry(guint32 *base, gint32 ipAddressPrefixIfIndex, gint32 ipAddressPrefixType, guchar *ipAddressPrefixPrefix, guint16 _ipAddressPrefixPrefixLength, guint32 ipAddressPrefixLength)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ipAddressPrefixIfIndex;
    base[idx++] = ipAddressPrefixType;
    len = _ipAddressPrefixPrefixLength;
    base[idx++] = len;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipAddressPrefixPrefix[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ipAddressPrefixLength;
    return idx;
}

static inline ip_mib_ipAddressPrefixEntry_t *
assign_ipAddressPrefixEntry(GList *vbl)
{
    ip_mib_ipAddressPrefixEntry_t *ipAddressPrefixEntry;
    char *p;

    ipAddressPrefixEntry = ip_mib_new_ipAddressPrefixEntry();
    p = (char *) ipAddressPrefixEntry + sizeof(ip_mib_ipAddressPrefixEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipAddressPrefixEntry((GNetSnmpVarBind *) vbl->data, ipAddressPrefixEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipAddressPrefixEntry");
        g_free(ipAddressPrefixEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipAddressPrefixEntry_oid, G_N_ELEMENTS(ipAddressPrefixEntry_oid),
                      ipAddressPrefixEntry_attr, ipAddressPrefixEntry);

    return ipAddressPrefixEntry;
}

void
ip_mib_get_ipAddressPrefixTable(GNetSnmp *s, ip_mib_ipAddressPrefixEntry_t ***ipAddressPrefixEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 32, 1, 0};
    guint32 base[128];

    *ipAddressPrefixEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipAddressPrefixEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipAddressPrefixEntry = (ip_mib_ipAddressPrefixEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipAddressPrefixEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipAddressPrefixEntry)[i] = assign_ipAddressPrefixEntry(row->data);
        }
    }
}

void
ip_mib_get_ipAddressPrefixEntry(GNetSnmp *s, ip_mib_ipAddressPrefixEntry_t **ipAddressPrefixEntry, gint32 ipAddressPrefixIfIndex, gint32 ipAddressPrefixType, guchar *ipAddressPrefixPrefix, guint16 _ipAddressPrefixPrefixLength, guint32 ipAddressPrefixLength, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipAddressPrefixEntry_oid, sizeof(ipAddressPrefixEntry_oid));
    len = pack_ipAddressPrefixEntry(base, ipAddressPrefixIfIndex, ipAddressPrefixType, ipAddressPrefixPrefix, _ipAddressPrefixPrefixLength, ipAddressPrefixLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipAddressPrefixEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipAddressPrefixEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipAddressPrefixEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipAddressPrefixEntry = assign_ipAddressPrefixEntry(out);
    }
}

void
ip_mib_free_ipAddressPrefixEntry(ip_mib_ipAddressPrefixEntry_t *ipAddressPrefixEntry)
{
    GList *vbl;
    char *p;

    if (ipAddressPrefixEntry) {
        p = (char *) ipAddressPrefixEntry + sizeof(ip_mib_ipAddressPrefixEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipAddressPrefixEntry);
    }
}

void
ip_mib_free_ipAddressPrefixTable(ip_mib_ipAddressPrefixEntry_t **ipAddressPrefixEntry)
{
    int i;

    if (ipAddressPrefixEntry) {
        for (i = 0; ipAddressPrefixEntry[i]; i++) {
            ip_mib_free_ipAddressPrefixEntry(ipAddressPrefixEntry[i]);
        }
        g_free(ipAddressPrefixEntry);
    }
}

ip_mib_ipAddressEntry_t *
ip_mib_new_ipAddressEntry()
{
    ip_mib_ipAddressEntry_t *ipAddressEntry;

    ipAddressEntry = (ip_mib_ipAddressEntry_t *) g_malloc0(sizeof(ip_mib_ipAddressEntry_t) + sizeof(gpointer));
    return ipAddressEntry;
}

static inline int
unpack_ipAddressEntry(GNetSnmpVarBind *vb, ip_mib_ipAddressEntry_t *ipAddressEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    ipAddressEntry->ipAddressAddrType = vb->oid[idx++];
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (len > 118) return -1;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddressEntry->ipAddressAddr[i] = vb->oid[idx++];
    }
    ipAddressEntry->_ipAddressAddrLength = len;
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipAddressEntry(guint32 *base, gint32 ipAddressAddrType, guchar *ipAddressAddr, guint16 _ipAddressAddrLength)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ipAddressAddrType;
    len = _ipAddressAddrLength;
    base[idx++] = len;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipAddressAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ip_mib_ipAddressEntry_t *
assign_ipAddressEntry(GList *vbl)
{
    ip_mib_ipAddressEntry_t *ipAddressEntry;
    char *p;

    ipAddressEntry = ip_mib_new_ipAddressEntry();
    p = (char *) ipAddressEntry + sizeof(ip_mib_ipAddressEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipAddressEntry((GNetSnmpVarBind *) vbl->data, ipAddressEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipAddressEntry");
        g_free(ipAddressEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipAddressEntry_oid, G_N_ELEMENTS(ipAddressEntry_oid),
                      ipAddressEntry_attr, ipAddressEntry);

    return ipAddressEntry;
}

void
ip_mib_get_ipAddressTable(GNetSnmp *s, ip_mib_ipAddressEntry_t ***ipAddressEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 34, 1, 0};
    guint32 base[128];

    *ipAddressEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipAddressEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipAddressEntry = (ip_mib_ipAddressEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipAddressEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipAddressEntry)[i] = assign_ipAddressEntry(row->data);
        }
    }
}

void
ip_mib_get_ipAddressEntry(GNetSnmp *s, ip_mib_ipAddressEntry_t **ipAddressEntry, gint32 ipAddressAddrType, guchar *ipAddressAddr, guint16 _ipAddressAddrLength, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipAddressEntry_oid, sizeof(ipAddressEntry_oid));
    len = pack_ipAddressEntry(base, ipAddressAddrType, ipAddressAddr, _ipAddressAddrLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipAddressEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipAddressEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipAddressEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipAddressEntry = assign_ipAddressEntry(out);
    }
}

void
ip_mib_set_ipAddressEntry(GNetSnmp *s, ip_mib_ipAddressEntry_t *ipAddressEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipAddressEntry_oid, sizeof(ipAddressEntry_oid));
    len = pack_ipAddressEntry(base, ipAddressEntry->ipAddressAddrType, ipAddressEntry->ipAddressAddr, ipAddressEntry->_ipAddressAddrLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipAddressEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipAddressEntry_attr, mask, ipAddressEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipAddressEntry(ip_mib_ipAddressEntry_t *ipAddressEntry)
{
    GList *vbl;
    char *p;

    if (ipAddressEntry) {
        p = (char *) ipAddressEntry + sizeof(ip_mib_ipAddressEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipAddressEntry);
    }
}

void
ip_mib_free_ipAddressTable(ip_mib_ipAddressEntry_t **ipAddressEntry)
{
    int i;

    if (ipAddressEntry) {
        for (i = 0; ipAddressEntry[i]; i++) {
            ip_mib_free_ipAddressEntry(ipAddressEntry[i]);
        }
        g_free(ipAddressEntry);
    }
}

ip_mib_ipNetToPhysicalEntry_t *
ip_mib_new_ipNetToPhysicalEntry()
{
    ip_mib_ipNetToPhysicalEntry_t *ipNetToPhysicalEntry;

    ipNetToPhysicalEntry = (ip_mib_ipNetToPhysicalEntry_t *) g_malloc0(sizeof(ip_mib_ipNetToPhysicalEntry_t) + sizeof(gpointer));
    return ipNetToPhysicalEntry;
}

static inline int
unpack_ipNetToPhysicalEntry(GNetSnmpVarBind *vb, ip_mib_ipNetToPhysicalEntry_t *ipNetToPhysicalEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    ipNetToPhysicalEntry->ipNetToPhysicalIfIndex = vb->oid[idx++];
    if ((ipNetToPhysicalEntry->ipNetToPhysicalIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len < idx) return -1;
    ipNetToPhysicalEntry->ipNetToPhysicalNetAddressType = vb->oid[idx++];
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (len > 118) return -1;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipNetToPhysicalEntry->ipNetToPhysicalNetAddress[i] = vb->oid[idx++];
    }
    ipNetToPhysicalEntry->_ipNetToPhysicalNetAddressLength = len;
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipNetToPhysicalEntry(guint32 *base, gint32 ipNetToPhysicalIfIndex, gint32 ipNetToPhysicalNetAddressType, guchar *ipNetToPhysicalNetAddress, guint16 _ipNetToPhysicalNetAddressLength)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ipNetToPhysicalIfIndex;
    base[idx++] = ipNetToPhysicalNetAddressType;
    len = _ipNetToPhysicalNetAddressLength;
    base[idx++] = len;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipNetToPhysicalNetAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ip_mib_ipNetToPhysicalEntry_t *
assign_ipNetToPhysicalEntry(GList *vbl)
{
    ip_mib_ipNetToPhysicalEntry_t *ipNetToPhysicalEntry;
    char *p;

    ipNetToPhysicalEntry = ip_mib_new_ipNetToPhysicalEntry();
    p = (char *) ipNetToPhysicalEntry + sizeof(ip_mib_ipNetToPhysicalEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipNetToPhysicalEntry((GNetSnmpVarBind *) vbl->data, ipNetToPhysicalEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipNetToPhysicalEntry");
        g_free(ipNetToPhysicalEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipNetToPhysicalEntry_oid, G_N_ELEMENTS(ipNetToPhysicalEntry_oid),
                      ipNetToPhysicalEntry_attr, ipNetToPhysicalEntry);

    return ipNetToPhysicalEntry;
}

void
ip_mib_get_ipNetToPhysicalTable(GNetSnmp *s, ip_mib_ipNetToPhysicalEntry_t ***ipNetToPhysicalEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 35, 1, 0};
    guint32 base[128];

    *ipNetToPhysicalEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipNetToPhysicalEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipNetToPhysicalEntry = (ip_mib_ipNetToPhysicalEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipNetToPhysicalEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipNetToPhysicalEntry)[i] = assign_ipNetToPhysicalEntry(row->data);
        }
    }
}

void
ip_mib_get_ipNetToPhysicalEntry(GNetSnmp *s, ip_mib_ipNetToPhysicalEntry_t **ipNetToPhysicalEntry, gint32 ipNetToPhysicalIfIndex, gint32 ipNetToPhysicalNetAddressType, guchar *ipNetToPhysicalNetAddress, guint16 _ipNetToPhysicalNetAddressLength, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipNetToPhysicalEntry_oid, sizeof(ipNetToPhysicalEntry_oid));
    len = pack_ipNetToPhysicalEntry(base, ipNetToPhysicalIfIndex, ipNetToPhysicalNetAddressType, ipNetToPhysicalNetAddress, _ipNetToPhysicalNetAddressLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipNetToPhysicalEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipNetToPhysicalEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipNetToPhysicalEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipNetToPhysicalEntry = assign_ipNetToPhysicalEntry(out);
    }
}

void
ip_mib_set_ipNetToPhysicalEntry(GNetSnmp *s, ip_mib_ipNetToPhysicalEntry_t *ipNetToPhysicalEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipNetToPhysicalEntry_oid, sizeof(ipNetToPhysicalEntry_oid));
    len = pack_ipNetToPhysicalEntry(base, ipNetToPhysicalEntry->ipNetToPhysicalIfIndex, ipNetToPhysicalEntry->ipNetToPhysicalNetAddressType, ipNetToPhysicalEntry->ipNetToPhysicalNetAddress, ipNetToPhysicalEntry->_ipNetToPhysicalNetAddressLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipNetToPhysicalEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipNetToPhysicalEntry_attr, mask, ipNetToPhysicalEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipNetToPhysicalEntry(ip_mib_ipNetToPhysicalEntry_t *ipNetToPhysicalEntry)
{
    GList *vbl;
    char *p;

    if (ipNetToPhysicalEntry) {
        p = (char *) ipNetToPhysicalEntry + sizeof(ip_mib_ipNetToPhysicalEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipNetToPhysicalEntry);
    }
}

void
ip_mib_free_ipNetToPhysicalTable(ip_mib_ipNetToPhysicalEntry_t **ipNetToPhysicalEntry)
{
    int i;

    if (ipNetToPhysicalEntry) {
        for (i = 0; ipNetToPhysicalEntry[i]; i++) {
            ip_mib_free_ipNetToPhysicalEntry(ipNetToPhysicalEntry[i]);
        }
        g_free(ipNetToPhysicalEntry);
    }
}

ip_mib_ipv6ScopeZoneIndexEntry_t *
ip_mib_new_ipv6ScopeZoneIndexEntry()
{
    ip_mib_ipv6ScopeZoneIndexEntry_t *ipv6ScopeZoneIndexEntry;

    ipv6ScopeZoneIndexEntry = (ip_mib_ipv6ScopeZoneIndexEntry_t *) g_malloc0(sizeof(ip_mib_ipv6ScopeZoneIndexEntry_t) + sizeof(gpointer));
    return ipv6ScopeZoneIndexEntry;
}

static inline int
unpack_ipv6ScopeZoneIndexEntry(GNetSnmpVarBind *vb, ip_mib_ipv6ScopeZoneIndexEntry_t *ipv6ScopeZoneIndexEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    ipv6ScopeZoneIndexEntry->ipv6ScopeZoneIndexIfIndex = vb->oid[idx++];
    if ((ipv6ScopeZoneIndexEntry->ipv6ScopeZoneIndexIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipv6ScopeZoneIndexEntry(guint32 *base, gint32 ipv6ScopeZoneIndexIfIndex)
{
    guint8 idx = 10;

    base[idx++] = ipv6ScopeZoneIndexIfIndex;
    return idx;
}

static inline ip_mib_ipv6ScopeZoneIndexEntry_t *
assign_ipv6ScopeZoneIndexEntry(GList *vbl)
{
    ip_mib_ipv6ScopeZoneIndexEntry_t *ipv6ScopeZoneIndexEntry;
    char *p;

    ipv6ScopeZoneIndexEntry = ip_mib_new_ipv6ScopeZoneIndexEntry();
    p = (char *) ipv6ScopeZoneIndexEntry + sizeof(ip_mib_ipv6ScopeZoneIndexEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipv6ScopeZoneIndexEntry((GNetSnmpVarBind *) vbl->data, ipv6ScopeZoneIndexEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipv6ScopeZoneIndexEntry");
        g_free(ipv6ScopeZoneIndexEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipv6ScopeZoneIndexEntry_oid, G_N_ELEMENTS(ipv6ScopeZoneIndexEntry_oid),
                      ipv6ScopeZoneIndexEntry_attr, ipv6ScopeZoneIndexEntry);

    return ipv6ScopeZoneIndexEntry;
}

void
ip_mib_get_ipv6ScopeZoneIndexTable(GNetSnmp *s, ip_mib_ipv6ScopeZoneIndexEntry_t ***ipv6ScopeZoneIndexEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 36, 1, 0};
    guint32 base[128];

    *ipv6ScopeZoneIndexEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipv6ScopeZoneIndexEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipv6ScopeZoneIndexEntry = (ip_mib_ipv6ScopeZoneIndexEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipv6ScopeZoneIndexEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipv6ScopeZoneIndexEntry)[i] = assign_ipv6ScopeZoneIndexEntry(row->data);
        }
    }
}

void
ip_mib_get_ipv6ScopeZoneIndexEntry(GNetSnmp *s, ip_mib_ipv6ScopeZoneIndexEntry_t **ipv6ScopeZoneIndexEntry, gint32 ipv6ScopeZoneIndexIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv6ScopeZoneIndexEntry_oid, sizeof(ipv6ScopeZoneIndexEntry_oid));
    len = pack_ipv6ScopeZoneIndexEntry(base, ipv6ScopeZoneIndexIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv6ScopeZoneIndexEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipv6ScopeZoneIndexEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipv6ScopeZoneIndexEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipv6ScopeZoneIndexEntry = assign_ipv6ScopeZoneIndexEntry(out);
    }
}

void
ip_mib_free_ipv6ScopeZoneIndexEntry(ip_mib_ipv6ScopeZoneIndexEntry_t *ipv6ScopeZoneIndexEntry)
{
    GList *vbl;
    char *p;

    if (ipv6ScopeZoneIndexEntry) {
        p = (char *) ipv6ScopeZoneIndexEntry + sizeof(ip_mib_ipv6ScopeZoneIndexEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipv6ScopeZoneIndexEntry);
    }
}

void
ip_mib_free_ipv6ScopeZoneIndexTable(ip_mib_ipv6ScopeZoneIndexEntry_t **ipv6ScopeZoneIndexEntry)
{
    int i;

    if (ipv6ScopeZoneIndexEntry) {
        for (i = 0; ipv6ScopeZoneIndexEntry[i]; i++) {
            ip_mib_free_ipv6ScopeZoneIndexEntry(ipv6ScopeZoneIndexEntry[i]);
        }
        g_free(ipv6ScopeZoneIndexEntry);
    }
}

ip_mib_ipDefaultRouterEntry_t *
ip_mib_new_ipDefaultRouterEntry()
{
    ip_mib_ipDefaultRouterEntry_t *ipDefaultRouterEntry;

    ipDefaultRouterEntry = (ip_mib_ipDefaultRouterEntry_t *) g_malloc0(sizeof(ip_mib_ipDefaultRouterEntry_t) + sizeof(gpointer));
    return ipDefaultRouterEntry;
}

static inline int
unpack_ipDefaultRouterEntry(GNetSnmpVarBind *vb, ip_mib_ipDefaultRouterEntry_t *ipDefaultRouterEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    ipDefaultRouterEntry->ipDefaultRouterAddressType = vb->oid[idx++];
    if (vb->oid_len < idx) return -1;
    len = vb->oid[idx++];
    if (len > 118) return -1;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipDefaultRouterEntry->ipDefaultRouterAddress[i] = vb->oid[idx++];
    }
    ipDefaultRouterEntry->_ipDefaultRouterAddressLength = len;
    if (vb->oid_len < idx) return -1;
    ipDefaultRouterEntry->ipDefaultRouterIfIndex = vb->oid[idx++];
    if ((ipDefaultRouterEntry->ipDefaultRouterIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipDefaultRouterEntry(guint32 *base, gint32 ipDefaultRouterAddressType, guchar *ipDefaultRouterAddress, guint16 _ipDefaultRouterAddressLength, gint32 ipDefaultRouterIfIndex)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ipDefaultRouterAddressType;
    len = _ipDefaultRouterAddressLength;
    base[idx++] = len;
    if (len > 118) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipDefaultRouterAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ipDefaultRouterIfIndex;
    return idx;
}

static inline ip_mib_ipDefaultRouterEntry_t *
assign_ipDefaultRouterEntry(GList *vbl)
{
    ip_mib_ipDefaultRouterEntry_t *ipDefaultRouterEntry;
    char *p;

    ipDefaultRouterEntry = ip_mib_new_ipDefaultRouterEntry();
    p = (char *) ipDefaultRouterEntry + sizeof(ip_mib_ipDefaultRouterEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipDefaultRouterEntry((GNetSnmpVarBind *) vbl->data, ipDefaultRouterEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipDefaultRouterEntry");
        g_free(ipDefaultRouterEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipDefaultRouterEntry_oid, G_N_ELEMENTS(ipDefaultRouterEntry_oid),
                      ipDefaultRouterEntry_attr, ipDefaultRouterEntry);

    return ipDefaultRouterEntry;
}

void
ip_mib_get_ipDefaultRouterTable(GNetSnmp *s, ip_mib_ipDefaultRouterEntry_t ***ipDefaultRouterEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 37, 1, 0};
    guint32 base[128];

    *ipDefaultRouterEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipDefaultRouterEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipDefaultRouterEntry = (ip_mib_ipDefaultRouterEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipDefaultRouterEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipDefaultRouterEntry)[i] = assign_ipDefaultRouterEntry(row->data);
        }
    }
}

void
ip_mib_get_ipDefaultRouterEntry(GNetSnmp *s, ip_mib_ipDefaultRouterEntry_t **ipDefaultRouterEntry, gint32 ipDefaultRouterAddressType, guchar *ipDefaultRouterAddress, guint16 _ipDefaultRouterAddressLength, gint32 ipDefaultRouterIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipDefaultRouterEntry_oid, sizeof(ipDefaultRouterEntry_oid));
    len = pack_ipDefaultRouterEntry(base, ipDefaultRouterAddressType, ipDefaultRouterAddress, _ipDefaultRouterAddressLength, ipDefaultRouterIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipDefaultRouterEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipDefaultRouterEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipDefaultRouterEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipDefaultRouterEntry = assign_ipDefaultRouterEntry(out);
    }
}

void
ip_mib_free_ipDefaultRouterEntry(ip_mib_ipDefaultRouterEntry_t *ipDefaultRouterEntry)
{
    GList *vbl;
    char *p;

    if (ipDefaultRouterEntry) {
        p = (char *) ipDefaultRouterEntry + sizeof(ip_mib_ipDefaultRouterEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipDefaultRouterEntry);
    }
}

void
ip_mib_free_ipDefaultRouterTable(ip_mib_ipDefaultRouterEntry_t **ipDefaultRouterEntry)
{
    int i;

    if (ipDefaultRouterEntry) {
        for (i = 0; ipDefaultRouterEntry[i]; i++) {
            ip_mib_free_ipDefaultRouterEntry(ipDefaultRouterEntry[i]);
        }
        g_free(ipDefaultRouterEntry);
    }
}

ip_mib_ipv6RouterAdvertEntry_t *
ip_mib_new_ipv6RouterAdvertEntry()
{
    ip_mib_ipv6RouterAdvertEntry_t *ipv6RouterAdvertEntry;

    ipv6RouterAdvertEntry = (ip_mib_ipv6RouterAdvertEntry_t *) g_malloc0(sizeof(ip_mib_ipv6RouterAdvertEntry_t) + sizeof(gpointer));
    return ipv6RouterAdvertEntry;
}

static inline int
unpack_ipv6RouterAdvertEntry(GNetSnmpVarBind *vb, ip_mib_ipv6RouterAdvertEntry_t *ipv6RouterAdvertEntry)
{
    guint8 idx = 10;

    if (vb->oid_len < idx) return -1;
    ipv6RouterAdvertEntry->ipv6RouterAdvertIfIndex = vb->oid[idx++];
    if ((ipv6RouterAdvertEntry->ipv6RouterAdvertIfIndex < 1)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_ipv6RouterAdvertEntry(guint32 *base, gint32 ipv6RouterAdvertIfIndex)
{
    guint8 idx = 10;

    base[idx++] = ipv6RouterAdvertIfIndex;
    return idx;
}

static inline ip_mib_ipv6RouterAdvertEntry_t *
assign_ipv6RouterAdvertEntry(GList *vbl)
{
    ip_mib_ipv6RouterAdvertEntry_t *ipv6RouterAdvertEntry;
    char *p;

    ipv6RouterAdvertEntry = ip_mib_new_ipv6RouterAdvertEntry();
    p = (char *) ipv6RouterAdvertEntry + sizeof(ip_mib_ipv6RouterAdvertEntry_t);
    * (GList **) p = vbl;

    if (unpack_ipv6RouterAdvertEntry((GNetSnmpVarBind *) vbl->data, ipv6RouterAdvertEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ipv6RouterAdvertEntry");
        g_free(ipv6RouterAdvertEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, ipv6RouterAdvertEntry_oid, G_N_ELEMENTS(ipv6RouterAdvertEntry_oid),
                      ipv6RouterAdvertEntry_attr, ipv6RouterAdvertEntry);

    return ipv6RouterAdvertEntry;
}

void
ip_mib_get_ipv6RouterAdvertTable(GNetSnmp *s, ip_mib_ipv6RouterAdvertEntry_t ***ipv6RouterAdvertEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 2, 1, 4, 39, 1, 0};
    guint32 base[128];

    *ipv6RouterAdvertEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 10, 9, ipv6RouterAdvertEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *ipv6RouterAdvertEntry = (ip_mib_ipv6RouterAdvertEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(ip_mib_ipv6RouterAdvertEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*ipv6RouterAdvertEntry)[i] = assign_ipv6RouterAdvertEntry(row->data);
        }
    }
}

void
ip_mib_get_ipv6RouterAdvertEntry(GNetSnmp *s, ip_mib_ipv6RouterAdvertEntry_t **ipv6RouterAdvertEntry, gint32 ipv6RouterAdvertIfIndex, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv6RouterAdvertEntry_oid, sizeof(ipv6RouterAdvertEntry_oid));
    len = pack_ipv6RouterAdvertEntry(base, ipv6RouterAdvertIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv6RouterAdvertEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *ipv6RouterAdvertEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 9, ipv6RouterAdvertEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *ipv6RouterAdvertEntry = assign_ipv6RouterAdvertEntry(out);
    }
}

void
ip_mib_set_ipv6RouterAdvertEntry(GNetSnmp *s, ip_mib_ipv6RouterAdvertEntry_t *ipv6RouterAdvertEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, ipv6RouterAdvertEntry_oid, sizeof(ipv6RouterAdvertEntry_oid));
    len = pack_ipv6RouterAdvertEntry(base, ipv6RouterAdvertEntry->ipv6RouterAdvertIfIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ipv6RouterAdvertEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 9, ipv6RouterAdvertEntry_attr, mask, ipv6RouterAdvertEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
ip_mib_free_ipv6RouterAdvertEntry(ip_mib_ipv6RouterAdvertEntry_t *ipv6RouterAdvertEntry)
{
    GList *vbl;
    char *p;

    if (ipv6RouterAdvertEntry) {
        p = (char *) ipv6RouterAdvertEntry + sizeof(ip_mib_ipv6RouterAdvertEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(ipv6RouterAdvertEntry);
    }
}

void
ip_mib_free_ipv6RouterAdvertTable(ip_mib_ipv6RouterAdvertEntry_t **ipv6RouterAdvertEntry)
{
    int i;

    if (ipv6RouterAdvertEntry) {
        for (i = 0; ipv6RouterAdvertEntry[i]; i++) {
            ip_mib_free_ipv6RouterAdvertEntry(ipv6RouterAdvertEntry[i]);
        }
        g_free(ipv6RouterAdvertEntry);
    }
}


