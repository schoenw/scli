/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from IP-MIB:
 *   The MIB module for managing IP and ICMP implementations,
 *   but excluding their management of IP routes.
 *
 * Revision 1994-11-01 00:00:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * Revision 1991-03-31 00:00:
 *   The initial revision of this MIB module was part of MIB-
 *   II.
 *
 * $Id$
 */

#include "ip-mib.h"

GSnmpEnum const ip_mib_enums_ipForwarding[] = {
    { IP_MIB_IPFORWARDING_FORWARDING,	"forwarding" },
    { IP_MIB_IPFORWARDING_NOTFORWARDING,	"notForwarding" },
    { 0, NULL }
};

GSnmpEnum const ip_mib_enums_ipNetToMediaType[] = {
    { IP_MIB_IPNETTOMEDIATYPE_OTHER,	"other" },
    { IP_MIB_IPNETTOMEDIATYPE_INVALID,	"invalid" },
    { IP_MIB_IPNETTOMEDIATYPE_DYNAMIC,	"dynamic" },
    { IP_MIB_IPNETTOMEDIATYPE_STATIC,	"static" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_ip[] = {1, 3, 6, 1, 2, 1, 4};

static attribute_t attr_ip[] = {
    { 1, G_SNMP_INTEGER32, IP_MIB_IPFORWARDING, "ipForwarding" },
    { 2, G_SNMP_INTEGER32, IP_MIB_IPDEFAULTTTL, "ipDefaultTTL" },
    { 3, G_SNMP_COUNTER32, IP_MIB_IPINRECEIVES, "ipInReceives" },
    { 4, G_SNMP_COUNTER32, IP_MIB_IPINHDRERRORS, "ipInHdrErrors" },
    { 5, G_SNMP_COUNTER32, IP_MIB_IPINADDRERRORS, "ipInAddrErrors" },
    { 6, G_SNMP_COUNTER32, IP_MIB_IPFORWDATAGRAMS, "ipForwDatagrams" },
    { 7, G_SNMP_COUNTER32, IP_MIB_IPINUNKNOWNPROTOS, "ipInUnknownProtos" },
    { 8, G_SNMP_COUNTER32, IP_MIB_IPINDISCARDS, "ipInDiscards" },
    { 9, G_SNMP_COUNTER32, IP_MIB_IPINDELIVERS, "ipInDelivers" },
    { 10, G_SNMP_COUNTER32, IP_MIB_IPOUTREQUESTS, "ipOutRequests" },
    { 11, G_SNMP_COUNTER32, IP_MIB_IPOUTDISCARDS, "ipOutDiscards" },
    { 12, G_SNMP_COUNTER32, IP_MIB_IPOUTNOROUTES, "ipOutNoRoutes" },
    { 13, G_SNMP_INTEGER32, IP_MIB_IPREASMTIMEOUT, "ipReasmTimeout" },
    { 14, G_SNMP_COUNTER32, IP_MIB_IPREASMREQDS, "ipReasmReqds" },
    { 15, G_SNMP_COUNTER32, IP_MIB_IPREASMOKS, "ipReasmOKs" },
    { 16, G_SNMP_COUNTER32, IP_MIB_IPREASMFAILS, "ipReasmFails" },
    { 17, G_SNMP_COUNTER32, IP_MIB_IPFRAGOKS, "ipFragOKs" },
    { 18, G_SNMP_COUNTER32, IP_MIB_IPFRAGFAILS, "ipFragFails" },
    { 19, G_SNMP_COUNTER32, IP_MIB_IPFRAGCREATES, "ipFragCreates" },
    { 23, G_SNMP_COUNTER32, IP_MIB_IPROUTINGDISCARDS, "ipRoutingDiscards" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ipAddrEntry[] = {1, 3, 6, 1, 2, 1, 4, 20, 1};

static attribute_t attr_ipAddrEntry[] = {
    { 2, G_SNMP_INTEGER32, IP_MIB_IPADENTIFINDEX, "ipAdEntIfIndex" },
    { 3, G_SNMP_IPADDRESS, IP_MIB_IPADENTNETMASK, "ipAdEntNetMask" },
    { 4, G_SNMP_INTEGER32, IP_MIB_IPADENTBCASTADDR, "ipAdEntBcastAddr" },
    { 5, G_SNMP_INTEGER32, IP_MIB_IPADENTREASMMAXSIZE, "ipAdEntReasmMaxSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ipNetToMediaEntry[] = {1, 3, 6, 1, 2, 1, 4, 22, 1};

static attribute_t attr_ipNetToMediaEntry[] = {
    { 2, G_SNMP_OCTETSTRING, IP_MIB_IPNETTOMEDIAPHYSADDRESS, "ipNetToMediaPhysAddress" },
    { 4, G_SNMP_INTEGER32, IP_MIB_IPNETTOMEDIATYPE, "ipNetToMediaType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_icmp[] = {1, 3, 6, 1, 2, 1, 5};

static attribute_t attr_icmp[] = {
    { 1, G_SNMP_COUNTER32, IP_MIB_ICMPINMSGS, "icmpInMsgs" },
    { 2, G_SNMP_COUNTER32, IP_MIB_ICMPINERRORS, "icmpInErrors" },
    { 3, G_SNMP_COUNTER32, IP_MIB_ICMPINDESTUNREACHS, "icmpInDestUnreachs" },
    { 4, G_SNMP_COUNTER32, IP_MIB_ICMPINTIMEEXCDS, "icmpInTimeExcds" },
    { 5, G_SNMP_COUNTER32, IP_MIB_ICMPINPARMPROBS, "icmpInParmProbs" },
    { 6, G_SNMP_COUNTER32, IP_MIB_ICMPINSRCQUENCHS, "icmpInSrcQuenchs" },
    { 7, G_SNMP_COUNTER32, IP_MIB_ICMPINREDIRECTS, "icmpInRedirects" },
    { 8, G_SNMP_COUNTER32, IP_MIB_ICMPINECHOS, "icmpInEchos" },
    { 9, G_SNMP_COUNTER32, IP_MIB_ICMPINECHOREPS, "icmpInEchoReps" },
    { 10, G_SNMP_COUNTER32, IP_MIB_ICMPINTIMESTAMPS, "icmpInTimestamps" },
    { 11, G_SNMP_COUNTER32, IP_MIB_ICMPINTIMESTAMPREPS, "icmpInTimestampReps" },
    { 12, G_SNMP_COUNTER32, IP_MIB_ICMPINADDRMASKS, "icmpInAddrMasks" },
    { 13, G_SNMP_COUNTER32, IP_MIB_ICMPINADDRMASKREPS, "icmpInAddrMaskReps" },
    { 14, G_SNMP_COUNTER32, IP_MIB_ICMPOUTMSGS, "icmpOutMsgs" },
    { 15, G_SNMP_COUNTER32, IP_MIB_ICMPOUTERRORS, "icmpOutErrors" },
    { 16, G_SNMP_COUNTER32, IP_MIB_ICMPOUTDESTUNREACHS, "icmpOutDestUnreachs" },
    { 17, G_SNMP_COUNTER32, IP_MIB_ICMPOUTTIMEEXCDS, "icmpOutTimeExcds" },
    { 18, G_SNMP_COUNTER32, IP_MIB_ICMPOUTPARMPROBS, "icmpOutParmProbs" },
    { 19, G_SNMP_COUNTER32, IP_MIB_ICMPOUTSRCQUENCHS, "icmpOutSrcQuenchs" },
    { 20, G_SNMP_COUNTER32, IP_MIB_ICMPOUTREDIRECTS, "icmpOutRedirects" },
    { 21, G_SNMP_COUNTER32, IP_MIB_ICMPOUTECHOS, "icmpOutEchos" },
    { 22, G_SNMP_COUNTER32, IP_MIB_ICMPOUTECHOREPS, "icmpOutEchoReps" },
    { 23, G_SNMP_COUNTER32, IP_MIB_ICMPOUTTIMESTAMPS, "icmpOutTimestamps" },
    { 24, G_SNMP_COUNTER32, IP_MIB_ICMPOUTTIMESTAMPREPS, "icmpOutTimestampReps" },
    { 25, G_SNMP_COUNTER32, IP_MIB_ICMPOUTADDRMASKS, "icmpOutAddrMasks" },
    { 26, G_SNMP_COUNTER32, IP_MIB_ICMPOUTADDRMASKREPS, "icmpOutAddrMaskReps" },
    { 0, 0, 0, NULL }
};


ip_mib_ip_t *
ip_mib_new_ip()
{
    ip_mib_ip_t *ip;

    ip = (ip_mib_ip_t *) g_malloc0(sizeof(ip_mib_ip_t) + sizeof(gpointer));
    return ip;
}

static ip_mib_ip_t *
assign_ip(GSList *vbl)
{
    GSList *elem;
    ip_mib_ip_t *ip;
    guint32 idx;
    char *p;

    ip = ip_mib_new_ip();
    if (! ip) {
        return NULL;
    }

    p = (char *) ip + sizeof(ip_mib_ip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ip, sizeof(oid_ip)/sizeof(guint32),
                   attr_ip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ip->ipForwarding = &(vb->syntax.i32[0]);
            break;
        case 2:
            ip->ipDefaultTTL = &(vb->syntax.i32[0]);
            break;
        case 3:
            ip->ipInReceives = &(vb->syntax.ui32[0]);
            break;
        case 4:
            ip->ipInHdrErrors = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ip->ipInAddrErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ip->ipForwDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ip->ipInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ip->ipInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ip->ipInDelivers = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ip->ipOutRequests = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ip->ipOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ip->ipOutNoRoutes = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ip->ipReasmTimeout = &(vb->syntax.i32[0]);
            break;
        case 14:
            ip->ipReasmReqds = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ip->ipReasmOKs = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ip->ipReasmFails = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ip->ipFragOKs = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ip->ipFragFails = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ip->ipFragCreates = &(vb->syntax.ui32[0]);
            break;
        case 23:
            ip->ipRoutingDiscards = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return ip;
}

void
ip_mib_get_ip(GSnmpSession *s, ip_mib_ip_t **ip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0};

    *ip = NULL;

    add_attributes(s, &in, base, 8, 7, attr_ip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ip = assign_ip(out);
    }
}

void
ip_mib_set_ip(GSnmpSession *s, ip_mib_ip_t *ip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0, 0};

    if (ip->ipForwarding) {
        base[7] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ip->ipForwarding,
                       0);
    }
    if (ip->ipDefaultTTL) {
        base[7] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ip->ipDefaultTTL,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ip_mib_free_ip(ip_mib_ip_t *ip)
{
    GSList *vbl;
    char *p;

    if (ip) {
        p = (char *) ip + sizeof(ip_mib_ip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ip);
    }
}

ip_mib_ipAddrEntry_t *
ip_mib_new_ipAddrEntry()
{
    ip_mib_ipAddrEntry_t *ipAddrEntry;

    ipAddrEntry = (ip_mib_ipAddrEntry_t *) g_malloc0(sizeof(ip_mib_ipAddrEntry_t) + sizeof(gpointer));
    return ipAddrEntry;
}

static int
unpack_ipAddrEntry(GSnmpVarBind *vb, ip_mib_ipAddrEntry_t *ipAddrEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddrEntry->ipAdEntAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ipAddrEntry(guint32 *base, guchar *ipAdEntAddr)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipAdEntAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ip_mib_ipAddrEntry_t *
assign_ipAddrEntry(GSList *vbl)
{
    GSList *elem;
    ip_mib_ipAddrEntry_t *ipAddrEntry;
    guint32 idx;
    char *p;

    ipAddrEntry = ip_mib_new_ipAddrEntry();
    if (! ipAddrEntry) {
        return NULL;
    }

    p = (char *) ipAddrEntry + sizeof(ip_mib_ipAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipAddrEntry((GSnmpVarBind *) vbl->data, ipAddrEntry) < 0) {
        g_warning("illegal ipAddrEntry instance identifier");
        g_free(ipAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ipAddrEntry, sizeof(oid_ipAddrEntry)/sizeof(guint32),
                   attr_ipAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipAddrEntry->ipAdEntIfIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            if (vb->syntax_len != 4) break;
            ipAddrEntry->ipAdEntNetMask = vb->syntax.uc;
            break;
        case 4:
            ipAddrEntry->ipAdEntBcastAddr = &(vb->syntax.i32[0]);
            break;
        case 5:
            ipAddrEntry->ipAdEntReasmMaxSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipAddrEntry;
}

void
ip_mib_get_ipAddrTable(GSnmpSession *s, ip_mib_ipAddrEntry_t ***ipAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 20, 1, 0};

    *ipAddrEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ipAddrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ipAddrEntry = (ip_mib_ipAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ip_mib_ipAddrEntry_t *));
        if (! *ipAddrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ipAddrEntry)[i] = assign_ipAddrEntry(row->data);
        }
    }
}

void
ip_mib_get_ipAddrEntry(GSnmpSession *s, ip_mib_ipAddrEntry_t **ipAddrEntry, guchar *ipAdEntAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipAddrEntry, sizeof(oid_ipAddrEntry));
    len = pack_ipAddrEntry(base, ipAdEntAddr);
    if (len < 0) {
        g_warning("illegal ipAddrEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ipAddrEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ipAddrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ipAddrEntry = assign_ipAddrEntry(out);
    }
}

void
ip_mib_free_ipAddrEntry(ip_mib_ipAddrEntry_t *ipAddrEntry)
{
    GSList *vbl;
    char *p;

    if (ipAddrEntry) {
        p = (char *) ipAddrEntry + sizeof(ip_mib_ipAddrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ipAddrEntry);
    }
}

void
ip_mib_free_ipAddrTable(ip_mib_ipAddrEntry_t **ipAddrEntry)
{
    int i;

    if (ipAddrEntry) {
        for (i = 0; ipAddrEntry[i]; i++) {
            ip_mib_free_ipAddrEntry(ipAddrEntry[i]);
        }
        g_free(ipAddrEntry);
    }
}

ip_mib_ipNetToMediaEntry_t *
ip_mib_new_ipNetToMediaEntry()
{
    ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;

    ipNetToMediaEntry = (ip_mib_ipNetToMediaEntry_t *) g_malloc0(sizeof(ip_mib_ipNetToMediaEntry_t) + sizeof(gpointer));
    return ipNetToMediaEntry;
}

static int
unpack_ipNetToMediaEntry(GSnmpVarBind *vb, ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    int idx = 10;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    ipNetToMediaEntry->ipNetToMediaIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipNetToMediaEntry->ipNetToMediaNetAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ipNetToMediaEntry(guint32 *base, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress)
{
    int idx = 10;
    guint16 i, len;

    base[idx++] = ipNetToMediaIfIndex;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ipNetToMediaNetAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ip_mib_ipNetToMediaEntry_t *
assign_ipNetToMediaEntry(GSList *vbl)
{
    GSList *elem;
    ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;
    guint32 idx;
    char *p;

    ipNetToMediaEntry = ip_mib_new_ipNetToMediaEntry();
    if (! ipNetToMediaEntry) {
        return NULL;
    }

    p = (char *) ipNetToMediaEntry + sizeof(ip_mib_ipNetToMediaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipNetToMediaEntry((GSnmpVarBind *) vbl->data, ipNetToMediaEntry) < 0) {
        g_warning("illegal ipNetToMediaEntry instance identifier");
        g_free(ipNetToMediaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry)/sizeof(guint32),
                   attr_ipNetToMediaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipNetToMediaEntry->_ipNetToMediaPhysAddressLength = vb->syntax_len;
            ipNetToMediaEntry->ipNetToMediaPhysAddress = vb->syntax.uc;
            break;
        case 4:
            ipNetToMediaEntry->ipNetToMediaType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipNetToMediaEntry;
}

void
ip_mib_get_ipNetToMediaTable(GSnmpSession *s, ip_mib_ipNetToMediaEntry_t ***ipNetToMediaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 22, 1, 0};

    *ipNetToMediaEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ipNetToMediaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ipNetToMediaEntry = (ip_mib_ipNetToMediaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ip_mib_ipNetToMediaEntry_t *));
        if (! *ipNetToMediaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ipNetToMediaEntry)[i] = assign_ipNetToMediaEntry(row->data);
        }
    }
}

void
ip_mib_get_ipNetToMediaEntry(GSnmpSession *s, ip_mib_ipNetToMediaEntry_t **ipNetToMediaEntry, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaIfIndex, ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("illegal ipNetToMediaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ipNetToMediaEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ipNetToMediaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ipNetToMediaEntry = assign_ipNetToMediaEntry(out);
    }
}

void
ip_mib_set_ipNetToMediaEntry(GSnmpSession *s, ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaEntry->ipNetToMediaIfIndex, ipNetToMediaEntry->ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("illegal ipNetToMediaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ipNetToMediaEntry->ipNetToMediaPhysAddress) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       ipNetToMediaEntry->ipNetToMediaPhysAddress,
                       ipNetToMediaEntry->_ipNetToMediaPhysAddressLength);
    }
    if (ipNetToMediaEntry->ipNetToMediaType) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipNetToMediaEntry->ipNetToMediaType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ip_mib_free_ipNetToMediaEntry(ip_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    GSList *vbl;
    char *p;

    if (ipNetToMediaEntry) {
        p = (char *) ipNetToMediaEntry + sizeof(ip_mib_ipNetToMediaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ipNetToMediaEntry);
    }
}

void
ip_mib_free_ipNetToMediaTable(ip_mib_ipNetToMediaEntry_t **ipNetToMediaEntry)
{
    int i;

    if (ipNetToMediaEntry) {
        for (i = 0; ipNetToMediaEntry[i]; i++) {
            ip_mib_free_ipNetToMediaEntry(ipNetToMediaEntry[i]);
        }
        g_free(ipNetToMediaEntry);
    }
}

ip_mib_icmp_t *
ip_mib_new_icmp()
{
    ip_mib_icmp_t *icmp;

    icmp = (ip_mib_icmp_t *) g_malloc0(sizeof(ip_mib_icmp_t) + sizeof(gpointer));
    return icmp;
}

static ip_mib_icmp_t *
assign_icmp(GSList *vbl)
{
    GSList *elem;
    ip_mib_icmp_t *icmp;
    guint32 idx;
    char *p;

    icmp = ip_mib_new_icmp();
    if (! icmp) {
        return NULL;
    }

    p = (char *) icmp + sizeof(ip_mib_icmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_icmp, sizeof(oid_icmp)/sizeof(guint32),
                   attr_icmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            icmp->icmpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            icmp->icmpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            icmp->icmpInDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            icmp->icmpInTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 5:
            icmp->icmpInParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            icmp->icmpInSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 7:
            icmp->icmpInRedirects = &(vb->syntax.ui32[0]);
            break;
        case 8:
            icmp->icmpInEchos = &(vb->syntax.ui32[0]);
            break;
        case 9:
            icmp->icmpInEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 10:
            icmp->icmpInTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 11:
            icmp->icmpInTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 12:
            icmp->icmpInAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 13:
            icmp->icmpInAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        case 14:
            icmp->icmpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 15:
            icmp->icmpOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 16:
            icmp->icmpOutDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 17:
            icmp->icmpOutTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 18:
            icmp->icmpOutParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 19:
            icmp->icmpOutSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 20:
            icmp->icmpOutRedirects = &(vb->syntax.ui32[0]);
            break;
        case 21:
            icmp->icmpOutEchos = &(vb->syntax.ui32[0]);
            break;
        case 22:
            icmp->icmpOutEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 23:
            icmp->icmpOutTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 24:
            icmp->icmpOutTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 25:
            icmp->icmpOutAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 26:
            icmp->icmpOutAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return icmp;
}

void
ip_mib_get_icmp(GSnmpSession *s, ip_mib_icmp_t **icmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 5, 0};

    *icmp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_icmp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *icmp = assign_icmp(out);
    }
}

void
ip_mib_free_icmp(ip_mib_icmp_t *icmp)
{
    GSList *vbl;
    char *p;

    if (icmp) {
        p = (char *) icmp + sizeof(ip_mib_icmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(icmp);
    }
}


