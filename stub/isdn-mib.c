/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from ISDN-MIB:
 *   The MIB module to describe the
 *   management of ISDN interfaces.
 *
 * Revision 1996-09-23 16:42:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "isdn-mib.h"

GSnmpEnum const isdn_mib_enums_isdnBasicRateIfType[] = {
    { ISDN_MIB_ISDNBASICRATEIFTYPE_ISDNS, "isdns" },
    { ISDN_MIB_ISDNBASICRATEIFTYPE_ISDNU, "isdnu" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBasicRateLineTopology[] = {
    { ISDN_MIB_ISDNBASICRATELINETOPOLOGY_POINTTOPOINT,      "pointToPoint" },
    { ISDN_MIB_ISDNBASICRATELINETOPOLOGY_POINTTOMULTIPOINT, "pointToMultipoint" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBasicRateIfMode[] = {
    { ISDN_MIB_ISDNBASICRATEIFMODE_TE, "te" },
    { ISDN_MIB_ISDNBASICRATEIFMODE_NT, "nt" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBasicRateSignalMode[] = {
    { ISDN_MIB_ISDNBASICRATESIGNALMODE_ACTIVE,   "active" },
    { ISDN_MIB_ISDNBASICRATESIGNALMODE_INACTIVE, "inactive" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBearerChannelType[] = {
    { ISDN_MIB_ISDNBEARERCHANNELTYPE_DIALUP, "dialup" },
    { ISDN_MIB_ISDNBEARERCHANNELTYPE_LEASED, "leased" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBearerOperStatus[] = {
    { ISDN_MIB_ISDNBEAREROPERSTATUS_IDLE,       "idle" },
    { ISDN_MIB_ISDNBEAREROPERSTATUS_CONNECTING, "connecting" },
    { ISDN_MIB_ISDNBEAREROPERSTATUS_CONNECTED,  "connected" },
    { ISDN_MIB_ISDNBEAREROPERSTATUS_ACTIVE,     "active" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBearerCallOrigin[] = {
    { ISDN_MIB_ISDNBEARERCALLORIGIN_UNKNOWN,   "unknown" },
    { ISDN_MIB_ISDNBEARERCALLORIGIN_ORIGINATE, "originate" },
    { ISDN_MIB_ISDNBEARERCALLORIGIN_ANSWER,    "answer" },
    { ISDN_MIB_ISDNBEARERCALLORIGIN_CALLBACK,  "callback" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBearerInfoType[] = {
    { ISDN_MIB_ISDNBEARERINFOTYPE_UNKNOWN,               "unknown" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_SPEECH,                "speech" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_UNRESTRICTEDDIGITAL,   "unrestrictedDigital" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_UNRESTRICTEDDIGITAL56, "unrestrictedDigital56" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_RESTRICTEDDIGITAL,     "restrictedDigital" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_AUDIO31,               "audio31" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_AUDIO7,                "audio7" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_VIDEO,                 "video" },
    { ISDN_MIB_ISDNBEARERINFOTYPE_PACKETSWITCHED,        "packetSwitched" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnBearerMultirate[] = {
    { ISDN_MIB_ISDNBEARERMULTIRATE_TRUE,  "true" },
    { ISDN_MIB_ISDNBEARERMULTIRATE_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnSignalingProtocol[] = {
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_OTHER,     "other" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_DSS1,      "dss1" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_ETSI,      "etsi" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_DASS2,     "dass2" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_ESS4,      "ess4" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_ESS5,      "ess5" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_DMS100,    "dms100" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_DMS250,    "dms250" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_NI1,       "ni1" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_NI2,       "ni2" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_NI3,       "ni3" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_VN2,       "vn2" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_VN3,       "vn3" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_VN4,       "vn4" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_VN6,       "vn6" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_KDD,       "kdd" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_INS64,     "ins64" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_INS1500,   "ins1500" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_ITR6,      "itr6" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_CORNET,    "cornet" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_TS013,     "ts013" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_TS014,     "ts014" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_QSIG,      "qsig" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_SWISSNET2, "swissnet2" },
    { ISDN_MIB_ISDNSIGNALINGPROTOCOL_SWISSNET3, "swissnet3" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnSignalingInfoTrapEnable[] = {
    { ISDN_MIB_ISDNSIGNALINGINFOTRAPENABLE_ENABLED,  "enabled" },
    { ISDN_MIB_ISDNSIGNALINGINFOTRAPENABLE_DISABLED, "disabled" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnSignalingStatus[] = {
    { ISDN_MIB_ISDNSIGNALINGSTATUS_ACTIVE,        "active" },
    { ISDN_MIB_ISDNSIGNALINGSTATUS_NOTINSERVICE,  "notInService" },
    { ISDN_MIB_ISDNSIGNALINGSTATUS_NOTREADY,      "notReady" },
    { ISDN_MIB_ISDNSIGNALINGSTATUS_CREATEANDGO,   "createAndGo" },
    { ISDN_MIB_ISDNSIGNALINGSTATUS_CREATEANDWAIT, "createAndWait" },
    { ISDN_MIB_ISDNSIGNALINGSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnLapdPrimaryChannel[] = {
    { ISDN_MIB_ISDNLAPDPRIMARYCHANNEL_TRUE,  "true" },
    { ISDN_MIB_ISDNLAPDPRIMARYCHANNEL_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnLapdOperStatus[] = {
    { ISDN_MIB_ISDNLAPDOPERSTATUS_INACTIVE, "inactive" },
    { ISDN_MIB_ISDNLAPDOPERSTATUS_L1ACTIVE, "l1Active" },
    { ISDN_MIB_ISDNLAPDOPERSTATUS_L2ACTIVE, "l2Active" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnEndpointIfType[] = {
    { ISDN_MIB_ISDNENDPOINTIFTYPE_OTHER,                         "other" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_REGULAR1822,                   "regular1822" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HDH1822,                       "hdh1822" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DDNX25,                        "ddnX25" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RFC877X25,                     "rfc877x25" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ETHERNETCSMACD,                "ethernetCsmacd" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88023CSMACD,                "iso88023Csmacd" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88024TOKENBUS,              "iso88024TokenBus" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88025TOKENRING,             "iso88025TokenRing" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88026MAN,                   "iso88026Man" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_STARLAN,                       "starLan" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROTEON10MBIT,                 "proteon10Mbit" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROTEON80MBIT,                 "proteon80Mbit" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HYPERCHANNEL,                  "hyperchannel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FDDI,                          "fddi" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_LAPB,                          "lapb" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SDLC,                          "sdlc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DS1,                           "ds1" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_E1,                            "e1" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_BASICISDN,                     "basicISDN" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PRIMARYISDN,                   "primaryISDN" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPPOINTTOPOINTSERIAL,        "propPointToPointSerial" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PPP,                           "ppp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SOFTWARELOOPBACK,              "softwareLoopback" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_EON,                           "eon" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ETHERNET3MBIT,                 "ethernet3Mbit" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_NSIP,                          "nsip" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SLIP,                          "slip" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ULTRA,                         "ultra" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DS3,                           "ds3" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SIP,                           "sip" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRAMERELAY,                    "frameRelay" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RS232,                         "rs232" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PARA,                          "para" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ARCNET,                        "arcnet" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ARCNETPLUS,                    "arcnetPlus" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATM,                           "atm" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MIOX25,                        "miox25" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SONET,                         "sonet" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_X25PLE,                        "x25ple" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88022LLC,                   "iso88022llc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_LOCALTALK,                     "localTalk" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SMDSDXI,                       "smdsDxi" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRAMERELAYSERVICE,             "frameRelayService" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_V35,                           "v35" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HSSI,                          "hssi" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HIPPI,                         "hippi" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MODEM,                         "modem" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_AAL5,                          "aal5" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SONETPATH,                     "sonetPath" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SONETVT,                       "sonetVT" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SMDSICIP,                      "smdsIcip" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPVIRTUAL,                   "propVirtual" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPMULTIPLEXOR,               "propMultiplexor" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IEEE80212,                     "ieee80212" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FIBRECHANNEL,                  "fibreChannel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HIPPIINTERFACE,                "hippiInterface" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRAMERELAYINTERCONNECT,        "frameRelayInterconnect" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_AFLANE8023,                    "aflane8023" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_AFLANE8025,                    "aflane8025" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_CCTEMUL,                       "cctEmul" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FASTETHER,                     "fastEther" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISDN,                          "isdn" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_V11,                           "v11" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_V36,                           "v36" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_G703AT64K,                     "g703at64k" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_G703AT2MB,                     "g703at2mb" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_QLLC,                          "qllc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FASTETHERFX,                   "fastEtherFX" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_CHANNEL,                       "channel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IEEE80211,                     "ieee80211" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IBM370PARCHAN,                 "ibm370parChan" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ESCON,                         "escon" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DLSW,                          "dlsw" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISDNS,                         "isdns" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISDNU,                         "isdnu" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_LAPD,                          "lapd" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IPSWITCH,                      "ipSwitch" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RSRB,                          "rsrb" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMLOGICAL,                    "atmLogical" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DS0,                           "ds0" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DS0BUNDLE,                     "ds0Bundle" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_BSC,                           "bsc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ASYNC,                         "async" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_CNR,                           "cnr" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88025DTR,                   "iso88025Dtr" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_EPLRS,                         "eplrs" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ARAP,                          "arap" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPCNLS,                      "propCnls" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HOSTPAD,                       "hostPad" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_TERMPAD,                       "termPad" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRAMERELAYMPI,                 "frameRelayMPI" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_X213,                          "x213" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ADSL,                          "adsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RADSL,                         "radsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SDSL,                          "sdsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VDSL,                          "vdsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88025CRFPINT,               "iso88025CRFPInt" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MYRINET,                       "myrinet" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEEM,                       "voiceEM" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEFXO,                      "voiceFXO" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEFXS,                      "voiceFXS" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEENCAP,                    "voiceEncap" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEOVERIP,                   "voiceOverIp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMDXI,                        "atmDxi" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMFUNI,                       "atmFuni" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMIMA,                        "atmIma" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PPPMULTILINKBUNDLE,            "pppMultilinkBundle" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IPOVERCDLC,                    "ipOverCdlc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IPOVERCLAW,                    "ipOverClaw" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_STACKTOSTACK,                  "stackToStack" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VIRTUALIPADDRESS,              "virtualIpAddress" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MPC,                           "mpc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IPOVERATM,                     "ipOverAtm" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISO88025FIBER,                 "iso88025Fiber" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_TDLC,                          "tdlc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_GIGABITETHERNET,               "gigabitEthernet" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HDLC,                          "hdlc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_LAPF,                          "lapf" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_V37,                           "v37" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_X25MLP,                        "x25mlp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_X25HUNTGROUP,                  "x25huntGroup" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_TRASNPHDLC,                    "trasnpHdlc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_INTERLEAVE,                    "interleave" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FAST,                          "fast" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IP,                            "ip" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DOCSCABLEMACLAYER,             "docsCableMaclayer" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DOCSCABLEDOWNSTREAM,           "docsCableDownstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DOCSCABLEUPSTREAM,             "docsCableUpstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_A12MPPSWITCH,                  "a12MppSwitch" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_TUNNEL,                        "tunnel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_COFFEE,                        "coffee" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_CES,                           "ces" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMSUBINTERFACE,               "atmSubInterface" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_L2VLAN,                        "l2vlan" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_L3IPVLAN,                      "l3ipvlan" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_L3IPXVLAN,                     "l3ipxvlan" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DIGITALPOWERLINE,              "digitalPowerline" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MEDIAMAILOVERIP,               "mediaMailOverIp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DTM,                           "dtm" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DCN,                           "dcn" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IPFORWARD,                     "ipForward" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MSDSL,                         "msdsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IEEE1394,                      "ieee1394" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IF_GSN,                        "if-gsn" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DVBRCCMACLAYER,                "dvbRccMacLayer" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DVBRCCDOWNSTREAM,              "dvbRccDownstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DVBRCCUPSTREAM,                "dvbRccUpstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMVIRTUAL,                    "atmVirtual" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MPLSTUNNEL,                    "mplsTunnel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SRP,                           "srp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEOVERATM,                  "voiceOverAtm" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_VOICEOVERFRAMERELAY,           "voiceOverFrameRelay" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IDSL,                          "idsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_COMPOSITELINK,                 "compositeLink" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SS7SIGLINK,                    "ss7SigLink" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPWIRELESSP2P,               "propWirelessP2P" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRFORWARD,                     "frForward" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RFC1483,                       "rfc1483" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_USB,                           "usb" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_IEEE8023ADLAG,                 "ieee8023adLag" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_BGPPOLICYACCOUNTING,           "bgppolicyaccounting" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_FRF16MFRBUNDLE,                "frf16MfrBundle" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_H323GATEKEEPER,                "h323Gatekeeper" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_H323PROXY,                     "h323Proxy" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MPLS,                          "mpls" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_MFSIGLINK,                     "mfSigLink" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HDSL2,                         "hdsl2" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SHDSL,                         "shdsl" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DS1FDL,                        "ds1FDL" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_POS,                           "pos" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DVBASILN,                      "dvbAsiln" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DVBASIOUT,                     "dvbAsiOut" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PLC,                           "plc" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_NFAS,                          "nfas" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_TR008,                         "tr008" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_GR303RDT,                      "gr303RDT" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_GR303IDT,                      "gr303IDT" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ISUP,                          "isup" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPDOCSWIRELESSMACLAYER,      "propDocsWirelessMaclayer" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPDOCSWIRELESSDOWNSTREAM,    "propDocsWirelessDownstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPDOCSWIRELESSUPSTREAM,      "propDocsWirelessUpstream" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_HIPERLAN2,                     "hiperlan2" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_PROPBWAP2MP,                   "propBWAp2Mp" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_SONETOVERHEADCHANNEL,          "sonetOverheadChannel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_DIGITALWRAPPEROVERHEADCHANNEL, "digitalWrapperOverheadChannel" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_AAL2,                          "aal2" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_RADIOMAC,                      "radioMAC" },
    { ISDN_MIB_ISDNENDPOINTIFTYPE_ATMRADIO,                      "atmRadio" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnEndpointTeiType[] = {
    { ISDN_MIB_ISDNENDPOINTTEITYPE_DYNAMIC, "dynamic" },
    { ISDN_MIB_ISDNENDPOINTTEITYPE_STATIC,  "static" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnEndpointStatus[] = {
    { ISDN_MIB_ISDNENDPOINTSTATUS_ACTIVE,        "active" },
    { ISDN_MIB_ISDNENDPOINTSTATUS_NOTINSERVICE,  "notInService" },
    { ISDN_MIB_ISDNENDPOINTSTATUS_NOTREADY,      "notReady" },
    { ISDN_MIB_ISDNENDPOINTSTATUS_CREATEANDGO,   "createAndGo" },
    { ISDN_MIB_ISDNENDPOINTSTATUS_CREATEANDWAIT, "createAndWait" },
    { ISDN_MIB_ISDNENDPOINTSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const isdn_mib_enums_isdnDirectoryStatus[] = {
    { ISDN_MIB_ISDNDIRECTORYSTATUS_ACTIVE,        "active" },
    { ISDN_MIB_ISDNDIRECTORYSTATUS_NOTINSERVICE,  "notInService" },
    { ISDN_MIB_ISDNDIRECTORYSTATUS_NOTREADY,      "notReady" },
    { ISDN_MIB_ISDNDIRECTORYSTATUS_CREATEANDGO,   "createAndGo" },
    { ISDN_MIB_ISDNDIRECTORYSTATUS_CREATEANDWAIT, "createAndWait" },
    { ISDN_MIB_ISDNDIRECTORYSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};


static guint32 isdnBearerChannelNumber_constraints[] = {1L, 30L, 0, 0};
static guint16 isdnBearerPeerAddress_constraints[] = {0, 255, 0, 0};
static guint16 isdnBearerPeerSubAddress_constraints[] = {0, 255, 0, 0};
static guint32 isdnSignalingGetIndex_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 isdnSignalingIfIndex_constraints[] = {1L, 2147483647L, 0, 0};
static guint16 isdnSignalingCallingAddress_constraints[] = {0, 255, 0, 0};
static guint16 isdnSignalingSubAddress_constraints[] = {0, 255, 0, 0};
static guint32 isdnSignalingBchannelCount_constraints[] = {1L, 65535L, 0, 0};
static guint32 isdnEndpointGetIndex_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 isdnEndpointIfIndex_constraints[] = {1L, 2147483647L, 0, 0};
static guint32 isdnEndpointTeiValue_constraints[] = {0L, 255L, 0, 0};
static guint16 isdnEndpointSpid_constraints[] = {0, 255, 0, 0};
static guint16 isdnDirectoryNumber_constraints[] = {0, 255, 0, 0};
static guint32 isdnDirectorySigIndex_constraints[] = {1L, 2147483647L, 0, 0};


static guint32 const isdnBasicRateEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 1, 1, 1};

static GSnmpAttribute isdnBasicRateEntry_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBASICRATEIFTYPE, "isdnBasicRateIfType",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBasicRateEntry_t, isdnBasicRateIfType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBASICRATELINETOPOLOGY, "isdnBasicRateLineTopology",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBasicRateEntry_t, isdnBasicRateLineTopology),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBASICRATEIFMODE, "isdnBasicRateIfMode",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBasicRateEntry_t, isdnBasicRateIfMode),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBASICRATESIGNALMODE, "isdnBasicRateSignalMode",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBasicRateEntry_t, isdnBasicRateSignalMode),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const isdnBearerEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 2, 1, 1};

static GSnmpAttribute isdnBearerEntry_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEARERCHANNELTYPE, "isdnBearerChannelType",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerChannelType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEAREROPERSTATUS, "isdnBearerOperStatus",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerOperStatus),
      0,
      0 },
    { 3, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEARERCHANNELNUMBER, "isdnBearerChannelNumber",
       isdnBearerChannelNumber_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerChannelNumber),
      0,
      0 },
    { 4, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNBEARERPEERADDRESS, "isdnBearerPeerAddress",
       isdnBearerPeerAddress_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerPeerAddress),
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, _isdnBearerPeerAddressLength),
      0 },
    { 5, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNBEARERPEERSUBADDRESS, "isdnBearerPeerSubAddress",
       isdnBearerPeerSubAddress_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerPeerSubAddress),
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, _isdnBearerPeerSubAddressLength),
      0 },
    { 6, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEARERCALLORIGIN, "isdnBearerCallOrigin",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerCallOrigin),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEARERINFOTYPE, "isdnBearerInfoType",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerInfoType),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNBEARERMULTIRATE, "isdnBearerMultirate",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerMultirate),
      0,
      0 },
    { 9, G_SNMP_TIMETICKS,
      ISDN_MIB_ISDNBEARERCALLSETUPTIME, "isdnBearerCallSetupTime",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerCallSetupTime),
      0,
      0 },
    { 10, G_SNMP_TIMETICKS,
      ISDN_MIB_ISDNBEARERCALLCONNECTTIME, "isdnBearerCallConnectTime",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerCallConnectTime),
      0,
      0 },
    { 11, G_SNMP_UNSIGNED32,
      ISDN_MIB_ISDNBEARERCHARGEDUNITS, "isdnBearerChargedUnits",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnBearerEntry_t, isdnBearerChargedUnits),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const isdnSignalingGroup_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3};

static GSnmpAttribute isdnSignalingGroup_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGGETINDEX, "isdnSignalingGetIndex",
       isdnSignalingGetIndex_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingGroup_t, isdnSignalingGetIndex),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const isdnSignalingEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 2, 1};

static GSnmpAttribute isdnSignalingEntry_attr[] = {
    { 2, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGIFINDEX, "isdnSignalingIfIndex",
       isdnSignalingIfIndex_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingIfIndex),
      0,
      0 },
    { 3, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGPROTOCOL, "isdnSignalingProtocol",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingProtocol),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNSIGNALINGCALLINGADDRESS, "isdnSignalingCallingAddress",
       isdnSignalingCallingAddress_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingCallingAddress),
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, _isdnSignalingCallingAddressLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNSIGNALINGSUBADDRESS, "isdnSignalingSubAddress",
       isdnSignalingSubAddress_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingSubAddress),
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, _isdnSignalingSubAddressLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGBCHANNELCOUNT, "isdnSignalingBchannelCount",
       isdnSignalingBchannelCount_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingBchannelCount),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGINFOTRAPENABLE, "isdnSignalingInfoTrapEnable",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingInfoTrapEnable),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNSIGNALINGSTATUS, "isdnSignalingStatus",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingEntry_t, isdnSignalingStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const isdnSignalingStatsEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 3, 1};

static GSnmpAttribute isdnSignalingStatsEntry_attr[] = {
    { 1, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNSIGSTATSINCALLS, "isdnSigStatsInCalls",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingStatsEntry_t, isdnSigStatsInCalls),
      0,
      0 },
    { 2, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNSIGSTATSINCONNECTED, "isdnSigStatsInConnected",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingStatsEntry_t, isdnSigStatsInConnected),
      0,
      0 },
    { 3, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNSIGSTATSOUTCALLS, "isdnSigStatsOutCalls",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingStatsEntry_t, isdnSigStatsOutCalls),
      0,
      0 },
    { 4, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNSIGSTATSOUTCONNECTED, "isdnSigStatsOutConnected",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingStatsEntry_t, isdnSigStatsOutConnected),
      0,
      0 },
    { 5, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNSIGSTATSCHARGEDUNITS, "isdnSigStatsChargedUnits",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnSignalingStatsEntry_t, isdnSigStatsChargedUnits),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const isdnLapdEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 4, 1};

static GSnmpAttribute isdnLapdEntry_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNLAPDPRIMARYCHANNEL, "isdnLapdPrimaryChannel",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnLapdEntry_t, isdnLapdPrimaryChannel),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNLAPDOPERSTATUS, "isdnLapdOperStatus",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnLapdEntry_t, isdnLapdOperStatus),
      0,
      0 },
    { 3, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNLAPDPEERSABME, "isdnLapdPeerSabme",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnLapdEntry_t, isdnLapdPeerSabme),
      0,
      0 },
    { 4, G_SNMP_COUNTER32,
      ISDN_MIB_ISDNLAPDRECVDFRMR, "isdnLapdRecvdFrmr",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnLapdEntry_t, isdnLapdRecvdFrmr),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const isdnEndpointGroup_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 4};

static GSnmpAttribute isdnEndpointGroup_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTGETINDEX, "isdnEndpointGetIndex",
       isdnEndpointGetIndex_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointGroup_t, isdnEndpointGetIndex),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const isdnEndpointEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 4, 2, 1};

static GSnmpAttribute isdnEndpointEntry_attr[] = {
    { 2, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTIFINDEX, "isdnEndpointIfIndex",
       isdnEndpointIfIndex_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointIfIndex),
      0,
      0 },
    { 3, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTIFTYPE, "isdnEndpointIfType",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointIfType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTTEITYPE, "isdnEndpointTeiType",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointTeiType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTTEIVALUE, "isdnEndpointTeiValue",
       isdnEndpointTeiValue_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointTeiValue),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNENDPOINTSPID, "isdnEndpointSpid",
       isdnEndpointSpid_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointSpid),
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, _isdnEndpointSpidLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNENDPOINTSTATUS, "isdnEndpointStatus",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnEndpointEntry_t, isdnEndpointStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const isdnDirectoryEntry_oid[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 5, 1, 1};

static GSnmpAttribute isdnDirectoryEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      ISDN_MIB_ISDNDIRECTORYNUMBER, "isdnDirectoryNumber",
       isdnDirectoryNumber_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnDirectoryEntry_t, isdnDirectoryNumber),
      G_STRUCT_OFFSET(isdn_mib_isdnDirectoryEntry_t, _isdnDirectoryNumberLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNDIRECTORYSIGINDEX, "isdnDirectorySigIndex",
       isdnDirectorySigIndex_constraints,
      G_STRUCT_OFFSET(isdn_mib_isdnDirectoryEntry_t, isdnDirectorySigIndex),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      ISDN_MIB_ISDNDIRECTORYSTATUS, "isdnDirectoryStatus",
       NULL,
      G_STRUCT_OFFSET(isdn_mib_isdnDirectoryEntry_t, isdnDirectoryStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


isdn_mib_isdnBasicRateEntry_t *
isdn_mib_new_isdnBasicRateEntry()
{
    isdn_mib_isdnBasicRateEntry_t *isdnBasicRateEntry;

    isdnBasicRateEntry = (isdn_mib_isdnBasicRateEntry_t *) g_malloc0(sizeof(isdn_mib_isdnBasicRateEntry_t) + sizeof(gpointer));
    return isdnBasicRateEntry;
}

static int
unpack_isdnBasicRateEntry(GSnmpVarBind *vb, isdn_mib_isdnBasicRateEntry_t *isdnBasicRateEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnBasicRateEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnBasicRateEntry(guint32 *base, gint32 ifIndex)
{
    guint8 idx = 13;

    base[idx++] = ifIndex;
    return idx;
}

static isdn_mib_isdnBasicRateEntry_t *
assign_isdnBasicRateEntry(GSList *vbl)
{
    isdn_mib_isdnBasicRateEntry_t *isdnBasicRateEntry;
    char *p;

    isdnBasicRateEntry = isdn_mib_new_isdnBasicRateEntry();
    if (! isdnBasicRateEntry) {
        return NULL;
    }

    p = (char *) isdnBasicRateEntry + sizeof(isdn_mib_isdnBasicRateEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnBasicRateEntry((GSnmpVarBind *) vbl->data, isdnBasicRateEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnBasicRateEntry");
        g_free(isdnBasicRateEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnBasicRateEntry_oid, sizeof(isdnBasicRateEntry_oid)/sizeof(guint32),
                      isdnBasicRateEntry_attr, isdnBasicRateEntry);

    return isdnBasicRateEntry;
}

void
isdn_mib_get_isdnBasicRateTable(GSnmpSession *s, isdn_mib_isdnBasicRateEntry_t ***isdnBasicRateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 1, 1, 1, 0};

    *isdnBasicRateEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnBasicRateEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnBasicRateEntry = (isdn_mib_isdnBasicRateEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnBasicRateEntry_t *));
        if (! *isdnBasicRateEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnBasicRateEntry)[i] = assign_isdnBasicRateEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnBasicRateEntry(GSnmpSession *s, isdn_mib_isdnBasicRateEntry_t **isdnBasicRateEntry, gint32 ifIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnBasicRateEntry_oid, sizeof(isdnBasicRateEntry_oid));
    len = pack_isdnBasicRateEntry(base, ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnBasicRateEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnBasicRateEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnBasicRateEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnBasicRateEntry = assign_isdnBasicRateEntry(out);
    }
}

void
isdn_mib_set_isdnBasicRateEntry(GSnmpSession *s, isdn_mib_isdnBasicRateEntry_t *isdnBasicRateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnBasicRateEntry_oid, sizeof(isdnBasicRateEntry_oid));
    len = pack_isdnBasicRateEntry(base, isdnBasicRateEntry->ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnBasicRateEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnBasicRateEntry_attr, mask, isdnBasicRateEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnBasicRateEntry(isdn_mib_isdnBasicRateEntry_t *isdnBasicRateEntry)
{
    GSList *vbl;
    char *p;

    if (isdnBasicRateEntry) {
        p = (char *) isdnBasicRateEntry + sizeof(isdn_mib_isdnBasicRateEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnBasicRateEntry);
    }
}

void
isdn_mib_free_isdnBasicRateTable(isdn_mib_isdnBasicRateEntry_t **isdnBasicRateEntry)
{
    int i;

    if (isdnBasicRateEntry) {
        for (i = 0; isdnBasicRateEntry[i]; i++) {
            isdn_mib_free_isdnBasicRateEntry(isdnBasicRateEntry[i]);
        }
        g_free(isdnBasicRateEntry);
    }
}

isdn_mib_isdnBearerEntry_t *
isdn_mib_new_isdnBearerEntry()
{
    isdn_mib_isdnBearerEntry_t *isdnBearerEntry;

    isdnBearerEntry = (isdn_mib_isdnBearerEntry_t *) g_malloc0(sizeof(isdn_mib_isdnBearerEntry_t) + sizeof(gpointer));
    return isdnBearerEntry;
}

static int
unpack_isdnBearerEntry(GSnmpVarBind *vb, isdn_mib_isdnBearerEntry_t *isdnBearerEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnBearerEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnBearerEntry(guint32 *base, gint32 ifIndex)
{
    guint8 idx = 13;

    base[idx++] = ifIndex;
    return idx;
}

static isdn_mib_isdnBearerEntry_t *
assign_isdnBearerEntry(GSList *vbl)
{
    isdn_mib_isdnBearerEntry_t *isdnBearerEntry;
    char *p;

    isdnBearerEntry = isdn_mib_new_isdnBearerEntry();
    if (! isdnBearerEntry) {
        return NULL;
    }

    p = (char *) isdnBearerEntry + sizeof(isdn_mib_isdnBearerEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnBearerEntry((GSnmpVarBind *) vbl->data, isdnBearerEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnBearerEntry");
        g_free(isdnBearerEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnBearerEntry_oid, sizeof(isdnBearerEntry_oid)/sizeof(guint32),
                      isdnBearerEntry_attr, isdnBearerEntry);

    return isdnBearerEntry;
}

void
isdn_mib_get_isdnBearerTable(GSnmpSession *s, isdn_mib_isdnBearerEntry_t ***isdnBearerEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 2, 1, 1, 0};

    *isdnBearerEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnBearerEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnBearerEntry = (isdn_mib_isdnBearerEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnBearerEntry_t *));
        if (! *isdnBearerEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnBearerEntry)[i] = assign_isdnBearerEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnBearerEntry(GSnmpSession *s, isdn_mib_isdnBearerEntry_t **isdnBearerEntry, gint32 ifIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnBearerEntry_oid, sizeof(isdnBearerEntry_oid));
    len = pack_isdnBearerEntry(base, ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnBearerEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnBearerEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnBearerEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnBearerEntry = assign_isdnBearerEntry(out);
    }
}

void
isdn_mib_set_isdnBearerEntry(GSnmpSession *s, isdn_mib_isdnBearerEntry_t *isdnBearerEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnBearerEntry_oid, sizeof(isdnBearerEntry_oid));
    len = pack_isdnBearerEntry(base, isdnBearerEntry->ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnBearerEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnBearerEntry_attr, mask, isdnBearerEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnBearerEntry(isdn_mib_isdnBearerEntry_t *isdnBearerEntry)
{
    GSList *vbl;
    char *p;

    if (isdnBearerEntry) {
        p = (char *) isdnBearerEntry + sizeof(isdn_mib_isdnBearerEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnBearerEntry);
    }
}

void
isdn_mib_free_isdnBearerTable(isdn_mib_isdnBearerEntry_t **isdnBearerEntry)
{
    int i;

    if (isdnBearerEntry) {
        for (i = 0; isdnBearerEntry[i]; i++) {
            isdn_mib_free_isdnBearerEntry(isdnBearerEntry[i]);
        }
        g_free(isdnBearerEntry);
    }
}

isdn_mib_isdnSignalingGroup_t *
isdn_mib_new_isdnSignalingGroup()
{
    isdn_mib_isdnSignalingGroup_t *isdnSignalingGroup;

    isdnSignalingGroup = (isdn_mib_isdnSignalingGroup_t *) g_malloc0(sizeof(isdn_mib_isdnSignalingGroup_t) + sizeof(gpointer));
    return isdnSignalingGroup;
}

static isdn_mib_isdnSignalingGroup_t *
assign_isdnSignalingGroup(GSList *vbl)
{
    isdn_mib_isdnSignalingGroup_t *isdnSignalingGroup;
    char *p;

    isdnSignalingGroup = isdn_mib_new_isdnSignalingGroup();
    if (! isdnSignalingGroup) {
        return NULL;
    }

    p = (char *) isdnSignalingGroup + sizeof(isdn_mib_isdnSignalingGroup_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, isdnSignalingGroup_oid, sizeof(isdnSignalingGroup_oid)/sizeof(guint32),
                      isdnSignalingGroup_attr, isdnSignalingGroup);

    return isdnSignalingGroup;
}

void
isdn_mib_get_isdnSignalingGroup(GSnmpSession *s, isdn_mib_isdnSignalingGroup_t **isdnSignalingGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 0};

    *isdnSignalingGroup = NULL;

    gsnmp_attr_get(s, &in, base, 11, 10, isdnSignalingGroup_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnSignalingGroup = assign_isdnSignalingGroup(out);
    }
}

void
isdn_mib_set_isdnSignalingGroup(GSnmpSession *s, isdn_mib_isdnSignalingGroup_t *isdnSignalingGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 0, 0};

    gsnmp_attr_set(s, &in, base, 12, 10, isdnSignalingGroup_attr, mask, isdnSignalingGroup);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnSignalingGroup(isdn_mib_isdnSignalingGroup_t *isdnSignalingGroup)
{
    GSList *vbl;
    char *p;

    if (isdnSignalingGroup) {
        p = (char *) isdnSignalingGroup + sizeof(isdn_mib_isdnSignalingGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnSignalingGroup);
    }
}

isdn_mib_isdnSignalingEntry_t *
isdn_mib_new_isdnSignalingEntry()
{
    isdn_mib_isdnSignalingEntry_t *isdnSignalingEntry;

    isdnSignalingEntry = (isdn_mib_isdnSignalingEntry_t *) g_malloc0(sizeof(isdn_mib_isdnSignalingEntry_t) + sizeof(gpointer));
    return isdnSignalingEntry;
}

static int
unpack_isdnSignalingEntry(GSnmpVarBind *vb, isdn_mib_isdnSignalingEntry_t *isdnSignalingEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnSignalingEntry->isdnSignalingIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnSignalingEntry(guint32 *base, gint32 isdnSignalingIndex)
{
    guint8 idx = 13;

    base[idx++] = isdnSignalingIndex;
    return idx;
}

static isdn_mib_isdnSignalingEntry_t *
assign_isdnSignalingEntry(GSList *vbl)
{
    isdn_mib_isdnSignalingEntry_t *isdnSignalingEntry;
    char *p;

    isdnSignalingEntry = isdn_mib_new_isdnSignalingEntry();
    if (! isdnSignalingEntry) {
        return NULL;
    }

    p = (char *) isdnSignalingEntry + sizeof(isdn_mib_isdnSignalingEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnSignalingEntry((GSnmpVarBind *) vbl->data, isdnSignalingEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnSignalingEntry");
        g_free(isdnSignalingEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnSignalingEntry_oid, sizeof(isdnSignalingEntry_oid)/sizeof(guint32),
                      isdnSignalingEntry_attr, isdnSignalingEntry);

    return isdnSignalingEntry;
}

void
isdn_mib_get_isdnSignalingTable(GSnmpSession *s, isdn_mib_isdnSignalingEntry_t ***isdnSignalingEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 2, 1, 0};

    *isdnSignalingEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnSignalingEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnSignalingEntry = (isdn_mib_isdnSignalingEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnSignalingEntry_t *));
        if (! *isdnSignalingEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnSignalingEntry)[i] = assign_isdnSignalingEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnSignalingEntry(GSnmpSession *s, isdn_mib_isdnSignalingEntry_t **isdnSignalingEntry, gint32 isdnSignalingIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnSignalingEntry_oid, sizeof(isdnSignalingEntry_oid));
    len = pack_isdnSignalingEntry(base, isdnSignalingIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnSignalingEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnSignalingEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnSignalingEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnSignalingEntry = assign_isdnSignalingEntry(out);
    }
}

void
isdn_mib_set_isdnSignalingEntry(GSnmpSession *s, isdn_mib_isdnSignalingEntry_t *isdnSignalingEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnSignalingEntry_oid, sizeof(isdnSignalingEntry_oid));
    len = pack_isdnSignalingEntry(base, isdnSignalingEntry->isdnSignalingIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnSignalingEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnSignalingEntry_attr, mask, isdnSignalingEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnSignalingEntry(isdn_mib_isdnSignalingEntry_t *isdnSignalingEntry)
{
    GSList *vbl;
    char *p;

    if (isdnSignalingEntry) {
        p = (char *) isdnSignalingEntry + sizeof(isdn_mib_isdnSignalingEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnSignalingEntry);
    }
}

void
isdn_mib_free_isdnSignalingTable(isdn_mib_isdnSignalingEntry_t **isdnSignalingEntry)
{
    int i;

    if (isdnSignalingEntry) {
        for (i = 0; isdnSignalingEntry[i]; i++) {
            isdn_mib_free_isdnSignalingEntry(isdnSignalingEntry[i]);
        }
        g_free(isdnSignalingEntry);
    }
}

isdn_mib_isdnSignalingStatsEntry_t *
isdn_mib_new_isdnSignalingStatsEntry()
{
    isdn_mib_isdnSignalingStatsEntry_t *isdnSignalingStatsEntry;

    isdnSignalingStatsEntry = (isdn_mib_isdnSignalingStatsEntry_t *) g_malloc0(sizeof(isdn_mib_isdnSignalingStatsEntry_t) + sizeof(gpointer));
    return isdnSignalingStatsEntry;
}

static int
unpack_isdnSignalingStatsEntry(GSnmpVarBind *vb, isdn_mib_isdnSignalingStatsEntry_t *isdnSignalingStatsEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnSignalingStatsEntry->isdnSignalingIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnSignalingStatsEntry(guint32 *base, gint32 isdnSignalingIndex)
{
    guint8 idx = 13;

    base[idx++] = isdnSignalingIndex;
    return idx;
}

static isdn_mib_isdnSignalingStatsEntry_t *
assign_isdnSignalingStatsEntry(GSList *vbl)
{
    isdn_mib_isdnSignalingStatsEntry_t *isdnSignalingStatsEntry;
    char *p;

    isdnSignalingStatsEntry = isdn_mib_new_isdnSignalingStatsEntry();
    if (! isdnSignalingStatsEntry) {
        return NULL;
    }

    p = (char *) isdnSignalingStatsEntry + sizeof(isdn_mib_isdnSignalingStatsEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnSignalingStatsEntry((GSnmpVarBind *) vbl->data, isdnSignalingStatsEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnSignalingStatsEntry");
        g_free(isdnSignalingStatsEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnSignalingStatsEntry_oid, sizeof(isdnSignalingStatsEntry_oid)/sizeof(guint32),
                      isdnSignalingStatsEntry_attr, isdnSignalingStatsEntry);

    return isdnSignalingStatsEntry;
}

void
isdn_mib_get_isdnSignalingStatsTable(GSnmpSession *s, isdn_mib_isdnSignalingStatsEntry_t ***isdnSignalingStatsEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 3, 1, 0};

    *isdnSignalingStatsEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnSignalingStatsEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnSignalingStatsEntry = (isdn_mib_isdnSignalingStatsEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnSignalingStatsEntry_t *));
        if (! *isdnSignalingStatsEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnSignalingStatsEntry)[i] = assign_isdnSignalingStatsEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnSignalingStatsEntry(GSnmpSession *s, isdn_mib_isdnSignalingStatsEntry_t **isdnSignalingStatsEntry, gint32 isdnSignalingIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnSignalingStatsEntry_oid, sizeof(isdnSignalingStatsEntry_oid));
    len = pack_isdnSignalingStatsEntry(base, isdnSignalingIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnSignalingStatsEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnSignalingStatsEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnSignalingStatsEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnSignalingStatsEntry = assign_isdnSignalingStatsEntry(out);
    }
}

void
isdn_mib_free_isdnSignalingStatsEntry(isdn_mib_isdnSignalingStatsEntry_t *isdnSignalingStatsEntry)
{
    GSList *vbl;
    char *p;

    if (isdnSignalingStatsEntry) {
        p = (char *) isdnSignalingStatsEntry + sizeof(isdn_mib_isdnSignalingStatsEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnSignalingStatsEntry);
    }
}

void
isdn_mib_free_isdnSignalingStatsTable(isdn_mib_isdnSignalingStatsEntry_t **isdnSignalingStatsEntry)
{
    int i;

    if (isdnSignalingStatsEntry) {
        for (i = 0; isdnSignalingStatsEntry[i]; i++) {
            isdn_mib_free_isdnSignalingStatsEntry(isdnSignalingStatsEntry[i]);
        }
        g_free(isdnSignalingStatsEntry);
    }
}

isdn_mib_isdnLapdEntry_t *
isdn_mib_new_isdnLapdEntry()
{
    isdn_mib_isdnLapdEntry_t *isdnLapdEntry;

    isdnLapdEntry = (isdn_mib_isdnLapdEntry_t *) g_malloc0(sizeof(isdn_mib_isdnLapdEntry_t) + sizeof(gpointer));
    return isdnLapdEntry;
}

static int
unpack_isdnLapdEntry(GSnmpVarBind *vb, isdn_mib_isdnLapdEntry_t *isdnLapdEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnLapdEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnLapdEntry(guint32 *base, gint32 ifIndex)
{
    guint8 idx = 13;

    base[idx++] = ifIndex;
    return idx;
}

static isdn_mib_isdnLapdEntry_t *
assign_isdnLapdEntry(GSList *vbl)
{
    isdn_mib_isdnLapdEntry_t *isdnLapdEntry;
    char *p;

    isdnLapdEntry = isdn_mib_new_isdnLapdEntry();
    if (! isdnLapdEntry) {
        return NULL;
    }

    p = (char *) isdnLapdEntry + sizeof(isdn_mib_isdnLapdEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnLapdEntry((GSnmpVarBind *) vbl->data, isdnLapdEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnLapdEntry");
        g_free(isdnLapdEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnLapdEntry_oid, sizeof(isdnLapdEntry_oid)/sizeof(guint32),
                      isdnLapdEntry_attr, isdnLapdEntry);

    return isdnLapdEntry;
}

void
isdn_mib_get_isdnLapdTable(GSnmpSession *s, isdn_mib_isdnLapdEntry_t ***isdnLapdEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 3, 4, 1, 0};

    *isdnLapdEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnLapdEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnLapdEntry = (isdn_mib_isdnLapdEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnLapdEntry_t *));
        if (! *isdnLapdEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnLapdEntry)[i] = assign_isdnLapdEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnLapdEntry(GSnmpSession *s, isdn_mib_isdnLapdEntry_t **isdnLapdEntry, gint32 ifIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnLapdEntry_oid, sizeof(isdnLapdEntry_oid));
    len = pack_isdnLapdEntry(base, ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnLapdEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnLapdEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnLapdEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnLapdEntry = assign_isdnLapdEntry(out);
    }
}

void
isdn_mib_set_isdnLapdEntry(GSnmpSession *s, isdn_mib_isdnLapdEntry_t *isdnLapdEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnLapdEntry_oid, sizeof(isdnLapdEntry_oid));
    len = pack_isdnLapdEntry(base, isdnLapdEntry->ifIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnLapdEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnLapdEntry_attr, mask, isdnLapdEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnLapdEntry(isdn_mib_isdnLapdEntry_t *isdnLapdEntry)
{
    GSList *vbl;
    char *p;

    if (isdnLapdEntry) {
        p = (char *) isdnLapdEntry + sizeof(isdn_mib_isdnLapdEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnLapdEntry);
    }
}

void
isdn_mib_free_isdnLapdTable(isdn_mib_isdnLapdEntry_t **isdnLapdEntry)
{
    int i;

    if (isdnLapdEntry) {
        for (i = 0; isdnLapdEntry[i]; i++) {
            isdn_mib_free_isdnLapdEntry(isdnLapdEntry[i]);
        }
        g_free(isdnLapdEntry);
    }
}

isdn_mib_isdnEndpointGroup_t *
isdn_mib_new_isdnEndpointGroup()
{
    isdn_mib_isdnEndpointGroup_t *isdnEndpointGroup;

    isdnEndpointGroup = (isdn_mib_isdnEndpointGroup_t *) g_malloc0(sizeof(isdn_mib_isdnEndpointGroup_t) + sizeof(gpointer));
    return isdnEndpointGroup;
}

static isdn_mib_isdnEndpointGroup_t *
assign_isdnEndpointGroup(GSList *vbl)
{
    isdn_mib_isdnEndpointGroup_t *isdnEndpointGroup;
    char *p;

    isdnEndpointGroup = isdn_mib_new_isdnEndpointGroup();
    if (! isdnEndpointGroup) {
        return NULL;
    }

    p = (char *) isdnEndpointGroup + sizeof(isdn_mib_isdnEndpointGroup_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, isdnEndpointGroup_oid, sizeof(isdnEndpointGroup_oid)/sizeof(guint32),
                      isdnEndpointGroup_attr, isdnEndpointGroup);

    return isdnEndpointGroup;
}

void
isdn_mib_get_isdnEndpointGroup(GSnmpSession *s, isdn_mib_isdnEndpointGroup_t **isdnEndpointGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 4, 0};

    *isdnEndpointGroup = NULL;

    gsnmp_attr_get(s, &in, base, 11, 10, isdnEndpointGroup_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnEndpointGroup = assign_isdnEndpointGroup(out);
    }
}

void
isdn_mib_set_isdnEndpointGroup(GSnmpSession *s, isdn_mib_isdnEndpointGroup_t *isdnEndpointGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 4, 0, 0};

    gsnmp_attr_set(s, &in, base, 12, 10, isdnEndpointGroup_attr, mask, isdnEndpointGroup);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnEndpointGroup(isdn_mib_isdnEndpointGroup_t *isdnEndpointGroup)
{
    GSList *vbl;
    char *p;

    if (isdnEndpointGroup) {
        p = (char *) isdnEndpointGroup + sizeof(isdn_mib_isdnEndpointGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnEndpointGroup);
    }
}

isdn_mib_isdnEndpointEntry_t *
isdn_mib_new_isdnEndpointEntry()
{
    isdn_mib_isdnEndpointEntry_t *isdnEndpointEntry;

    isdnEndpointEntry = (isdn_mib_isdnEndpointEntry_t *) g_malloc0(sizeof(isdn_mib_isdnEndpointEntry_t) + sizeof(gpointer));
    return isdnEndpointEntry;
}

static int
unpack_isdnEndpointEntry(GSnmpVarBind *vb, isdn_mib_isdnEndpointEntry_t *isdnEndpointEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnEndpointEntry->isdnEndpointIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnEndpointEntry(guint32 *base, gint32 isdnEndpointIndex)
{
    guint8 idx = 13;

    base[idx++] = isdnEndpointIndex;
    return idx;
}

static isdn_mib_isdnEndpointEntry_t *
assign_isdnEndpointEntry(GSList *vbl)
{
    isdn_mib_isdnEndpointEntry_t *isdnEndpointEntry;
    char *p;

    isdnEndpointEntry = isdn_mib_new_isdnEndpointEntry();
    if (! isdnEndpointEntry) {
        return NULL;
    }

    p = (char *) isdnEndpointEntry + sizeof(isdn_mib_isdnEndpointEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnEndpointEntry((GSnmpVarBind *) vbl->data, isdnEndpointEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnEndpointEntry");
        g_free(isdnEndpointEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnEndpointEntry_oid, sizeof(isdnEndpointEntry_oid)/sizeof(guint32),
                      isdnEndpointEntry_attr, isdnEndpointEntry);

    return isdnEndpointEntry;
}

void
isdn_mib_get_isdnEndpointTable(GSnmpSession *s, isdn_mib_isdnEndpointEntry_t ***isdnEndpointEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 4, 2, 1, 0};

    *isdnEndpointEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnEndpointEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnEndpointEntry = (isdn_mib_isdnEndpointEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnEndpointEntry_t *));
        if (! *isdnEndpointEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnEndpointEntry)[i] = assign_isdnEndpointEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnEndpointEntry(GSnmpSession *s, isdn_mib_isdnEndpointEntry_t **isdnEndpointEntry, gint32 isdnEndpointIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnEndpointEntry_oid, sizeof(isdnEndpointEntry_oid));
    len = pack_isdnEndpointEntry(base, isdnEndpointIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnEndpointEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnEndpointEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnEndpointEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnEndpointEntry = assign_isdnEndpointEntry(out);
    }
}

void
isdn_mib_set_isdnEndpointEntry(GSnmpSession *s, isdn_mib_isdnEndpointEntry_t *isdnEndpointEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnEndpointEntry_oid, sizeof(isdnEndpointEntry_oid));
    len = pack_isdnEndpointEntry(base, isdnEndpointEntry->isdnEndpointIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnEndpointEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnEndpointEntry_attr, mask, isdnEndpointEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnEndpointEntry(isdn_mib_isdnEndpointEntry_t *isdnEndpointEntry)
{
    GSList *vbl;
    char *p;

    if (isdnEndpointEntry) {
        p = (char *) isdnEndpointEntry + sizeof(isdn_mib_isdnEndpointEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnEndpointEntry);
    }
}

void
isdn_mib_free_isdnEndpointTable(isdn_mib_isdnEndpointEntry_t **isdnEndpointEntry)
{
    int i;

    if (isdnEndpointEntry) {
        for (i = 0; isdnEndpointEntry[i]; i++) {
            isdn_mib_free_isdnEndpointEntry(isdnEndpointEntry[i]);
        }
        g_free(isdnEndpointEntry);
    }
}

isdn_mib_isdnDirectoryEntry_t *
isdn_mib_new_isdnDirectoryEntry()
{
    isdn_mib_isdnDirectoryEntry_t *isdnDirectoryEntry;

    isdnDirectoryEntry = (isdn_mib_isdnDirectoryEntry_t *) g_malloc0(sizeof(isdn_mib_isdnDirectoryEntry_t) + sizeof(gpointer));
    return isdnDirectoryEntry;
}

static int
unpack_isdnDirectoryEntry(GSnmpVarBind *vb, isdn_mib_isdnDirectoryEntry_t *isdnDirectoryEntry)
{
    guint8 idx = 13;

    if (vb->id_len < idx) return -1;
    isdnDirectoryEntry->isdnDirectoryIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_isdnDirectoryEntry(guint32 *base, gint32 isdnDirectoryIndex)
{
    guint8 idx = 13;

    base[idx++] = isdnDirectoryIndex;
    return idx;
}

static isdn_mib_isdnDirectoryEntry_t *
assign_isdnDirectoryEntry(GSList *vbl)
{
    isdn_mib_isdnDirectoryEntry_t *isdnDirectoryEntry;
    char *p;

    isdnDirectoryEntry = isdn_mib_new_isdnDirectoryEntry();
    if (! isdnDirectoryEntry) {
        return NULL;
    }

    p = (char *) isdnDirectoryEntry + sizeof(isdn_mib_isdnDirectoryEntry_t);
    * (GSList **) p = vbl;

    if (unpack_isdnDirectoryEntry((GSnmpVarBind *) vbl->data, isdnDirectoryEntry) < 0) {
        g_warning("%s: invalid instance identifier", "isdnDirectoryEntry");
        g_free(isdnDirectoryEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, isdnDirectoryEntry_oid, sizeof(isdnDirectoryEntry_oid)/sizeof(guint32),
                      isdnDirectoryEntry_attr, isdnDirectoryEntry);

    return isdnDirectoryEntry;
}

void
isdn_mib_get_isdnDirectoryTable(GSnmpSession *s, isdn_mib_isdnDirectoryEntry_t ***isdnDirectoryEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 10, 20, 1, 5, 1, 1, 0};

    *isdnDirectoryEntry = NULL;

    gsnmp_attr_get(s, &in, base, 13, 12, isdnDirectoryEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *isdnDirectoryEntry = (isdn_mib_isdnDirectoryEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(isdn_mib_isdnDirectoryEntry_t *));
        if (! *isdnDirectoryEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*isdnDirectoryEntry)[i] = assign_isdnDirectoryEntry(row->data);
        }
    }
}

void
isdn_mib_get_isdnDirectoryEntry(GSnmpSession *s, isdn_mib_isdnDirectoryEntry_t **isdnDirectoryEntry, gint32 isdnDirectoryIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnDirectoryEntry_oid, sizeof(isdnDirectoryEntry_oid));
    len = pack_isdnDirectoryEntry(base, isdnDirectoryIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnDirectoryEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *isdnDirectoryEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 12, isdnDirectoryEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *isdnDirectoryEntry = assign_isdnDirectoryEntry(out);
    }
}

void
isdn_mib_set_isdnDirectoryEntry(GSnmpSession *s, isdn_mib_isdnDirectoryEntry_t *isdnDirectoryEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, isdnDirectoryEntry_oid, sizeof(isdnDirectoryEntry_oid));
    len = pack_isdnDirectoryEntry(base, isdnDirectoryEntry->isdnDirectoryIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "isdnDirectoryEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 12, isdnDirectoryEntry_attr, mask, isdnDirectoryEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
isdn_mib_free_isdnDirectoryEntry(isdn_mib_isdnDirectoryEntry_t *isdnDirectoryEntry)
{
    GSList *vbl;
    char *p;

    if (isdnDirectoryEntry) {
        p = (char *) isdnDirectoryEntry + sizeof(isdn_mib_isdnDirectoryEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(isdnDirectoryEntry);
    }
}

void
isdn_mib_free_isdnDirectoryTable(isdn_mib_isdnDirectoryEntry_t **isdnDirectoryEntry)
{
    int i;

    if (isdnDirectoryEntry) {
        for (i = 0; isdnDirectoryEntry[i]; i++) {
            isdn_mib_free_isdnDirectoryEntry(isdnDirectoryEntry[i]);
        }
        g_free(isdnDirectoryEntry);
    }
}


