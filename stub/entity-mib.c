/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from ENTITY-MIB revision 1999-12-07 00:00.
 *
 * $Id$
 */

#include "entity-mib.h"

static guint32 const entPhysicalIndex[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 1};
static guint32 const entPhysicalDescr[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 2};
static guint32 const entPhysicalVendorType[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 3};
static guint32 const entPhysicalContainedIn[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 4};
static guint32 const entPhysicalClass[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 5};
static guint32 const entPhysicalParentRelPos[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 6};
static guint32 const entPhysicalName[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 7};
static guint32 const entPhysicalHardwareRev[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 8};
static guint32 const entPhysicalFirmwareRev[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 9};
static guint32 const entPhysicalSoftwareRev[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 10};
static guint32 const entPhysicalSerialNum[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 11};
static guint32 const entPhysicalMfgName[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 12};
static guint32 const entPhysicalModelName[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 13};
static guint32 const entPhysicalAlias[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 14};
static guint32 const entPhysicalAssetID[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 15};
static guint32 const entPhysicalIsFRU[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 16};
static guint32 const entLogicalIndex[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 1};
static guint32 const entLogicalDescr[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 2};
static guint32 const entLogicalType[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 3};
static guint32 const entLogicalCommunity[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 4};
static guint32 const entLogicalTAddress[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 5};
static guint32 const entLogicalTDomain[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 6};
static guint32 const entLogicalContextEngineID[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 7};
static guint32 const entLogicalContextName[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 8};
static guint32 const entLPPhysicalIndex[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 1, 1, 1};
static guint32 const entAliasLogicalIndexOrZero[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 2, 1, 1};
static guint32 const entAliasMappingIdentifier[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 2, 1, 2};
static guint32 const entPhysicalChildIndex[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 3, 1, 1};
static guint32 const entLastChangeTime[] = {1, 3, 6, 1, 2, 1, 47, 1, 4, 1};

static gsize const _entPhysicalIndexLength = sizeof(entPhysicalIndex)/sizeof(guint32);
static gsize const _entPhysicalDescrLength = sizeof(entPhysicalDescr)/sizeof(guint32);
static gsize const _entPhysicalVendorTypeLength = sizeof(entPhysicalVendorType)/sizeof(guint32);
static gsize const _entPhysicalContainedInLength = sizeof(entPhysicalContainedIn)/sizeof(guint32);
static gsize const _entPhysicalClassLength = sizeof(entPhysicalClass)/sizeof(guint32);
static gsize const _entPhysicalParentRelPosLength = sizeof(entPhysicalParentRelPos)/sizeof(guint32);
static gsize const _entPhysicalNameLength = sizeof(entPhysicalName)/sizeof(guint32);
static gsize const _entPhysicalHardwareRevLength = sizeof(entPhysicalHardwareRev)/sizeof(guint32);
static gsize const _entPhysicalFirmwareRevLength = sizeof(entPhysicalFirmwareRev)/sizeof(guint32);
static gsize const _entPhysicalSoftwareRevLength = sizeof(entPhysicalSoftwareRev)/sizeof(guint32);
static gsize const _entPhysicalSerialNumLength = sizeof(entPhysicalSerialNum)/sizeof(guint32);
static gsize const _entPhysicalMfgNameLength = sizeof(entPhysicalMfgName)/sizeof(guint32);
static gsize const _entPhysicalModelNameLength = sizeof(entPhysicalModelName)/sizeof(guint32);
static gsize const _entPhysicalAliasLength = sizeof(entPhysicalAlias)/sizeof(guint32);
static gsize const _entPhysicalAssetIDLength = sizeof(entPhysicalAssetID)/sizeof(guint32);
static gsize const _entPhysicalIsFRULength = sizeof(entPhysicalIsFRU)/sizeof(guint32);
static gsize const _entLogicalIndexLength = sizeof(entLogicalIndex)/sizeof(guint32);
static gsize const _entLogicalDescrLength = sizeof(entLogicalDescr)/sizeof(guint32);
static gsize const _entLogicalTypeLength = sizeof(entLogicalType)/sizeof(guint32);
static gsize const _entLogicalCommunityLength = sizeof(entLogicalCommunity)/sizeof(guint32);
static gsize const _entLogicalTAddressLength = sizeof(entLogicalTAddress)/sizeof(guint32);
static gsize const _entLogicalTDomainLength = sizeof(entLogicalTDomain)/sizeof(guint32);
static gsize const _entLogicalContextEngineIDLength = sizeof(entLogicalContextEngineID)/sizeof(guint32);
static gsize const _entLogicalContextNameLength = sizeof(entLogicalContextName)/sizeof(guint32);
static gsize const _entLPPhysicalIndexLength = sizeof(entLPPhysicalIndex)/sizeof(guint32);
static gsize const _entAliasLogicalIndexOrZeroLength = sizeof(entAliasLogicalIndexOrZero)/sizeof(guint32);
static gsize const _entAliasMappingIdentifierLength = sizeof(entAliasMappingIdentifier)/sizeof(guint32);
static gsize const _entPhysicalChildIndexLength = sizeof(entPhysicalChildIndex)/sizeof(guint32);
static gsize const _entLastChangeTimeLength = sizeof(entLastChangeTime)/sizeof(guint32);

stls_table_t entity_mib_enums_entPhysicalClass[] = {
    { 1, "other" },
    { 2, "unknown" },
    { 3, "chassis" },
    { 4, "backplane" },
    { 5, "container" },
    { 6, "powerSupply" },
    { 7, "fan" },
    { 8, "sensor" },
    { 9, "module" },
    { 10, "port" },
    { 11, "stack" },
    { 0, NULL }
};

stls_table_t entity_mib_enums_entPhysicalIsFRU[] = {
    { 1, "true" },
    { 2, "false" },
    { 0, NULL }
};


static entPhysicalEntry_t *
assign_entPhysicalEntry(GSList *vbl)
{
    GSList *elem;
    entPhysicalEntry_t *entPhysicalEntry;
    char *p;

    entPhysicalEntry = (entPhysicalEntry_t *) g_malloc0(sizeof(entPhysicalEntry_t) + sizeof(GSList *));
    if (! entPhysicalEntry) {
        return NULL;
    }

    p = (char *) entPhysicalEntry + sizeof(entPhysicalEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entPhysicalDescrLength
            && memcmp(vb->id, entPhysicalDescr, sizeof(entPhysicalDescr)) == 0) {
            entPhysicalEntry->_entPhysicalDescrLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalDescr = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalVendorTypeLength
            && memcmp(vb->id, entPhysicalVendorType, sizeof(entPhysicalVendorType)) == 0) {
            entPhysicalEntry->_entPhysicalVendorTypeLength = vb->syntax_len / sizeof(guint32);
            entPhysicalEntry->entPhysicalVendorType = vb->syntax.ui32;
        }
        if (vb->id_len > _entPhysicalContainedInLength
            && memcmp(vb->id, entPhysicalContainedIn, sizeof(entPhysicalContainedIn)) == 0) {
            entPhysicalEntry->entPhysicalContainedIn = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _entPhysicalClassLength
            && memcmp(vb->id, entPhysicalClass, sizeof(entPhysicalClass)) == 0) {
            entPhysicalEntry->entPhysicalClass = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _entPhysicalParentRelPosLength
            && memcmp(vb->id, entPhysicalParentRelPos, sizeof(entPhysicalParentRelPos)) == 0) {
            entPhysicalEntry->entPhysicalParentRelPos = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _entPhysicalNameLength
            && memcmp(vb->id, entPhysicalName, sizeof(entPhysicalName)) == 0) {
            entPhysicalEntry->_entPhysicalNameLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalName = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalHardwareRevLength
            && memcmp(vb->id, entPhysicalHardwareRev, sizeof(entPhysicalHardwareRev)) == 0) {
            entPhysicalEntry->_entPhysicalHardwareRevLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalHardwareRev = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalFirmwareRevLength
            && memcmp(vb->id, entPhysicalFirmwareRev, sizeof(entPhysicalFirmwareRev)) == 0) {
            entPhysicalEntry->_entPhysicalFirmwareRevLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalFirmwareRev = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalSoftwareRevLength
            && memcmp(vb->id, entPhysicalSoftwareRev, sizeof(entPhysicalSoftwareRev)) == 0) {
            entPhysicalEntry->_entPhysicalSoftwareRevLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalSoftwareRev = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalSerialNumLength
            && memcmp(vb->id, entPhysicalSerialNum, sizeof(entPhysicalSerialNum)) == 0) {
            entPhysicalEntry->_entPhysicalSerialNumLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalSerialNum = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalMfgNameLength
            && memcmp(vb->id, entPhysicalMfgName, sizeof(entPhysicalMfgName)) == 0) {
            entPhysicalEntry->_entPhysicalMfgNameLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalMfgName = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalModelNameLength
            && memcmp(vb->id, entPhysicalModelName, sizeof(entPhysicalModelName)) == 0) {
            entPhysicalEntry->_entPhysicalModelNameLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalModelName = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalAliasLength
            && memcmp(vb->id, entPhysicalAlias, sizeof(entPhysicalAlias)) == 0) {
            entPhysicalEntry->_entPhysicalAliasLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalAlias = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalAssetIDLength
            && memcmp(vb->id, entPhysicalAssetID, sizeof(entPhysicalAssetID)) == 0) {
            entPhysicalEntry->_entPhysicalAssetIDLength = vb->syntax_len;
            entPhysicalEntry->entPhysicalAssetID = vb->syntax.uc;
        }
        if (vb->id_len > _entPhysicalIsFRULength
            && memcmp(vb->id, entPhysicalIsFRU, sizeof(entPhysicalIsFRU)) == 0) {
            entPhysicalEntry->entPhysicalIsFRU = &(vb->syntax.i32[0]);
        }
    }

    return entPhysicalEntry;
}

int
entity_mib_get_entPhysicalEntry(host_snmp *s, entPhysicalEntry_t ***entPhysicalEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *entPhysicalEntry = NULL;

    stls_vbl_add_null(&in, entPhysicalDescr, _entPhysicalDescrLength);
    stls_vbl_add_null(&in, entPhysicalVendorType, _entPhysicalVendorTypeLength);
    stls_vbl_add_null(&in, entPhysicalContainedIn, _entPhysicalContainedInLength);
    stls_vbl_add_null(&in, entPhysicalClass, _entPhysicalClassLength);
    stls_vbl_add_null(&in, entPhysicalParentRelPos, _entPhysicalParentRelPosLength);
    stls_vbl_add_null(&in, entPhysicalName, _entPhysicalNameLength);
    stls_vbl_add_null(&in, entPhysicalHardwareRev, _entPhysicalHardwareRevLength);
    stls_vbl_add_null(&in, entPhysicalFirmwareRev, _entPhysicalFirmwareRevLength);
    stls_vbl_add_null(&in, entPhysicalSoftwareRev, _entPhysicalSoftwareRevLength);
    stls_vbl_add_null(&in, entPhysicalSerialNum, _entPhysicalSerialNumLength);
    stls_vbl_add_null(&in, entPhysicalMfgName, _entPhysicalMfgNameLength);
    stls_vbl_add_null(&in, entPhysicalModelName, _entPhysicalModelNameLength);
    stls_vbl_add_null(&in, entPhysicalAlias, _entPhysicalAliasLength);
    stls_vbl_add_null(&in, entPhysicalAssetID, _entPhysicalAssetIDLength);
    stls_vbl_add_null(&in, entPhysicalIsFRU, _entPhysicalIsFRULength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *entPhysicalEntry = (entPhysicalEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entPhysicalEntry_t *));
    if (! *entPhysicalEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*entPhysicalEntry)[i] = assign_entPhysicalEntry(row->data);
    }

    return 0;
}

void
entity_mib_free_entPhysicalEntry(entPhysicalEntry_t **entPhysicalEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (entPhysicalEntry) {
        for (i = 0; entPhysicalEntry[i]; i++) {
            p = (char *) entPhysicalEntry[i] + sizeof(entPhysicalEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(entPhysicalEntry[i]);
        }
        g_free(entPhysicalEntry);
    }
}

static entLogicalEntry_t *
assign_entLogicalEntry(GSList *vbl)
{
    GSList *elem;
    entLogicalEntry_t *entLogicalEntry;
    char *p;

    entLogicalEntry = (entLogicalEntry_t *) g_malloc0(sizeof(entLogicalEntry_t) + sizeof(GSList *));
    if (! entLogicalEntry) {
        return NULL;
    }

    p = (char *) entLogicalEntry + sizeof(entLogicalEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entLogicalDescrLength
            && memcmp(vb->id, entLogicalDescr, sizeof(entLogicalDescr)) == 0) {
            entLogicalEntry->_entLogicalDescrLength = vb->syntax_len;
            entLogicalEntry->entLogicalDescr = vb->syntax.uc;
        }
        if (vb->id_len > _entLogicalTypeLength
            && memcmp(vb->id, entLogicalType, sizeof(entLogicalType)) == 0) {
            entLogicalEntry->_entLogicalTypeLength = vb->syntax_len / sizeof(guint32);
            entLogicalEntry->entLogicalType = vb->syntax.ui32;
        }
        if (vb->id_len > _entLogicalCommunityLength
            && memcmp(vb->id, entLogicalCommunity, sizeof(entLogicalCommunity)) == 0) {
            entLogicalEntry->_entLogicalCommunityLength = vb->syntax_len;
            entLogicalEntry->entLogicalCommunity = vb->syntax.uc;
        }
        if (vb->id_len > _entLogicalTAddressLength
            && memcmp(vb->id, entLogicalTAddress, sizeof(entLogicalTAddress)) == 0) {
            entLogicalEntry->_entLogicalTAddressLength = vb->syntax_len;
            entLogicalEntry->entLogicalTAddress = vb->syntax.uc;
        }
        if (vb->id_len > _entLogicalTDomainLength
            && memcmp(vb->id, entLogicalTDomain, sizeof(entLogicalTDomain)) == 0) {
            entLogicalEntry->_entLogicalTDomainLength = vb->syntax_len / sizeof(guint32);
            entLogicalEntry->entLogicalTDomain = vb->syntax.ui32;
        }
        if (vb->id_len > _entLogicalContextEngineIDLength
            && memcmp(vb->id, entLogicalContextEngineID, sizeof(entLogicalContextEngineID)) == 0) {
            entLogicalEntry->_entLogicalContextEngineIDLength = vb->syntax_len;
            entLogicalEntry->entLogicalContextEngineID = vb->syntax.uc;
        }
        if (vb->id_len > _entLogicalContextNameLength
            && memcmp(vb->id, entLogicalContextName, sizeof(entLogicalContextName)) == 0) {
            entLogicalEntry->_entLogicalContextNameLength = vb->syntax_len;
            entLogicalEntry->entLogicalContextName = vb->syntax.uc;
        }
    }

    return entLogicalEntry;
}

int
entity_mib_get_entLogicalEntry(host_snmp *s, entLogicalEntry_t ***entLogicalEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *entLogicalEntry = NULL;

    stls_vbl_add_null(&in, entLogicalDescr, _entLogicalDescrLength);
    stls_vbl_add_null(&in, entLogicalType, _entLogicalTypeLength);
    stls_vbl_add_null(&in, entLogicalCommunity, _entLogicalCommunityLength);
    stls_vbl_add_null(&in, entLogicalTAddress, _entLogicalTAddressLength);
    stls_vbl_add_null(&in, entLogicalTDomain, _entLogicalTDomainLength);
    stls_vbl_add_null(&in, entLogicalContextEngineID, _entLogicalContextEngineIDLength);
    stls_vbl_add_null(&in, entLogicalContextName, _entLogicalContextNameLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *entLogicalEntry = (entLogicalEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entLogicalEntry_t *));
    if (! *entLogicalEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*entLogicalEntry)[i] = assign_entLogicalEntry(row->data);
    }

    return 0;
}

void
entity_mib_free_entLogicalEntry(entLogicalEntry_t **entLogicalEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (entLogicalEntry) {
        for (i = 0; entLogicalEntry[i]; i++) {
            p = (char *) entLogicalEntry[i] + sizeof(entLogicalEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(entLogicalEntry[i]);
        }
        g_free(entLogicalEntry);
    }
}

static entLPMappingEntry_t *
assign_entLPMappingEntry(GSList *vbl)
{
    GSList *elem;
    entLPMappingEntry_t *entLPMappingEntry;
    char *p;

    entLPMappingEntry = (entLPMappingEntry_t *) g_malloc0(sizeof(entLPMappingEntry_t) + sizeof(GSList *));
    if (! entLPMappingEntry) {
        return NULL;
    }

    p = (char *) entLPMappingEntry + sizeof(entLPMappingEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entLPPhysicalIndexLength
            && memcmp(vb->id, entLPPhysicalIndex, sizeof(entLPPhysicalIndex)) == 0) {
            entLPMappingEntry->entLPPhysicalIndex = &(vb->syntax.i32[0]);
        }
    }

    return entLPMappingEntry;
}

int
entity_mib_get_entLPMappingEntry(host_snmp *s, entLPMappingEntry_t ***entLPMappingEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *entLPMappingEntry = NULL;


    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *entLPMappingEntry = (entLPMappingEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entLPMappingEntry_t *));
    if (! *entLPMappingEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*entLPMappingEntry)[i] = assign_entLPMappingEntry(row->data);
    }

    return 0;
}

void
entity_mib_free_entLPMappingEntry(entLPMappingEntry_t **entLPMappingEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (entLPMappingEntry) {
        for (i = 0; entLPMappingEntry[i]; i++) {
            p = (char *) entLPMappingEntry[i] + sizeof(entLPMappingEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(entLPMappingEntry[i]);
        }
        g_free(entLPMappingEntry);
    }
}

static entAliasMappingEntry_t *
assign_entAliasMappingEntry(GSList *vbl)
{
    GSList *elem;
    entAliasMappingEntry_t *entAliasMappingEntry;
    char *p;

    entAliasMappingEntry = (entAliasMappingEntry_t *) g_malloc0(sizeof(entAliasMappingEntry_t) + sizeof(GSList *));
    if (! entAliasMappingEntry) {
        return NULL;
    }

    p = (char *) entAliasMappingEntry + sizeof(entAliasMappingEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entAliasMappingIdentifierLength
            && memcmp(vb->id, entAliasMappingIdentifier, sizeof(entAliasMappingIdentifier)) == 0) {
            entAliasMappingEntry->_entAliasMappingIdentifierLength = vb->syntax_len / sizeof(guint32);
            entAliasMappingEntry->entAliasMappingIdentifier = vb->syntax.ui32;
        }
    }

    return entAliasMappingEntry;
}

int
entity_mib_get_entAliasMappingEntry(host_snmp *s, entAliasMappingEntry_t ***entAliasMappingEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *entAliasMappingEntry = NULL;

    stls_vbl_add_null(&in, entAliasMappingIdentifier, _entAliasMappingIdentifierLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *entAliasMappingEntry = (entAliasMappingEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entAliasMappingEntry_t *));
    if (! *entAliasMappingEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*entAliasMappingEntry)[i] = assign_entAliasMappingEntry(row->data);
    }

    return 0;
}

void
entity_mib_free_entAliasMappingEntry(entAliasMappingEntry_t **entAliasMappingEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (entAliasMappingEntry) {
        for (i = 0; entAliasMappingEntry[i]; i++) {
            p = (char *) entAliasMappingEntry[i] + sizeof(entAliasMappingEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(entAliasMappingEntry[i]);
        }
        g_free(entAliasMappingEntry);
    }
}

static entPhysicalContainsEntry_t *
assign_entPhysicalContainsEntry(GSList *vbl)
{
    GSList *elem;
    entPhysicalContainsEntry_t *entPhysicalContainsEntry;
    char *p;

    entPhysicalContainsEntry = (entPhysicalContainsEntry_t *) g_malloc0(sizeof(entPhysicalContainsEntry_t) + sizeof(GSList *));
    if (! entPhysicalContainsEntry) {
        return NULL;
    }

    p = (char *) entPhysicalContainsEntry + sizeof(entPhysicalContainsEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entPhysicalChildIndexLength
            && memcmp(vb->id, entPhysicalChildIndex, sizeof(entPhysicalChildIndex)) == 0) {
            entPhysicalContainsEntry->entPhysicalChildIndex = &(vb->syntax.i32[0]);
        }
    }

    return entPhysicalContainsEntry;
}

int
entity_mib_get_entPhysicalContainsEntry(host_snmp *s, entPhysicalContainsEntry_t ***entPhysicalContainsEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *entPhysicalContainsEntry = NULL;


    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *entPhysicalContainsEntry = (entPhysicalContainsEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entPhysicalContainsEntry_t *));
    if (! *entPhysicalContainsEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*entPhysicalContainsEntry)[i] = assign_entPhysicalContainsEntry(row->data);
    }

    return 0;
}

void
entity_mib_free_entPhysicalContainsEntry(entPhysicalContainsEntry_t **entPhysicalContainsEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (entPhysicalContainsEntry) {
        for (i = 0; entPhysicalContainsEntry[i]; i++) {
            p = (char *) entPhysicalContainsEntry[i] + sizeof(entPhysicalContainsEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(entPhysicalContainsEntry[i]);
        }
        g_free(entPhysicalContainsEntry);
    }
}

static entityGeneral_t *
assign_entityGeneral(GSList *vbl)
{
    GSList *elem;
    entityGeneral_t *entityGeneral;
    char *p;

    entityGeneral = (entityGeneral_t *) g_malloc0(sizeof(entityGeneral_t) + sizeof(GSList *));
    if (! entityGeneral) {
        return NULL;
    }

    p = (char *) entityGeneral + sizeof(entityGeneral_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _entLastChangeTimeLength
            && memcmp(vb->id, entLastChangeTime, sizeof(entLastChangeTime)) == 0) {
            entityGeneral->entLastChangeTime = &(vb->syntax.ui32[0]);
        }
    }

    return entityGeneral;
}

int
entity_mib_get_entityGeneral(host_snmp *s, entityGeneral_t **entityGeneral)
{
    GSList *in = NULL, *out = NULL;

    *entityGeneral = NULL;

    stls_vbl_add_null(&in, entLastChangeTime, _entLastChangeTimeLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *entityGeneral = assign_entityGeneral(out);

    return 0;
}

void
entity_mib_free_entityGeneral(entityGeneral_t *entityGeneral)
{
    GSList *vbl;
    char *p;

    if (entityGeneral) {
        p = (char *) entityGeneral + sizeof(entityGeneral_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(entityGeneral);
    }
}


