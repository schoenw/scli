/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from ENTITY-MIB:
 *   The MIB module for representing multiple logical
 *   entities supported by a single SNMP agent.
 *
 * Revision 1999-12-07 00:00:
 *   Initial Version of Entity MIB (Version 2).
 *   This revision obsoletes RFC 2037.
 *   This version published as RFC 2737.
 *
 * Revision 1996-10-31 00:00:
 *   Initial version (version 1), published as
 *   RFC 2037.
 *
 * $Id$
 */

#include "entity-mib.h"

GSnmpEnum const entity_mib_enums_entPhysicalClass[] = {
    { ENTITY_MIB_ENTPHYSICALCLASS_OTHER,       "other" },
    { ENTITY_MIB_ENTPHYSICALCLASS_UNKNOWN,     "unknown" },
    { ENTITY_MIB_ENTPHYSICALCLASS_CHASSIS,     "chassis" },
    { ENTITY_MIB_ENTPHYSICALCLASS_BACKPLANE,   "backplane" },
    { ENTITY_MIB_ENTPHYSICALCLASS_CONTAINER,   "container" },
    { ENTITY_MIB_ENTPHYSICALCLASS_POWERSUPPLY, "powerSupply" },
    { ENTITY_MIB_ENTPHYSICALCLASS_FAN,         "fan" },
    { ENTITY_MIB_ENTPHYSICALCLASS_SENSOR,      "sensor" },
    { ENTITY_MIB_ENTPHYSICALCLASS_MODULE,      "module" },
    { ENTITY_MIB_ENTPHYSICALCLASS_PORT,        "port" },
    { ENTITY_MIB_ENTPHYSICALCLASS_STACK,       "stack" },
    { 0, NULL }
};

GSnmpEnum const entity_mib_enums_entPhysicalIsFRU[] = {
    { ENTITY_MIB_ENTPHYSICALISFRU_TRUE,  "true" },
    { ENTITY_MIB_ENTPHYSICALISFRU_FALSE, "false" },
    { 0, NULL }
};


static guint16 entPhysicalDescr_constraints[] = {0, 255, 0, 0};
static guint32 entPhysicalContainedIn_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 entPhysicalParentRelPos_constraints[] = {-1L, 2147483647L, 0, 0};
static guint16 entPhysicalName_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalHardwareRev_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalFirmwareRev_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalSoftwareRev_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalSerialNum_constraints[] = {0, 32, 0, 0};
static guint16 entPhysicalMfgName_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalModelName_constraints[] = {0, 255, 0, 0};
static guint16 entPhysicalAlias_constraints[] = {0, 32, 0, 0};
static guint16 entPhysicalAssetID_constraints[] = {0, 32, 0, 0};
static guint16 entLogicalDescr_constraints[] = {0, 255, 0, 0};
static guint16 entLogicalCommunity_constraints[] = {0, 255, 0, 0};
static guint16 entLogicalTAddress_constraints[] = {1, 255, 0, 0};
static guint16 entLogicalContextEngineID_constraints[] = {0, 32, 0, 0};
static guint16 entLogicalContextName_constraints[] = {0, 255, 0, 0};
static guint32 entLPPhysicalIndex_constraints[] = {1L, 2147483647L, 0, 0};
static guint32 entPhysicalChildIndex_constraints[] = {1L, 2147483647L, 0, 0};


static guint32 const entPhysicalEntry_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1};

static GSnmpAttribute entPhysicalEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALDESCR, "entPhysicalDescr",
       entPhysicalDescr_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalDescr),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalDescrLength),
      0 },
    { 3, G_SNMP_OBJECTID,
      ENTITY_MIB_ENTPHYSICALVENDORTYPE, "entPhysicalVendorType",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalVendorType),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalVendorTypeLength),
      0 },
    { 4, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTPHYSICALCONTAINEDIN, "entPhysicalContainedIn",
       entPhysicalContainedIn_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalContainedIn),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTPHYSICALCLASS, "entPhysicalClass",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalClass),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTPHYSICALPARENTRELPOS, "entPhysicalParentRelPos",
       entPhysicalParentRelPos_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalParentRelPos),
      0,
      0 },
    { 7, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALNAME, "entPhysicalName",
       entPhysicalName_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalName),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalNameLength),
      0 },
    { 8, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALHARDWAREREV, "entPhysicalHardwareRev",
       entPhysicalHardwareRev_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalHardwareRev),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalHardwareRevLength),
      0 },
    { 9, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALFIRMWAREREV, "entPhysicalFirmwareRev",
       entPhysicalFirmwareRev_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalFirmwareRev),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalFirmwareRevLength),
      0 },
    { 10, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALSOFTWAREREV, "entPhysicalSoftwareRev",
       entPhysicalSoftwareRev_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalSoftwareRev),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalSoftwareRevLength),
      0 },
    { 11, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALSERIALNUM, "entPhysicalSerialNum",
       entPhysicalSerialNum_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalSerialNum),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalSerialNumLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALMFGNAME, "entPhysicalMfgName",
       entPhysicalMfgName_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalMfgName),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalMfgNameLength),
      0 },
    { 13, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALMODELNAME, "entPhysicalModelName",
       entPhysicalModelName_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalModelName),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalModelNameLength),
      0 },
    { 14, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALALIAS, "entPhysicalAlias",
       entPhysicalAlias_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalAlias),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalAliasLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 15, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTPHYSICALASSETID, "entPhysicalAssetID",
       entPhysicalAssetID_constraints,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalAssetID),
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, _entPhysicalAssetIDLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 16, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTPHYSICALISFRU, "entPhysicalIsFRU",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entPhysicalEntry_t, entPhysicalIsFRU),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const entLogicalEntry_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1};

static GSnmpAttribute entLogicalEntry_attr[] = {
    { 2, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTLOGICALDESCR, "entLogicalDescr",
       entLogicalDescr_constraints,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalDescr),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalDescrLength),
      0 },
    { 3, G_SNMP_OBJECTID,
      ENTITY_MIB_ENTLOGICALTYPE, "entLogicalType",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalType),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalTypeLength),
      0 },
    { 4, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTLOGICALCOMMUNITY, "entLogicalCommunity",
       entLogicalCommunity_constraints,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalCommunity),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalCommunityLength),
      0 },
    { 5, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTLOGICALTADDRESS, "entLogicalTAddress",
       entLogicalTAddress_constraints,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalTAddress),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalTAddressLength),
      0 },
    { 6, G_SNMP_OBJECTID,
      ENTITY_MIB_ENTLOGICALTDOMAIN, "entLogicalTDomain",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalTDomain),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalTDomainLength),
      0 },
    { 7, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTLOGICALCONTEXTENGINEID, "entLogicalContextEngineID",
       entLogicalContextEngineID_constraints,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalContextEngineID),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalContextEngineIDLength),
      0 },
    { 8, G_SNMP_OCTETSTRING,
      ENTITY_MIB_ENTLOGICALCONTEXTNAME, "entLogicalContextName",
       entLogicalContextName_constraints,
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, entLogicalContextName),
      G_STRUCT_OFFSET(entity_mib_entLogicalEntry_t, _entLogicalContextNameLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const entLPMappingEntry_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 1, 1};

static GSnmpAttribute entLPMappingEntry_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTLPPHYSICALINDEX, "entLPPhysicalIndex",
       entLPPhysicalIndex_constraints,
      -1,
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const entAliasMappingEntry_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 2, 1};

static GSnmpAttribute entAliasMappingEntry_attr[] = {
    { 2, G_SNMP_OBJECTID,
      ENTITY_MIB_ENTALIASMAPPINGIDENTIFIER, "entAliasMappingIdentifier",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entAliasMappingEntry_t, entAliasMappingIdentifier),
      G_STRUCT_OFFSET(entity_mib_entAliasMappingEntry_t, _entAliasMappingIdentifierLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const entPhysicalContainsEntry_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 3, 1};

static GSnmpAttribute entPhysicalContainsEntry_attr[] = {
    { 1, G_SNMP_INTEGER32,
      ENTITY_MIB_ENTPHYSICALCHILDINDEX, "entPhysicalChildIndex",
       entPhysicalChildIndex_constraints,
      -1,
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const entityGeneral_oid[] = {1, 3, 6, 1, 2, 1, 47, 1, 4};

static GSnmpAttribute entityGeneral_attr[] = {
    { 1, G_SNMP_TIMETICKS,
      ENTITY_MIB_ENTLASTCHANGETIME, "entLastChangeTime",
       NULL,
      G_STRUCT_OFFSET(entity_mib_entityGeneral_t, entLastChangeTime),
      0,
      0 },
    { 0, 0, 0, NULL }
};


entity_mib_entPhysicalEntry_t *
entity_mib_new_entPhysicalEntry()
{
    entity_mib_entPhysicalEntry_t *entPhysicalEntry;

    entPhysicalEntry = (entity_mib_entPhysicalEntry_t *) g_malloc0(sizeof(entity_mib_entPhysicalEntry_t) + sizeof(gpointer));
    return entPhysicalEntry;
}

static int
unpack_entPhysicalEntry(GSnmpVarBind *vb, entity_mib_entPhysicalEntry_t *entPhysicalEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    entPhysicalEntry->entPhysicalIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_entPhysicalEntry(guint32 *base, gint32 entPhysicalIndex)
{
    guint8 idx = 12;

    base[idx++] = entPhysicalIndex;
    return idx;
}

static entity_mib_entPhysicalEntry_t *
assign_entPhysicalEntry(GSList *vbl)
{
    entity_mib_entPhysicalEntry_t *entPhysicalEntry;
    char *p;

    entPhysicalEntry = entity_mib_new_entPhysicalEntry();
    if (! entPhysicalEntry) {
        return NULL;
    }

    p = (char *) entPhysicalEntry + sizeof(entity_mib_entPhysicalEntry_t);
    * (GSList **) p = vbl;

    if (unpack_entPhysicalEntry((GSnmpVarBind *) vbl->data, entPhysicalEntry) < 0) {
        g_warning("%s: invalid instance identifier", "entPhysicalEntry");
        g_free(entPhysicalEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, entPhysicalEntry_oid, sizeof(entPhysicalEntry_oid)/sizeof(guint32),
                      entPhysicalEntry_attr, entPhysicalEntry);

    return entPhysicalEntry;
}

void
entity_mib_get_entPhysicalTable(GSnmpSession *s, entity_mib_entPhysicalEntry_t ***entPhysicalEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 1, 1, 1, 0};

    *entPhysicalEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, entPhysicalEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *entPhysicalEntry = (entity_mib_entPhysicalEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entity_mib_entPhysicalEntry_t *));
        if (! *entPhysicalEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*entPhysicalEntry)[i] = assign_entPhysicalEntry(row->data);
        }
    }
}

void
entity_mib_get_entPhysicalEntry(GSnmpSession *s, entity_mib_entPhysicalEntry_t **entPhysicalEntry, gint32 entPhysicalIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entPhysicalEntry_oid, sizeof(entPhysicalEntry_oid));
    len = pack_entPhysicalEntry(base, entPhysicalIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "entPhysicalEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *entPhysicalEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, entPhysicalEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entPhysicalEntry = assign_entPhysicalEntry(out);
    }
}

void
entity_mib_set_entPhysicalEntry(GSnmpSession *s, entity_mib_entPhysicalEntry_t *entPhysicalEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entPhysicalEntry_oid, sizeof(entPhysicalEntry_oid));
    len = pack_entPhysicalEntry(base, entPhysicalEntry->entPhysicalIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "entPhysicalEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 11, entPhysicalEntry_attr, mask, entPhysicalEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
entity_mib_free_entPhysicalEntry(entity_mib_entPhysicalEntry_t *entPhysicalEntry)
{
    GSList *vbl;
    char *p;

    if (entPhysicalEntry) {
        p = (char *) entPhysicalEntry + sizeof(entity_mib_entPhysicalEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entPhysicalEntry);
    }
}

void
entity_mib_free_entPhysicalTable(entity_mib_entPhysicalEntry_t **entPhysicalEntry)
{
    int i;

    if (entPhysicalEntry) {
        for (i = 0; entPhysicalEntry[i]; i++) {
            entity_mib_free_entPhysicalEntry(entPhysicalEntry[i]);
        }
        g_free(entPhysicalEntry);
    }
}

entity_mib_entLogicalEntry_t *
entity_mib_new_entLogicalEntry()
{
    entity_mib_entLogicalEntry_t *entLogicalEntry;

    entLogicalEntry = (entity_mib_entLogicalEntry_t *) g_malloc0(sizeof(entity_mib_entLogicalEntry_t) + sizeof(gpointer));
    return entLogicalEntry;
}

static int
unpack_entLogicalEntry(GSnmpVarBind *vb, entity_mib_entLogicalEntry_t *entLogicalEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    entLogicalEntry->entLogicalIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_entLogicalEntry(guint32 *base, gint32 entLogicalIndex)
{
    guint8 idx = 12;

    base[idx++] = entLogicalIndex;
    return idx;
}

static entity_mib_entLogicalEntry_t *
assign_entLogicalEntry(GSList *vbl)
{
    entity_mib_entLogicalEntry_t *entLogicalEntry;
    char *p;

    entLogicalEntry = entity_mib_new_entLogicalEntry();
    if (! entLogicalEntry) {
        return NULL;
    }

    p = (char *) entLogicalEntry + sizeof(entity_mib_entLogicalEntry_t);
    * (GSList **) p = vbl;

    if (unpack_entLogicalEntry((GSnmpVarBind *) vbl->data, entLogicalEntry) < 0) {
        g_warning("%s: invalid instance identifier", "entLogicalEntry");
        g_free(entLogicalEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, entLogicalEntry_oid, sizeof(entLogicalEntry_oid)/sizeof(guint32),
                      entLogicalEntry_attr, entLogicalEntry);

    return entLogicalEntry;
}

void
entity_mib_get_entLogicalTable(GSnmpSession *s, entity_mib_entLogicalEntry_t ***entLogicalEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 2, 1, 1, 0};

    *entLogicalEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, entLogicalEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *entLogicalEntry = (entity_mib_entLogicalEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entity_mib_entLogicalEntry_t *));
        if (! *entLogicalEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*entLogicalEntry)[i] = assign_entLogicalEntry(row->data);
        }
    }
}

void
entity_mib_get_entLogicalEntry(GSnmpSession *s, entity_mib_entLogicalEntry_t **entLogicalEntry, gint32 entLogicalIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entLogicalEntry_oid, sizeof(entLogicalEntry_oid));
    len = pack_entLogicalEntry(base, entLogicalIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "entLogicalEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *entLogicalEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, entLogicalEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entLogicalEntry = assign_entLogicalEntry(out);
    }
}

void
entity_mib_free_entLogicalEntry(entity_mib_entLogicalEntry_t *entLogicalEntry)
{
    GSList *vbl;
    char *p;

    if (entLogicalEntry) {
        p = (char *) entLogicalEntry + sizeof(entity_mib_entLogicalEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entLogicalEntry);
    }
}

void
entity_mib_free_entLogicalTable(entity_mib_entLogicalEntry_t **entLogicalEntry)
{
    int i;

    if (entLogicalEntry) {
        for (i = 0; entLogicalEntry[i]; i++) {
            entity_mib_free_entLogicalEntry(entLogicalEntry[i]);
        }
        g_free(entLogicalEntry);
    }
}

entity_mib_entLPMappingEntry_t *
entity_mib_new_entLPMappingEntry()
{
    entity_mib_entLPMappingEntry_t *entLPMappingEntry;

    entLPMappingEntry = (entity_mib_entLPMappingEntry_t *) g_malloc0(sizeof(entity_mib_entLPMappingEntry_t) + sizeof(gpointer));
    return entLPMappingEntry;
}

static int
unpack_entLPMappingEntry(GSnmpVarBind *vb, entity_mib_entLPMappingEntry_t *entLPMappingEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    entLPMappingEntry->entLogicalIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    entLPMappingEntry->entLPPhysicalIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_entLPMappingEntry(guint32 *base, gint32 entLogicalIndex, gint32 entLPPhysicalIndex)
{
    guint8 idx = 12;

    base[idx++] = entLogicalIndex;
    base[idx++] = entLPPhysicalIndex;
    return idx;
}

static entity_mib_entLPMappingEntry_t *
assign_entLPMappingEntry(GSList *vbl)
{
    entity_mib_entLPMappingEntry_t *entLPMappingEntry;
    char *p;

    entLPMappingEntry = entity_mib_new_entLPMappingEntry();
    if (! entLPMappingEntry) {
        return NULL;
    }

    p = (char *) entLPMappingEntry + sizeof(entity_mib_entLPMappingEntry_t);
    * (GSList **) p = vbl;

    if (unpack_entLPMappingEntry((GSnmpVarBind *) vbl->data, entLPMappingEntry) < 0) {
        g_warning("%s: invalid instance identifier", "entLPMappingEntry");
        g_free(entLPMappingEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, entLPMappingEntry_oid, sizeof(entLPMappingEntry_oid)/sizeof(guint32),
                      entLPMappingEntry_attr, entLPMappingEntry);

    return entLPMappingEntry;
}

void
entity_mib_get_entLPMappingTable(GSnmpSession *s, entity_mib_entLPMappingEntry_t ***entLPMappingEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 1, 1, 0};

    *entLPMappingEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, entLPMappingEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *entLPMappingEntry = (entity_mib_entLPMappingEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entity_mib_entLPMappingEntry_t *));
        if (! *entLPMappingEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*entLPMappingEntry)[i] = assign_entLPMappingEntry(row->data);
        }
    }
}

void
entity_mib_get_entLPMappingEntry(GSnmpSession *s, entity_mib_entLPMappingEntry_t **entLPMappingEntry, gint32 entLogicalIndex, gint32 entLPPhysicalIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entLPMappingEntry_oid, sizeof(entLPMappingEntry_oid));
    len = pack_entLPMappingEntry(base, entLogicalIndex, entLPPhysicalIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "entLPMappingEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *entLPMappingEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, entLPMappingEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entLPMappingEntry = assign_entLPMappingEntry(out);
    }
}

void
entity_mib_free_entLPMappingEntry(entity_mib_entLPMappingEntry_t *entLPMappingEntry)
{
    GSList *vbl;
    char *p;

    if (entLPMappingEntry) {
        p = (char *) entLPMappingEntry + sizeof(entity_mib_entLPMappingEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entLPMappingEntry);
    }
}

void
entity_mib_free_entLPMappingTable(entity_mib_entLPMappingEntry_t **entLPMappingEntry)
{
    int i;

    if (entLPMappingEntry) {
        for (i = 0; entLPMappingEntry[i]; i++) {
            entity_mib_free_entLPMappingEntry(entLPMappingEntry[i]);
        }
        g_free(entLPMappingEntry);
    }
}

entity_mib_entAliasMappingEntry_t *
entity_mib_new_entAliasMappingEntry()
{
    entity_mib_entAliasMappingEntry_t *entAliasMappingEntry;

    entAliasMappingEntry = (entity_mib_entAliasMappingEntry_t *) g_malloc0(sizeof(entity_mib_entAliasMappingEntry_t) + sizeof(gpointer));
    return entAliasMappingEntry;
}

static int
unpack_entAliasMappingEntry(GSnmpVarBind *vb, entity_mib_entAliasMappingEntry_t *entAliasMappingEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    entAliasMappingEntry->entPhysicalIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    entAliasMappingEntry->entAliasLogicalIndexOrZero = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_entAliasMappingEntry(guint32 *base, gint32 entPhysicalIndex, gint32 entAliasLogicalIndexOrZero)
{
    guint8 idx = 12;

    base[idx++] = entPhysicalIndex;
    base[idx++] = entAliasLogicalIndexOrZero;
    return idx;
}

static entity_mib_entAliasMappingEntry_t *
assign_entAliasMappingEntry(GSList *vbl)
{
    entity_mib_entAliasMappingEntry_t *entAliasMappingEntry;
    char *p;

    entAliasMappingEntry = entity_mib_new_entAliasMappingEntry();
    if (! entAliasMappingEntry) {
        return NULL;
    }

    p = (char *) entAliasMappingEntry + sizeof(entity_mib_entAliasMappingEntry_t);
    * (GSList **) p = vbl;

    if (unpack_entAliasMappingEntry((GSnmpVarBind *) vbl->data, entAliasMappingEntry) < 0) {
        g_warning("%s: invalid instance identifier", "entAliasMappingEntry");
        g_free(entAliasMappingEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, entAliasMappingEntry_oid, sizeof(entAliasMappingEntry_oid)/sizeof(guint32),
                      entAliasMappingEntry_attr, entAliasMappingEntry);

    return entAliasMappingEntry;
}

void
entity_mib_get_entAliasMappingTable(GSnmpSession *s, entity_mib_entAliasMappingEntry_t ***entAliasMappingEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 2, 1, 0};

    *entAliasMappingEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, entAliasMappingEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *entAliasMappingEntry = (entity_mib_entAliasMappingEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entity_mib_entAliasMappingEntry_t *));
        if (! *entAliasMappingEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*entAliasMappingEntry)[i] = assign_entAliasMappingEntry(row->data);
        }
    }
}

void
entity_mib_get_entAliasMappingEntry(GSnmpSession *s, entity_mib_entAliasMappingEntry_t **entAliasMappingEntry, gint32 entPhysicalIndex, gint32 entAliasLogicalIndexOrZero, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entAliasMappingEntry_oid, sizeof(entAliasMappingEntry_oid));
    len = pack_entAliasMappingEntry(base, entPhysicalIndex, entAliasLogicalIndexOrZero);
    if (len < 0) {
        g_warning("%s: invalid index values", "entAliasMappingEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *entAliasMappingEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, entAliasMappingEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entAliasMappingEntry = assign_entAliasMappingEntry(out);
    }
}

void
entity_mib_free_entAliasMappingEntry(entity_mib_entAliasMappingEntry_t *entAliasMappingEntry)
{
    GSList *vbl;
    char *p;

    if (entAliasMappingEntry) {
        p = (char *) entAliasMappingEntry + sizeof(entity_mib_entAliasMappingEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entAliasMappingEntry);
    }
}

void
entity_mib_free_entAliasMappingTable(entity_mib_entAliasMappingEntry_t **entAliasMappingEntry)
{
    int i;

    if (entAliasMappingEntry) {
        for (i = 0; entAliasMappingEntry[i]; i++) {
            entity_mib_free_entAliasMappingEntry(entAliasMappingEntry[i]);
        }
        g_free(entAliasMappingEntry);
    }
}

entity_mib_entPhysicalContainsEntry_t *
entity_mib_new_entPhysicalContainsEntry()
{
    entity_mib_entPhysicalContainsEntry_t *entPhysicalContainsEntry;

    entPhysicalContainsEntry = (entity_mib_entPhysicalContainsEntry_t *) g_malloc0(sizeof(entity_mib_entPhysicalContainsEntry_t) + sizeof(gpointer));
    return entPhysicalContainsEntry;
}

static int
unpack_entPhysicalContainsEntry(GSnmpVarBind *vb, entity_mib_entPhysicalContainsEntry_t *entPhysicalContainsEntry)
{
    guint8 idx = 12;

    if (vb->id_len < idx) return -1;
    entPhysicalContainsEntry->entPhysicalIndex = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    entPhysicalContainsEntry->entPhysicalChildIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_entPhysicalContainsEntry(guint32 *base, gint32 entPhysicalIndex, gint32 entPhysicalChildIndex)
{
    guint8 idx = 12;

    base[idx++] = entPhysicalIndex;
    base[idx++] = entPhysicalChildIndex;
    return idx;
}

static entity_mib_entPhysicalContainsEntry_t *
assign_entPhysicalContainsEntry(GSList *vbl)
{
    entity_mib_entPhysicalContainsEntry_t *entPhysicalContainsEntry;
    char *p;

    entPhysicalContainsEntry = entity_mib_new_entPhysicalContainsEntry();
    if (! entPhysicalContainsEntry) {
        return NULL;
    }

    p = (char *) entPhysicalContainsEntry + sizeof(entity_mib_entPhysicalContainsEntry_t);
    * (GSList **) p = vbl;

    if (unpack_entPhysicalContainsEntry((GSnmpVarBind *) vbl->data, entPhysicalContainsEntry) < 0) {
        g_warning("%s: invalid instance identifier", "entPhysicalContainsEntry");
        g_free(entPhysicalContainsEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, entPhysicalContainsEntry_oid, sizeof(entPhysicalContainsEntry_oid)/sizeof(guint32),
                      entPhysicalContainsEntry_attr, entPhysicalContainsEntry);

    return entPhysicalContainsEntry;
}

void
entity_mib_get_entPhysicalContainsTable(GSnmpSession *s, entity_mib_entPhysicalContainsEntry_t ***entPhysicalContainsEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 3, 3, 1, 0};

    *entPhysicalContainsEntry = NULL;

    gsnmp_attr_get(s, &in, base, 12, 11, entPhysicalContainsEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *entPhysicalContainsEntry = (entity_mib_entPhysicalContainsEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(entity_mib_entPhysicalContainsEntry_t *));
        if (! *entPhysicalContainsEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*entPhysicalContainsEntry)[i] = assign_entPhysicalContainsEntry(row->data);
        }
    }
}

void
entity_mib_get_entPhysicalContainsEntry(GSnmpSession *s, entity_mib_entPhysicalContainsEntry_t **entPhysicalContainsEntry, gint32 entPhysicalIndex, gint32 entPhysicalChildIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, entPhysicalContainsEntry_oid, sizeof(entPhysicalContainsEntry_oid));
    len = pack_entPhysicalContainsEntry(base, entPhysicalIndex, entPhysicalChildIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "entPhysicalContainsEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *entPhysicalContainsEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 11, entPhysicalContainsEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entPhysicalContainsEntry = assign_entPhysicalContainsEntry(out);
    }
}

void
entity_mib_free_entPhysicalContainsEntry(entity_mib_entPhysicalContainsEntry_t *entPhysicalContainsEntry)
{
    GSList *vbl;
    char *p;

    if (entPhysicalContainsEntry) {
        p = (char *) entPhysicalContainsEntry + sizeof(entity_mib_entPhysicalContainsEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entPhysicalContainsEntry);
    }
}

void
entity_mib_free_entPhysicalContainsTable(entity_mib_entPhysicalContainsEntry_t **entPhysicalContainsEntry)
{
    int i;

    if (entPhysicalContainsEntry) {
        for (i = 0; entPhysicalContainsEntry[i]; i++) {
            entity_mib_free_entPhysicalContainsEntry(entPhysicalContainsEntry[i]);
        }
        g_free(entPhysicalContainsEntry);
    }
}

entity_mib_entityGeneral_t *
entity_mib_new_entityGeneral()
{
    entity_mib_entityGeneral_t *entityGeneral;

    entityGeneral = (entity_mib_entityGeneral_t *) g_malloc0(sizeof(entity_mib_entityGeneral_t) + sizeof(gpointer));
    return entityGeneral;
}

static entity_mib_entityGeneral_t *
assign_entityGeneral(GSList *vbl)
{
    entity_mib_entityGeneral_t *entityGeneral;
    char *p;

    entityGeneral = entity_mib_new_entityGeneral();
    if (! entityGeneral) {
        return NULL;
    }

    p = (char *) entityGeneral + sizeof(entity_mib_entityGeneral_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, entityGeneral_oid, sizeof(entityGeneral_oid)/sizeof(guint32),
                      entityGeneral_attr, entityGeneral);

    return entityGeneral;
}

void
entity_mib_get_entityGeneral(GSnmpSession *s, entity_mib_entityGeneral_t **entityGeneral, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 47, 1, 4, 0};

    *entityGeneral = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, entityGeneral_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *entityGeneral = assign_entityGeneral(out);
    }
}

void
entity_mib_free_entityGeneral(entity_mib_entityGeneral_t *entityGeneral)
{
    GSList *vbl;
    char *p;

    if (entityGeneral) {
        p = (char *) entityGeneral + sizeof(entity_mib_entityGeneral_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(entityGeneral);
    }
}


