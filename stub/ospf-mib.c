/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.0 for the scli package.
 *
 * Derived from OSPF-MIB:
 *   The MIB module to describe the OSPF Version 2
 *   Protocol
 *
 * Revision 1995-01-20 12:25:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "ospf-mib.h"

GSnmpEnum const ospf_mib_enums_ospfAdminStat[] = {
    { OSPF_MIB_OSPFADMINSTAT_ENABLED,	"enabled" },
    { OSPF_MIB_OSPFADMINSTAT_DISABLED,	"disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVersionNumber[] = {
    { OSPF_MIB_OSPFVERSIONNUMBER_VERSION2,	"version2" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaBdrRtrStatus[] = {
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_TRUE,	"true" },
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfASBdrRtrStatus[] = {
    { OSPF_MIB_OSPFASBDRRTRSTATUS_TRUE,	"true" },
    { OSPF_MIB_OSPFASBDRRTRSTATUS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfTOSSupport[] = {
    { OSPF_MIB_OSPFTOSSUPPORT_TRUE,	"true" },
    { OSPF_MIB_OSPFTOSSUPPORT_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfDemandExtensions[] = {
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_TRUE,	"true" },
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfImportAsExtern[] = {
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTEXTERNAL,	"importExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNOEXTERNAL,	"importNoExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNSSA,	"importNssa" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaSummary[] = {
    { OSPF_MIB_OSPFAREASUMMARY_NOAREASUMMARY,	"noAreaSummary" },
    { OSPF_MIB_OSPFAREASUMMARY_SENDAREASUMMARY,	"sendAreaSummary" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaStatus[] = {
    { OSPF_MIB_OSPFAREASTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREASTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREASTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREASTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfStubStatus[] = {
    { OSPF_MIB_OSPFSTUBSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFSTUBSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfStubMetricType[] = {
    { OSPF_MIB_OSPFSTUBMETRICTYPE_OSPFMETRIC,	"ospfMetric" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_COMPARABLECOST,	"comparableCost" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_NONCOMPARABLE,	"nonComparable" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfLsdbType[] = {
    { OSPF_MIB_OSPFLSDBTYPE_ROUTERLINK,	"routerLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NETWORKLINK,	"networkLink" },
    { OSPF_MIB_OSPFLSDBTYPE_SUMMARYLINK,	"summaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASSUMMARYLINK,	"asSummaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASEXTERNALLINK,	"asExternalLink" },
    { OSPF_MIB_OSPFLSDBTYPE_MULTICASTLINK,	"multicastLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NSSAEXTERNALLINK,	"nssaExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaRangeStatus[] = {
    { OSPF_MIB_OSPFAREARANGESTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREARANGESTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaRangeEffect[] = {
    { OSPF_MIB_OSPFAREARANGEEFFECT_ADVERTISEMATCHING,	"advertiseMatching" },
    { OSPF_MIB_OSPFAREARANGEEFFECT_DONOTADVERTISEMATCHING,	"doNotAdvertiseMatching" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfHostStatus[] = {
    { OSPF_MIB_OSPFHOSTSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFHOSTSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfType[] = {
    { OSPF_MIB_OSPFIFTYPE_BROADCAST,	"broadcast" },
    { OSPF_MIB_OSPFIFTYPE_NBMA,	"nbma" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOPOINT,	"pointToPoint" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOMULTIPOINT,	"pointToMultipoint" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfAdminStat[] = {
    { OSPF_MIB_OSPFIFADMINSTAT_ENABLED,	"enabled" },
    { OSPF_MIB_OSPFIFADMINSTAT_DISABLED,	"disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfState[] = {
    { OSPF_MIB_OSPFIFSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFIFSTATE_LOOPBACK,	"loopback" },
    { OSPF_MIB_OSPFIFSTATE_WAITING,	"waiting" },
    { OSPF_MIB_OSPFIFSTATE_POINTTOPOINT,	"pointToPoint" },
    { OSPF_MIB_OSPFIFSTATE_DESIGNATEDROUTER,	"designatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_BACKUPDESIGNATEDROUTER,	"backupDesignatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_OTHERDESIGNATEDROUTER,	"otherDesignatedRouter" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfStatus[] = {
    { OSPF_MIB_OSPFIFSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFIFSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFIFSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFIFSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfMulticastForwarding[] = {
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_BLOCKED,	"blocked" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_MULTICAST,	"multicast" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_UNICAST,	"unicast" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfDemand[] = {
    { OSPF_MIB_OSPFIFDEMAND_TRUE,	"true" },
    { OSPF_MIB_OSPFIFDEMAND_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfMetricStatus[] = {
    { OSPF_MIB_OSPFIFMETRICSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtIfState[] = {
    { OSPF_MIB_OSPFVIRTIFSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFVIRTIFSTATE_POINTTOPOINT,	"pointToPoint" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtIfStatus[] = {
    { OSPF_MIB_OSPFVIRTIFSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbrState[] = {
    { OSPF_MIB_OSPFNBRSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFNBRSTATE_ATTEMPT,	"attempt" },
    { OSPF_MIB_OSPFNBRSTATE_INIT,	"init" },
    { OSPF_MIB_OSPFNBRSTATE_TWOWAY,	"twoWay" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGESTART,	"exchangeStart" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGE,	"exchange" },
    { OSPF_MIB_OSPFNBRSTATE_LOADING,	"loading" },
    { OSPF_MIB_OSPFNBRSTATE_FULL,	"full" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbmaNbrStatus[] = {
    { OSPF_MIB_OSPFNBMANBRSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbmaNbrPermanence[] = {
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_DYNAMIC,	"dynamic" },
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_PERMANENT,	"permanent" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_TRUE,	"true" },
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtNbrState[] = {
    { OSPF_MIB_OSPFVIRTNBRSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_ATTEMPT,	"attempt" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_INIT,	"init" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_TWOWAY,	"twoWay" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGESTART,	"exchangeStart" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGE,	"exchange" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_LOADING,	"loading" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_FULL,	"full" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_TRUE,	"true" },
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_FALSE,	"false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfExtLsdbType[] = {
    { OSPF_MIB_OSPFEXTLSDBTYPE_ASEXTERNALLINK,	"asExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateLsdbType[] = {
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_SUMMARYLINK,	"summaryLink" },
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_NSSAEXTERNALLINK,	"nssaExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateStatus[] = {
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateEffect[] = {
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_ADVERTISEMATCHING,	"advertiseMatching" },
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_DONOTADVERTISEMATCHING,	"doNotAdvertiseMatching" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, guint8 len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, guint16 const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		const char *a = gsnmp_enum_get_label(gsnmp_enum_type_table, vb->type);
		const char *b = gsnmp_enum_get_label(gsnmp_enum_type_table, attributes[i].type);
		g_warning("%s: type mismatch: %s%s%s", attributes[i].label,
		          (a) ? a : "", (a || b) ? " != " : "", (b) ? b : "");
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_ospfGeneralGroup[] = {1, 3, 6, 1, 2, 1, 14, 1};

static attribute_t attr_ospfGeneralGroup[] = {
    { 1, G_SNMP_IPADDRESS, OSPF_MIB_OSPFROUTERID, "ospfRouterId" },
    { 2, G_SNMP_INTEGER32, OSPF_MIB_OSPFADMINSTAT, "ospfAdminStat" },
    { 3, G_SNMP_INTEGER32, OSPF_MIB_OSPFVERSIONNUMBER, "ospfVersionNumber" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREABDRRTRSTATUS, "ospfAreaBdrRtrStatus" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFASBDRRTRSTATUS, "ospfASBdrRtrStatus" },
    { 6, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFEXTERNLSACOUNT, "ospfExternLsaCount" },
    { 7, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXTERNLSACKSUMSUM, "ospfExternLsaCksumSum" },
    { 8, G_SNMP_INTEGER32, OSPF_MIB_OSPFTOSSUPPORT, "ospfTOSSupport" },
    { 9, G_SNMP_COUNTER32, OSPF_MIB_OSPFORIGINATENEWLSAS, "ospfOriginateNewLsas" },
    { 10, G_SNMP_COUNTER32, OSPF_MIB_OSPFRXNEWLSAS, "ospfRxNewLsas" },
    { 11, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXTLSDBLIMIT, "ospfExtLsdbLimit" },
    { 12, G_SNMP_INTEGER32, OSPF_MIB_OSPFMULTICASTEXTENSIONS, "ospfMulticastExtensions" },
    { 13, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXITOVERFLOWINTERVAL, "ospfExitOverflowInterval" },
    { 14, G_SNMP_INTEGER32, OSPF_MIB_OSPFDEMANDEXTENSIONS, "ospfDemandExtensions" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfAreaEntry[] = {1, 3, 6, 1, 2, 1, 14, 2, 1};

static attribute_t attr_ospfAreaEntry[] = {
    { 2, G_SNMP_INTEGER32, OSPF_MIB_OSPFAUTHTYPE, "ospfAuthType" },
    { 3, G_SNMP_INTEGER32, OSPF_MIB_OSPFIMPORTASEXTERN, "ospfImportAsExtern" },
    { 4, G_SNMP_COUNTER32, OSPF_MIB_OSPFSPFRUNS, "ospfSpfRuns" },
    { 5, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFAREABDRRTRCOUNT, "ospfAreaBdrRtrCount" },
    { 6, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFASBDRRTRCOUNT, "ospfAsBdrRtrCount" },
    { 7, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFAREALSACOUNT, "ospfAreaLsaCount" },
    { 8, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREALSACKSUMSUM, "ospfAreaLsaCksumSum" },
    { 9, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREASUMMARY, "ospfAreaSummary" },
    { 10, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREASTATUS, "ospfAreaStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfStubAreaEntry[] = {1, 3, 6, 1, 2, 1, 14, 3, 1};

static attribute_t attr_ospfStubAreaEntry[] = {
    { 3, G_SNMP_INTEGER32, OSPF_MIB_OSPFSTUBMETRIC, "ospfStubMetric" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFSTUBSTATUS, "ospfStubStatus" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFSTUBMETRICTYPE, "ospfStubMetricType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfLsdbEntry[] = {1, 3, 6, 1, 2, 1, 14, 4, 1};

static attribute_t attr_ospfLsdbEntry[] = {
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFLSDBSEQUENCE, "ospfLsdbSequence" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFLSDBAGE, "ospfLsdbAge" },
    { 7, G_SNMP_INTEGER32, OSPF_MIB_OSPFLSDBCHECKSUM, "ospfLsdbChecksum" },
    { 8, G_SNMP_OCTETSTRING, OSPF_MIB_OSPFLSDBADVERTISEMENT, "ospfLsdbAdvertisement" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfAreaRangeEntry[] = {1, 3, 6, 1, 2, 1, 14, 5, 1};

static attribute_t attr_ospfAreaRangeEntry[] = {
    { 3, G_SNMP_IPADDRESS, OSPF_MIB_OSPFAREARANGEMASK, "ospfAreaRangeMask" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREARANGESTATUS, "ospfAreaRangeStatus" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREARANGEEFFECT, "ospfAreaRangeEffect" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfHostEntry[] = {1, 3, 6, 1, 2, 1, 14, 6, 1};

static attribute_t attr_ospfHostEntry[] = {
    { 3, G_SNMP_INTEGER32, OSPF_MIB_OSPFHOSTMETRIC, "ospfHostMetric" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFHOSTSTATUS, "ospfHostStatus" },
    { 5, G_SNMP_IPADDRESS, OSPF_MIB_OSPFHOSTAREAID, "ospfHostAreaID" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfIfEntry[] = {1, 3, 6, 1, 2, 1, 14, 7, 1};

static attribute_t attr_ospfIfEntry[] = {
    { 3, G_SNMP_IPADDRESS, OSPF_MIB_OSPFIFAREAID, "ospfIfAreaId" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFTYPE, "ospfIfType" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFADMINSTAT, "ospfIfAdminStat" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFRTRPRIORITY, "ospfIfRtrPriority" },
    { 7, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFTRANSITDELAY, "ospfIfTransitDelay" },
    { 8, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFRETRANSINTERVAL, "ospfIfRetransInterval" },
    { 9, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFHELLOINTERVAL, "ospfIfHelloInterval" },
    { 10, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFRTRDEADINTERVAL, "ospfIfRtrDeadInterval" },
    { 11, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFPOLLINTERVAL, "ospfIfPollInterval" },
    { 12, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFSTATE, "ospfIfState" },
    { 13, G_SNMP_IPADDRESS, OSPF_MIB_OSPFIFDESIGNATEDROUTER, "ospfIfDesignatedRouter" },
    { 14, G_SNMP_IPADDRESS, OSPF_MIB_OSPFIFBACKUPDESIGNATEDROUTER, "ospfIfBackupDesignatedRouter" },
    { 15, G_SNMP_COUNTER32, OSPF_MIB_OSPFIFEVENTS, "ospfIfEvents" },
    { 16, G_SNMP_OCTETSTRING, OSPF_MIB_OSPFIFAUTHKEY, "ospfIfAuthKey" },
    { 17, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFSTATUS, "ospfIfStatus" },
    { 18, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFMULTICASTFORWARDING, "ospfIfMulticastForwarding" },
    { 19, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFDEMAND, "ospfIfDemand" },
    { 20, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFAUTHTYPE, "ospfIfAuthType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfIfMetricEntry[] = {1, 3, 6, 1, 2, 1, 14, 8, 1};

static attribute_t attr_ospfIfMetricEntry[] = {
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFMETRICVALUE, "ospfIfMetricValue" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFIFMETRICSTATUS, "ospfIfMetricStatus" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfVirtIfEntry[] = {1, 3, 6, 1, 2, 1, 14, 9, 1};

static attribute_t attr_ospfVirtIfEntry[] = {
    { 3, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFTRANSITDELAY, "ospfVirtIfTransitDelay" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFRETRANSINTERVAL, "ospfVirtIfRetransInterval" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFHELLOINTERVAL, "ospfVirtIfHelloInterval" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFRTRDEADINTERVAL, "ospfVirtIfRtrDeadInterval" },
    { 7, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFSTATE, "ospfVirtIfState" },
    { 8, G_SNMP_COUNTER32, OSPF_MIB_OSPFVIRTIFEVENTS, "ospfVirtIfEvents" },
    { 9, G_SNMP_OCTETSTRING, OSPF_MIB_OSPFVIRTIFAUTHKEY, "ospfVirtIfAuthKey" },
    { 10, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFSTATUS, "ospfVirtIfStatus" },
    { 11, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTIFAUTHTYPE, "ospfVirtIfAuthType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfNbrEntry[] = {1, 3, 6, 1, 2, 1, 14, 10, 1};

static attribute_t attr_ospfNbrEntry[] = {
    { 3, G_SNMP_IPADDRESS, OSPF_MIB_OSPFNBRRTRID, "ospfNbrRtrId" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBROPTIONS, "ospfNbrOptions" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBRPRIORITY, "ospfNbrPriority" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBRSTATE, "ospfNbrState" },
    { 7, G_SNMP_COUNTER32, OSPF_MIB_OSPFNBREVENTS, "ospfNbrEvents" },
    { 8, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFNBRLSRETRANSQLEN, "ospfNbrLsRetransQLen" },
    { 9, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBMANBRSTATUS, "ospfNbmaNbrStatus" },
    { 10, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBMANBRPERMANENCE, "ospfNbmaNbrPermanence" },
    { 11, G_SNMP_INTEGER32, OSPF_MIB_OSPFNBRHELLOSUPPRESSED, "ospfNbrHelloSuppressed" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfVirtNbrEntry[] = {1, 3, 6, 1, 2, 1, 14, 11, 1};

static attribute_t attr_ospfVirtNbrEntry[] = {
    { 3, G_SNMP_IPADDRESS, OSPF_MIB_OSPFVIRTNBRIPADDR, "ospfVirtNbrIpAddr" },
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTNBROPTIONS, "ospfVirtNbrOptions" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTNBRSTATE, "ospfVirtNbrState" },
    { 6, G_SNMP_COUNTER32, OSPF_MIB_OSPFVIRTNBREVENTS, "ospfVirtNbrEvents" },
    { 7, G_SNMP_UNSIGNED32, OSPF_MIB_OSPFVIRTNBRLSRETRANSQLEN, "ospfVirtNbrLsRetransQLen" },
    { 8, G_SNMP_INTEGER32, OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED, "ospfVirtNbrHelloSuppressed" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfExtLsdbEntry[] = {1, 3, 6, 1, 2, 1, 14, 12, 1};

static attribute_t attr_ospfExtLsdbEntry[] = {
    { 4, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXTLSDBSEQUENCE, "ospfExtLsdbSequence" },
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXTLSDBAGE, "ospfExtLsdbAge" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFEXTLSDBCHECKSUM, "ospfExtLsdbChecksum" },
    { 7, G_SNMP_OCTETSTRING, OSPF_MIB_OSPFEXTLSDBADVERTISEMENT, "ospfExtLsdbAdvertisement" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ospfAreaAggregateEntry[] = {1, 3, 6, 1, 2, 1, 14, 14, 1};

static attribute_t attr_ospfAreaAggregateEntry[] = {
    { 5, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREAAGGREGATESTATUS, "ospfAreaAggregateStatus" },
    { 6, G_SNMP_INTEGER32, OSPF_MIB_OSPFAREAAGGREGATEEFFECT, "ospfAreaAggregateEffect" },
    { 0, 0, 0, NULL }
};


ospf_mib_ospfGeneralGroup_t *
ospf_mib_new_ospfGeneralGroup()
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;

    ospfGeneralGroup = (ospf_mib_ospfGeneralGroup_t *) g_malloc0(sizeof(ospf_mib_ospfGeneralGroup_t) + sizeof(gpointer));
    return ospfGeneralGroup;
}

static ospf_mib_ospfGeneralGroup_t *
assign_ospfGeneralGroup(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;
    guint32 idx;
    char *p;

    ospfGeneralGroup = ospf_mib_new_ospfGeneralGroup();
    if (! ospfGeneralGroup) {
        return NULL;
    }

    p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfGeneralGroup, sizeof(oid_ospfGeneralGroup)/sizeof(guint32),
                   attr_ospfGeneralGroup, &idx) < 0) continue;

        switch (idx) {
        case 1:
            if (vb->syntax_len != 4) break;
            ospfGeneralGroup->ospfRouterId = vb->syntax.uc;
            break;
        case 2:
            ospfGeneralGroup->ospfAdminStat = &(vb->syntax.i32[0]);
            break;
        case 3:
            ospfGeneralGroup->ospfVersionNumber = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfGeneralGroup->ospfAreaBdrRtrStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfGeneralGroup->ospfASBdrRtrStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfGeneralGroup->ospfExternLsaCount = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfGeneralGroup->ospfExternLsaCksumSum = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfGeneralGroup->ospfTOSSupport = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfGeneralGroup->ospfOriginateNewLsas = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ospfGeneralGroup->ospfRxNewLsas = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ospfGeneralGroup->ospfExtLsdbLimit = &(vb->syntax.i32[0]);
            break;
        case 12:
            ospfGeneralGroup->ospfMulticastExtensions = &(vb->syntax.i32[0]);
            break;
        case 13:
            ospfGeneralGroup->ospfExitOverflowInterval = &(vb->syntax.i32[0]);
            break;
        case 14:
            ospfGeneralGroup->ospfDemandExtensions = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfGeneralGroup;
}

void
ospf_mib_get_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t **ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0};

    *ospfGeneralGroup = NULL;

    add_attributes(s, &in, base, 9, 8, attr_ospfGeneralGroup, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfGeneralGroup = assign_ospfGeneralGroup(out);
    }
}

void
ospf_mib_set_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0, 0};

    if (ospfGeneralGroup->ospfRouterId) {
        base[8] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_IPADDRESS,
                       ospfGeneralGroup->ospfRouterId,
                       4);
    }
    if (ospfGeneralGroup->ospfAdminStat) {
        base[8] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfAdminStat,
                       0);
    }
    if (ospfGeneralGroup->ospfASBdrRtrStatus) {
        base[8] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfASBdrRtrStatus,
                       0);
    }
    if (ospfGeneralGroup->ospfTOSSupport) {
        base[8] = 8;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfTOSSupport,
                       0);
    }
    if (ospfGeneralGroup->ospfExtLsdbLimit) {
        base[8] = 11;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfExtLsdbLimit,
                       0);
    }
    if (ospfGeneralGroup->ospfMulticastExtensions) {
        base[8] = 12;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfMulticastExtensions,
                       0);
    }
    if (ospfGeneralGroup->ospfExitOverflowInterval) {
        base[8] = 13;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfExitOverflowInterval,
                       0);
    }
    if (ospfGeneralGroup->ospfDemandExtensions) {
        base[8] = 14;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ospfGeneralGroup->ospfDemandExtensions,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfGeneralGroup(ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup)
{
    GSList *vbl;
    char *p;

    if (ospfGeneralGroup) {
        p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfGeneralGroup);
    }
}

ospf_mib_ospfAreaEntry_t *
ospf_mib_new_ospfAreaEntry()
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;

    ospfAreaEntry = (ospf_mib_ospfAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaEntry_t) + sizeof(gpointer));
    return ospfAreaEntry;
}

static int
unpack_ospfAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaEntry->ospfAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaEntry(guint32 *base, guchar *ospfAreaId)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaEntry_t *
assign_ospfAreaEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;
    guint32 idx;
    char *p;

    ospfAreaEntry = ospf_mib_new_ospfAreaEntry();
    if (! ospfAreaEntry) {
        return NULL;
    }

    p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaEntry((GSnmpVarBind *) vbl->data, ospfAreaEntry) < 0) {
        g_warning("illegal ospfAreaEntry instance identifier");
        g_free(ospfAreaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfAreaEntry, sizeof(oid_ospfAreaEntry)/sizeof(guint32),
                   attr_ospfAreaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ospfAreaEntry->ospfAuthType = &(vb->syntax.i32[0]);
            break;
        case 3:
            ospfAreaEntry->ospfImportAsExtern = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfAreaEntry->ospfSpfRuns = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ospfAreaEntry->ospfAreaBdrRtrCount = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ospfAreaEntry->ospfAsBdrRtrCount = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfAreaEntry->ospfAreaLsaCount = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfAreaEntry->ospfAreaLsaCksumSum = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfAreaEntry->ospfAreaSummary = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfAreaEntry->ospfAreaStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaEntry;
}

void
ospf_mib_get_ospfAreaTable(GSnmpSession *s, ospf_mib_ospfAreaEntry_t ***ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 2, 1, 0};

    *ospfAreaEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfAreaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaEntry = (ospf_mib_ospfAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaEntry_t *));
        if (! *ospfAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaEntry)[i] = assign_ospfAreaEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t **ospfAreaEntry, guchar *ospfAreaId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaEntry, sizeof(oid_ospfAreaEntry));
    len = pack_ospfAreaEntry(base, ospfAreaId);
    if (len < 0) {
        g_warning("illegal ospfAreaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfAreaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaEntry = assign_ospfAreaEntry(out);
    }
}

void
ospf_mib_set_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t *ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaEntry, sizeof(oid_ospfAreaEntry));
    len = pack_ospfAreaEntry(base, ospfAreaEntry->ospfAreaId);
    if (len < 0) {
        g_warning("illegal ospfAreaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfAreaEntry->ospfAuthType) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaEntry->ospfAuthType,
                       0);
    }
    if (ospfAreaEntry->ospfImportAsExtern) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaEntry->ospfImportAsExtern,
                       0);
    }
    if (ospfAreaEntry->ospfAreaSummary) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaEntry->ospfAreaSummary,
                       0);
    }
    if (ospfAreaEntry->ospfAreaStatus) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaEntry->ospfAreaStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaEntry(ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaEntry) {
        p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaEntry);
    }
}

void
ospf_mib_free_ospfAreaTable(ospf_mib_ospfAreaEntry_t **ospfAreaEntry)
{
    int i;

    if (ospfAreaEntry) {
        for (i = 0; ospfAreaEntry[i]; i++) {
            ospf_mib_free_ospfAreaEntry(ospfAreaEntry[i]);
        }
        g_free(ospfAreaEntry);
    }
}

ospf_mib_ospfStubAreaEntry_t *
ospf_mib_new_ospfStubAreaEntry()
{
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;

    ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfStubAreaEntry_t) + sizeof(gpointer));
    return ospfStubAreaEntry;
}

static int
unpack_ospfStubAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfStubAreaEntry->ospfStubAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfStubAreaEntry->ospfStubTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfStubAreaEntry(guint32 *base, guchar *ospfStubAreaId, gint32 ospfStubTOS)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfStubAreaId[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfStubTOS;
    return idx;
}

static ospf_mib_ospfStubAreaEntry_t *
assign_ospfStubAreaEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;
    guint32 idx;
    char *p;

    ospfStubAreaEntry = ospf_mib_new_ospfStubAreaEntry();
    if (! ospfStubAreaEntry) {
        return NULL;
    }

    p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfStubAreaEntry((GSnmpVarBind *) vbl->data, ospfStubAreaEntry) < 0) {
        g_warning("illegal ospfStubAreaEntry instance identifier");
        g_free(ospfStubAreaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfStubAreaEntry, sizeof(oid_ospfStubAreaEntry)/sizeof(guint32),
                   attr_ospfStubAreaEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfStubAreaEntry->ospfStubMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfStubAreaEntry->ospfStubStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfStubAreaEntry->ospfStubMetricType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfStubAreaEntry;
}

void
ospf_mib_get_ospfStubAreaTable(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t ***ospfStubAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 3, 1, 0};

    *ospfStubAreaEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfStubAreaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfStubAreaEntry_t *));
        if (! *ospfStubAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfStubAreaEntry)[i] = assign_ospfStubAreaEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfStubAreaEntry(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t **ospfStubAreaEntry, guchar *ospfStubAreaId, gint32 ospfStubTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfStubAreaEntry, sizeof(oid_ospfStubAreaEntry));
    len = pack_ospfStubAreaEntry(base, ospfStubAreaId, ospfStubTOS);
    if (len < 0) {
        g_warning("illegal ospfStubAreaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfStubAreaEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfStubAreaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfStubAreaEntry = assign_ospfStubAreaEntry(out);
    }
}

void
ospf_mib_set_ospfStubAreaEntry(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfStubAreaEntry, sizeof(oid_ospfStubAreaEntry));
    len = pack_ospfStubAreaEntry(base, ospfStubAreaEntry->ospfStubAreaId, ospfStubAreaEntry->ospfStubTOS);
    if (len < 0) {
        g_warning("illegal ospfStubAreaEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfStubAreaEntry->ospfStubMetric) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfStubAreaEntry->ospfStubMetric,
                       0);
    }
    if (ospfStubAreaEntry->ospfStubStatus) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfStubAreaEntry->ospfStubStatus,
                       0);
    }
    if (ospfStubAreaEntry->ospfStubMetricType) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfStubAreaEntry->ospfStubMetricType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfStubAreaEntry(ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfStubAreaEntry) {
        p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfStubAreaEntry);
    }
}

void
ospf_mib_free_ospfStubAreaTable(ospf_mib_ospfStubAreaEntry_t **ospfStubAreaEntry)
{
    int i;

    if (ospfStubAreaEntry) {
        for (i = 0; ospfStubAreaEntry[i]; i++) {
            ospf_mib_free_ospfStubAreaEntry(ospfStubAreaEntry[i]);
        }
        g_free(ospfStubAreaEntry);
    }
}

ospf_mib_ospfLsdbEntry_t *
ospf_mib_new_ospfLsdbEntry()
{
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;

    ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfLsdbEntry_t) + sizeof(gpointer));
    return ospfLsdbEntry;
}

static int
unpack_ospfLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfLsdbEntry->ospfLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfLsdbEntry(guint32 *base, guchar *ospfLsdbAreaId, gint32 ospfLsdbType, guchar *ospfLsdbLsid, guchar *ospfLsdbRouterId)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbAreaId[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbLsid[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbRouterId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfLsdbEntry_t *
assign_ospfLsdbEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;
    guint32 idx;
    char *p;

    ospfLsdbEntry = ospf_mib_new_ospfLsdbEntry();
    if (! ospfLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfLsdbEntry((GSnmpVarBind *) vbl->data, ospfLsdbEntry) < 0) {
        g_warning("illegal ospfLsdbEntry instance identifier");
        g_free(ospfLsdbEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfLsdbEntry, sizeof(oid_ospfLsdbEntry)/sizeof(guint32),
                   attr_ospfLsdbEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            ospfLsdbEntry->ospfLsdbSequence = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfLsdbEntry->ospfLsdbAge = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfLsdbEntry->ospfLsdbChecksum = &(vb->syntax.i32[0]);
            break;
        case 8:
            if (vb->syntax_len < 1) break;
            ospfLsdbEntry->_ospfLsdbAdvertisementLength = vb->syntax_len;
            ospfLsdbEntry->ospfLsdbAdvertisement = vb->syntax.uc;
            break;
        };
    }

    return ospfLsdbEntry;
}

void
ospf_mib_get_ospfLsdbTable(GSnmpSession *s, ospf_mib_ospfLsdbEntry_t ***ospfLsdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 4, 1, 0};

    *ospfLsdbEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfLsdbEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfLsdbEntry_t *));
        if (! *ospfLsdbEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfLsdbEntry)[i] = assign_ospfLsdbEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfLsdbEntry(GSnmpSession *s, ospf_mib_ospfLsdbEntry_t **ospfLsdbEntry, guchar *ospfLsdbAreaId, gint32 ospfLsdbType, guchar *ospfLsdbLsid, guchar *ospfLsdbRouterId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfLsdbEntry, sizeof(oid_ospfLsdbEntry));
    len = pack_ospfLsdbEntry(base, ospfLsdbAreaId, ospfLsdbType, ospfLsdbLsid, ospfLsdbRouterId);
    if (len < 0) {
        g_warning("illegal ospfLsdbEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfLsdbEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfLsdbEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfLsdbEntry = assign_ospfLsdbEntry(out);
    }
}

void
ospf_mib_free_ospfLsdbEntry(ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfLsdbEntry) {
        p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfLsdbEntry);
    }
}

void
ospf_mib_free_ospfLsdbTable(ospf_mib_ospfLsdbEntry_t **ospfLsdbEntry)
{
    int i;

    if (ospfLsdbEntry) {
        for (i = 0; ospfLsdbEntry[i]; i++) {
            ospf_mib_free_ospfLsdbEntry(ospfLsdbEntry[i]);
        }
        g_free(ospfLsdbEntry);
    }
}

ospf_mib_ospfAreaRangeEntry_t *
ospf_mib_new_ospfAreaRangeEntry()
{
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;

    ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaRangeEntry_t) + sizeof(gpointer));
    return ospfAreaRangeEntry;
}

static int
unpack_ospfAreaRangeEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeNet[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaRangeEntry(guint32 *base, guchar *ospfAreaRangeAreaId, guchar *ospfAreaRangeNet)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaRangeAreaId[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaRangeNet[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaRangeEntry_t *
assign_ospfAreaRangeEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;
    guint32 idx;
    char *p;

    ospfAreaRangeEntry = ospf_mib_new_ospfAreaRangeEntry();
    if (! ospfAreaRangeEntry) {
        return NULL;
    }

    p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaRangeEntry((GSnmpVarBind *) vbl->data, ospfAreaRangeEntry) < 0) {
        g_warning("illegal ospfAreaRangeEntry instance identifier");
        g_free(ospfAreaRangeEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfAreaRangeEntry, sizeof(oid_ospfAreaRangeEntry)/sizeof(guint32),
                   attr_ospfAreaRangeEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len != 4) break;
            ospfAreaRangeEntry->ospfAreaRangeMask = vb->syntax.uc;
            break;
        case 4:
            ospfAreaRangeEntry->ospfAreaRangeStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfAreaRangeEntry->ospfAreaRangeEffect = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaRangeEntry;
}

void
ospf_mib_get_ospfAreaRangeTable(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t ***ospfAreaRangeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 5, 1, 0};

    *ospfAreaRangeEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfAreaRangeEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaRangeEntry_t *));
        if (! *ospfAreaRangeEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaRangeEntry)[i] = assign_ospfAreaRangeEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaRangeEntry(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t **ospfAreaRangeEntry, guchar *ospfAreaRangeAreaId, guchar *ospfAreaRangeNet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaRangeEntry, sizeof(oid_ospfAreaRangeEntry));
    len = pack_ospfAreaRangeEntry(base, ospfAreaRangeAreaId, ospfAreaRangeNet);
    if (len < 0) {
        g_warning("illegal ospfAreaRangeEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaRangeEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfAreaRangeEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaRangeEntry = assign_ospfAreaRangeEntry(out);
    }
}

void
ospf_mib_set_ospfAreaRangeEntry(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaRangeEntry, sizeof(oid_ospfAreaRangeEntry));
    len = pack_ospfAreaRangeEntry(base, ospfAreaRangeEntry->ospfAreaRangeAreaId, ospfAreaRangeEntry->ospfAreaRangeNet);
    if (len < 0) {
        g_warning("illegal ospfAreaRangeEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfAreaRangeEntry->ospfAreaRangeMask) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       ospfAreaRangeEntry->ospfAreaRangeMask,
                       4);
    }
    if (ospfAreaRangeEntry->ospfAreaRangeStatus) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaRangeEntry->ospfAreaRangeStatus,
                       0);
    }
    if (ospfAreaRangeEntry->ospfAreaRangeEffect) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaRangeEntry->ospfAreaRangeEffect,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaRangeEntry(ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaRangeEntry) {
        p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaRangeEntry);
    }
}

void
ospf_mib_free_ospfAreaRangeTable(ospf_mib_ospfAreaRangeEntry_t **ospfAreaRangeEntry)
{
    int i;

    if (ospfAreaRangeEntry) {
        for (i = 0; ospfAreaRangeEntry[i]; i++) {
            ospf_mib_free_ospfAreaRangeEntry(ospfAreaRangeEntry[i]);
        }
        g_free(ospfAreaRangeEntry);
    }
}

ospf_mib_ospfHostEntry_t *
ospf_mib_new_ospfHostEntry()
{
    ospf_mib_ospfHostEntry_t *ospfHostEntry;

    ospfHostEntry = (ospf_mib_ospfHostEntry_t *) g_malloc0(sizeof(ospf_mib_ospfHostEntry_t) + sizeof(gpointer));
    return ospfHostEntry;
}

static int
unpack_ospfHostEntry(GSnmpVarBind *vb, ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfHostEntry->ospfHostIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfHostEntry->ospfHostTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfHostEntry(guint32 *base, guchar *ospfHostIpAddress, gint32 ospfHostTOS)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfHostIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfHostTOS;
    return idx;
}

static ospf_mib_ospfHostEntry_t *
assign_ospfHostEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfHostEntry_t *ospfHostEntry;
    guint32 idx;
    char *p;

    ospfHostEntry = ospf_mib_new_ospfHostEntry();
    if (! ospfHostEntry) {
        return NULL;
    }

    p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfHostEntry((GSnmpVarBind *) vbl->data, ospfHostEntry) < 0) {
        g_warning("illegal ospfHostEntry instance identifier");
        g_free(ospfHostEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfHostEntry, sizeof(oid_ospfHostEntry)/sizeof(guint32),
                   attr_ospfHostEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfHostEntry->ospfHostMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfHostEntry->ospfHostStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            if (vb->syntax_len != 4) break;
            ospfHostEntry->ospfHostAreaID = vb->syntax.uc;
            break;
        };
    }

    return ospfHostEntry;
}

void
ospf_mib_get_ospfHostTable(GSnmpSession *s, ospf_mib_ospfHostEntry_t ***ospfHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 6, 1, 0};

    *ospfHostEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfHostEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfHostEntry = (ospf_mib_ospfHostEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfHostEntry_t *));
        if (! *ospfHostEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfHostEntry)[i] = assign_ospfHostEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfHostEntry(GSnmpSession *s, ospf_mib_ospfHostEntry_t **ospfHostEntry, guchar *ospfHostIpAddress, gint32 ospfHostTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfHostEntry, sizeof(oid_ospfHostEntry));
    len = pack_ospfHostEntry(base, ospfHostIpAddress, ospfHostTOS);
    if (len < 0) {
        g_warning("illegal ospfHostEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfHostEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfHostEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfHostEntry = assign_ospfHostEntry(out);
    }
}

void
ospf_mib_set_ospfHostEntry(GSnmpSession *s, ospf_mib_ospfHostEntry_t *ospfHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfHostEntry, sizeof(oid_ospfHostEntry));
    len = pack_ospfHostEntry(base, ospfHostEntry->ospfHostIpAddress, ospfHostEntry->ospfHostTOS);
    if (len < 0) {
        g_warning("illegal ospfHostEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfHostEntry->ospfHostMetric) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfHostEntry->ospfHostMetric,
                       0);
    }
    if (ospfHostEntry->ospfHostStatus) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfHostEntry->ospfHostStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfHostEntry(ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    GSList *vbl;
    char *p;

    if (ospfHostEntry) {
        p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfHostEntry);
    }
}

void
ospf_mib_free_ospfHostTable(ospf_mib_ospfHostEntry_t **ospfHostEntry)
{
    int i;

    if (ospfHostEntry) {
        for (i = 0; ospfHostEntry[i]; i++) {
            ospf_mib_free_ospfHostEntry(ospfHostEntry[i]);
        }
        g_free(ospfHostEntry);
    }
}

ospf_mib_ospfIfEntry_t *
ospf_mib_new_ospfIfEntry()
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;

    ospfIfEntry = (ospf_mib_ospfIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfEntry_t) + sizeof(gpointer));
    return ospfIfEntry;
}

static int
unpack_ospfIfEntry(GSnmpVarBind *vb, ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfEntry->ospfIfIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfEntry->ospfAddressLessIf = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfIfEntry(guint32 *base, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfIfIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfAddressLessIf;
    return idx;
}

static ospf_mib_ospfIfEntry_t *
assign_ospfIfEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfIfEntry_t *ospfIfEntry;
    guint32 idx;
    char *p;

    ospfIfEntry = ospf_mib_new_ospfIfEntry();
    if (! ospfIfEntry) {
        return NULL;
    }

    p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfEntry((GSnmpVarBind *) vbl->data, ospfIfEntry) < 0) {
        g_warning("illegal ospfIfEntry instance identifier");
        g_free(ospfIfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfIfEntry, sizeof(oid_ospfIfEntry)/sizeof(guint32),
                   attr_ospfIfEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len != 4) break;
            ospfIfEntry->ospfIfAreaId = vb->syntax.uc;
            break;
        case 4:
            ospfIfEntry->ospfIfType = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfIfEntry->ospfIfAdminStat = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfIfEntry->ospfIfRtrPriority = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfIfEntry->ospfIfTransitDelay = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfIfEntry->ospfIfRetransInterval = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfIfEntry->ospfIfHelloInterval = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfIfEntry->ospfIfRtrDeadInterval = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfIfEntry->ospfIfPollInterval = &(vb->syntax.i32[0]);
            break;
        case 12:
            ospfIfEntry->ospfIfState = &(vb->syntax.i32[0]);
            break;
        case 13:
            if (vb->syntax_len != 4) break;
            ospfIfEntry->ospfIfDesignatedRouter = vb->syntax.uc;
            break;
        case 14:
            if (vb->syntax_len != 4) break;
            ospfIfEntry->ospfIfBackupDesignatedRouter = vb->syntax.uc;
            break;
        case 15:
            ospfIfEntry->ospfIfEvents = &(vb->syntax.ui32[0]);
            break;
        case 16:
            if (vb->syntax_len > 256) break;
            ospfIfEntry->_ospfIfAuthKeyLength = vb->syntax_len;
            ospfIfEntry->ospfIfAuthKey = vb->syntax.uc;
            break;
        case 17:
            ospfIfEntry->ospfIfStatus = &(vb->syntax.i32[0]);
            break;
        case 18:
            ospfIfEntry->ospfIfMulticastForwarding = &(vb->syntax.i32[0]);
            break;
        case 19:
            ospfIfEntry->ospfIfDemand = &(vb->syntax.i32[0]);
            break;
        case 20:
            ospfIfEntry->ospfIfAuthType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfIfEntry;
}

void
ospf_mib_get_ospfIfTable(GSnmpSession *s, ospf_mib_ospfIfEntry_t ***ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 7, 1, 0};

    *ospfIfEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfIfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfIfEntry = (ospf_mib_ospfIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfEntry_t *));
        if (! *ospfIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfIfEntry)[i] = assign_ospfIfEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t **ospfIfEntry, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfIfEntry, sizeof(oid_ospfIfEntry));
    len = pack_ospfIfEntry(base, ospfIfIpAddress, ospfAddressLessIf);
    if (len < 0) {
        g_warning("illegal ospfIfEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfIfEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfIfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfIfEntry = assign_ospfIfEntry(out);
    }
}

void
ospf_mib_set_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t *ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfIfEntry, sizeof(oid_ospfIfEntry));
    len = pack_ospfIfEntry(base, ospfIfEntry->ospfIfIpAddress, ospfIfEntry->ospfAddressLessIf);
    if (len < 0) {
        g_warning("illegal ospfIfEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfIfEntry->ospfIfAreaId) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       ospfIfEntry->ospfIfAreaId,
                       4);
    }
    if (ospfIfEntry->ospfIfType) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfType,
                       0);
    }
    if (ospfIfEntry->ospfIfAdminStat) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfAdminStat,
                       0);
    }
    if (ospfIfEntry->ospfIfRtrPriority) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfRtrPriority,
                       0);
    }
    if (ospfIfEntry->ospfIfTransitDelay) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfTransitDelay,
                       0);
    }
    if (ospfIfEntry->ospfIfRetransInterval) {
        base[9] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfRetransInterval,
                       0);
    }
    if (ospfIfEntry->ospfIfHelloInterval) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfHelloInterval,
                       0);
    }
    if (ospfIfEntry->ospfIfRtrDeadInterval) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfRtrDeadInterval,
                       0);
    }
    if (ospfIfEntry->ospfIfPollInterval) {
        base[9] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfPollInterval,
                       0);
    }
    if (ospfIfEntry->ospfIfAuthKey) {
        base[9] = 16;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       ospfIfEntry->ospfIfAuthKey,
                       ospfIfEntry->_ospfIfAuthKeyLength);
    }
    if (ospfIfEntry->ospfIfStatus) {
        base[9] = 17;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfStatus,
                       0);
    }
    if (ospfIfEntry->ospfIfMulticastForwarding) {
        base[9] = 18;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfMulticastForwarding,
                       0);
    }
    if (ospfIfEntry->ospfIfDemand) {
        base[9] = 19;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfDemand,
                       0);
    }
    if (ospfIfEntry->ospfIfAuthType) {
        base[9] = 20;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfEntry->ospfIfAuthType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfIfEntry(ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfEntry) {
        p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfEntry);
    }
}

void
ospf_mib_free_ospfIfTable(ospf_mib_ospfIfEntry_t **ospfIfEntry)
{
    int i;

    if (ospfIfEntry) {
        for (i = 0; ospfIfEntry[i]; i++) {
            ospf_mib_free_ospfIfEntry(ospfIfEntry[i]);
        }
        g_free(ospfIfEntry);
    }
}

ospf_mib_ospfIfMetricEntry_t *
ospf_mib_new_ospfIfMetricEntry()
{
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;

    ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfMetricEntry_t) + sizeof(gpointer));
    return ospfIfMetricEntry;
}

static int
unpack_ospfIfMetricEntry(GSnmpVarBind *vb, ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfMetricEntry->ospfIfMetricIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricAddressLessIf = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfIfMetricEntry(guint32 *base, guchar *ospfIfMetricIpAddress, gint32 ospfIfMetricAddressLessIf, gint32 ospfIfMetricTOS)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfIfMetricIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfIfMetricAddressLessIf;
    base[idx++] = ospfIfMetricTOS;
    return idx;
}

static ospf_mib_ospfIfMetricEntry_t *
assign_ospfIfMetricEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;
    guint32 idx;
    char *p;

    ospfIfMetricEntry = ospf_mib_new_ospfIfMetricEntry();
    if (! ospfIfMetricEntry) {
        return NULL;
    }

    p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfMetricEntry((GSnmpVarBind *) vbl->data, ospfIfMetricEntry) < 0) {
        g_warning("illegal ospfIfMetricEntry instance identifier");
        g_free(ospfIfMetricEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfIfMetricEntry, sizeof(oid_ospfIfMetricEntry)/sizeof(guint32),
                   attr_ospfIfMetricEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            ospfIfMetricEntry->ospfIfMetricValue = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfIfMetricEntry->ospfIfMetricStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfIfMetricEntry;
}

void
ospf_mib_get_ospfIfMetricTable(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t ***ospfIfMetricEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 8, 1, 0};

    *ospfIfMetricEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfIfMetricEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfMetricEntry_t *));
        if (! *ospfIfMetricEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfIfMetricEntry)[i] = assign_ospfIfMetricEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfIfMetricEntry(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t **ospfIfMetricEntry, guchar *ospfIfMetricIpAddress, gint32 ospfIfMetricAddressLessIf, gint32 ospfIfMetricTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfIfMetricEntry, sizeof(oid_ospfIfMetricEntry));
    len = pack_ospfIfMetricEntry(base, ospfIfMetricIpAddress, ospfIfMetricAddressLessIf, ospfIfMetricTOS);
    if (len < 0) {
        g_warning("illegal ospfIfMetricEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfIfMetricEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfIfMetricEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfIfMetricEntry = assign_ospfIfMetricEntry(out);
    }
}

void
ospf_mib_set_ospfIfMetricEntry(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfIfMetricEntry, sizeof(oid_ospfIfMetricEntry));
    len = pack_ospfIfMetricEntry(base, ospfIfMetricEntry->ospfIfMetricIpAddress, ospfIfMetricEntry->ospfIfMetricAddressLessIf, ospfIfMetricEntry->ospfIfMetricTOS);
    if (len < 0) {
        g_warning("illegal ospfIfMetricEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfIfMetricEntry->ospfIfMetricValue) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfMetricEntry->ospfIfMetricValue,
                       0);
    }
    if (ospfIfMetricEntry->ospfIfMetricStatus) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfIfMetricEntry->ospfIfMetricStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfIfMetricEntry(ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfMetricEntry) {
        p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfMetricEntry);
    }
}

void
ospf_mib_free_ospfIfMetricTable(ospf_mib_ospfIfMetricEntry_t **ospfIfMetricEntry)
{
    int i;

    if (ospfIfMetricEntry) {
        for (i = 0; ospfIfMetricEntry[i]; i++) {
            ospf_mib_free_ospfIfMetricEntry(ospfIfMetricEntry[i]);
        }
        g_free(ospfIfMetricEntry);
    }
}

ospf_mib_ospfVirtIfEntry_t *
ospf_mib_new_ospfVirtIfEntry()
{
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;

    ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtIfEntry_t) + sizeof(gpointer));
    return ospfVirtIfEntry;
}

static int
unpack_ospfVirtIfEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfNeighbor[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfVirtIfEntry(guint32 *base, guchar *ospfVirtIfAreaId, guchar *ospfVirtIfNeighbor)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtIfAreaId[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtIfNeighbor[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfVirtIfEntry_t *
assign_ospfVirtIfEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;
    guint32 idx;
    char *p;

    ospfVirtIfEntry = ospf_mib_new_ospfVirtIfEntry();
    if (! ospfVirtIfEntry) {
        return NULL;
    }

    p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtIfEntry((GSnmpVarBind *) vbl->data, ospfVirtIfEntry) < 0) {
        g_warning("illegal ospfVirtIfEntry instance identifier");
        g_free(ospfVirtIfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfVirtIfEntry, sizeof(oid_ospfVirtIfEntry)/sizeof(guint32),
                   attr_ospfVirtIfEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfVirtIfEntry->ospfVirtIfTransitDelay = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfVirtIfEntry->ospfVirtIfRetransInterval = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfVirtIfEntry->ospfVirtIfHelloInterval = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfVirtIfEntry->ospfVirtIfRtrDeadInterval = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfVirtIfEntry->ospfVirtIfState = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfVirtIfEntry->ospfVirtIfEvents = &(vb->syntax.ui32[0]);
            break;
        case 9:
            if (vb->syntax_len > 256) break;
            ospfVirtIfEntry->_ospfVirtIfAuthKeyLength = vb->syntax_len;
            ospfVirtIfEntry->ospfVirtIfAuthKey = vb->syntax.uc;
            break;
        case 10:
            ospfVirtIfEntry->ospfVirtIfStatus = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfVirtIfEntry->ospfVirtIfAuthType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfVirtIfEntry;
}

void
ospf_mib_get_ospfVirtIfTable(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t ***ospfVirtIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 9, 1, 0};

    *ospfVirtIfEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfVirtIfEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtIfEntry_t *));
        if (! *ospfVirtIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfVirtIfEntry)[i] = assign_ospfVirtIfEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfVirtIfEntry(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t **ospfVirtIfEntry, guchar *ospfVirtIfAreaId, guchar *ospfVirtIfNeighbor, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfVirtIfEntry, sizeof(oid_ospfVirtIfEntry));
    len = pack_ospfVirtIfEntry(base, ospfVirtIfAreaId, ospfVirtIfNeighbor);
    if (len < 0) {
        g_warning("illegal ospfVirtIfEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfVirtIfEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfVirtIfEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfVirtIfEntry = assign_ospfVirtIfEntry(out);
    }
}

void
ospf_mib_set_ospfVirtIfEntry(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfVirtIfEntry, sizeof(oid_ospfVirtIfEntry));
    len = pack_ospfVirtIfEntry(base, ospfVirtIfEntry->ospfVirtIfAreaId, ospfVirtIfEntry->ospfVirtIfNeighbor);
    if (len < 0) {
        g_warning("illegal ospfVirtIfEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfVirtIfEntry->ospfVirtIfTransitDelay) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfTransitDelay,
                       0);
    }
    if (ospfVirtIfEntry->ospfVirtIfRetransInterval) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfRetransInterval,
                       0);
    }
    if (ospfVirtIfEntry->ospfVirtIfHelloInterval) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfHelloInterval,
                       0);
    }
    if (ospfVirtIfEntry->ospfVirtIfRtrDeadInterval) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfRtrDeadInterval,
                       0);
    }
    if (ospfVirtIfEntry->ospfVirtIfAuthKey) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTETSTRING,
                       ospfVirtIfEntry->ospfVirtIfAuthKey,
                       ospfVirtIfEntry->_ospfVirtIfAuthKeyLength);
    }
    if (ospfVirtIfEntry->ospfVirtIfStatus) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfStatus,
                       0);
    }
    if (ospfVirtIfEntry->ospfVirtIfAuthType) {
        base[9] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfVirtIfEntry->ospfVirtIfAuthType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfVirtIfEntry(ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtIfEntry) {
        p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtIfEntry);
    }
}

void
ospf_mib_free_ospfVirtIfTable(ospf_mib_ospfVirtIfEntry_t **ospfVirtIfEntry)
{
    int i;

    if (ospfVirtIfEntry) {
        for (i = 0; ospfVirtIfEntry[i]; i++) {
            ospf_mib_free_ospfVirtIfEntry(ospfVirtIfEntry[i]);
        }
        g_free(ospfVirtIfEntry);
    }
}

ospf_mib_ospfNbrEntry_t *
ospf_mib_new_ospfNbrEntry()
{
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;

    ospfNbrEntry = (ospf_mib_ospfNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfNbrEntry_t) + sizeof(gpointer));
    return ospfNbrEntry;
}

static int
unpack_ospfNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfNbrEntry->ospfNbrIpAddr[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfNbrEntry->ospfNbrAddressLessIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfNbrEntry(guint32 *base, guchar *ospfNbrIpAddr, gint32 ospfNbrAddressLessIndex)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfNbrIpAddr[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfNbrAddressLessIndex;
    return idx;
}

static ospf_mib_ospfNbrEntry_t *
assign_ospfNbrEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;
    guint32 idx;
    char *p;

    ospfNbrEntry = ospf_mib_new_ospfNbrEntry();
    if (! ospfNbrEntry) {
        return NULL;
    }

    p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfNbrEntry((GSnmpVarBind *) vbl->data, ospfNbrEntry) < 0) {
        g_warning("illegal ospfNbrEntry instance identifier");
        g_free(ospfNbrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfNbrEntry, sizeof(oid_ospfNbrEntry)/sizeof(guint32),
                   attr_ospfNbrEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len != 4) break;
            ospfNbrEntry->ospfNbrRtrId = vb->syntax.uc;
            break;
        case 4:
            ospfNbrEntry->ospfNbrOptions = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfNbrEntry->ospfNbrPriority = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfNbrEntry->ospfNbrState = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfNbrEntry->ospfNbrEvents = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfNbrEntry->ospfNbrLsRetransQLen = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ospfNbrEntry->ospfNbmaNbrStatus = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfNbrEntry->ospfNbmaNbrPermanence = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfNbrEntry->ospfNbrHelloSuppressed = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfNbrEntry;
}

void
ospf_mib_get_ospfNbrTable(GSnmpSession *s, ospf_mib_ospfNbrEntry_t ***ospfNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 10, 1, 0};

    *ospfNbrEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfNbrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfNbrEntry = (ospf_mib_ospfNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfNbrEntry_t *));
        if (! *ospfNbrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfNbrEntry)[i] = assign_ospfNbrEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfNbrEntry(GSnmpSession *s, ospf_mib_ospfNbrEntry_t **ospfNbrEntry, guchar *ospfNbrIpAddr, gint32 ospfNbrAddressLessIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfNbrEntry, sizeof(oid_ospfNbrEntry));
    len = pack_ospfNbrEntry(base, ospfNbrIpAddr, ospfNbrAddressLessIndex);
    if (len < 0) {
        g_warning("illegal ospfNbrEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfNbrEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfNbrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfNbrEntry = assign_ospfNbrEntry(out);
    }
}

void
ospf_mib_set_ospfNbrEntry(GSnmpSession *s, ospf_mib_ospfNbrEntry_t *ospfNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfNbrEntry, sizeof(oid_ospfNbrEntry));
    len = pack_ospfNbrEntry(base, ospfNbrEntry->ospfNbrIpAddr, ospfNbrEntry->ospfNbrAddressLessIndex);
    if (len < 0) {
        g_warning("illegal ospfNbrEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfNbrEntry->ospfNbrPriority) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfNbrEntry->ospfNbrPriority,
                       0);
    }
    if (ospfNbrEntry->ospfNbmaNbrStatus) {
        base[9] = 9;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfNbrEntry->ospfNbmaNbrStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfNbrEntry(ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfNbrEntry) {
        p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfNbrEntry);
    }
}

void
ospf_mib_free_ospfNbrTable(ospf_mib_ospfNbrEntry_t **ospfNbrEntry)
{
    int i;

    if (ospfNbrEntry) {
        for (i = 0; ospfNbrEntry[i]; i++) {
            ospf_mib_free_ospfNbrEntry(ospfNbrEntry[i]);
        }
        g_free(ospfNbrEntry);
    }
}

ospf_mib_ospfVirtNbrEntry_t *
ospf_mib_new_ospfVirtNbrEntry()
{
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;

    ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtNbrEntry_t) + sizeof(gpointer));
    return ospfVirtNbrEntry;
}

static int
unpack_ospfVirtNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrArea[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrRtrId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfVirtNbrEntry(guint32 *base, guchar *ospfVirtNbrArea, guchar *ospfVirtNbrRtrId)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtNbrArea[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtNbrRtrId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfVirtNbrEntry_t *
assign_ospfVirtNbrEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;
    guint32 idx;
    char *p;

    ospfVirtNbrEntry = ospf_mib_new_ospfVirtNbrEntry();
    if (! ospfVirtNbrEntry) {
        return NULL;
    }

    p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtNbrEntry((GSnmpVarBind *) vbl->data, ospfVirtNbrEntry) < 0) {
        g_warning("illegal ospfVirtNbrEntry instance identifier");
        g_free(ospfVirtNbrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfVirtNbrEntry, sizeof(oid_ospfVirtNbrEntry)/sizeof(guint32),
                   attr_ospfVirtNbrEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            if (vb->syntax_len != 4) break;
            ospfVirtNbrEntry->ospfVirtNbrIpAddr = vb->syntax.uc;
            break;
        case 4:
            ospfVirtNbrEntry->ospfVirtNbrOptions = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfVirtNbrEntry->ospfVirtNbrState = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfVirtNbrEntry->ospfVirtNbrEvents = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfVirtNbrEntry->ospfVirtNbrLsRetransQLen = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfVirtNbrEntry->ospfVirtNbrHelloSuppressed = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfVirtNbrEntry;
}

void
ospf_mib_get_ospfVirtNbrTable(GSnmpSession *s, ospf_mib_ospfVirtNbrEntry_t ***ospfVirtNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 11, 1, 0};

    *ospfVirtNbrEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfVirtNbrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtNbrEntry_t *));
        if (! *ospfVirtNbrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfVirtNbrEntry)[i] = assign_ospfVirtNbrEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfVirtNbrEntry(GSnmpSession *s, ospf_mib_ospfVirtNbrEntry_t **ospfVirtNbrEntry, guchar *ospfVirtNbrArea, guchar *ospfVirtNbrRtrId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfVirtNbrEntry, sizeof(oid_ospfVirtNbrEntry));
    len = pack_ospfVirtNbrEntry(base, ospfVirtNbrArea, ospfVirtNbrRtrId);
    if (len < 0) {
        g_warning("illegal ospfVirtNbrEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfVirtNbrEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfVirtNbrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfVirtNbrEntry = assign_ospfVirtNbrEntry(out);
    }
}

void
ospf_mib_free_ospfVirtNbrEntry(ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtNbrEntry) {
        p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtNbrEntry);
    }
}

void
ospf_mib_free_ospfVirtNbrTable(ospf_mib_ospfVirtNbrEntry_t **ospfVirtNbrEntry)
{
    int i;

    if (ospfVirtNbrEntry) {
        for (i = 0; ospfVirtNbrEntry[i]; i++) {
            ospf_mib_free_ospfVirtNbrEntry(ospfVirtNbrEntry[i]);
        }
        g_free(ospfVirtNbrEntry);
    }
}

ospf_mib_ospfExtLsdbEntry_t *
ospf_mib_new_ospfExtLsdbEntry()
{
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;

    ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfExtLsdbEntry_t) + sizeof(gpointer));
    return ospfExtLsdbEntry;
}

static int
unpack_ospfExtLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    int idx = 10;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    ospfExtLsdbEntry->ospfExtLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfExtLsdbEntry(guint32 *base, gint32 ospfExtLsdbType, guchar *ospfExtLsdbLsid, guchar *ospfExtLsdbRouterId)
{
    int idx = 10;
    guint16 i, len;

    base[idx++] = ospfExtLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfExtLsdbLsid[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfExtLsdbRouterId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfExtLsdbEntry_t *
assign_ospfExtLsdbEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;
    guint32 idx;
    char *p;

    ospfExtLsdbEntry = ospf_mib_new_ospfExtLsdbEntry();
    if (! ospfExtLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfExtLsdbEntry((GSnmpVarBind *) vbl->data, ospfExtLsdbEntry) < 0) {
        g_warning("illegal ospfExtLsdbEntry instance identifier");
        g_free(ospfExtLsdbEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfExtLsdbEntry, sizeof(oid_ospfExtLsdbEntry)/sizeof(guint32),
                   attr_ospfExtLsdbEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            ospfExtLsdbEntry->ospfExtLsdbSequence = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfExtLsdbEntry->ospfExtLsdbAge = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfExtLsdbEntry->ospfExtLsdbChecksum = &(vb->syntax.i32[0]);
            break;
        case 7:
            if (vb->syntax_len != 36) break;
            ospfExtLsdbEntry->ospfExtLsdbAdvertisement = vb->syntax.uc;
            break;
        };
    }

    return ospfExtLsdbEntry;
}

void
ospf_mib_get_ospfExtLsdbTable(GSnmpSession *s, ospf_mib_ospfExtLsdbEntry_t ***ospfExtLsdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 12, 1, 0};

    *ospfExtLsdbEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfExtLsdbEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfExtLsdbEntry_t *));
        if (! *ospfExtLsdbEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfExtLsdbEntry)[i] = assign_ospfExtLsdbEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfExtLsdbEntry(GSnmpSession *s, ospf_mib_ospfExtLsdbEntry_t **ospfExtLsdbEntry, gint32 ospfExtLsdbType, guchar *ospfExtLsdbLsid, guchar *ospfExtLsdbRouterId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfExtLsdbEntry, sizeof(oid_ospfExtLsdbEntry));
    len = pack_ospfExtLsdbEntry(base, ospfExtLsdbType, ospfExtLsdbLsid, ospfExtLsdbRouterId);
    if (len < 0) {
        g_warning("illegal ospfExtLsdbEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfExtLsdbEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfExtLsdbEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfExtLsdbEntry = assign_ospfExtLsdbEntry(out);
    }
}

void
ospf_mib_free_ospfExtLsdbEntry(ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfExtLsdbEntry) {
        p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfExtLsdbEntry);
    }
}

void
ospf_mib_free_ospfExtLsdbTable(ospf_mib_ospfExtLsdbEntry_t **ospfExtLsdbEntry)
{
    int i;

    if (ospfExtLsdbEntry) {
        for (i = 0; ospfExtLsdbEntry[i]; i++) {
            ospf_mib_free_ospfExtLsdbEntry(ospfExtLsdbEntry[i]);
        }
        g_free(ospfExtLsdbEntry);
    }
}

ospf_mib_ospfAreaAggregateEntry_t *
ospf_mib_new_ospfAreaAggregateEntry()
{
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;

    ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaAggregateEntry_t) + sizeof(gpointer));
    return ospfAreaAggregateEntry;
}

static int
unpack_ospfAreaAggregateEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateAreaID[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfAreaAggregateEntry->ospfAreaAggregateLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateNet[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaAggregateEntry(guint32 *base, guchar *ospfAreaAggregateAreaID, gint32 ospfAreaAggregateLsdbType, guchar *ospfAreaAggregateNet, guchar *ospfAreaAggregateMask)
{
    int idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateAreaID[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfAreaAggregateLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateNet[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateMask[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaAggregateEntry_t *
assign_ospfAreaAggregateEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;
    guint32 idx;
    char *p;

    ospfAreaAggregateEntry = ospf_mib_new_ospfAreaAggregateEntry();
    if (! ospfAreaAggregateEntry) {
        return NULL;
    }

    p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaAggregateEntry((GSnmpVarBind *) vbl->data, ospfAreaAggregateEntry) < 0) {
        g_warning("illegal ospfAreaAggregateEntry instance identifier");
        g_free(ospfAreaAggregateEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ospfAreaAggregateEntry, sizeof(oid_ospfAreaAggregateEntry)/sizeof(guint32),
                   attr_ospfAreaAggregateEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            ospfAreaAggregateEntry->ospfAreaAggregateStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfAreaAggregateEntry->ospfAreaAggregateEffect = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaAggregateEntry;
}

void
ospf_mib_get_ospfAreaAggregateTable(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t ***ospfAreaAggregateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 14, 1, 0};

    *ospfAreaAggregateEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ospfAreaAggregateEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaAggregateEntry_t *));
        if (! *ospfAreaAggregateEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaAggregateEntry)[i] = assign_ospfAreaAggregateEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaAggregateEntry(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t **ospfAreaAggregateEntry, guchar *ospfAreaAggregateAreaID, gint32 ospfAreaAggregateLsdbType, guchar *ospfAreaAggregateNet, guchar *ospfAreaAggregateMask, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaAggregateEntry, sizeof(oid_ospfAreaAggregateEntry));
    len = pack_ospfAreaAggregateEntry(base, ospfAreaAggregateAreaID, ospfAreaAggregateLsdbType, ospfAreaAggregateNet, ospfAreaAggregateMask);
    if (len < 0) {
        g_warning("illegal ospfAreaAggregateEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaAggregateEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ospfAreaAggregateEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaAggregateEntry = assign_ospfAreaAggregateEntry(out);
    }
}

void
ospf_mib_set_ospfAreaAggregateEntry(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ospfAreaAggregateEntry, sizeof(oid_ospfAreaAggregateEntry));
    len = pack_ospfAreaAggregateEntry(base, ospfAreaAggregateEntry->ospfAreaAggregateAreaID, ospfAreaAggregateEntry->ospfAreaAggregateLsdbType, ospfAreaAggregateEntry->ospfAreaAggregateNet, ospfAreaAggregateEntry->ospfAreaAggregateMask);
    if (len < 0) {
        g_warning("illegal ospfAreaAggregateEntry index values");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    if (ospfAreaAggregateEntry->ospfAreaAggregateStatus) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaAggregateEntry->ospfAreaAggregateStatus,
                       0);
    }
    if (ospfAreaAggregateEntry->ospfAreaAggregateEffect) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ospfAreaAggregateEntry->ospfAreaAggregateEffect,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaAggregateEntry(ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaAggregateEntry) {
        p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaAggregateEntry);
    }
}

void
ospf_mib_free_ospfAreaAggregateTable(ospf_mib_ospfAreaAggregateEntry_t **ospfAreaAggregateEntry)
{
    int i;

    if (ospfAreaAggregateEntry) {
        for (i = 0; ospfAreaAggregateEntry[i]; i++) {
            ospf_mib_free_ospfAreaAggregateEntry(ospfAreaAggregateEntry[i]);
        }
        g_free(ospfAreaAggregateEntry);
    }
}


