/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.14 for the stools package.
 *
 * Derived from OSPF-MIB:
 *   The MIB module to describe the OSPF Version 2
 *   Protocol
 *
 * Revision 1995-01-20 12:25:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "ospf-mib.h"

stls_enum_t const ospf_mib_enums_ospfAdminStat[] = {
    { OSPF_MIB_OSPFADMINSTAT_ENABLED,	"enabled" },
    { OSPF_MIB_OSPFADMINSTAT_DISABLED,	"disabled" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfVersionNumber[] = {
    { OSPF_MIB_OSPFVERSIONNUMBER_VERSION2,	"version2" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaBdrRtrStatus[] = {
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_TRUE,	"true" },
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfASBdrRtrStatus[] = {
    { OSPF_MIB_OSPFASBDRRTRSTATUS_TRUE,	"true" },
    { OSPF_MIB_OSPFASBDRRTRSTATUS_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfTOSSupport[] = {
    { OSPF_MIB_OSPFTOSSUPPORT_TRUE,	"true" },
    { OSPF_MIB_OSPFTOSSUPPORT_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfDemandExtensions[] = {
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_TRUE,	"true" },
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfImportAsExtern[] = {
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTEXTERNAL,	"importExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNOEXTERNAL,	"importNoExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNSSA,	"importNssa" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaSummary[] = {
    { OSPF_MIB_OSPFAREASUMMARY_NOAREASUMMARY,	"noAreaSummary" },
    { OSPF_MIB_OSPFAREASUMMARY_SENDAREASUMMARY,	"sendAreaSummary" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaStatus[] = {
    { OSPF_MIB_OSPFAREASTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREASTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREASTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREASTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfStubStatus[] = {
    { OSPF_MIB_OSPFSTUBSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFSTUBSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfStubMetricType[] = {
    { OSPF_MIB_OSPFSTUBMETRICTYPE_OSPFMETRIC,	"ospfMetric" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_COMPARABLECOST,	"comparableCost" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_NONCOMPARABLE,	"nonComparable" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfLsdbType[] = {
    { OSPF_MIB_OSPFLSDBTYPE_ROUTERLINK,	"routerLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NETWORKLINK,	"networkLink" },
    { OSPF_MIB_OSPFLSDBTYPE_SUMMARYLINK,	"summaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASSUMMARYLINK,	"asSummaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASEXTERNALLINK,	"asExternalLink" },
    { OSPF_MIB_OSPFLSDBTYPE_MULTICASTLINK,	"multicastLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NSSAEXTERNALLINK,	"nssaExternalLink" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaRangeStatus[] = {
    { OSPF_MIB_OSPFAREARANGESTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREARANGESTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaRangeEffect[] = {
    { OSPF_MIB_OSPFAREARANGEEFFECT_ADVERTISEMATCHING,	"advertiseMatching" },
    { OSPF_MIB_OSPFAREARANGEEFFECT_DONOTADVERTISEMATCHING,	"doNotAdvertiseMatching" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfHostStatus[] = {
    { OSPF_MIB_OSPFHOSTSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFHOSTSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfType[] = {
    { OSPF_MIB_OSPFIFTYPE_BROADCAST,	"broadcast" },
    { OSPF_MIB_OSPFIFTYPE_NBMA,	"nbma" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOPOINT,	"pointToPoint" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOMULTIPOINT,	"pointToMultipoint" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfAdminStat[] = {
    { OSPF_MIB_OSPFIFADMINSTAT_ENABLED,	"enabled" },
    { OSPF_MIB_OSPFIFADMINSTAT_DISABLED,	"disabled" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfState[] = {
    { OSPF_MIB_OSPFIFSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFIFSTATE_LOOPBACK,	"loopback" },
    { OSPF_MIB_OSPFIFSTATE_WAITING,	"waiting" },
    { OSPF_MIB_OSPFIFSTATE_POINTTOPOINT,	"pointToPoint" },
    { OSPF_MIB_OSPFIFSTATE_DESIGNATEDROUTER,	"designatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_BACKUPDESIGNATEDROUTER,	"backupDesignatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_OTHERDESIGNATEDROUTER,	"otherDesignatedRouter" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfStatus[] = {
    { OSPF_MIB_OSPFIFSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFIFSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFIFSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFIFSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfMulticastForwarding[] = {
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_BLOCKED,	"blocked" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_MULTICAST,	"multicast" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_UNICAST,	"unicast" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfDemand[] = {
    { OSPF_MIB_OSPFIFDEMAND_TRUE,	"true" },
    { OSPF_MIB_OSPFIFDEMAND_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfIfMetricStatus[] = {
    { OSPF_MIB_OSPFIFMETRICSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfVirtIfState[] = {
    { OSPF_MIB_OSPFVIRTIFSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFVIRTIFSTATE_POINTTOPOINT,	"pointToPoint" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfVirtIfStatus[] = {
    { OSPF_MIB_OSPFVIRTIFSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfNbrState[] = {
    { OSPF_MIB_OSPFNBRSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFNBRSTATE_ATTEMPT,	"attempt" },
    { OSPF_MIB_OSPFNBRSTATE_INIT,	"init" },
    { OSPF_MIB_OSPFNBRSTATE_TWOWAY,	"twoWay" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGESTART,	"exchangeStart" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGE,	"exchange" },
    { OSPF_MIB_OSPFNBRSTATE_LOADING,	"loading" },
    { OSPF_MIB_OSPFNBRSTATE_FULL,	"full" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfNbmaNbrStatus[] = {
    { OSPF_MIB_OSPFNBMANBRSTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfNbmaNbrPermanence[] = {
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_DYNAMIC,	"dynamic" },
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_PERMANENT,	"permanent" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_TRUE,	"true" },
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfVirtNbrState[] = {
    { OSPF_MIB_OSPFVIRTNBRSTATE_DOWN,	"down" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_ATTEMPT,	"attempt" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_INIT,	"init" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_TWOWAY,	"twoWay" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGESTART,	"exchangeStart" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGE,	"exchange" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_LOADING,	"loading" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_FULL,	"full" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfVirtNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_TRUE,	"true" },
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_FALSE,	"false" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfExtLsdbType[] = {
    { OSPF_MIB_OSPFEXTLSDBTYPE_ASEXTERNALLINK,	"asExternalLink" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaAggregateLsdbType[] = {
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_SUMMARYLINK,	"summaryLink" },
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_NSSAEXTERNALLINK,	"nssaExternalLink" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaAggregateStatus[] = {
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_ACTIVE,	"active" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTINSERVICE,	"notInService" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTREADY,	"notReady" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDGO,	"createAndGo" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDWAIT,	"createAndWait" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_DESTROY,	"destroy" },
    { 0, NULL }
};

stls_enum_t const ospf_mib_enums_ospfAreaAggregateEffect[] = {
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_ADVERTISEMATCHING,	"advertiseMatching" },
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_DONOTADVERTISEMATCHING,	"doNotAdvertiseMatching" },
    { 0, NULL }
};


static stls_stub_attr_t _ospfGeneralGroup[] = {
    { 1, G_SNMP_IPADDRESS, "ospfRouterId" },
    { 2, G_SNMP_INTEGER32, "ospfAdminStat" },
    { 3, G_SNMP_INTEGER32, "ospfVersionNumber" },
    { 4, G_SNMP_INTEGER32, "ospfAreaBdrRtrStatus" },
    { 5, G_SNMP_INTEGER32, "ospfASBdrRtrStatus" },
    { 6, G_SNMP_UNSIGNED32, "ospfExternLsaCount" },
    { 7, G_SNMP_INTEGER32, "ospfExternLsaCksumSum" },
    { 8, G_SNMP_INTEGER32, "ospfTOSSupport" },
    { 9, G_SNMP_COUNTER32, "ospfOriginateNewLsas" },
    { 10, G_SNMP_COUNTER32, "ospfRxNewLsas" },
    { 11, G_SNMP_INTEGER32, "ospfExtLsdbLimit" },
    { 12, G_SNMP_INTEGER32, "ospfMulticastExtensions" },
    { 13, G_SNMP_INTEGER32, "ospfExitOverflowInterval" },
    { 14, G_SNMP_INTEGER32, "ospfDemandExtensions" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfAreaEntry[] = {
    { 2, G_SNMP_INTEGER32, "ospfAuthType" },
    { 3, G_SNMP_INTEGER32, "ospfImportAsExtern" },
    { 4, G_SNMP_COUNTER32, "ospfSpfRuns" },
    { 5, G_SNMP_UNSIGNED32, "ospfAreaBdrRtrCount" },
    { 6, G_SNMP_UNSIGNED32, "ospfAsBdrRtrCount" },
    { 7, G_SNMP_UNSIGNED32, "ospfAreaLsaCount" },
    { 8, G_SNMP_INTEGER32, "ospfAreaLsaCksumSum" },
    { 9, G_SNMP_INTEGER32, "ospfAreaSummary" },
    { 10, G_SNMP_INTEGER32, "ospfAreaStatus" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfStubAreaEntry[] = {
    { 3, G_SNMP_INTEGER32, "ospfStubMetric" },
    { 4, G_SNMP_INTEGER32, "ospfStubStatus" },
    { 5, G_SNMP_INTEGER32, "ospfStubMetricType" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfLsdbEntry[] = {
    { 5, G_SNMP_INTEGER32, "ospfLsdbSequence" },
    { 6, G_SNMP_INTEGER32, "ospfLsdbAge" },
    { 7, G_SNMP_INTEGER32, "ospfLsdbChecksum" },
    { 8, G_SNMP_OCTET_STRING, "ospfLsdbAdvertisement" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfAreaRangeEntry[] = {
    { 3, G_SNMP_IPADDRESS, "ospfAreaRangeMask" },
    { 4, G_SNMP_INTEGER32, "ospfAreaRangeStatus" },
    { 5, G_SNMP_INTEGER32, "ospfAreaRangeEffect" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfHostEntry[] = {
    { 3, G_SNMP_INTEGER32, "ospfHostMetric" },
    { 4, G_SNMP_INTEGER32, "ospfHostStatus" },
    { 5, G_SNMP_IPADDRESS, "ospfHostAreaID" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfIfEntry[] = {
    { 3, G_SNMP_IPADDRESS, "ospfIfAreaId" },
    { 4, G_SNMP_INTEGER32, "ospfIfType" },
    { 5, G_SNMP_INTEGER32, "ospfIfAdminStat" },
    { 6, G_SNMP_INTEGER32, "ospfIfRtrPriority" },
    { 7, G_SNMP_INTEGER32, "ospfIfTransitDelay" },
    { 8, G_SNMP_INTEGER32, "ospfIfRetransInterval" },
    { 9, G_SNMP_INTEGER32, "ospfIfHelloInterval" },
    { 10, G_SNMP_INTEGER32, "ospfIfRtrDeadInterval" },
    { 11, G_SNMP_INTEGER32, "ospfIfPollInterval" },
    { 12, G_SNMP_INTEGER32, "ospfIfState" },
    { 13, G_SNMP_IPADDRESS, "ospfIfDesignatedRouter" },
    { 14, G_SNMP_IPADDRESS, "ospfIfBackupDesignatedRouter" },
    { 15, G_SNMP_COUNTER32, "ospfIfEvents" },
    { 16, G_SNMP_OCTET_STRING, "ospfIfAuthKey" },
    { 17, G_SNMP_INTEGER32, "ospfIfStatus" },
    { 18, G_SNMP_INTEGER32, "ospfIfMulticastForwarding" },
    { 19, G_SNMP_INTEGER32, "ospfIfDemand" },
    { 20, G_SNMP_INTEGER32, "ospfIfAuthType" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfIfMetricEntry[] = {
    { 4, G_SNMP_INTEGER32, "ospfIfMetricValue" },
    { 5, G_SNMP_INTEGER32, "ospfIfMetricStatus" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfVirtIfEntry[] = {
    { 3, G_SNMP_INTEGER32, "ospfVirtIfTransitDelay" },
    { 4, G_SNMP_INTEGER32, "ospfVirtIfRetransInterval" },
    { 5, G_SNMP_INTEGER32, "ospfVirtIfHelloInterval" },
    { 6, G_SNMP_INTEGER32, "ospfVirtIfRtrDeadInterval" },
    { 7, G_SNMP_INTEGER32, "ospfVirtIfState" },
    { 8, G_SNMP_COUNTER32, "ospfVirtIfEvents" },
    { 9, G_SNMP_OCTET_STRING, "ospfVirtIfAuthKey" },
    { 10, G_SNMP_INTEGER32, "ospfVirtIfStatus" },
    { 11, G_SNMP_INTEGER32, "ospfVirtIfAuthType" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfNbrEntry[] = {
    { 3, G_SNMP_IPADDRESS, "ospfNbrRtrId" },
    { 4, G_SNMP_INTEGER32, "ospfNbrOptions" },
    { 5, G_SNMP_INTEGER32, "ospfNbrPriority" },
    { 6, G_SNMP_INTEGER32, "ospfNbrState" },
    { 7, G_SNMP_COUNTER32, "ospfNbrEvents" },
    { 8, G_SNMP_UNSIGNED32, "ospfNbrLsRetransQLen" },
    { 9, G_SNMP_INTEGER32, "ospfNbmaNbrStatus" },
    { 10, G_SNMP_INTEGER32, "ospfNbmaNbrPermanence" },
    { 11, G_SNMP_INTEGER32, "ospfNbrHelloSuppressed" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfVirtNbrEntry[] = {
    { 3, G_SNMP_IPADDRESS, "ospfVirtNbrIpAddr" },
    { 4, G_SNMP_INTEGER32, "ospfVirtNbrOptions" },
    { 5, G_SNMP_INTEGER32, "ospfVirtNbrState" },
    { 6, G_SNMP_COUNTER32, "ospfVirtNbrEvents" },
    { 7, G_SNMP_UNSIGNED32, "ospfVirtNbrLsRetransQLen" },
    { 8, G_SNMP_INTEGER32, "ospfVirtNbrHelloSuppressed" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfExtLsdbEntry[] = {
    { 4, G_SNMP_INTEGER32, "ospfExtLsdbSequence" },
    { 5, G_SNMP_INTEGER32, "ospfExtLsdbAge" },
    { 6, G_SNMP_INTEGER32, "ospfExtLsdbChecksum" },
    { 7, G_SNMP_OCTET_STRING, "ospfExtLsdbAdvertisement" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ospfAreaAggregateEntry[] = {
    { 5, G_SNMP_INTEGER32, "ospfAreaAggregateStatus" },
    { 6, G_SNMP_INTEGER32, "ospfAreaAggregateEffect" },
    { 0, 0, NULL }
};


ospf_mib_ospfGeneralGroup_t *
ospf_mib_new_ospfGeneralGroup()
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;

    ospfGeneralGroup = (ospf_mib_ospfGeneralGroup_t *) g_malloc0(sizeof(ospf_mib_ospfGeneralGroup_t) + sizeof(gpointer));
    return ospfGeneralGroup;
}

static ospf_mib_ospfGeneralGroup_t *
assign_ospfGeneralGroup(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 1};

    ospfGeneralGroup = ospf_mib_new_ospfGeneralGroup();
    if (! ospfGeneralGroup) {
        return NULL;
    }

    p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfGeneralGroup, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ospfGeneralGroup->ospfRouterId = vb->syntax.uc;
            break;
        case 2:
            ospfGeneralGroup->ospfAdminStat = &(vb->syntax.i32[0]);
            break;
        case 3:
            ospfGeneralGroup->ospfVersionNumber = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfGeneralGroup->ospfAreaBdrRtrStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfGeneralGroup->ospfASBdrRtrStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfGeneralGroup->ospfExternLsaCount = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfGeneralGroup->ospfExternLsaCksumSum = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfGeneralGroup->ospfTOSSupport = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfGeneralGroup->ospfOriginateNewLsas = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ospfGeneralGroup->ospfRxNewLsas = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ospfGeneralGroup->ospfExtLsdbLimit = &(vb->syntax.i32[0]);
            break;
        case 12:
            ospfGeneralGroup->ospfMulticastExtensions = &(vb->syntax.i32[0]);
            break;
        case 13:
            ospfGeneralGroup->ospfExitOverflowInterval = &(vb->syntax.i32[0]);
            break;
        case 14:
            ospfGeneralGroup->ospfDemandExtensions = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfGeneralGroup;
}

int
ospf_mib_get_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t **ospfGeneralGroup)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0};

    *ospfGeneralGroup = NULL;

    stls_vbl_attributes(s, &in, base, 8, _ospfGeneralGroup);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ospfGeneralGroup = assign_ospfGeneralGroup(out);

    return 0;
}

void
ospf_mib_free_ospfGeneralGroup(ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup)
{
    GSList *vbl;
    char *p;

    if (ospfGeneralGroup) {
        p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfGeneralGroup);
    }
}

ospf_mib_ospfAreaEntry_t *
ospf_mib_new_ospfAreaEntry()
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;

    ospfAreaEntry = (ospf_mib_ospfAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaEntry_t) + sizeof(gpointer));
    return ospfAreaEntry;
}

static int
unpack_ospfAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaEntry->ospfAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfAreaEntry_t *
assign_ospfAreaEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 2, 1};

    ospfAreaEntry = ospf_mib_new_ospfAreaEntry();
    if (! ospfAreaEntry) {
        return NULL;
    }

    p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaEntry((GSnmpVarBind *) vbl->data, ospfAreaEntry) < 0) {
        g_warning("illegal ospfAreaEntry instance identifier");
        g_free(ospfAreaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfAreaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ospfAreaEntry->ospfAuthType = &(vb->syntax.i32[0]);
            break;
        case 3:
            ospfAreaEntry->ospfImportAsExtern = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfAreaEntry->ospfSpfRuns = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ospfAreaEntry->ospfAreaBdrRtrCount = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ospfAreaEntry->ospfAsBdrRtrCount = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfAreaEntry->ospfAreaLsaCount = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfAreaEntry->ospfAreaLsaCksumSum = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfAreaEntry->ospfAreaSummary = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfAreaEntry->ospfAreaStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaEntry;
}

int
ospf_mib_get_ospfAreaTable(GSnmpSession *s, ospf_mib_ospfAreaEntry_t ***ospfAreaEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 2, 1, 0};

    *ospfAreaEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfAreaEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfAreaEntry = (ospf_mib_ospfAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaEntry_t *));
    if (! *ospfAreaEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfAreaEntry)[i] = assign_ospfAreaEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfAreaEntry(ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaEntry) {
        p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaEntry);
    }
}

void
ospf_mib_free_ospfAreaTable(ospf_mib_ospfAreaEntry_t **ospfAreaEntry)
{
    int i;

    if (ospfAreaEntry) {
        for (i = 0; ospfAreaEntry[i]; i++) {
            ospf_mib_free_ospfAreaEntry(ospfAreaEntry[i]);
        }
        g_free(ospfAreaEntry);
    }
}

ospf_mib_ospfStubAreaEntry_t *
ospf_mib_new_ospfStubAreaEntry()
{
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;

    ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfStubAreaEntry_t) + sizeof(gpointer));
    return ospfStubAreaEntry;
}

static int
unpack_ospfStubAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfStubAreaEntry->ospfStubAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfStubAreaEntry->ospfStubTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfStubAreaEntry_t *
assign_ospfStubAreaEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 3, 1};

    ospfStubAreaEntry = ospf_mib_new_ospfStubAreaEntry();
    if (! ospfStubAreaEntry) {
        return NULL;
    }

    p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfStubAreaEntry((GSnmpVarBind *) vbl->data, ospfStubAreaEntry) < 0) {
        g_warning("illegal ospfStubAreaEntry instance identifier");
        g_free(ospfStubAreaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfStubAreaEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfStubAreaEntry->ospfStubMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfStubAreaEntry->ospfStubStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfStubAreaEntry->ospfStubMetricType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfStubAreaEntry;
}

int
ospf_mib_get_ospfStubAreaTable(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t ***ospfStubAreaEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 3, 1, 0};

    *ospfStubAreaEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfStubAreaEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfStubAreaEntry_t *));
    if (! *ospfStubAreaEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfStubAreaEntry)[i] = assign_ospfStubAreaEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfStubAreaEntry(ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfStubAreaEntry) {
        p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfStubAreaEntry);
    }
}

void
ospf_mib_free_ospfStubAreaTable(ospf_mib_ospfStubAreaEntry_t **ospfStubAreaEntry)
{
    int i;

    if (ospfStubAreaEntry) {
        for (i = 0; ospfStubAreaEntry[i]; i++) {
            ospf_mib_free_ospfStubAreaEntry(ospfStubAreaEntry[i]);
        }
        g_free(ospfStubAreaEntry);
    }
}

ospf_mib_ospfLsdbEntry_t *
ospf_mib_new_ospfLsdbEntry()
{
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;

    ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfLsdbEntry_t) + sizeof(gpointer));
    return ospfLsdbEntry;
}

static int
unpack_ospfLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfLsdbEntry->ospfLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfLsdbEntry_t *
assign_ospfLsdbEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 4, 1};

    ospfLsdbEntry = ospf_mib_new_ospfLsdbEntry();
    if (! ospfLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfLsdbEntry((GSnmpVarBind *) vbl->data, ospfLsdbEntry) < 0) {
        g_warning("illegal ospfLsdbEntry instance identifier");
        g_free(ospfLsdbEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfLsdbEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            ospfLsdbEntry->ospfLsdbSequence = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfLsdbEntry->ospfLsdbAge = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfLsdbEntry->ospfLsdbChecksum = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfLsdbEntry->_ospfLsdbAdvertisementLength = vb->syntax_len;
            ospfLsdbEntry->ospfLsdbAdvertisement = vb->syntax.uc;
            break;
        };
    }

    return ospfLsdbEntry;
}

int
ospf_mib_get_ospfLsdbTable(GSnmpSession *s, ospf_mib_ospfLsdbEntry_t ***ospfLsdbEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 4, 1, 0};

    *ospfLsdbEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfLsdbEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfLsdbEntry_t *));
    if (! *ospfLsdbEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfLsdbEntry)[i] = assign_ospfLsdbEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfLsdbEntry(ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfLsdbEntry) {
        p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfLsdbEntry);
    }
}

void
ospf_mib_free_ospfLsdbTable(ospf_mib_ospfLsdbEntry_t **ospfLsdbEntry)
{
    int i;

    if (ospfLsdbEntry) {
        for (i = 0; ospfLsdbEntry[i]; i++) {
            ospf_mib_free_ospfLsdbEntry(ospfLsdbEntry[i]);
        }
        g_free(ospfLsdbEntry);
    }
}

ospf_mib_ospfAreaRangeEntry_t *
ospf_mib_new_ospfAreaRangeEntry()
{
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;

    ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaRangeEntry_t) + sizeof(gpointer));
    return ospfAreaRangeEntry;
}

static int
unpack_ospfAreaRangeEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeNet[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfAreaRangeEntry_t *
assign_ospfAreaRangeEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 5, 1};

    ospfAreaRangeEntry = ospf_mib_new_ospfAreaRangeEntry();
    if (! ospfAreaRangeEntry) {
        return NULL;
    }

    p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaRangeEntry((GSnmpVarBind *) vbl->data, ospfAreaRangeEntry) < 0) {
        g_warning("illegal ospfAreaRangeEntry instance identifier");
        g_free(ospfAreaRangeEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfAreaRangeEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfAreaRangeEntry->ospfAreaRangeMask = vb->syntax.uc;
            break;
        case 4:
            ospfAreaRangeEntry->ospfAreaRangeStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfAreaRangeEntry->ospfAreaRangeEffect = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaRangeEntry;
}

int
ospf_mib_get_ospfAreaRangeTable(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t ***ospfAreaRangeEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 5, 1, 0};

    *ospfAreaRangeEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfAreaRangeEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaRangeEntry_t *));
    if (! *ospfAreaRangeEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfAreaRangeEntry)[i] = assign_ospfAreaRangeEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfAreaRangeEntry(ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaRangeEntry) {
        p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaRangeEntry);
    }
}

void
ospf_mib_free_ospfAreaRangeTable(ospf_mib_ospfAreaRangeEntry_t **ospfAreaRangeEntry)
{
    int i;

    if (ospfAreaRangeEntry) {
        for (i = 0; ospfAreaRangeEntry[i]; i++) {
            ospf_mib_free_ospfAreaRangeEntry(ospfAreaRangeEntry[i]);
        }
        g_free(ospfAreaRangeEntry);
    }
}

ospf_mib_ospfHostEntry_t *
ospf_mib_new_ospfHostEntry()
{
    ospf_mib_ospfHostEntry_t *ospfHostEntry;

    ospfHostEntry = (ospf_mib_ospfHostEntry_t *) g_malloc0(sizeof(ospf_mib_ospfHostEntry_t) + sizeof(gpointer));
    return ospfHostEntry;
}

static int
unpack_ospfHostEntry(GSnmpVarBind *vb, ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfHostEntry->ospfHostIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfHostEntry->ospfHostTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfHostEntry_t *
assign_ospfHostEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfHostEntry_t *ospfHostEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 6, 1};

    ospfHostEntry = ospf_mib_new_ospfHostEntry();
    if (! ospfHostEntry) {
        return NULL;
    }

    p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfHostEntry((GSnmpVarBind *) vbl->data, ospfHostEntry) < 0) {
        g_warning("illegal ospfHostEntry instance identifier");
        g_free(ospfHostEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfHostEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfHostEntry->ospfHostMetric = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfHostEntry->ospfHostStatus = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfHostEntry->ospfHostAreaID = vb->syntax.uc;
            break;
        };
    }

    return ospfHostEntry;
}

int
ospf_mib_get_ospfHostTable(GSnmpSession *s, ospf_mib_ospfHostEntry_t ***ospfHostEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 6, 1, 0};

    *ospfHostEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfHostEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfHostEntry = (ospf_mib_ospfHostEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfHostEntry_t *));
    if (! *ospfHostEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfHostEntry)[i] = assign_ospfHostEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfHostEntry(ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    GSList *vbl;
    char *p;

    if (ospfHostEntry) {
        p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfHostEntry);
    }
}

void
ospf_mib_free_ospfHostTable(ospf_mib_ospfHostEntry_t **ospfHostEntry)
{
    int i;

    if (ospfHostEntry) {
        for (i = 0; ospfHostEntry[i]; i++) {
            ospf_mib_free_ospfHostEntry(ospfHostEntry[i]);
        }
        g_free(ospfHostEntry);
    }
}

ospf_mib_ospfIfEntry_t *
ospf_mib_new_ospfIfEntry()
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;

    ospfIfEntry = (ospf_mib_ospfIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfEntry_t) + sizeof(gpointer));
    return ospfIfEntry;
}

static int
unpack_ospfIfEntry(GSnmpVarBind *vb, ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfEntry->ospfIfIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfEntry->ospfAddressLessIf = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfIfEntry_t *
assign_ospfIfEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfIfEntry_t *ospfIfEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 7, 1};

    ospfIfEntry = ospf_mib_new_ospfIfEntry();
    if (! ospfIfEntry) {
        return NULL;
    }

    p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfEntry((GSnmpVarBind *) vbl->data, ospfIfEntry) < 0) {
        g_warning("illegal ospfIfEntry instance identifier");
        g_free(ospfIfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfIfEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfIfEntry->ospfIfAreaId = vb->syntax.uc;
            break;
        case 4:
            ospfIfEntry->ospfIfType = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfIfEntry->ospfIfAdminStat = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfIfEntry->ospfIfRtrPriority = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfIfEntry->ospfIfTransitDelay = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfIfEntry->ospfIfRetransInterval = &(vb->syntax.i32[0]);
            break;
        case 9:
            ospfIfEntry->ospfIfHelloInterval = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfIfEntry->ospfIfRtrDeadInterval = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfIfEntry->ospfIfPollInterval = &(vb->syntax.i32[0]);
            break;
        case 12:
            ospfIfEntry->ospfIfState = &(vb->syntax.i32[0]);
            break;
        case 13:
            ospfIfEntry->ospfIfDesignatedRouter = vb->syntax.uc;
            break;
        case 14:
            ospfIfEntry->ospfIfBackupDesignatedRouter = vb->syntax.uc;
            break;
        case 15:
            ospfIfEntry->ospfIfEvents = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ospfIfEntry->_ospfIfAuthKeyLength = vb->syntax_len;
            ospfIfEntry->ospfIfAuthKey = vb->syntax.uc;
            break;
        case 17:
            ospfIfEntry->ospfIfStatus = &(vb->syntax.i32[0]);
            break;
        case 18:
            ospfIfEntry->ospfIfMulticastForwarding = &(vb->syntax.i32[0]);
            break;
        case 19:
            ospfIfEntry->ospfIfDemand = &(vb->syntax.i32[0]);
            break;
        case 20:
            ospfIfEntry->ospfIfAuthType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfIfEntry;
}

int
ospf_mib_get_ospfIfTable(GSnmpSession *s, ospf_mib_ospfIfEntry_t ***ospfIfEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 7, 1, 0};

    *ospfIfEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfIfEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfIfEntry = (ospf_mib_ospfIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfEntry_t *));
    if (! *ospfIfEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfIfEntry)[i] = assign_ospfIfEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfIfEntry(ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfEntry) {
        p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfEntry);
    }
}

void
ospf_mib_free_ospfIfTable(ospf_mib_ospfIfEntry_t **ospfIfEntry)
{
    int i;

    if (ospfIfEntry) {
        for (i = 0; ospfIfEntry[i]; i++) {
            ospf_mib_free_ospfIfEntry(ospfIfEntry[i]);
        }
        g_free(ospfIfEntry);
    }
}

ospf_mib_ospfIfMetricEntry_t *
ospf_mib_new_ospfIfMetricEntry()
{
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;

    ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfMetricEntry_t) + sizeof(gpointer));
    return ospfIfMetricEntry;
}

static int
unpack_ospfIfMetricEntry(GSnmpVarBind *vb, ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfMetricEntry->ospfIfMetricIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricAddressLessIf = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfIfMetricEntry_t *
assign_ospfIfMetricEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 8, 1};

    ospfIfMetricEntry = ospf_mib_new_ospfIfMetricEntry();
    if (! ospfIfMetricEntry) {
        return NULL;
    }

    p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfMetricEntry((GSnmpVarBind *) vbl->data, ospfIfMetricEntry) < 0) {
        g_warning("illegal ospfIfMetricEntry instance identifier");
        g_free(ospfIfMetricEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfIfMetricEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            ospfIfMetricEntry->ospfIfMetricValue = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfIfMetricEntry->ospfIfMetricStatus = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfIfMetricEntry;
}

int
ospf_mib_get_ospfIfMetricTable(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t ***ospfIfMetricEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 8, 1, 0};

    *ospfIfMetricEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfIfMetricEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfMetricEntry_t *));
    if (! *ospfIfMetricEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfIfMetricEntry)[i] = assign_ospfIfMetricEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfIfMetricEntry(ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfMetricEntry) {
        p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfMetricEntry);
    }
}

void
ospf_mib_free_ospfIfMetricTable(ospf_mib_ospfIfMetricEntry_t **ospfIfMetricEntry)
{
    int i;

    if (ospfIfMetricEntry) {
        for (i = 0; ospfIfMetricEntry[i]; i++) {
            ospf_mib_free_ospfIfMetricEntry(ospfIfMetricEntry[i]);
        }
        g_free(ospfIfMetricEntry);
    }
}

ospf_mib_ospfVirtIfEntry_t *
ospf_mib_new_ospfVirtIfEntry()
{
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;

    ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtIfEntry_t) + sizeof(gpointer));
    return ospfVirtIfEntry;
}

static int
unpack_ospfVirtIfEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfNeighbor[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfVirtIfEntry_t *
assign_ospfVirtIfEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 9, 1};

    ospfVirtIfEntry = ospf_mib_new_ospfVirtIfEntry();
    if (! ospfVirtIfEntry) {
        return NULL;
    }

    p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtIfEntry((GSnmpVarBind *) vbl->data, ospfVirtIfEntry) < 0) {
        g_warning("illegal ospfVirtIfEntry instance identifier");
        g_free(ospfVirtIfEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfVirtIfEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfVirtIfEntry->ospfVirtIfTransitDelay = &(vb->syntax.i32[0]);
            break;
        case 4:
            ospfVirtIfEntry->ospfVirtIfRetransInterval = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfVirtIfEntry->ospfVirtIfHelloInterval = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfVirtIfEntry->ospfVirtIfRtrDeadInterval = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfVirtIfEntry->ospfVirtIfState = &(vb->syntax.i32[0]);
            break;
        case 8:
            ospfVirtIfEntry->ospfVirtIfEvents = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ospfVirtIfEntry->_ospfVirtIfAuthKeyLength = vb->syntax_len;
            ospfVirtIfEntry->ospfVirtIfAuthKey = vb->syntax.uc;
            break;
        case 10:
            ospfVirtIfEntry->ospfVirtIfStatus = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfVirtIfEntry->ospfVirtIfAuthType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfVirtIfEntry;
}

int
ospf_mib_get_ospfVirtIfTable(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t ***ospfVirtIfEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 9, 1, 0};

    *ospfVirtIfEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfVirtIfEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtIfEntry_t *));
    if (! *ospfVirtIfEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfVirtIfEntry)[i] = assign_ospfVirtIfEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfVirtIfEntry(ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtIfEntry) {
        p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtIfEntry);
    }
}

void
ospf_mib_free_ospfVirtIfTable(ospf_mib_ospfVirtIfEntry_t **ospfVirtIfEntry)
{
    int i;

    if (ospfVirtIfEntry) {
        for (i = 0; ospfVirtIfEntry[i]; i++) {
            ospf_mib_free_ospfVirtIfEntry(ospfVirtIfEntry[i]);
        }
        g_free(ospfVirtIfEntry);
    }
}

ospf_mib_ospfNbrEntry_t *
ospf_mib_new_ospfNbrEntry()
{
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;

    ospfNbrEntry = (ospf_mib_ospfNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfNbrEntry_t) + sizeof(gpointer));
    return ospfNbrEntry;
}

static int
unpack_ospfNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfNbrEntry->ospfNbrIpAddr[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfNbrEntry->ospfNbrAddressLessIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfNbrEntry_t *
assign_ospfNbrEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 10, 1};

    ospfNbrEntry = ospf_mib_new_ospfNbrEntry();
    if (! ospfNbrEntry) {
        return NULL;
    }

    p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfNbrEntry((GSnmpVarBind *) vbl->data, ospfNbrEntry) < 0) {
        g_warning("illegal ospfNbrEntry instance identifier");
        g_free(ospfNbrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfNbrEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfNbrEntry->ospfNbrRtrId = vb->syntax.uc;
            break;
        case 4:
            ospfNbrEntry->ospfNbrOptions = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfNbrEntry->ospfNbrPriority = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfNbrEntry->ospfNbrState = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfNbrEntry->ospfNbrEvents = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfNbrEntry->ospfNbrLsRetransQLen = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ospfNbrEntry->ospfNbmaNbrStatus = &(vb->syntax.i32[0]);
            break;
        case 10:
            ospfNbrEntry->ospfNbmaNbrPermanence = &(vb->syntax.i32[0]);
            break;
        case 11:
            ospfNbrEntry->ospfNbrHelloSuppressed = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfNbrEntry;
}

int
ospf_mib_get_ospfNbrTable(GSnmpSession *s, ospf_mib_ospfNbrEntry_t ***ospfNbrEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 10, 1, 0};

    *ospfNbrEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfNbrEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfNbrEntry = (ospf_mib_ospfNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfNbrEntry_t *));
    if (! *ospfNbrEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfNbrEntry)[i] = assign_ospfNbrEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfNbrEntry(ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfNbrEntry) {
        p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfNbrEntry);
    }
}

void
ospf_mib_free_ospfNbrTable(ospf_mib_ospfNbrEntry_t **ospfNbrEntry)
{
    int i;

    if (ospfNbrEntry) {
        for (i = 0; ospfNbrEntry[i]; i++) {
            ospf_mib_free_ospfNbrEntry(ospfNbrEntry[i]);
        }
        g_free(ospfNbrEntry);
    }
}

ospf_mib_ospfVirtNbrEntry_t *
ospf_mib_new_ospfVirtNbrEntry()
{
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;

    ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtNbrEntry_t) + sizeof(gpointer));
    return ospfVirtNbrEntry;
}

static int
unpack_ospfVirtNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrArea[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrRtrId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfVirtNbrEntry_t *
assign_ospfVirtNbrEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 11, 1};

    ospfVirtNbrEntry = ospf_mib_new_ospfVirtNbrEntry();
    if (! ospfVirtNbrEntry) {
        return NULL;
    }

    p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtNbrEntry((GSnmpVarBind *) vbl->data, ospfVirtNbrEntry) < 0) {
        g_warning("illegal ospfVirtNbrEntry instance identifier");
        g_free(ospfVirtNbrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfVirtNbrEntry, &idx) < 0) continue;

        switch (idx) {
        case 3:
            ospfVirtNbrEntry->ospfVirtNbrIpAddr = vb->syntax.uc;
            break;
        case 4:
            ospfVirtNbrEntry->ospfVirtNbrOptions = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfVirtNbrEntry->ospfVirtNbrState = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfVirtNbrEntry->ospfVirtNbrEvents = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ospfVirtNbrEntry->ospfVirtNbrLsRetransQLen = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ospfVirtNbrEntry->ospfVirtNbrHelloSuppressed = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfVirtNbrEntry;
}

int
ospf_mib_get_ospfVirtNbrTable(GSnmpSession *s, ospf_mib_ospfVirtNbrEntry_t ***ospfVirtNbrEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 11, 1, 0};

    *ospfVirtNbrEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfVirtNbrEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtNbrEntry_t *));
    if (! *ospfVirtNbrEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfVirtNbrEntry)[i] = assign_ospfVirtNbrEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfVirtNbrEntry(ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtNbrEntry) {
        p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtNbrEntry);
    }
}

void
ospf_mib_free_ospfVirtNbrTable(ospf_mib_ospfVirtNbrEntry_t **ospfVirtNbrEntry)
{
    int i;

    if (ospfVirtNbrEntry) {
        for (i = 0; ospfVirtNbrEntry[i]; i++) {
            ospf_mib_free_ospfVirtNbrEntry(ospfVirtNbrEntry[i]);
        }
        g_free(ospfVirtNbrEntry);
    }
}

ospf_mib_ospfExtLsdbEntry_t *
ospf_mib_new_ospfExtLsdbEntry()
{
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;

    ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfExtLsdbEntry_t) + sizeof(gpointer));
    return ospfExtLsdbEntry;
}

static int
unpack_ospfExtLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    int i, len, idx = 10;

    if (vb->id_len < idx) return -1;
    ospfExtLsdbEntry->ospfExtLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfExtLsdbEntry_t *
assign_ospfExtLsdbEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 12, 1};

    ospfExtLsdbEntry = ospf_mib_new_ospfExtLsdbEntry();
    if (! ospfExtLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfExtLsdbEntry((GSnmpVarBind *) vbl->data, ospfExtLsdbEntry) < 0) {
        g_warning("illegal ospfExtLsdbEntry instance identifier");
        g_free(ospfExtLsdbEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfExtLsdbEntry, &idx) < 0) continue;

        switch (idx) {
        case 4:
            ospfExtLsdbEntry->ospfExtLsdbSequence = &(vb->syntax.i32[0]);
            break;
        case 5:
            ospfExtLsdbEntry->ospfExtLsdbAge = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfExtLsdbEntry->ospfExtLsdbChecksum = &(vb->syntax.i32[0]);
            break;
        case 7:
            ospfExtLsdbEntry->ospfExtLsdbAdvertisement = vb->syntax.uc;
            break;
        };
    }

    return ospfExtLsdbEntry;
}

int
ospf_mib_get_ospfExtLsdbTable(GSnmpSession *s, ospf_mib_ospfExtLsdbEntry_t ***ospfExtLsdbEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 12, 1, 0};

    *ospfExtLsdbEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfExtLsdbEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfExtLsdbEntry_t *));
    if (! *ospfExtLsdbEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfExtLsdbEntry)[i] = assign_ospfExtLsdbEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfExtLsdbEntry(ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfExtLsdbEntry) {
        p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfExtLsdbEntry);
    }
}

void
ospf_mib_free_ospfExtLsdbTable(ospf_mib_ospfExtLsdbEntry_t **ospfExtLsdbEntry)
{
    int i;

    if (ospfExtLsdbEntry) {
        for (i = 0; ospfExtLsdbEntry[i]; i++) {
            ospf_mib_free_ospfExtLsdbEntry(ospfExtLsdbEntry[i]);
        }
        g_free(ospfExtLsdbEntry);
    }
}

ospf_mib_ospfAreaAggregateEntry_t *
ospf_mib_new_ospfAreaAggregateEntry()
{
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;

    ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaAggregateEntry_t) + sizeof(gpointer));
    return ospfAreaAggregateEntry;
}

static int
unpack_ospfAreaAggregateEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateAreaID[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfAreaAggregateEntry->ospfAreaAggregateLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateNet[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static ospf_mib_ospfAreaAggregateEntry_t *
assign_ospfAreaAggregateEntry(GSList *vbl)
{
    GSList *elem;
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 14, 14, 1};

    ospfAreaAggregateEntry = ospf_mib_new_ospfAreaAggregateEntry();
    if (! ospfAreaAggregateEntry) {
        return NULL;
    }

    p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaAggregateEntry((GSnmpVarBind *) vbl->data, ospfAreaAggregateEntry) < 0) {
        g_warning("illegal ospfAreaAggregateEntry instance identifier");
        g_free(ospfAreaAggregateEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ospfAreaAggregateEntry, &idx) < 0) continue;

        switch (idx) {
        case 5:
            ospfAreaAggregateEntry->ospfAreaAggregateStatus = &(vb->syntax.i32[0]);
            break;
        case 6:
            ospfAreaAggregateEntry->ospfAreaAggregateEffect = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ospfAreaAggregateEntry;
}

int
ospf_mib_get_ospfAreaAggregateTable(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t ***ospfAreaAggregateEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 14, 1, 0};

    *ospfAreaAggregateEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ospfAreaAggregateEntry);

    out = stls_snmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaAggregateEntry_t *));
    if (! *ospfAreaAggregateEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ospfAreaAggregateEntry)[i] = assign_ospfAreaAggregateEntry(row->data);
    }

    return 0;
}

void
ospf_mib_free_ospfAreaAggregateEntry(ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaAggregateEntry) {
        p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaAggregateEntry);
    }
}

void
ospf_mib_free_ospfAreaAggregateTable(ospf_mib_ospfAreaAggregateEntry_t **ospfAreaAggregateEntry)
{
    int i;

    if (ospfAreaAggregateEntry) {
        for (i = 0; ospfAreaAggregateEntry[i]; i++) {
            ospf_mib_free_ospfAreaAggregateEntry(ospfAreaAggregateEntry[i]);
        }
        g_free(ospfAreaAggregateEntry);
    }
}


