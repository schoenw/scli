/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Options:
 *   --scli-include='ospfGeneralGroup|ospfAreaEntry|ospfIfEntry'
 *
 * Derived from OSPF-MIB:
 *   The MIB module to describe the OSPF Version 2
 *   Protocol
 *
 * Revision 1995-01-20 12:25:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "ospf-mib.h"

GSnmpEnum const ospf_mib_enums_ospfAdminStat[] = {
    { OSPF_MIB_OSPFADMINSTAT_ENABLED,  "enabled" },
    { OSPF_MIB_OSPFADMINSTAT_DISABLED, "disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVersionNumber[] = {
    { OSPF_MIB_OSPFVERSIONNUMBER_VERSION2, "version2" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaBdrRtrStatus[] = {
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_TRUE,  "true" },
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfASBdrRtrStatus[] = {
    { OSPF_MIB_OSPFASBDRRTRSTATUS_TRUE,  "true" },
    { OSPF_MIB_OSPFASBDRRTRSTATUS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfTOSSupport[] = {
    { OSPF_MIB_OSPFTOSSUPPORT_TRUE,  "true" },
    { OSPF_MIB_OSPFTOSSUPPORT_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfDemandExtensions[] = {
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_TRUE,  "true" },
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfImportAsExtern[] = {
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTEXTERNAL,   "importExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNOEXTERNAL, "importNoExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNSSA,       "importNssa" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaSummary[] = {
    { OSPF_MIB_OSPFAREASUMMARY_NOAREASUMMARY,   "noAreaSummary" },
    { OSPF_MIB_OSPFAREASUMMARY_SENDAREASUMMARY, "sendAreaSummary" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaStatus[] = {
    { OSPF_MIB_OSPFAREASTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFAREASTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFAREASTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFAREASTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfType[] = {
    { OSPF_MIB_OSPFIFTYPE_BROADCAST,         "broadcast" },
    { OSPF_MIB_OSPFIFTYPE_NBMA,              "nbma" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOPOINT,      "pointToPoint" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOMULTIPOINT, "pointToMultipoint" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfAdminStat[] = {
    { OSPF_MIB_OSPFIFADMINSTAT_ENABLED,  "enabled" },
    { OSPF_MIB_OSPFIFADMINSTAT_DISABLED, "disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfState[] = {
    { OSPF_MIB_OSPFIFSTATE_DOWN,                   "down" },
    { OSPF_MIB_OSPFIFSTATE_LOOPBACK,               "loopback" },
    { OSPF_MIB_OSPFIFSTATE_WAITING,                "waiting" },
    { OSPF_MIB_OSPFIFSTATE_POINTTOPOINT,           "pointToPoint" },
    { OSPF_MIB_OSPFIFSTATE_DESIGNATEDROUTER,       "designatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_BACKUPDESIGNATEDROUTER, "backupDesignatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_OTHERDESIGNATEDROUTER,  "otherDesignatedRouter" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfStatus[] = {
    { OSPF_MIB_OSPFIFSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFIFSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFIFSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFIFSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfMulticastForwarding[] = {
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_BLOCKED,   "blocked" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_MULTICAST, "multicast" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_UNICAST,   "unicast" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfDemand[] = {
    { OSPF_MIB_OSPFIFDEMAND_TRUE,  "true" },
    { OSPF_MIB_OSPFIFDEMAND_FALSE, "false" },
    { 0, NULL }
};


static guint16 ospfRouterId_constraints[] = {4, 4, 0, 0};
static guint32 ospfExtLsdbLimit_constraints[] = {-1L, 2147483647L, 0, 0};
static guint32 ospfExitOverflowInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint16 ospfIfAreaId_constraints[] = {4, 4, 0, 0};
static guint32 ospfIfRtrPriority_constraints[] = {0L, 255L, 0, 0};
static guint32 ospfIfTransitDelay_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfIfRetransInterval_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfIfHelloInterval_constraints[] = {1L, 65535L, 0, 0};
static guint32 ospfIfRtrDeadInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 ospfIfPollInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint16 ospfIfDesignatedRouter_constraints[] = {4, 4, 0, 0};
static guint16 ospfIfBackupDesignatedRouter_constraints[] = {4, 4, 0, 0};
static guint16 ospfIfAuthKey_constraints[] = {0, 256, 0, 0};
static guint32 ospfIfAuthType_constraints[] = {0L, 255L, 0, 0};


static guint32 const ospfGeneralGroup_oid[] = {1, 3, 6, 1, 2, 1, 14, 1};

static GSnmpAttribute ospfGeneralGroup_attr[] = {
    { 1, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFROUTERID, "ospfRouterId",
       ospfRouterId_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfRouterId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFADMINSTAT, "ospfAdminStat",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfAdminStat),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVERSIONNUMBER, "ospfVersionNumber",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfVersionNumber),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREABDRRTRSTATUS, "ospfAreaBdrRtrStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfAreaBdrRtrStatus),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFASBDRRTRSTATUS, "ospfASBdrRtrStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfASBdrRtrStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFEXTERNLSACOUNT, "ospfExternLsaCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExternLsaCount),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTERNLSACKSUMSUM, "ospfExternLsaCksumSum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExternLsaCksumSum),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFTOSSUPPORT, "ospfTOSSupport",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfTOSSupport),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 9, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFORIGINATENEWLSAS, "ospfOriginateNewLsas",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfOriginateNewLsas),
      0,
      0 },
    { 10, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFRXNEWLSAS, "ospfRxNewLsas",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfRxNewLsas),
      0,
      0 },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTLSDBLIMIT, "ospfExtLsdbLimit",
       ospfExtLsdbLimit_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExtLsdbLimit),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFMULTICASTEXTENSIONS, "ospfMulticastExtensions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfMulticastExtensions),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 13, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXITOVERFLOWINTERVAL, "ospfExitOverflowInterval",
       ospfExitOverflowInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExitOverflowInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 14, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFDEMANDEXTENSIONS, "ospfDemandExtensions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfDemandExtensions),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfAreaEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 2, 1};

static GSnmpAttribute ospfAreaEntry_attr[] = {
    { 2, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAUTHTYPE, "ospfAuthType",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAuthType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIMPORTASEXTERN, "ospfImportAsExtern",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfImportAsExtern),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFSPFRUNS, "ospfSpfRuns",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfSpfRuns),
      0,
      0 },
    { 5, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFAREABDRRTRCOUNT, "ospfAreaBdrRtrCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaBdrRtrCount),
      0,
      0 },
    { 6, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFASBDRRTRCOUNT, "ospfAsBdrRtrCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAsBdrRtrCount),
      0,
      0 },
    { 7, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFAREALSACOUNT, "ospfAreaLsaCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaLsaCount),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREALSACKSUMSUM, "ospfAreaLsaCksumSum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaLsaCksumSum),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREASUMMARY, "ospfAreaSummary",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaSummary),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREASTATUS, "ospfAreaStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfIfEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 7, 1};

static GSnmpAttribute ospfIfEntry_attr[] = {
    { 3, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFAREAID, "ospfIfAreaId",
       ospfIfAreaId_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAreaId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFTYPE, "ospfIfType",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFADMINSTAT, "ospfIfAdminStat",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAdminStat),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRTRPRIORITY, "ospfIfRtrPriority",
       ospfIfRtrPriority_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRtrPriority),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFTRANSITDELAY, "ospfIfTransitDelay",
       ospfIfTransitDelay_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfTransitDelay),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRETRANSINTERVAL, "ospfIfRetransInterval",
       ospfIfRetransInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRetransInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 9, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFHELLOINTERVAL, "ospfIfHelloInterval",
       ospfIfHelloInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfHelloInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRTRDEADINTERVAL, "ospfIfRtrDeadInterval",
       ospfIfRtrDeadInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRtrDeadInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFPOLLINTERVAL, "ospfIfPollInterval",
       ospfIfPollInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfPollInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFSTATE, "ospfIfState",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfState),
      0,
      0 },
    { 13, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFDESIGNATEDROUTER, "ospfIfDesignatedRouter",
       ospfIfDesignatedRouter_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfDesignatedRouter),
      0,
      0 },
    { 14, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFBACKUPDESIGNATEDROUTER, "ospfIfBackupDesignatedRouter",
       ospfIfBackupDesignatedRouter_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfBackupDesignatedRouter),
      0,
      0 },
    { 15, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFIFEVENTS, "ospfIfEvents",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfEvents),
      0,
      0 },
    { 16, G_SNMP_OCTETSTRING,
      OSPF_MIB_OSPFIFAUTHKEY, "ospfIfAuthKey",
       ospfIfAuthKey_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAuthKey),
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, _ospfIfAuthKeyLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 17, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFSTATUS, "ospfIfStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 18, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFMULTICASTFORWARDING, "ospfIfMulticastForwarding",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfMulticastForwarding),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 19, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFDEMAND, "ospfIfDemand",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfDemand),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 20, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFAUTHTYPE, "ospfIfAuthType",
       ospfIfAuthType_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAuthType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


ospf_mib_ospfGeneralGroup_t *
ospf_mib_new_ospfGeneralGroup()
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;

    ospfGeneralGroup = (ospf_mib_ospfGeneralGroup_t *) g_malloc0(sizeof(ospf_mib_ospfGeneralGroup_t) + sizeof(gpointer));
    return ospfGeneralGroup;
}

static inline ospf_mib_ospfGeneralGroup_t *
assign_ospfGeneralGroup(GSList *vbl)
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;
    char *p;

    ospfGeneralGroup = ospf_mib_new_ospfGeneralGroup();
    if (! ospfGeneralGroup) {
        return NULL;
    }

    p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, ospfGeneralGroup_oid, sizeof(ospfGeneralGroup_oid)/sizeof(guint32),
                      ospfGeneralGroup_attr, ospfGeneralGroup);

    return ospfGeneralGroup;
}

void
ospf_mib_get_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t **ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0};

    *ospfGeneralGroup = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, ospfGeneralGroup_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfGeneralGroup = assign_ospfGeneralGroup(out);
    }
}

void
ospf_mib_set_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0, 0};

    gsnmp_attr_set(s, &in, base, 10, 8, ospfGeneralGroup_attr, mask, ospfGeneralGroup);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfGeneralGroup(ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup)
{
    GSList *vbl;
    char *p;

    if (ospfGeneralGroup) {
        p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfGeneralGroup);
    }
}

ospf_mib_ospfAreaEntry_t *
ospf_mib_new_ospfAreaEntry()
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;

    ospfAreaEntry = (ospf_mib_ospfAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaEntry_t) + sizeof(gpointer));
    return ospfAreaEntry;
}

static inline int
unpack_ospfAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaEntry->ospfAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static inline int
pack_ospfAreaEntry(guint32 *base, guchar *ospfAreaId)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline ospf_mib_ospfAreaEntry_t *
assign_ospfAreaEntry(GSList *vbl)
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;
    char *p;

    ospfAreaEntry = ospf_mib_new_ospfAreaEntry();
    if (! ospfAreaEntry) {
        return NULL;
    }

    p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaEntry((GSnmpVarBind *) vbl->data, ospfAreaEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfAreaEntry");
        g_free(ospfAreaEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid)/sizeof(guint32),
                      ospfAreaEntry_attr, ospfAreaEntry);

    return ospfAreaEntry;
}

void
ospf_mib_get_ospfAreaTable(GSnmpSession *s, ospf_mib_ospfAreaEntry_t ***ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 2, 1, 0};

    *ospfAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfAreaEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaEntry = (ospf_mib_ospfAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaEntry_t *));
        if (! *ospfAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaEntry)[i] = assign_ospfAreaEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t **ospfAreaEntry, guchar *ospfAreaId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid));
    len = pack_ospfAreaEntry(base, ospfAreaId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfAreaEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaEntry = assign_ospfAreaEntry(out);
    }
}

void
ospf_mib_set_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t *ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid));
    len = pack_ospfAreaEntry(base, ospfAreaEntry->ospfAreaId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfAreaEntry_attr, mask, ospfAreaEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaEntry(ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaEntry) {
        p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaEntry);
    }
}

void
ospf_mib_free_ospfAreaTable(ospf_mib_ospfAreaEntry_t **ospfAreaEntry)
{
    int i;

    if (ospfAreaEntry) {
        for (i = 0; ospfAreaEntry[i]; i++) {
            ospf_mib_free_ospfAreaEntry(ospfAreaEntry[i]);
        }
        g_free(ospfAreaEntry);
    }
}

ospf_mib_ospfIfEntry_t *
ospf_mib_new_ospfIfEntry()
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;

    ospfIfEntry = (ospf_mib_ospfIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfEntry_t) + sizeof(gpointer));
    return ospfIfEntry;
}

static inline int
unpack_ospfIfEntry(GSnmpVarBind *vb, ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfEntry->ospfIfIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfEntry->ospfAddressLessIf = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static inline int
pack_ospfIfEntry(guint32 *base, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfIfIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfAddressLessIf;
    return idx;
}

static inline ospf_mib_ospfIfEntry_t *
assign_ospfIfEntry(GSList *vbl)
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;
    char *p;

    ospfIfEntry = ospf_mib_new_ospfIfEntry();
    if (! ospfIfEntry) {
        return NULL;
    }

    p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfEntry((GSnmpVarBind *) vbl->data, ospfIfEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfIfEntry");
        g_free(ospfIfEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfIfEntry_oid, sizeof(ospfIfEntry_oid)/sizeof(guint32),
                      ospfIfEntry_attr, ospfIfEntry);

    return ospfIfEntry;
}

void
ospf_mib_get_ospfIfTable(GSnmpSession *s, ospf_mib_ospfIfEntry_t ***ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 7, 1, 0};

    *ospfIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfIfEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfIfEntry = (ospf_mib_ospfIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfEntry_t *));
        if (! *ospfIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfIfEntry)[i] = assign_ospfIfEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t **ospfIfEntry, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfEntry_oid, sizeof(ospfIfEntry_oid));
    len = pack_ospfIfEntry(base, ospfIfIpAddress, ospfAddressLessIf);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfIfEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfIfEntry = assign_ospfIfEntry(out);
    }
}

void
ospf_mib_set_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t *ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfEntry_oid, sizeof(ospfIfEntry_oid));
    len = pack_ospfIfEntry(base, ospfIfEntry->ospfIfIpAddress, ospfIfEntry->ospfAddressLessIf);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfIfEntry_attr, mask, ospfIfEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfIfEntry(ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfEntry) {
        p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfEntry);
    }
}

void
ospf_mib_free_ospfIfTable(ospf_mib_ospfIfEntry_t **ospfIfEntry)
{
    int i;

    if (ospfIfEntry) {
        for (i = 0; ospfIfEntry[i]; i++) {
            ospf_mib_free_ospfIfEntry(ospfIfEntry[i]);
        }
        g_free(ospfIfEntry);
    }
}


