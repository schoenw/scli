/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.3.1 for the scli package.
 *
 * Derived from OSPF-MIB:
 *   The MIB module to describe the OSPF Version 2
 *   Protocol
 *
 * Revision 1995-01-20 12:25:
 *   [Revision added by libsmi due to a LAST-UPDATED clause.]
 *
 * $Id$
 */

#include "ospf-mib.h"

GSnmpEnum const ospf_mib_enums_ospfAdminStat[] = {
    { OSPF_MIB_OSPFADMINSTAT_ENABLED,  "enabled" },
    { OSPF_MIB_OSPFADMINSTAT_DISABLED, "disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVersionNumber[] = {
    { OSPF_MIB_OSPFVERSIONNUMBER_VERSION2, "version2" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaBdrRtrStatus[] = {
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_TRUE,  "true" },
    { OSPF_MIB_OSPFAREABDRRTRSTATUS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfASBdrRtrStatus[] = {
    { OSPF_MIB_OSPFASBDRRTRSTATUS_TRUE,  "true" },
    { OSPF_MIB_OSPFASBDRRTRSTATUS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfTOSSupport[] = {
    { OSPF_MIB_OSPFTOSSUPPORT_TRUE,  "true" },
    { OSPF_MIB_OSPFTOSSUPPORT_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfDemandExtensions[] = {
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_TRUE,  "true" },
    { OSPF_MIB_OSPFDEMANDEXTENSIONS_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfImportAsExtern[] = {
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTEXTERNAL,   "importExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNOEXTERNAL, "importNoExternal" },
    { OSPF_MIB_OSPFIMPORTASEXTERN_IMPORTNSSA,       "importNssa" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaSummary[] = {
    { OSPF_MIB_OSPFAREASUMMARY_NOAREASUMMARY,   "noAreaSummary" },
    { OSPF_MIB_OSPFAREASUMMARY_SENDAREASUMMARY, "sendAreaSummary" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaStatus[] = {
    { OSPF_MIB_OSPFAREASTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFAREASTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFAREASTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFAREASTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFAREASTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfStubStatus[] = {
    { OSPF_MIB_OSPFSTUBSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFSTUBSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFSTUBSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFSTUBSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfStubMetricType[] = {
    { OSPF_MIB_OSPFSTUBMETRICTYPE_OSPFMETRIC,     "ospfMetric" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_COMPARABLECOST, "comparableCost" },
    { OSPF_MIB_OSPFSTUBMETRICTYPE_NONCOMPARABLE,  "nonComparable" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfLsdbType[] = {
    { OSPF_MIB_OSPFLSDBTYPE_ROUTERLINK,       "routerLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NETWORKLINK,      "networkLink" },
    { OSPF_MIB_OSPFLSDBTYPE_SUMMARYLINK,      "summaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASSUMMARYLINK,    "asSummaryLink" },
    { OSPF_MIB_OSPFLSDBTYPE_ASEXTERNALLINK,   "asExternalLink" },
    { OSPF_MIB_OSPFLSDBTYPE_MULTICASTLINK,    "multicastLink" },
    { OSPF_MIB_OSPFLSDBTYPE_NSSAEXTERNALLINK, "nssaExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaRangeStatus[] = {
    { OSPF_MIB_OSPFAREARANGESTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFAREARANGESTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFAREARANGESTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFAREARANGESTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaRangeEffect[] = {
    { OSPF_MIB_OSPFAREARANGEEFFECT_ADVERTISEMATCHING,      "advertiseMatching" },
    { OSPF_MIB_OSPFAREARANGEEFFECT_DONOTADVERTISEMATCHING, "doNotAdvertiseMatching" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfHostStatus[] = {
    { OSPF_MIB_OSPFHOSTSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFHOSTSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFHOSTSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFHOSTSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfType[] = {
    { OSPF_MIB_OSPFIFTYPE_BROADCAST,         "broadcast" },
    { OSPF_MIB_OSPFIFTYPE_NBMA,              "nbma" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOPOINT,      "pointToPoint" },
    { OSPF_MIB_OSPFIFTYPE_POINTTOMULTIPOINT, "pointToMultipoint" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfAdminStat[] = {
    { OSPF_MIB_OSPFIFADMINSTAT_ENABLED,  "enabled" },
    { OSPF_MIB_OSPFIFADMINSTAT_DISABLED, "disabled" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfState[] = {
    { OSPF_MIB_OSPFIFSTATE_DOWN,                   "down" },
    { OSPF_MIB_OSPFIFSTATE_LOOPBACK,               "loopback" },
    { OSPF_MIB_OSPFIFSTATE_WAITING,                "waiting" },
    { OSPF_MIB_OSPFIFSTATE_POINTTOPOINT,           "pointToPoint" },
    { OSPF_MIB_OSPFIFSTATE_DESIGNATEDROUTER,       "designatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_BACKUPDESIGNATEDROUTER, "backupDesignatedRouter" },
    { OSPF_MIB_OSPFIFSTATE_OTHERDESIGNATEDROUTER,  "otherDesignatedRouter" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfStatus[] = {
    { OSPF_MIB_OSPFIFSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFIFSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFIFSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFIFSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFIFSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfMulticastForwarding[] = {
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_BLOCKED,   "blocked" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_MULTICAST, "multicast" },
    { OSPF_MIB_OSPFIFMULTICASTFORWARDING_UNICAST,   "unicast" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfDemand[] = {
    { OSPF_MIB_OSPFIFDEMAND_TRUE,  "true" },
    { OSPF_MIB_OSPFIFDEMAND_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfIfMetricStatus[] = {
    { OSPF_MIB_OSPFIFMETRICSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFIFMETRICSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtIfState[] = {
    { OSPF_MIB_OSPFVIRTIFSTATE_DOWN,         "down" },
    { OSPF_MIB_OSPFVIRTIFSTATE_POINTTOPOINT, "pointToPoint" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtIfStatus[] = {
    { OSPF_MIB_OSPFVIRTIFSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFVIRTIFSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbrState[] = {
    { OSPF_MIB_OSPFNBRSTATE_DOWN,          "down" },
    { OSPF_MIB_OSPFNBRSTATE_ATTEMPT,       "attempt" },
    { OSPF_MIB_OSPFNBRSTATE_INIT,          "init" },
    { OSPF_MIB_OSPFNBRSTATE_TWOWAY,        "twoWay" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGESTART, "exchangeStart" },
    { OSPF_MIB_OSPFNBRSTATE_EXCHANGE,      "exchange" },
    { OSPF_MIB_OSPFNBRSTATE_LOADING,       "loading" },
    { OSPF_MIB_OSPFNBRSTATE_FULL,          "full" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbmaNbrStatus[] = {
    { OSPF_MIB_OSPFNBMANBRSTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFNBMANBRSTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbmaNbrPermanence[] = {
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_DYNAMIC,   "dynamic" },
    { OSPF_MIB_OSPFNBMANBRPERMANENCE_PERMANENT, "permanent" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_TRUE,  "true" },
    { OSPF_MIB_OSPFNBRHELLOSUPPRESSED_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtNbrState[] = {
    { OSPF_MIB_OSPFVIRTNBRSTATE_DOWN,          "down" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_ATTEMPT,       "attempt" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_INIT,          "init" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_TWOWAY,        "twoWay" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGESTART, "exchangeStart" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_EXCHANGE,      "exchange" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_LOADING,       "loading" },
    { OSPF_MIB_OSPFVIRTNBRSTATE_FULL,          "full" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfVirtNbrHelloSuppressed[] = {
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_TRUE,  "true" },
    { OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED_FALSE, "false" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfExtLsdbType[] = {
    { OSPF_MIB_OSPFEXTLSDBTYPE_ASEXTERNALLINK, "asExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateLsdbType[] = {
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_SUMMARYLINK,      "summaryLink" },
    { OSPF_MIB_OSPFAREAAGGREGATELSDBTYPE_NSSAEXTERNALLINK, "nssaExternalLink" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateStatus[] = {
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_ACTIVE,        "active" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTINSERVICE,  "notInService" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_NOTREADY,      "notReady" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDGO,   "createAndGo" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_CREATEANDWAIT, "createAndWait" },
    { OSPF_MIB_OSPFAREAAGGREGATESTATUS_DESTROY,       "destroy" },
    { 0, NULL }
};

GSnmpEnum const ospf_mib_enums_ospfAreaAggregateEffect[] = {
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_ADVERTISEMATCHING,      "advertiseMatching" },
    { OSPF_MIB_OSPFAREAAGGREGATEEFFECT_DONOTADVERTISEMATCHING, "doNotAdvertiseMatching" },
    { 0, NULL }
};


static guint16 ospfRouterId_constraints[] = {4, 4, 0, 0};
static guint32 ospfExtLsdbLimit_constraints[] = {-1L, 2147483647L, 0, 0};
static guint32 ospfExitOverflowInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 ospfStubMetric_constraints[] = {0L, 16777215L, 0, 0};
static guint16 ospfLsdbAdvertisement_constraints[] = {1, 65535, 0, 0};
static guint16 ospfAreaRangeMask_constraints[] = {4, 4, 0, 0};
static guint32 ospfHostMetric_constraints[] = {0L, 65535L, 0, 0};
static guint16 ospfHostAreaID_constraints[] = {4, 4, 0, 0};
static guint16 ospfIfAreaId_constraints[] = {4, 4, 0, 0};
static guint32 ospfIfRtrPriority_constraints[] = {0L, 255L, 0, 0};
static guint32 ospfIfTransitDelay_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfIfRetransInterval_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfIfHelloInterval_constraints[] = {1L, 65535L, 0, 0};
static guint32 ospfIfRtrDeadInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint32 ospfIfPollInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint16 ospfIfDesignatedRouter_constraints[] = {4, 4, 0, 0};
static guint16 ospfIfBackupDesignatedRouter_constraints[] = {4, 4, 0, 0};
static guint16 ospfIfAuthKey_constraints[] = {0, 256, 0, 0};
static guint32 ospfIfAuthType_constraints[] = {0L, 255L, 0, 0};
static guint32 ospfIfMetricValue_constraints[] = {0L, 65535L, 0, 0};
static guint32 ospfVirtIfTransitDelay_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfVirtIfRetransInterval_constraints[] = {0L, 3600L, 0, 0};
static guint32 ospfVirtIfHelloInterval_constraints[] = {1L, 65535L, 0, 0};
static guint32 ospfVirtIfRtrDeadInterval_constraints[] = {0L, 2147483647L, 0, 0};
static guint16 ospfVirtIfAuthKey_constraints[] = {0, 256, 0, 0};
static guint32 ospfVirtIfAuthType_constraints[] = {0L, 255L, 0, 0};
static guint16 ospfNbrRtrId_constraints[] = {4, 4, 0, 0};
static guint32 ospfNbrPriority_constraints[] = {0L, 255L, 0, 0};
static guint16 ospfVirtNbrIpAddr_constraints[] = {4, 4, 0, 0};
static guint16 ospfExtLsdbAdvertisement_constraints[] = {36, 36, 0, 0};


static guint32 const ospfGeneralGroup_oid[] = {1, 3, 6, 1, 2, 1, 14, 1};

static GSnmpAttribute ospfGeneralGroup_attr[] = {
    { 1, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFROUTERID, "ospfRouterId",
       ospfRouterId_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfRouterId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFADMINSTAT, "ospfAdminStat",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfAdminStat),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVERSIONNUMBER, "ospfVersionNumber",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfVersionNumber),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREABDRRTRSTATUS, "ospfAreaBdrRtrStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfAreaBdrRtrStatus),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFASBDRRTRSTATUS, "ospfASBdrRtrStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfASBdrRtrStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFEXTERNLSACOUNT, "ospfExternLsaCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExternLsaCount),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTERNLSACKSUMSUM, "ospfExternLsaCksumSum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExternLsaCksumSum),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFTOSSUPPORT, "ospfTOSSupport",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfTOSSupport),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 9, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFORIGINATENEWLSAS, "ospfOriginateNewLsas",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfOriginateNewLsas),
      0,
      0 },
    { 10, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFRXNEWLSAS, "ospfRxNewLsas",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfRxNewLsas),
      0,
      0 },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTLSDBLIMIT, "ospfExtLsdbLimit",
       ospfExtLsdbLimit_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExtLsdbLimit),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFMULTICASTEXTENSIONS, "ospfMulticastExtensions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfMulticastExtensions),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 13, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXITOVERFLOWINTERVAL, "ospfExitOverflowInterval",
       ospfExitOverflowInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfExitOverflowInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 14, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFDEMANDEXTENSIONS, "ospfDemandExtensions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfGeneralGroup_t, ospfDemandExtensions),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfAreaEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 2, 1};

static GSnmpAttribute ospfAreaEntry_attr[] = {
    { 2, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAUTHTYPE, "ospfAuthType",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAuthType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIMPORTASEXTERN, "ospfImportAsExtern",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfImportAsExtern),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFSPFRUNS, "ospfSpfRuns",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfSpfRuns),
      0,
      0 },
    { 5, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFAREABDRRTRCOUNT, "ospfAreaBdrRtrCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaBdrRtrCount),
      0,
      0 },
    { 6, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFASBDRRTRCOUNT, "ospfAsBdrRtrCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAsBdrRtrCount),
      0,
      0 },
    { 7, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFAREALSACOUNT, "ospfAreaLsaCount",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaLsaCount),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREALSACKSUMSUM, "ospfAreaLsaCksumSum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaLsaCksumSum),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREASUMMARY, "ospfAreaSummary",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaSummary),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREASTATUS, "ospfAreaStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaEntry_t, ospfAreaStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfStubAreaEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 3, 1};

static GSnmpAttribute ospfStubAreaEntry_attr[] = {
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFSTUBMETRIC, "ospfStubMetric",
       ospfStubMetric_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfStubAreaEntry_t, ospfStubMetric),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFSTUBSTATUS, "ospfStubStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfStubAreaEntry_t, ospfStubStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFSTUBMETRICTYPE, "ospfStubMetricType",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfStubAreaEntry_t, ospfStubMetricType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfLsdbEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 4, 1};

static GSnmpAttribute ospfLsdbEntry_attr[] = {
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFLSDBSEQUENCE, "ospfLsdbSequence",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfLsdbEntry_t, ospfLsdbSequence),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFLSDBAGE, "ospfLsdbAge",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfLsdbEntry_t, ospfLsdbAge),
      0,
      0 },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFLSDBCHECKSUM, "ospfLsdbChecksum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfLsdbEntry_t, ospfLsdbChecksum),
      0,
      0 },
    { 8, G_SNMP_OCTETSTRING,
      OSPF_MIB_OSPFLSDBADVERTISEMENT, "ospfLsdbAdvertisement",
       ospfLsdbAdvertisement_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfLsdbEntry_t, ospfLsdbAdvertisement),
      G_STRUCT_OFFSET(ospf_mib_ospfLsdbEntry_t, _ospfLsdbAdvertisementLength),
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ospfAreaRangeEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 5, 1};

static GSnmpAttribute ospfAreaRangeEntry_attr[] = {
    { 3, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFAREARANGEMASK, "ospfAreaRangeMask",
       ospfAreaRangeMask_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaRangeEntry_t, ospfAreaRangeMask),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREARANGESTATUS, "ospfAreaRangeStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaRangeEntry_t, ospfAreaRangeStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREARANGEEFFECT, "ospfAreaRangeEffect",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaRangeEntry_t, ospfAreaRangeEffect),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfHostEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 6, 1};

static GSnmpAttribute ospfHostEntry_attr[] = {
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFHOSTMETRIC, "ospfHostMetric",
       ospfHostMetric_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfHostEntry_t, ospfHostMetric),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFHOSTSTATUS, "ospfHostStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfHostEntry_t, ospfHostStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFHOSTAREAID, "ospfHostAreaID",
       ospfHostAreaID_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfHostEntry_t, ospfHostAreaID),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ospfIfEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 7, 1};

static GSnmpAttribute ospfIfEntry_attr[] = {
    { 3, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFAREAID, "ospfIfAreaId",
       ospfIfAreaId_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAreaId),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFTYPE, "ospfIfType",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFADMINSTAT, "ospfIfAdminStat",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAdminStat),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRTRPRIORITY, "ospfIfRtrPriority",
       ospfIfRtrPriority_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRtrPriority),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFTRANSITDELAY, "ospfIfTransitDelay",
       ospfIfTransitDelay_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfTransitDelay),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRETRANSINTERVAL, "ospfIfRetransInterval",
       ospfIfRetransInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRetransInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 9, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFHELLOINTERVAL, "ospfIfHelloInterval",
       ospfIfHelloInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfHelloInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFRTRDEADINTERVAL, "ospfIfRtrDeadInterval",
       ospfIfRtrDeadInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfRtrDeadInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFPOLLINTERVAL, "ospfIfPollInterval",
       ospfIfPollInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfPollInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 12, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFSTATE, "ospfIfState",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfState),
      0,
      0 },
    { 13, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFDESIGNATEDROUTER, "ospfIfDesignatedRouter",
       ospfIfDesignatedRouter_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfDesignatedRouter),
      0,
      0 },
    { 14, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFIFBACKUPDESIGNATEDROUTER, "ospfIfBackupDesignatedRouter",
       ospfIfBackupDesignatedRouter_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfBackupDesignatedRouter),
      0,
      0 },
    { 15, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFIFEVENTS, "ospfIfEvents",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfEvents),
      0,
      0 },
    { 16, G_SNMP_OCTETSTRING,
      OSPF_MIB_OSPFIFAUTHKEY, "ospfIfAuthKey",
       ospfIfAuthKey_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAuthKey),
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, _ospfIfAuthKeyLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 17, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFSTATUS, "ospfIfStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 18, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFMULTICASTFORWARDING, "ospfIfMulticastForwarding",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfMulticastForwarding),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 19, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFDEMAND, "ospfIfDemand",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfDemand),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 20, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFAUTHTYPE, "ospfIfAuthType",
       ospfIfAuthType_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfEntry_t, ospfIfAuthType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfIfMetricEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 8, 1};

static GSnmpAttribute ospfIfMetricEntry_attr[] = {
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFMETRICVALUE, "ospfIfMetricValue",
       ospfIfMetricValue_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfIfMetricEntry_t, ospfIfMetricValue),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFIFMETRICSTATUS, "ospfIfMetricStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfIfMetricEntry_t, ospfIfMetricStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfVirtIfEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 9, 1};

static GSnmpAttribute ospfVirtIfEntry_attr[] = {
    { 3, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFTRANSITDELAY, "ospfVirtIfTransitDelay",
       ospfVirtIfTransitDelay_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfTransitDelay),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFRETRANSINTERVAL, "ospfVirtIfRetransInterval",
       ospfVirtIfRetransInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfRetransInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFHELLOINTERVAL, "ospfVirtIfHelloInterval",
       ospfVirtIfHelloInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfHelloInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFRTRDEADINTERVAL, "ospfVirtIfRtrDeadInterval",
       ospfVirtIfRtrDeadInterval_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfRtrDeadInterval),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 7, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFSTATE, "ospfVirtIfState",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfState),
      0,
      0 },
    { 8, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFVIRTIFEVENTS, "ospfVirtIfEvents",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfEvents),
      0,
      0 },
    { 9, G_SNMP_OCTETSTRING,
      OSPF_MIB_OSPFVIRTIFAUTHKEY, "ospfVirtIfAuthKey",
       ospfVirtIfAuthKey_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfAuthKey),
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, _ospfVirtIfAuthKeyLength),
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFSTATUS, "ospfVirtIfStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTIFAUTHTYPE, "ospfVirtIfAuthType",
       ospfVirtIfAuthType_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtIfEntry_t, ospfVirtIfAuthType),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const ospfNbrEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 10, 1};

static GSnmpAttribute ospfNbrEntry_attr[] = {
    { 3, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFNBRRTRID, "ospfNbrRtrId",
       ospfNbrRtrId_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrRtrId),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBROPTIONS, "ospfNbrOptions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrOptions),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBRPRIORITY, "ospfNbrPriority",
       ospfNbrPriority_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrPriority),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBRSTATE, "ospfNbrState",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrState),
      0,
      0 },
    { 7, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFNBREVENTS, "ospfNbrEvents",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrEvents),
      0,
      0 },
    { 8, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFNBRLSRETRANSQLEN, "ospfNbrLsRetransQLen",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrLsRetransQLen),
      0,
      0 },
    { 9, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBMANBRSTATUS, "ospfNbmaNbrStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbmaNbrStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 10, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBMANBRPERMANENCE, "ospfNbmaNbrPermanence",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbmaNbrPermanence),
      0,
      0 },
    { 11, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFNBRHELLOSUPPRESSED, "ospfNbrHelloSuppressed",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfNbrEntry_t, ospfNbrHelloSuppressed),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ospfVirtNbrEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 11, 1};

static GSnmpAttribute ospfVirtNbrEntry_attr[] = {
    { 3, G_SNMP_IPADDRESS,
      OSPF_MIB_OSPFVIRTNBRIPADDR, "ospfVirtNbrIpAddr",
       ospfVirtNbrIpAddr_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrIpAddr),
      0,
      0 },
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTNBROPTIONS, "ospfVirtNbrOptions",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrOptions),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTNBRSTATE, "ospfVirtNbrState",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrState),
      0,
      0 },
    { 6, G_SNMP_COUNTER32,
      OSPF_MIB_OSPFVIRTNBREVENTS, "ospfVirtNbrEvents",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrEvents),
      0,
      0 },
    { 7, G_SNMP_UNSIGNED32,
      OSPF_MIB_OSPFVIRTNBRLSRETRANSQLEN, "ospfVirtNbrLsRetransQLen",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrLsRetransQLen),
      0,
      0 },
    { 8, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFVIRTNBRHELLOSUPPRESSED, "ospfVirtNbrHelloSuppressed",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfVirtNbrEntry_t, ospfVirtNbrHelloSuppressed),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ospfExtLsdbEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 12, 1};

static GSnmpAttribute ospfExtLsdbEntry_attr[] = {
    { 4, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTLSDBSEQUENCE, "ospfExtLsdbSequence",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfExtLsdbEntry_t, ospfExtLsdbSequence),
      0,
      0 },
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTLSDBAGE, "ospfExtLsdbAge",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfExtLsdbEntry_t, ospfExtLsdbAge),
      0,
      0 },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFEXTLSDBCHECKSUM, "ospfExtLsdbChecksum",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfExtLsdbEntry_t, ospfExtLsdbChecksum),
      0,
      0 },
    { 7, G_SNMP_OCTETSTRING,
      OSPF_MIB_OSPFEXTLSDBADVERTISEMENT, "ospfExtLsdbAdvertisement",
       ospfExtLsdbAdvertisement_constraints,
      G_STRUCT_OFFSET(ospf_mib_ospfExtLsdbEntry_t, ospfExtLsdbAdvertisement),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const ospfAreaAggregateEntry_oid[] = {1, 3, 6, 1, 2, 1, 14, 14, 1};

static GSnmpAttribute ospfAreaAggregateEntry_attr[] = {
    { 5, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREAAGGREGATESTATUS, "ospfAreaAggregateStatus",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaAggregateEntry_t, ospfAreaAggregateStatus),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 6, G_SNMP_INTEGER32,
      OSPF_MIB_OSPFAREAAGGREGATEEFFECT, "ospfAreaAggregateEffect",
       NULL,
      G_STRUCT_OFFSET(ospf_mib_ospfAreaAggregateEntry_t, ospfAreaAggregateEffect),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};


ospf_mib_ospfGeneralGroup_t *
ospf_mib_new_ospfGeneralGroup()
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;

    ospfGeneralGroup = (ospf_mib_ospfGeneralGroup_t *) g_malloc0(sizeof(ospf_mib_ospfGeneralGroup_t) + sizeof(gpointer));
    return ospfGeneralGroup;
}

static ospf_mib_ospfGeneralGroup_t *
assign_ospfGeneralGroup(GSList *vbl)
{
    ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup;
    char *p;

    ospfGeneralGroup = ospf_mib_new_ospfGeneralGroup();
    if (! ospfGeneralGroup) {
        return NULL;
    }

    p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
    * (GSList **) p = vbl;

    gsnmp_attr_assign(vbl, ospfGeneralGroup_oid, sizeof(ospfGeneralGroup_oid)/sizeof(guint32),
                      ospfGeneralGroup_attr, ospfGeneralGroup);

    return ospfGeneralGroup;
}

void
ospf_mib_get_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t **ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0};

    *ospfGeneralGroup = NULL;

    gsnmp_attr_get(s, &in, base, 9, 8, ospfGeneralGroup_attr, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfGeneralGroup = assign_ospfGeneralGroup(out);
    }
}

void
ospf_mib_set_ospfGeneralGroup(GSnmpSession *s, ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 1, 0, 0};

    gsnmp_attr_set(s, &in, base, 10, 8, ospfGeneralGroup_attr, mask, ospfGeneralGroup);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfGeneralGroup(ospf_mib_ospfGeneralGroup_t *ospfGeneralGroup)
{
    GSList *vbl;
    char *p;

    if (ospfGeneralGroup) {
        p = (char *) ospfGeneralGroup + sizeof(ospf_mib_ospfGeneralGroup_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfGeneralGroup);
    }
}

ospf_mib_ospfAreaEntry_t *
ospf_mib_new_ospfAreaEntry()
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;

    ospfAreaEntry = (ospf_mib_ospfAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaEntry_t) + sizeof(gpointer));
    return ospfAreaEntry;
}

static int
unpack_ospfAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaEntry->ospfAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaEntry(guint32 *base, guchar *ospfAreaId)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaEntry_t *
assign_ospfAreaEntry(GSList *vbl)
{
    ospf_mib_ospfAreaEntry_t *ospfAreaEntry;
    char *p;

    ospfAreaEntry = ospf_mib_new_ospfAreaEntry();
    if (! ospfAreaEntry) {
        return NULL;
    }

    p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaEntry((GSnmpVarBind *) vbl->data, ospfAreaEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfAreaEntry");
        g_free(ospfAreaEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid)/sizeof(guint32),
                      ospfAreaEntry_attr, ospfAreaEntry);

    return ospfAreaEntry;
}

void
ospf_mib_get_ospfAreaTable(GSnmpSession *s, ospf_mib_ospfAreaEntry_t ***ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 2, 1, 0};

    *ospfAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfAreaEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaEntry = (ospf_mib_ospfAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaEntry_t *));
        if (! *ospfAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaEntry)[i] = assign_ospfAreaEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t **ospfAreaEntry, guchar *ospfAreaId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid));
    len = pack_ospfAreaEntry(base, ospfAreaId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfAreaEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaEntry = assign_ospfAreaEntry(out);
    }
}

void
ospf_mib_set_ospfAreaEntry(GSnmpSession *s, ospf_mib_ospfAreaEntry_t *ospfAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaEntry_oid, sizeof(ospfAreaEntry_oid));
    len = pack_ospfAreaEntry(base, ospfAreaEntry->ospfAreaId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfAreaEntry_attr, mask, ospfAreaEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaEntry(ospf_mib_ospfAreaEntry_t *ospfAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaEntry) {
        p = (char *) ospfAreaEntry + sizeof(ospf_mib_ospfAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaEntry);
    }
}

void
ospf_mib_free_ospfAreaTable(ospf_mib_ospfAreaEntry_t **ospfAreaEntry)
{
    int i;

    if (ospfAreaEntry) {
        for (i = 0; ospfAreaEntry[i]; i++) {
            ospf_mib_free_ospfAreaEntry(ospfAreaEntry[i]);
        }
        g_free(ospfAreaEntry);
    }
}

ospf_mib_ospfStubAreaEntry_t *
ospf_mib_new_ospfStubAreaEntry()
{
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;

    ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t *) g_malloc0(sizeof(ospf_mib_ospfStubAreaEntry_t) + sizeof(gpointer));
    return ospfStubAreaEntry;
}

static int
unpack_ospfStubAreaEntry(GSnmpVarBind *vb, ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfStubAreaEntry->ospfStubAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfStubAreaEntry->ospfStubTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfStubAreaEntry(guint32 *base, guchar *ospfStubAreaId, gint32 ospfStubTOS)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfStubAreaId[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfStubTOS;
    return idx;
}

static ospf_mib_ospfStubAreaEntry_t *
assign_ospfStubAreaEntry(GSList *vbl)
{
    ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry;
    char *p;

    ospfStubAreaEntry = ospf_mib_new_ospfStubAreaEntry();
    if (! ospfStubAreaEntry) {
        return NULL;
    }

    p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfStubAreaEntry((GSnmpVarBind *) vbl->data, ospfStubAreaEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfStubAreaEntry");
        g_free(ospfStubAreaEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfStubAreaEntry_oid, sizeof(ospfStubAreaEntry_oid)/sizeof(guint32),
                      ospfStubAreaEntry_attr, ospfStubAreaEntry);

    return ospfStubAreaEntry;
}

void
ospf_mib_get_ospfStubAreaTable(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t ***ospfStubAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 3, 1, 0};

    *ospfStubAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfStubAreaEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfStubAreaEntry = (ospf_mib_ospfStubAreaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfStubAreaEntry_t *));
        if (! *ospfStubAreaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfStubAreaEntry)[i] = assign_ospfStubAreaEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfStubAreaEntry(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t **ospfStubAreaEntry, guchar *ospfStubAreaId, gint32 ospfStubTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfStubAreaEntry_oid, sizeof(ospfStubAreaEntry_oid));
    len = pack_ospfStubAreaEntry(base, ospfStubAreaId, ospfStubTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfStubAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfStubAreaEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfStubAreaEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfStubAreaEntry = assign_ospfStubAreaEntry(out);
    }
}

void
ospf_mib_set_ospfStubAreaEntry(GSnmpSession *s, ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfStubAreaEntry_oid, sizeof(ospfStubAreaEntry_oid));
    len = pack_ospfStubAreaEntry(base, ospfStubAreaEntry->ospfStubAreaId, ospfStubAreaEntry->ospfStubTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfStubAreaEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfStubAreaEntry_attr, mask, ospfStubAreaEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfStubAreaEntry(ospf_mib_ospfStubAreaEntry_t *ospfStubAreaEntry)
{
    GSList *vbl;
    char *p;

    if (ospfStubAreaEntry) {
        p = (char *) ospfStubAreaEntry + sizeof(ospf_mib_ospfStubAreaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfStubAreaEntry);
    }
}

void
ospf_mib_free_ospfStubAreaTable(ospf_mib_ospfStubAreaEntry_t **ospfStubAreaEntry)
{
    int i;

    if (ospfStubAreaEntry) {
        for (i = 0; ospfStubAreaEntry[i]; i++) {
            ospf_mib_free_ospfStubAreaEntry(ospfStubAreaEntry[i]);
        }
        g_free(ospfStubAreaEntry);
    }
}

ospf_mib_ospfLsdbEntry_t *
ospf_mib_new_ospfLsdbEntry()
{
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;

    ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfLsdbEntry_t) + sizeof(gpointer));
    return ospfLsdbEntry;
}

static int
unpack_ospfLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbAreaId[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfLsdbEntry->ospfLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfLsdbEntry->ospfLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfLsdbEntry(guint32 *base, guchar *ospfLsdbAreaId, gint32 ospfLsdbType, guchar *ospfLsdbLsid, guchar *ospfLsdbRouterId)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbAreaId[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbLsid[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfLsdbRouterId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfLsdbEntry_t *
assign_ospfLsdbEntry(GSList *vbl)
{
    ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry;
    char *p;

    ospfLsdbEntry = ospf_mib_new_ospfLsdbEntry();
    if (! ospfLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfLsdbEntry((GSnmpVarBind *) vbl->data, ospfLsdbEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfLsdbEntry");
        g_free(ospfLsdbEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfLsdbEntry_oid, sizeof(ospfLsdbEntry_oid)/sizeof(guint32),
                      ospfLsdbEntry_attr, ospfLsdbEntry);

    return ospfLsdbEntry;
}

void
ospf_mib_get_ospfLsdbTable(GSnmpSession *s, ospf_mib_ospfLsdbEntry_t ***ospfLsdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 4, 1, 0};

    *ospfLsdbEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfLsdbEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfLsdbEntry = (ospf_mib_ospfLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfLsdbEntry_t *));
        if (! *ospfLsdbEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfLsdbEntry)[i] = assign_ospfLsdbEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfLsdbEntry(GSnmpSession *s, ospf_mib_ospfLsdbEntry_t **ospfLsdbEntry, guchar *ospfLsdbAreaId, gint32 ospfLsdbType, guchar *ospfLsdbLsid, guchar *ospfLsdbRouterId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfLsdbEntry_oid, sizeof(ospfLsdbEntry_oid));
    len = pack_ospfLsdbEntry(base, ospfLsdbAreaId, ospfLsdbType, ospfLsdbLsid, ospfLsdbRouterId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfLsdbEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfLsdbEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfLsdbEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfLsdbEntry = assign_ospfLsdbEntry(out);
    }
}

void
ospf_mib_free_ospfLsdbEntry(ospf_mib_ospfLsdbEntry_t *ospfLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfLsdbEntry) {
        p = (char *) ospfLsdbEntry + sizeof(ospf_mib_ospfLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfLsdbEntry);
    }
}

void
ospf_mib_free_ospfLsdbTable(ospf_mib_ospfLsdbEntry_t **ospfLsdbEntry)
{
    int i;

    if (ospfLsdbEntry) {
        for (i = 0; ospfLsdbEntry[i]; i++) {
            ospf_mib_free_ospfLsdbEntry(ospfLsdbEntry[i]);
        }
        g_free(ospfLsdbEntry);
    }
}

ospf_mib_ospfAreaRangeEntry_t *
ospf_mib_new_ospfAreaRangeEntry()
{
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;

    ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaRangeEntry_t) + sizeof(gpointer));
    return ospfAreaRangeEntry;
}

static int
unpack_ospfAreaRangeEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaRangeEntry->ospfAreaRangeNet[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaRangeEntry(guint32 *base, guchar *ospfAreaRangeAreaId, guchar *ospfAreaRangeNet)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaRangeAreaId[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaRangeNet[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaRangeEntry_t *
assign_ospfAreaRangeEntry(GSList *vbl)
{
    ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry;
    char *p;

    ospfAreaRangeEntry = ospf_mib_new_ospfAreaRangeEntry();
    if (! ospfAreaRangeEntry) {
        return NULL;
    }

    p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaRangeEntry((GSnmpVarBind *) vbl->data, ospfAreaRangeEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfAreaRangeEntry");
        g_free(ospfAreaRangeEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfAreaRangeEntry_oid, sizeof(ospfAreaRangeEntry_oid)/sizeof(guint32),
                      ospfAreaRangeEntry_attr, ospfAreaRangeEntry);

    return ospfAreaRangeEntry;
}

void
ospf_mib_get_ospfAreaRangeTable(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t ***ospfAreaRangeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 5, 1, 0};

    *ospfAreaRangeEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfAreaRangeEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaRangeEntry = (ospf_mib_ospfAreaRangeEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaRangeEntry_t *));
        if (! *ospfAreaRangeEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaRangeEntry)[i] = assign_ospfAreaRangeEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaRangeEntry(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t **ospfAreaRangeEntry, guchar *ospfAreaRangeAreaId, guchar *ospfAreaRangeNet, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaRangeEntry_oid, sizeof(ospfAreaRangeEntry_oid));
    len = pack_ospfAreaRangeEntry(base, ospfAreaRangeAreaId, ospfAreaRangeNet);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaRangeEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaRangeEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfAreaRangeEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaRangeEntry = assign_ospfAreaRangeEntry(out);
    }
}

void
ospf_mib_set_ospfAreaRangeEntry(GSnmpSession *s, ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaRangeEntry_oid, sizeof(ospfAreaRangeEntry_oid));
    len = pack_ospfAreaRangeEntry(base, ospfAreaRangeEntry->ospfAreaRangeAreaId, ospfAreaRangeEntry->ospfAreaRangeNet);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaRangeEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfAreaRangeEntry_attr, mask, ospfAreaRangeEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaRangeEntry(ospf_mib_ospfAreaRangeEntry_t *ospfAreaRangeEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaRangeEntry) {
        p = (char *) ospfAreaRangeEntry + sizeof(ospf_mib_ospfAreaRangeEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaRangeEntry);
    }
}

void
ospf_mib_free_ospfAreaRangeTable(ospf_mib_ospfAreaRangeEntry_t **ospfAreaRangeEntry)
{
    int i;

    if (ospfAreaRangeEntry) {
        for (i = 0; ospfAreaRangeEntry[i]; i++) {
            ospf_mib_free_ospfAreaRangeEntry(ospfAreaRangeEntry[i]);
        }
        g_free(ospfAreaRangeEntry);
    }
}

ospf_mib_ospfHostEntry_t *
ospf_mib_new_ospfHostEntry()
{
    ospf_mib_ospfHostEntry_t *ospfHostEntry;

    ospfHostEntry = (ospf_mib_ospfHostEntry_t *) g_malloc0(sizeof(ospf_mib_ospfHostEntry_t) + sizeof(gpointer));
    return ospfHostEntry;
}

static int
unpack_ospfHostEntry(GSnmpVarBind *vb, ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfHostEntry->ospfHostIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfHostEntry->ospfHostTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfHostEntry(guint32 *base, guchar *ospfHostIpAddress, gint32 ospfHostTOS)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfHostIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfHostTOS;
    return idx;
}

static ospf_mib_ospfHostEntry_t *
assign_ospfHostEntry(GSList *vbl)
{
    ospf_mib_ospfHostEntry_t *ospfHostEntry;
    char *p;

    ospfHostEntry = ospf_mib_new_ospfHostEntry();
    if (! ospfHostEntry) {
        return NULL;
    }

    p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfHostEntry((GSnmpVarBind *) vbl->data, ospfHostEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfHostEntry");
        g_free(ospfHostEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfHostEntry_oid, sizeof(ospfHostEntry_oid)/sizeof(guint32),
                      ospfHostEntry_attr, ospfHostEntry);

    return ospfHostEntry;
}

void
ospf_mib_get_ospfHostTable(GSnmpSession *s, ospf_mib_ospfHostEntry_t ***ospfHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 6, 1, 0};

    *ospfHostEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfHostEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfHostEntry = (ospf_mib_ospfHostEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfHostEntry_t *));
        if (! *ospfHostEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfHostEntry)[i] = assign_ospfHostEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfHostEntry(GSnmpSession *s, ospf_mib_ospfHostEntry_t **ospfHostEntry, guchar *ospfHostIpAddress, gint32 ospfHostTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfHostEntry_oid, sizeof(ospfHostEntry_oid));
    len = pack_ospfHostEntry(base, ospfHostIpAddress, ospfHostTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfHostEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfHostEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfHostEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfHostEntry = assign_ospfHostEntry(out);
    }
}

void
ospf_mib_set_ospfHostEntry(GSnmpSession *s, ospf_mib_ospfHostEntry_t *ospfHostEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfHostEntry_oid, sizeof(ospfHostEntry_oid));
    len = pack_ospfHostEntry(base, ospfHostEntry->ospfHostIpAddress, ospfHostEntry->ospfHostTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfHostEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfHostEntry_attr, mask, ospfHostEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfHostEntry(ospf_mib_ospfHostEntry_t *ospfHostEntry)
{
    GSList *vbl;
    char *p;

    if (ospfHostEntry) {
        p = (char *) ospfHostEntry + sizeof(ospf_mib_ospfHostEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfHostEntry);
    }
}

void
ospf_mib_free_ospfHostTable(ospf_mib_ospfHostEntry_t **ospfHostEntry)
{
    int i;

    if (ospfHostEntry) {
        for (i = 0; ospfHostEntry[i]; i++) {
            ospf_mib_free_ospfHostEntry(ospfHostEntry[i]);
        }
        g_free(ospfHostEntry);
    }
}

ospf_mib_ospfIfEntry_t *
ospf_mib_new_ospfIfEntry()
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;

    ospfIfEntry = (ospf_mib_ospfIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfEntry_t) + sizeof(gpointer));
    return ospfIfEntry;
}

static int
unpack_ospfIfEntry(GSnmpVarBind *vb, ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfEntry->ospfIfIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfEntry->ospfAddressLessIf = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfIfEntry(guint32 *base, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfIfIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfAddressLessIf;
    return idx;
}

static ospf_mib_ospfIfEntry_t *
assign_ospfIfEntry(GSList *vbl)
{
    ospf_mib_ospfIfEntry_t *ospfIfEntry;
    char *p;

    ospfIfEntry = ospf_mib_new_ospfIfEntry();
    if (! ospfIfEntry) {
        return NULL;
    }

    p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfEntry((GSnmpVarBind *) vbl->data, ospfIfEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfIfEntry");
        g_free(ospfIfEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfIfEntry_oid, sizeof(ospfIfEntry_oid)/sizeof(guint32),
                      ospfIfEntry_attr, ospfIfEntry);

    return ospfIfEntry;
}

void
ospf_mib_get_ospfIfTable(GSnmpSession *s, ospf_mib_ospfIfEntry_t ***ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 7, 1, 0};

    *ospfIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfIfEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfIfEntry = (ospf_mib_ospfIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfEntry_t *));
        if (! *ospfIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfIfEntry)[i] = assign_ospfIfEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t **ospfIfEntry, guchar *ospfIfIpAddress, gint32 ospfAddressLessIf, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfEntry_oid, sizeof(ospfIfEntry_oid));
    len = pack_ospfIfEntry(base, ospfIfIpAddress, ospfAddressLessIf);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfIfEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfIfEntry = assign_ospfIfEntry(out);
    }
}

void
ospf_mib_set_ospfIfEntry(GSnmpSession *s, ospf_mib_ospfIfEntry_t *ospfIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfEntry_oid, sizeof(ospfIfEntry_oid));
    len = pack_ospfIfEntry(base, ospfIfEntry->ospfIfIpAddress, ospfIfEntry->ospfAddressLessIf);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfIfEntry_attr, mask, ospfIfEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfIfEntry(ospf_mib_ospfIfEntry_t *ospfIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfEntry) {
        p = (char *) ospfIfEntry + sizeof(ospf_mib_ospfIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfEntry);
    }
}

void
ospf_mib_free_ospfIfTable(ospf_mib_ospfIfEntry_t **ospfIfEntry)
{
    int i;

    if (ospfIfEntry) {
        for (i = 0; ospfIfEntry[i]; i++) {
            ospf_mib_free_ospfIfEntry(ospfIfEntry[i]);
        }
        g_free(ospfIfEntry);
    }
}

ospf_mib_ospfIfMetricEntry_t *
ospf_mib_new_ospfIfMetricEntry()
{
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;

    ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t *) g_malloc0(sizeof(ospf_mib_ospfIfMetricEntry_t) + sizeof(gpointer));
    return ospfIfMetricEntry;
}

static int
unpack_ospfIfMetricEntry(GSnmpVarBind *vb, ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfIfMetricEntry->ospfIfMetricIpAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricAddressLessIf = vb->id[idx++];
    if (vb->id_len < idx) return -1;
    ospfIfMetricEntry->ospfIfMetricTOS = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfIfMetricEntry(guint32 *base, guchar *ospfIfMetricIpAddress, gint32 ospfIfMetricAddressLessIf, gint32 ospfIfMetricTOS)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfIfMetricIpAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfIfMetricAddressLessIf;
    base[idx++] = ospfIfMetricTOS;
    return idx;
}

static ospf_mib_ospfIfMetricEntry_t *
assign_ospfIfMetricEntry(GSList *vbl)
{
    ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry;
    char *p;

    ospfIfMetricEntry = ospf_mib_new_ospfIfMetricEntry();
    if (! ospfIfMetricEntry) {
        return NULL;
    }

    p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfIfMetricEntry((GSnmpVarBind *) vbl->data, ospfIfMetricEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfIfMetricEntry");
        g_free(ospfIfMetricEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfIfMetricEntry_oid, sizeof(ospfIfMetricEntry_oid)/sizeof(guint32),
                      ospfIfMetricEntry_attr, ospfIfMetricEntry);

    return ospfIfMetricEntry;
}

void
ospf_mib_get_ospfIfMetricTable(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t ***ospfIfMetricEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 8, 1, 0};

    *ospfIfMetricEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfIfMetricEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfIfMetricEntry = (ospf_mib_ospfIfMetricEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfIfMetricEntry_t *));
        if (! *ospfIfMetricEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfIfMetricEntry)[i] = assign_ospfIfMetricEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfIfMetricEntry(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t **ospfIfMetricEntry, guchar *ospfIfMetricIpAddress, gint32 ospfIfMetricAddressLessIf, gint32 ospfIfMetricTOS, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfMetricEntry_oid, sizeof(ospfIfMetricEntry_oid));
    len = pack_ospfIfMetricEntry(base, ospfIfMetricIpAddress, ospfIfMetricAddressLessIf, ospfIfMetricTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfMetricEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfIfMetricEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfIfMetricEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfIfMetricEntry = assign_ospfIfMetricEntry(out);
    }
}

void
ospf_mib_set_ospfIfMetricEntry(GSnmpSession *s, ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfIfMetricEntry_oid, sizeof(ospfIfMetricEntry_oid));
    len = pack_ospfIfMetricEntry(base, ospfIfMetricEntry->ospfIfMetricIpAddress, ospfIfMetricEntry->ospfIfMetricAddressLessIf, ospfIfMetricEntry->ospfIfMetricTOS);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfIfMetricEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfIfMetricEntry_attr, mask, ospfIfMetricEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfIfMetricEntry(ospf_mib_ospfIfMetricEntry_t *ospfIfMetricEntry)
{
    GSList *vbl;
    char *p;

    if (ospfIfMetricEntry) {
        p = (char *) ospfIfMetricEntry + sizeof(ospf_mib_ospfIfMetricEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfIfMetricEntry);
    }
}

void
ospf_mib_free_ospfIfMetricTable(ospf_mib_ospfIfMetricEntry_t **ospfIfMetricEntry)
{
    int i;

    if (ospfIfMetricEntry) {
        for (i = 0; ospfIfMetricEntry[i]; i++) {
            ospf_mib_free_ospfIfMetricEntry(ospfIfMetricEntry[i]);
        }
        g_free(ospfIfMetricEntry);
    }
}

ospf_mib_ospfVirtIfEntry_t *
ospf_mib_new_ospfVirtIfEntry()
{
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;

    ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtIfEntry_t) + sizeof(gpointer));
    return ospfVirtIfEntry;
}

static int
unpack_ospfVirtIfEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfAreaId[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtIfEntry->ospfVirtIfNeighbor[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfVirtIfEntry(guint32 *base, guchar *ospfVirtIfAreaId, guchar *ospfVirtIfNeighbor)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtIfAreaId[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtIfNeighbor[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfVirtIfEntry_t *
assign_ospfVirtIfEntry(GSList *vbl)
{
    ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry;
    char *p;

    ospfVirtIfEntry = ospf_mib_new_ospfVirtIfEntry();
    if (! ospfVirtIfEntry) {
        return NULL;
    }

    p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtIfEntry((GSnmpVarBind *) vbl->data, ospfVirtIfEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfVirtIfEntry");
        g_free(ospfVirtIfEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfVirtIfEntry_oid, sizeof(ospfVirtIfEntry_oid)/sizeof(guint32),
                      ospfVirtIfEntry_attr, ospfVirtIfEntry);

    return ospfVirtIfEntry;
}

void
ospf_mib_get_ospfVirtIfTable(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t ***ospfVirtIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 9, 1, 0};

    *ospfVirtIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfVirtIfEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfVirtIfEntry = (ospf_mib_ospfVirtIfEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtIfEntry_t *));
        if (! *ospfVirtIfEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfVirtIfEntry)[i] = assign_ospfVirtIfEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfVirtIfEntry(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t **ospfVirtIfEntry, guchar *ospfVirtIfAreaId, guchar *ospfVirtIfNeighbor, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfVirtIfEntry_oid, sizeof(ospfVirtIfEntry_oid));
    len = pack_ospfVirtIfEntry(base, ospfVirtIfAreaId, ospfVirtIfNeighbor);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfVirtIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfVirtIfEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfVirtIfEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfVirtIfEntry = assign_ospfVirtIfEntry(out);
    }
}

void
ospf_mib_set_ospfVirtIfEntry(GSnmpSession *s, ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfVirtIfEntry_oid, sizeof(ospfVirtIfEntry_oid));
    len = pack_ospfVirtIfEntry(base, ospfVirtIfEntry->ospfVirtIfAreaId, ospfVirtIfEntry->ospfVirtIfNeighbor);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfVirtIfEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfVirtIfEntry_attr, mask, ospfVirtIfEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfVirtIfEntry(ospf_mib_ospfVirtIfEntry_t *ospfVirtIfEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtIfEntry) {
        p = (char *) ospfVirtIfEntry + sizeof(ospf_mib_ospfVirtIfEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtIfEntry);
    }
}

void
ospf_mib_free_ospfVirtIfTable(ospf_mib_ospfVirtIfEntry_t **ospfVirtIfEntry)
{
    int i;

    if (ospfVirtIfEntry) {
        for (i = 0; ospfVirtIfEntry[i]; i++) {
            ospf_mib_free_ospfVirtIfEntry(ospfVirtIfEntry[i]);
        }
        g_free(ospfVirtIfEntry);
    }
}

ospf_mib_ospfNbrEntry_t *
ospf_mib_new_ospfNbrEntry()
{
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;

    ospfNbrEntry = (ospf_mib_ospfNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfNbrEntry_t) + sizeof(gpointer));
    return ospfNbrEntry;
}

static int
unpack_ospfNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfNbrEntry->ospfNbrIpAddr[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfNbrEntry->ospfNbrAddressLessIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfNbrEntry(guint32 *base, guchar *ospfNbrIpAddr, gint32 ospfNbrAddressLessIndex)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfNbrIpAddr[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfNbrAddressLessIndex;
    return idx;
}

static ospf_mib_ospfNbrEntry_t *
assign_ospfNbrEntry(GSList *vbl)
{
    ospf_mib_ospfNbrEntry_t *ospfNbrEntry;
    char *p;

    ospfNbrEntry = ospf_mib_new_ospfNbrEntry();
    if (! ospfNbrEntry) {
        return NULL;
    }

    p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfNbrEntry((GSnmpVarBind *) vbl->data, ospfNbrEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfNbrEntry");
        g_free(ospfNbrEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfNbrEntry_oid, sizeof(ospfNbrEntry_oid)/sizeof(guint32),
                      ospfNbrEntry_attr, ospfNbrEntry);

    return ospfNbrEntry;
}

void
ospf_mib_get_ospfNbrTable(GSnmpSession *s, ospf_mib_ospfNbrEntry_t ***ospfNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 10, 1, 0};

    *ospfNbrEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfNbrEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfNbrEntry = (ospf_mib_ospfNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfNbrEntry_t *));
        if (! *ospfNbrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfNbrEntry)[i] = assign_ospfNbrEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfNbrEntry(GSnmpSession *s, ospf_mib_ospfNbrEntry_t **ospfNbrEntry, guchar *ospfNbrIpAddr, gint32 ospfNbrAddressLessIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfNbrEntry_oid, sizeof(ospfNbrEntry_oid));
    len = pack_ospfNbrEntry(base, ospfNbrIpAddr, ospfNbrAddressLessIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfNbrEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfNbrEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfNbrEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfNbrEntry = assign_ospfNbrEntry(out);
    }
}

void
ospf_mib_set_ospfNbrEntry(GSnmpSession *s, ospf_mib_ospfNbrEntry_t *ospfNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfNbrEntry_oid, sizeof(ospfNbrEntry_oid));
    len = pack_ospfNbrEntry(base, ospfNbrEntry->ospfNbrIpAddr, ospfNbrEntry->ospfNbrAddressLessIndex);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfNbrEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfNbrEntry_attr, mask, ospfNbrEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfNbrEntry(ospf_mib_ospfNbrEntry_t *ospfNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfNbrEntry) {
        p = (char *) ospfNbrEntry + sizeof(ospf_mib_ospfNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfNbrEntry);
    }
}

void
ospf_mib_free_ospfNbrTable(ospf_mib_ospfNbrEntry_t **ospfNbrEntry)
{
    int i;

    if (ospfNbrEntry) {
        for (i = 0; ospfNbrEntry[i]; i++) {
            ospf_mib_free_ospfNbrEntry(ospfNbrEntry[i]);
        }
        g_free(ospfNbrEntry);
    }
}

ospf_mib_ospfVirtNbrEntry_t *
ospf_mib_new_ospfVirtNbrEntry()
{
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;

    ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t *) g_malloc0(sizeof(ospf_mib_ospfVirtNbrEntry_t) + sizeof(gpointer));
    return ospfVirtNbrEntry;
}

static int
unpack_ospfVirtNbrEntry(GSnmpVarBind *vb, ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrArea[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfVirtNbrEntry->ospfVirtNbrRtrId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfVirtNbrEntry(guint32 *base, guchar *ospfVirtNbrArea, guchar *ospfVirtNbrRtrId)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtNbrArea[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfVirtNbrRtrId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfVirtNbrEntry_t *
assign_ospfVirtNbrEntry(GSList *vbl)
{
    ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry;
    char *p;

    ospfVirtNbrEntry = ospf_mib_new_ospfVirtNbrEntry();
    if (! ospfVirtNbrEntry) {
        return NULL;
    }

    p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfVirtNbrEntry((GSnmpVarBind *) vbl->data, ospfVirtNbrEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfVirtNbrEntry");
        g_free(ospfVirtNbrEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfVirtNbrEntry_oid, sizeof(ospfVirtNbrEntry_oid)/sizeof(guint32),
                      ospfVirtNbrEntry_attr, ospfVirtNbrEntry);

    return ospfVirtNbrEntry;
}

void
ospf_mib_get_ospfVirtNbrTable(GSnmpSession *s, ospf_mib_ospfVirtNbrEntry_t ***ospfVirtNbrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 11, 1, 0};

    *ospfVirtNbrEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfVirtNbrEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfVirtNbrEntry = (ospf_mib_ospfVirtNbrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfVirtNbrEntry_t *));
        if (! *ospfVirtNbrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfVirtNbrEntry)[i] = assign_ospfVirtNbrEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfVirtNbrEntry(GSnmpSession *s, ospf_mib_ospfVirtNbrEntry_t **ospfVirtNbrEntry, guchar *ospfVirtNbrArea, guchar *ospfVirtNbrRtrId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfVirtNbrEntry_oid, sizeof(ospfVirtNbrEntry_oid));
    len = pack_ospfVirtNbrEntry(base, ospfVirtNbrArea, ospfVirtNbrRtrId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfVirtNbrEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfVirtNbrEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfVirtNbrEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfVirtNbrEntry = assign_ospfVirtNbrEntry(out);
    }
}

void
ospf_mib_free_ospfVirtNbrEntry(ospf_mib_ospfVirtNbrEntry_t *ospfVirtNbrEntry)
{
    GSList *vbl;
    char *p;

    if (ospfVirtNbrEntry) {
        p = (char *) ospfVirtNbrEntry + sizeof(ospf_mib_ospfVirtNbrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfVirtNbrEntry);
    }
}

void
ospf_mib_free_ospfVirtNbrTable(ospf_mib_ospfVirtNbrEntry_t **ospfVirtNbrEntry)
{
    int i;

    if (ospfVirtNbrEntry) {
        for (i = 0; ospfVirtNbrEntry[i]; i++) {
            ospf_mib_free_ospfVirtNbrEntry(ospfVirtNbrEntry[i]);
        }
        g_free(ospfVirtNbrEntry);
    }
}

ospf_mib_ospfExtLsdbEntry_t *
ospf_mib_new_ospfExtLsdbEntry()
{
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;

    ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t *) g_malloc0(sizeof(ospf_mib_ospfExtLsdbEntry_t) + sizeof(gpointer));
    return ospfExtLsdbEntry;
}

static int
unpack_ospfExtLsdbEntry(GSnmpVarBind *vb, ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    if (vb->id_len < idx) return -1;
    ospfExtLsdbEntry->ospfExtLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbLsid[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfExtLsdbEntry->ospfExtLsdbRouterId[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfExtLsdbEntry(guint32 *base, gint32 ospfExtLsdbType, guchar *ospfExtLsdbLsid, guchar *ospfExtLsdbRouterId)
{
    guint8 idx = 10;
    guint16 i, len;

    base[idx++] = ospfExtLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfExtLsdbLsid[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfExtLsdbRouterId[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfExtLsdbEntry_t *
assign_ospfExtLsdbEntry(GSList *vbl)
{
    ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry;
    char *p;

    ospfExtLsdbEntry = ospf_mib_new_ospfExtLsdbEntry();
    if (! ospfExtLsdbEntry) {
        return NULL;
    }

    p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfExtLsdbEntry((GSnmpVarBind *) vbl->data, ospfExtLsdbEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfExtLsdbEntry");
        g_free(ospfExtLsdbEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfExtLsdbEntry_oid, sizeof(ospfExtLsdbEntry_oid)/sizeof(guint32),
                      ospfExtLsdbEntry_attr, ospfExtLsdbEntry);

    return ospfExtLsdbEntry;
}

void
ospf_mib_get_ospfExtLsdbTable(GSnmpSession *s, ospf_mib_ospfExtLsdbEntry_t ***ospfExtLsdbEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 12, 1, 0};

    *ospfExtLsdbEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfExtLsdbEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfExtLsdbEntry = (ospf_mib_ospfExtLsdbEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfExtLsdbEntry_t *));
        if (! *ospfExtLsdbEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfExtLsdbEntry)[i] = assign_ospfExtLsdbEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfExtLsdbEntry(GSnmpSession *s, ospf_mib_ospfExtLsdbEntry_t **ospfExtLsdbEntry, gint32 ospfExtLsdbType, guchar *ospfExtLsdbLsid, guchar *ospfExtLsdbRouterId, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfExtLsdbEntry_oid, sizeof(ospfExtLsdbEntry_oid));
    len = pack_ospfExtLsdbEntry(base, ospfExtLsdbType, ospfExtLsdbLsid, ospfExtLsdbRouterId);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfExtLsdbEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfExtLsdbEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfExtLsdbEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfExtLsdbEntry = assign_ospfExtLsdbEntry(out);
    }
}

void
ospf_mib_free_ospfExtLsdbEntry(ospf_mib_ospfExtLsdbEntry_t *ospfExtLsdbEntry)
{
    GSList *vbl;
    char *p;

    if (ospfExtLsdbEntry) {
        p = (char *) ospfExtLsdbEntry + sizeof(ospf_mib_ospfExtLsdbEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfExtLsdbEntry);
    }
}

void
ospf_mib_free_ospfExtLsdbTable(ospf_mib_ospfExtLsdbEntry_t **ospfExtLsdbEntry)
{
    int i;

    if (ospfExtLsdbEntry) {
        for (i = 0; ospfExtLsdbEntry[i]; i++) {
            ospf_mib_free_ospfExtLsdbEntry(ospfExtLsdbEntry[i]);
        }
        g_free(ospfExtLsdbEntry);
    }
}

ospf_mib_ospfAreaAggregateEntry_t *
ospf_mib_new_ospfAreaAggregateEntry()
{
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;

    ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t *) g_malloc0(sizeof(ospf_mib_ospfAreaAggregateEntry_t) + sizeof(gpointer));
    return ospfAreaAggregateEntry;
}

static int
unpack_ospfAreaAggregateEntry(GSnmpVarBind *vb, ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateAreaID[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    ospfAreaAggregateEntry->ospfAreaAggregateLsdbType = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateNet[i] = vb->id[idx++];
    }
    len = 4;
    if (vb->id_len < idx + len) return -1;
    if (len != 4) return -1;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ospfAreaAggregateEntry->ospfAreaAggregateMask[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ospfAreaAggregateEntry(guint32 *base, guchar *ospfAreaAggregateAreaID, gint32 ospfAreaAggregateLsdbType, guchar *ospfAreaAggregateNet, guchar *ospfAreaAggregateMask)
{
    guint8 idx = 10;
    guint16 i, len;

    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateAreaID[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = ospfAreaAggregateLsdbType;
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateNet[i];
        if (idx >= 128) return -1;
    }
    len = 4;
    if (len != 4) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = ospfAreaAggregateMask[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static ospf_mib_ospfAreaAggregateEntry_t *
assign_ospfAreaAggregateEntry(GSList *vbl)
{
    ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry;
    char *p;

    ospfAreaAggregateEntry = ospf_mib_new_ospfAreaAggregateEntry();
    if (! ospfAreaAggregateEntry) {
        return NULL;
    }

    p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ospfAreaAggregateEntry((GSnmpVarBind *) vbl->data, ospfAreaAggregateEntry) < 0) {
        g_warning("%s: invalid instance identifier", "ospfAreaAggregateEntry");
        g_free(ospfAreaAggregateEntry);
        return NULL;
    }

    gsnmp_attr_assign(vbl, ospfAreaAggregateEntry_oid, sizeof(ospfAreaAggregateEntry_oid)/sizeof(guint32),
                      ospfAreaAggregateEntry_attr, ospfAreaAggregateEntry);

    return ospfAreaAggregateEntry;
}

void
ospf_mib_get_ospfAreaAggregateTable(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t ***ospfAreaAggregateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 14, 14, 1, 0};

    *ospfAreaAggregateEntry = NULL;

    gsnmp_attr_get(s, &in, base, 10, 9, ospfAreaAggregateEntry_attr, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ospfAreaAggregateEntry = (ospf_mib_ospfAreaAggregateEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(ospf_mib_ospfAreaAggregateEntry_t *));
        if (! *ospfAreaAggregateEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ospfAreaAggregateEntry)[i] = assign_ospfAreaAggregateEntry(row->data);
        }
    }
}

void
ospf_mib_get_ospfAreaAggregateEntry(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t **ospfAreaAggregateEntry, guchar *ospfAreaAggregateAreaID, gint32 ospfAreaAggregateLsdbType, guchar *ospfAreaAggregateNet, guchar *ospfAreaAggregateMask, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaAggregateEntry_oid, sizeof(ospfAreaAggregateEntry_oid));
    len = pack_ospfAreaAggregateEntry(base, ospfAreaAggregateAreaID, ospfAreaAggregateLsdbType, ospfAreaAggregateNet, ospfAreaAggregateMask);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaAggregateEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    *ospfAreaAggregateEntry = NULL;

    gsnmp_attr_get(s, &in, base, len, 9, ospfAreaAggregateEntry_attr, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        if (s->error_status != G_SNMP_ERR_NOERROR) {
            g_snmp_vbl_free(out);
            return;
        }
        *ospfAreaAggregateEntry = assign_ospfAreaAggregateEntry(out);
    }
}

void
ospf_mib_set_ospfAreaAggregateEntry(GSnmpSession *s, ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memset(base, 0, sizeof(base));
    memcpy(base, ospfAreaAggregateEntry_oid, sizeof(ospfAreaAggregateEntry_oid));
    len = pack_ospfAreaAggregateEntry(base, ospfAreaAggregateEntry->ospfAreaAggregateAreaID, ospfAreaAggregateEntry->ospfAreaAggregateLsdbType, ospfAreaAggregateEntry->ospfAreaAggregateNet, ospfAreaAggregateEntry->ospfAreaAggregateMask);
    if (len < 0) {
        g_warning("%s: invalid index values", "ospfAreaAggregateEntry");
        s->error_status = G_SNMP_ERR_INTERNAL;
        return;
    }

    gsnmp_attr_set(s, &in, base, len, 9, ospfAreaAggregateEntry_attr, mask, ospfAreaAggregateEntry);

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
ospf_mib_free_ospfAreaAggregateEntry(ospf_mib_ospfAreaAggregateEntry_t *ospfAreaAggregateEntry)
{
    GSList *vbl;
    char *p;

    if (ospfAreaAggregateEntry) {
        p = (char *) ospfAreaAggregateEntry + sizeof(ospf_mib_ospfAreaAggregateEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ospfAreaAggregateEntry);
    }
}

void
ospf_mib_free_ospfAreaAggregateTable(ospf_mib_ospfAreaAggregateEntry_t **ospfAreaAggregateEntry)
{
    int i;

    if (ospfAreaAggregateEntry) {
        for (i = 0; ospfAreaAggregateEntry[i]; i++) {
            ospf_mib_free_ospfAreaAggregateEntry(ospfAreaAggregateEntry[i]);
        }
        g_free(ospfAreaAggregateEntry);
    }
}


