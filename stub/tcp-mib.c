/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from TCP-MIB revision 1994-11-01 00:00.
 *
 * $Id$
 */

#include "tcp-mib.h"

stls_table_t tcp_mib_enums_tcpRtoAlgorithm[] = {
    { 1, "other" },
    { 2, "constant" },
    { 3, "rsre" },
    { 4, "vanj" },
    { 0, NULL }
};

stls_table_t tcp_mib_enums_tcpConnState[] = {
    { 1, "closed" },
    { 2, "listen" },
    { 3, "synSent" },
    { 4, "synReceived" },
    { 5, "established" },
    { 6, "finWait1" },
    { 7, "finWait2" },
    { 8, "closeWait" },
    { 9, "lastAck" },
    { 10, "closing" },
    { 11, "timeWait" },
    { 12, "deleteTCB" },
    { 0, NULL }
};


static tcp_t *
assign_tcp(GSList *vbl)
{
    GSList *elem;
    tcp_t *tcp;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 6};

    tcp = (tcp_t *) g_malloc0(sizeof(tcp_t) + sizeof(GSList *));
    if (! tcp) {
        return NULL;
    }

    p = (char *) tcp + sizeof(tcp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 8 && vb->id[7] == 1) {
            tcp->tcpRtoAlgorithm = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 2) {
            tcp->tcpRtoMin = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 3) {
            tcp->tcpRtoMax = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 4) {
            tcp->tcpMaxConn = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 5) {
            tcp->tcpActiveOpens = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 6) {
            tcp->tcpPassiveOpens = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 7) {
            tcp->tcpAttemptFails = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 8) {
            tcp->tcpEstabResets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 9) {
            tcp->tcpCurrEstab = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 10) {
            tcp->tcpInSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 11) {
            tcp->tcpOutSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 12) {
            tcp->tcpRetransSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 14) {
            tcp->tcpInErrs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > 8 && vb->id[7] == 15) {
            tcp->tcpOutRsts = &(vb->syntax.ui32[0]);
        }
    }

    return tcp;
}

int
tcp_mib_get_tcp(host_snmp *s, tcp_t **tcp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 0};

    *tcp = NULL;

    base[7] = 1; stls_vbl_add_null(&in, base, 8);
    base[7] = 2; stls_vbl_add_null(&in, base, 8);
    base[7] = 3; stls_vbl_add_null(&in, base, 8);
    base[7] = 4; stls_vbl_add_null(&in, base, 8);
    base[7] = 5; stls_vbl_add_null(&in, base, 8);
    base[7] = 6; stls_vbl_add_null(&in, base, 8);
    base[7] = 7; stls_vbl_add_null(&in, base, 8);
    base[7] = 8; stls_vbl_add_null(&in, base, 8);
    base[7] = 9; stls_vbl_add_null(&in, base, 8);
    base[7] = 10; stls_vbl_add_null(&in, base, 8);
    base[7] = 11; stls_vbl_add_null(&in, base, 8);
    base[7] = 12; stls_vbl_add_null(&in, base, 8);
    base[7] = 14; stls_vbl_add_null(&in, base, 8);
    base[7] = 15; stls_vbl_add_null(&in, base, 8);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *tcp = assign_tcp(out);

    return 0;
}

void
tcp_mib_free_tcp(tcp_t *tcp)
{
    GSList *vbl;
    char *p;

    if (tcp) {
        p = (char *) tcp + sizeof(tcp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(tcp);
    }
}

static tcpConnEntry_t *
assign_tcpConnEntry(GSList *vbl)
{
    GSList *elem;
    tcpConnEntry_t *tcpConnEntry;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 6, 13, 1};

    tcpConnEntry = (tcpConnEntry_t *) g_malloc0(sizeof(tcpConnEntry_t) + sizeof(GSList *));
    if (! tcpConnEntry) {
        return NULL;
    }

    p = (char *) tcpConnEntry + sizeof(tcpConnEntry_t);
    * (GSList **) p = vbl;

    {
        GSnmpVarBind *vb = (GSnmpVarBind *) vbl->data;
        int idx = 10;
        if (vb->id_len < idx + 4) goto illegal;
        {
            int i;
            for (i = 0; i < 4; i++) {
                tcpConnEntry->tcpConnLocalAddress[i] = vb->id[idx++];
            }
        }
        if (vb->id_len < idx) goto illegal;
        tcpConnEntry->tcpConnLocalPort = vb->id[idx++];
        if (vb->id_len < idx + 4) goto illegal;
        {
            int i;
            for (i = 0; i < 4; i++) {
                tcpConnEntry->tcpConnRemAddress[i] = vb->id[idx++];
            }
        }
        if (vb->id_len < idx) goto illegal;
        tcpConnEntry->tcpConnRemPort = vb->id[idx++];
        if (vb->id_len > idx) { 
        illegal:
            g_warning("illegal tcpConnEntry instance identifier");
            g_free(tcpConnEntry);
            return NULL;
        }
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (memcmp(vb->id, base, sizeof(base)) != 0) {
            continue;
        }
        if (vb->id_len > 10 && vb->id[9] == 1) {
            tcpConnEntry->tcpConnState = &(vb->syntax.i32[0]);
        }
    }

    return tcpConnEntry;
}

int
tcp_mib_get_tcpConnEntry(host_snmp *s, tcpConnEntry_t ***tcpConnEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 0};

    *tcpConnEntry = NULL;

    base[9] = 1; stls_vbl_add_null(&in, base, 10);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *tcpConnEntry = (tcpConnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(tcpConnEntry_t *));
    if (! *tcpConnEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*tcpConnEntry)[i] = assign_tcpConnEntry(row->data);
    }

    return 0;
}

void
tcp_mib_free_tcpConnEntry(tcpConnEntry_t **tcpConnEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (tcpConnEntry) {
        for (i = 0; tcpConnEntry[i]; i++) {
            p = (char *) tcpConnEntry[i] + sizeof(tcpConnEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(tcpConnEntry[i]);
        }
        g_free(tcpConnEntry);
    }
}


