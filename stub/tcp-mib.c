/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from TCP-MIB revision 1994-11-01 00:00.
 *
 * $Id$
 */

#include "tcp-mib.h"

static guint32 const tcpRtoAlgorithm[] = {1, 3, 6, 1, 2, 1, 6, 1};
static guint32 const tcpRtoMin[] = {1, 3, 6, 1, 2, 1, 6, 2};
static guint32 const tcpRtoMax[] = {1, 3, 6, 1, 2, 1, 6, 3};
static guint32 const tcpMaxConn[] = {1, 3, 6, 1, 2, 1, 6, 4};
static guint32 const tcpActiveOpens[] = {1, 3, 6, 1, 2, 1, 6, 5};
static guint32 const tcpPassiveOpens[] = {1, 3, 6, 1, 2, 1, 6, 6};
static guint32 const tcpAttemptFails[] = {1, 3, 6, 1, 2, 1, 6, 7};
static guint32 const tcpEstabResets[] = {1, 3, 6, 1, 2, 1, 6, 8};
static guint32 const tcpCurrEstab[] = {1, 3, 6, 1, 2, 1, 6, 9};
static guint32 const tcpInSegs[] = {1, 3, 6, 1, 2, 1, 6, 10};
static guint32 const tcpOutSegs[] = {1, 3, 6, 1, 2, 1, 6, 11};
static guint32 const tcpRetransSegs[] = {1, 3, 6, 1, 2, 1, 6, 12};
static guint32 const tcpConnState[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 1};
static guint32 const tcpConnLocalAddress[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 2};
static guint32 const tcpConnLocalPort[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 3};
static guint32 const tcpConnRemAddress[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 4};
static guint32 const tcpConnRemPort[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 5};
static guint32 const tcpInErrs[] = {1, 3, 6, 1, 2, 1, 6, 14};
static guint32 const tcpOutRsts[] = {1, 3, 6, 1, 2, 1, 6, 15};

static gsize const _tcpRtoAlgorithmLength = sizeof(tcpRtoAlgorithm)/sizeof(guint32);
static gsize const _tcpRtoMinLength = sizeof(tcpRtoMin)/sizeof(guint32);
static gsize const _tcpRtoMaxLength = sizeof(tcpRtoMax)/sizeof(guint32);
static gsize const _tcpMaxConnLength = sizeof(tcpMaxConn)/sizeof(guint32);
static gsize const _tcpActiveOpensLength = sizeof(tcpActiveOpens)/sizeof(guint32);
static gsize const _tcpPassiveOpensLength = sizeof(tcpPassiveOpens)/sizeof(guint32);
static gsize const _tcpAttemptFailsLength = sizeof(tcpAttemptFails)/sizeof(guint32);
static gsize const _tcpEstabResetsLength = sizeof(tcpEstabResets)/sizeof(guint32);
static gsize const _tcpCurrEstabLength = sizeof(tcpCurrEstab)/sizeof(guint32);
static gsize const _tcpInSegsLength = sizeof(tcpInSegs)/sizeof(guint32);
static gsize const _tcpOutSegsLength = sizeof(tcpOutSegs)/sizeof(guint32);
static gsize const _tcpRetransSegsLength = sizeof(tcpRetransSegs)/sizeof(guint32);
static gsize const _tcpConnStateLength = sizeof(tcpConnState)/sizeof(guint32);
static gsize const _tcpConnLocalAddressLength = sizeof(tcpConnLocalAddress)/sizeof(guint32);
static gsize const _tcpConnLocalPortLength = sizeof(tcpConnLocalPort)/sizeof(guint32);
static gsize const _tcpConnRemAddressLength = sizeof(tcpConnRemAddress)/sizeof(guint32);
static gsize const _tcpConnRemPortLength = sizeof(tcpConnRemPort)/sizeof(guint32);
static gsize const _tcpInErrsLength = sizeof(tcpInErrs)/sizeof(guint32);
static gsize const _tcpOutRstsLength = sizeof(tcpOutRsts)/sizeof(guint32);

stls_table_t tcp_mib_enums_tcpRtoAlgorithm[] = {
    { 1, "other" },
    { 2, "constant" },
    { 3, "rsre" },
    { 4, "vanj" },
    { 0, NULL }
};

stls_table_t tcp_mib_enums_tcpConnState[] = {
    { 1, "closed" },
    { 2, "listen" },
    { 3, "synSent" },
    { 4, "synReceived" },
    { 5, "established" },
    { 6, "finWait1" },
    { 7, "finWait2" },
    { 8, "closeWait" },
    { 9, "lastAck" },
    { 10, "closing" },
    { 11, "timeWait" },
    { 12, "deleteTCB" },
    { 0, NULL }
};


static tcp_t *
assign_tcp(GSList *vbl)
{
    GSList *elem;
    tcp_t *tcp;
    char *p;

    tcp = (tcp_t *) g_malloc0(sizeof(tcp_t) + sizeof(GSList *));
    if (! tcp) {
        return NULL;
    }

    p = (char *) tcp + sizeof(tcp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _tcpRtoAlgorithmLength
            && memcmp(vb->id, tcpRtoAlgorithm, sizeof(tcpRtoAlgorithm)) == 0) {
            tcp->tcpRtoAlgorithm = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpRtoMinLength
            && memcmp(vb->id, tcpRtoMin, sizeof(tcpRtoMin)) == 0) {
            tcp->tcpRtoMin = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpRtoMaxLength
            && memcmp(vb->id, tcpRtoMax, sizeof(tcpRtoMax)) == 0) {
            tcp->tcpRtoMax = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpMaxConnLength
            && memcmp(vb->id, tcpMaxConn, sizeof(tcpMaxConn)) == 0) {
            tcp->tcpMaxConn = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpActiveOpensLength
            && memcmp(vb->id, tcpActiveOpens, sizeof(tcpActiveOpens)) == 0) {
            tcp->tcpActiveOpens = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpPassiveOpensLength
            && memcmp(vb->id, tcpPassiveOpens, sizeof(tcpPassiveOpens)) == 0) {
            tcp->tcpPassiveOpens = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpAttemptFailsLength
            && memcmp(vb->id, tcpAttemptFails, sizeof(tcpAttemptFails)) == 0) {
            tcp->tcpAttemptFails = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpEstabResetsLength
            && memcmp(vb->id, tcpEstabResets, sizeof(tcpEstabResets)) == 0) {
            tcp->tcpEstabResets = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpCurrEstabLength
            && memcmp(vb->id, tcpCurrEstab, sizeof(tcpCurrEstab)) == 0) {
            tcp->tcpCurrEstab = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpInSegsLength
            && memcmp(vb->id, tcpInSegs, sizeof(tcpInSegs)) == 0) {
            tcp->tcpInSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpOutSegsLength
            && memcmp(vb->id, tcpOutSegs, sizeof(tcpOutSegs)) == 0) {
            tcp->tcpOutSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpRetransSegsLength
            && memcmp(vb->id, tcpRetransSegs, sizeof(tcpRetransSegs)) == 0) {
            tcp->tcpRetransSegs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpInErrsLength
            && memcmp(vb->id, tcpInErrs, sizeof(tcpInErrs)) == 0) {
            tcp->tcpInErrs = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _tcpOutRstsLength
            && memcmp(vb->id, tcpOutRsts, sizeof(tcpOutRsts)) == 0) {
            tcp->tcpOutRsts = &(vb->syntax.ui32[0]);
        }
    }

    return tcp;
}

int
tcp_mib_get_tcp(host_snmp *s, tcp_t **tcp)
{
    GSList *in = NULL, *out = NULL;

    *tcp = NULL;

    stls_vbl_add_null(&in, tcpRtoAlgorithm, _tcpRtoAlgorithmLength);
    stls_vbl_add_null(&in, tcpRtoMin, _tcpRtoMinLength);
    stls_vbl_add_null(&in, tcpRtoMax, _tcpRtoMaxLength);
    stls_vbl_add_null(&in, tcpMaxConn, _tcpMaxConnLength);
    stls_vbl_add_null(&in, tcpActiveOpens, _tcpActiveOpensLength);
    stls_vbl_add_null(&in, tcpPassiveOpens, _tcpPassiveOpensLength);
    stls_vbl_add_null(&in, tcpAttemptFails, _tcpAttemptFailsLength);
    stls_vbl_add_null(&in, tcpEstabResets, _tcpEstabResetsLength);
    stls_vbl_add_null(&in, tcpCurrEstab, _tcpCurrEstabLength);
    stls_vbl_add_null(&in, tcpInSegs, _tcpInSegsLength);
    stls_vbl_add_null(&in, tcpOutSegs, _tcpOutSegsLength);
    stls_vbl_add_null(&in, tcpRetransSegs, _tcpRetransSegsLength);
    stls_vbl_add_null(&in, tcpInErrs, _tcpInErrsLength);
    stls_vbl_add_null(&in, tcpOutRsts, _tcpOutRstsLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *tcp = assign_tcp(out);

    return 0;
}

void
tcp_mib_free_tcp(tcp_t *tcp)
{
    GSList *vbl;
    char *p;

    if (tcp) {
        p = (char *) tcp + sizeof(tcp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(tcp);
    }
}

static tcpConnEntry_t *
assign_tcpConnEntry(GSList *vbl)
{
    GSList *elem;
    tcpConnEntry_t *tcpConnEntry;
    char *p;

    tcpConnEntry = (tcpConnEntry_t *) g_malloc0(sizeof(tcpConnEntry_t) + sizeof(GSList *));
    if (! tcpConnEntry) {
        return NULL;
    }

    p = (char *) tcpConnEntry + sizeof(tcpConnEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _tcpConnStateLength
            && memcmp(vb->id, tcpConnState, sizeof(tcpConnState)) == 0) {
            tcpConnEntry->tcpConnState = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpConnLocalAddressLength
            && memcmp(vb->id, tcpConnLocalAddress, sizeof(tcpConnLocalAddress)) == 0) {
            tcpConnEntry->tcpConnLocalAddress = vb->syntax.uc;
        }
        if (vb->id_len > _tcpConnLocalPortLength
            && memcmp(vb->id, tcpConnLocalPort, sizeof(tcpConnLocalPort)) == 0) {
            tcpConnEntry->tcpConnLocalPort = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _tcpConnRemAddressLength
            && memcmp(vb->id, tcpConnRemAddress, sizeof(tcpConnRemAddress)) == 0) {
            tcpConnEntry->tcpConnRemAddress = vb->syntax.uc;
        }
        if (vb->id_len > _tcpConnRemPortLength
            && memcmp(vb->id, tcpConnRemPort, sizeof(tcpConnRemPort)) == 0) {
            tcpConnEntry->tcpConnRemPort = &(vb->syntax.i32[0]);
        }
    }

    return tcpConnEntry;
}

int
tcp_mib_get_tcpConnEntry(host_snmp *s, tcpConnEntry_t ***tcpConnEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *tcpConnEntry = NULL;

    stls_vbl_add_null(&in, tcpConnState, _tcpConnStateLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *tcpConnEntry = (tcpConnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(tcpConnEntry_t *));
    if (! *tcpConnEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*tcpConnEntry)[i] = assign_tcpConnEntry(row->data);
    }

    return 0;
}

void
tcp_mib_free_tcpConnEntry(tcpConnEntry_t **tcpConnEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (tcpConnEntry) {
        for (i = 0; tcpConnEntry[i]; i++) {
            p = (char *) tcpConnEntry[i] + sizeof(tcpConnEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(tcpConnEntry[i]);
        }
        g_free(tcpConnEntry);
    }
}


