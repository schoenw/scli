/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.13 for the stools package.
 *
 * Derived from DISMAN-SCHEDULE-MIB revision 1998-11-17 18:00.
 *
 * $Id$
 */

#include "disman-schedule-mib.h"

static guint32 const schedLocalTime[] = {1, 3, 6, 1, 2, 1, 63, 1, 1};
static guint32 const schedOwner[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 1};
static guint32 const schedName[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 2};
static guint32 const schedDescr[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 3};
static guint32 const schedInterval[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 4};
static guint32 const schedWeekDay[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 5};
static guint32 const schedMonth[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 6};
static guint32 const schedDay[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 7};
static guint32 const schedHour[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 8};
static guint32 const schedMinute[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 9};
static guint32 const schedContextName[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 10};
static guint32 const schedVariable[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 11};
static guint32 const schedValue[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 12};
static guint32 const schedType[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 13};
static guint32 const schedAdminStatus[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 14};
static guint32 const schedOperStatus[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 15};
static guint32 const schedFailures[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 16};
static guint32 const schedLastFailure[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 17};
static guint32 const schedLastFailed[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 18};
static guint32 const schedStorageType[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 19};
static guint32 const schedRowStatus[] = {1, 3, 6, 1, 2, 1, 63, 1, 2, 1, 20};

static gsize const _schedLocalTimeLength = sizeof(schedLocalTime)/sizeof(guint32);
static gsize const _schedOwnerLength = sizeof(schedOwner)/sizeof(guint32);
static gsize const _schedNameLength = sizeof(schedName)/sizeof(guint32);
static gsize const _schedDescrLength = sizeof(schedDescr)/sizeof(guint32);
static gsize const _schedIntervalLength = sizeof(schedInterval)/sizeof(guint32);
static gsize const _schedWeekDayLength = sizeof(schedWeekDay)/sizeof(guint32);
static gsize const _schedMonthLength = sizeof(schedMonth)/sizeof(guint32);
static gsize const _schedDayLength = sizeof(schedDay)/sizeof(guint32);
static gsize const _schedHourLength = sizeof(schedHour)/sizeof(guint32);
static gsize const _schedMinuteLength = sizeof(schedMinute)/sizeof(guint32);
static gsize const _schedContextNameLength = sizeof(schedContextName)/sizeof(guint32);
static gsize const _schedVariableLength = sizeof(schedVariable)/sizeof(guint32);
static gsize const _schedValueLength = sizeof(schedValue)/sizeof(guint32);
static gsize const _schedTypeLength = sizeof(schedType)/sizeof(guint32);
static gsize const _schedAdminStatusLength = sizeof(schedAdminStatus)/sizeof(guint32);
static gsize const _schedOperStatusLength = sizeof(schedOperStatus)/sizeof(guint32);
static gsize const _schedFailuresLength = sizeof(schedFailures)/sizeof(guint32);
static gsize const _schedLastFailureLength = sizeof(schedLastFailure)/sizeof(guint32);
static gsize const _schedLastFailedLength = sizeof(schedLastFailed)/sizeof(guint32);
static gsize const _schedStorageTypeLength = sizeof(schedStorageType)/sizeof(guint32);
static gsize const _schedRowStatusLength = sizeof(schedRowStatus)/sizeof(guint32);

stls_table_t disman_schedule_mib_enums_schedType[] = {
    { 1, "periodic" },
    { 2, "calendar" },
    { 3, "oneshot" },
    { 0, NULL }
};

stls_table_t disman_schedule_mib_enums_schedAdminStatus[] = {
    { 1, "enabled" },
    { 2, "disabled" },
    { 0, NULL }
};

stls_table_t disman_schedule_mib_enums_schedOperStatus[] = {
    { 1, "enabled" },
    { 2, "disabled" },
    { 3, "finished" },
    { 0, NULL }
};

stls_table_t disman_schedule_mib_enums_schedLastFailure[] = {
    { -1, "noResponse" },
    { 0, "noError" },
    { 1, "tooBig" },
    { 2, "noSuchName" },
    { 3, "badValue" },
    { 4, "readOnly" },
    { 5, "genErr" },
    { 6, "noAccess" },
    { 7, "wrongType" },
    { 8, "wrongLength" },
    { 9, "wrongEncoding" },
    { 10, "wrongValue" },
    { 11, "noCreation" },
    { 12, "inconsistentValue" },
    { 13, "resourceUnavailable" },
    { 14, "commitFailed" },
    { 15, "undoFailed" },
    { 16, "authorizationError" },
    { 17, "notWritable" },
    { 18, "inconsistentName" },
    { 0, NULL }
};

stls_table_t disman_schedule_mib_enums_schedStorageType[] = {
    { 1, "other" },
    { 2, "volatile" },
    { 3, "nonVolatile" },
    { 4, "permanent" },
    { 5, "readOnly" },
    { 0, NULL }
};

stls_table_t disman_schedule_mib_enums_schedRowStatus[] = {
    { 1, "active" },
    { 2, "notInService" },
    { 3, "notReady" },
    { 4, "createAndGo" },
    { 5, "createAndWait" },
    { 6, "destroy" },
    { 0, NULL }
};


static schedObjects_t *
assign_schedObjects(GSList *vbl)
{
    GSList *elem;
    schedObjects_t *schedObjects;
    char *p;

    schedObjects = (schedObjects_t *) g_malloc0(sizeof(schedObjects_t) + sizeof(GSList *));
    if (! schedObjects) {
        return NULL;
    }

    p = (char *) schedObjects + sizeof(schedObjects_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _schedLocalTimeLength
            && memcmp(vb->id, schedLocalTime, sizeof(schedLocalTime)) == 0) {
            schedObjects->schedLocalTime = vb->syntax.uc;
        }
    }

    return schedObjects;
}

int
disman_schedule_mib_get_schedObjects(host_snmp *s, schedObjects_t **schedObjects)
{
    GSList *in = NULL, *out = NULL;

    *schedObjects = NULL;

    stls_vbl_add_null(&in, schedLocalTime, _schedLocalTimeLength);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *schedObjects = assign_schedObjects(out);

    return 0;
}

void
disman_schedule_mib_free_schedObjects(schedObjects_t *schedObjects)
{
    GSList *vbl;
    char *p;

    if (schedObjects) {
        p = (char *) schedObjects + sizeof(schedObjects_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(schedObjects);
    }
}

static schedEntry_t *
assign_schedEntry(GSList *vbl)
{
    GSList *elem;
    schedEntry_t *schedEntry;
    char *p;

    schedEntry = (schedEntry_t *) g_malloc0(sizeof(schedEntry_t) + sizeof(GSList *));
    if (! schedEntry) {
        return NULL;
    }

    p = (char *) schedEntry + sizeof(schedEntry_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;
        if (vb->type == G_SNMP_ENDOFMIBVIEW
            || (vb->type == G_SNMP_NOSUCHOBJECT)
            || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
            continue;
        }
        if (vb->id_len > _schedDescrLength
            && memcmp(vb->id, schedDescr, sizeof(schedDescr)) == 0) {
            schedEntry->_schedDescrLength = vb->syntax_len;
            schedEntry->schedDescr = vb->syntax.uc;
        }
        if (vb->id_len > _schedIntervalLength
            && memcmp(vb->id, schedInterval, sizeof(schedInterval)) == 0) {
            schedEntry->schedInterval = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _schedWeekDayLength
            && memcmp(vb->id, schedWeekDay, sizeof(schedWeekDay)) == 0) {
            schedEntry->_schedWeekDayLength = vb->syntax_len;
            schedEntry->schedWeekDay = vb->syntax.uc;
        }
        if (vb->id_len > _schedMonthLength
            && memcmp(vb->id, schedMonth, sizeof(schedMonth)) == 0) {
            schedEntry->_schedMonthLength = vb->syntax_len;
            schedEntry->schedMonth = vb->syntax.uc;
        }
        if (vb->id_len > _schedDayLength
            && memcmp(vb->id, schedDay, sizeof(schedDay)) == 0) {
            schedEntry->_schedDayLength = vb->syntax_len;
            schedEntry->schedDay = vb->syntax.uc;
        }
        if (vb->id_len > _schedHourLength
            && memcmp(vb->id, schedHour, sizeof(schedHour)) == 0) {
            schedEntry->_schedHourLength = vb->syntax_len;
            schedEntry->schedHour = vb->syntax.uc;
        }
        if (vb->id_len > _schedMinuteLength
            && memcmp(vb->id, schedMinute, sizeof(schedMinute)) == 0) {
            schedEntry->_schedMinuteLength = vb->syntax_len;
            schedEntry->schedMinute = vb->syntax.uc;
        }
        if (vb->id_len > _schedContextNameLength
            && memcmp(vb->id, schedContextName, sizeof(schedContextName)) == 0) {
            schedEntry->_schedContextNameLength = vb->syntax_len;
            schedEntry->schedContextName = vb->syntax.uc;
        }
        if (vb->id_len > _schedVariableLength
            && memcmp(vb->id, schedVariable, sizeof(schedVariable)) == 0) {
            schedEntry->_schedVariableLength = vb->syntax_len / sizeof(guint32);
            schedEntry->schedVariable = vb->syntax.ui32;
        }
        if (vb->id_len > _schedValueLength
            && memcmp(vb->id, schedValue, sizeof(schedValue)) == 0) {
            schedEntry->schedValue = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedTypeLength
            && memcmp(vb->id, schedType, sizeof(schedType)) == 0) {
            schedEntry->schedType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedAdminStatusLength
            && memcmp(vb->id, schedAdminStatus, sizeof(schedAdminStatus)) == 0) {
            schedEntry->schedAdminStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedOperStatusLength
            && memcmp(vb->id, schedOperStatus, sizeof(schedOperStatus)) == 0) {
            schedEntry->schedOperStatus = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedFailuresLength
            && memcmp(vb->id, schedFailures, sizeof(schedFailures)) == 0) {
            schedEntry->schedFailures = &(vb->syntax.ui32[0]);
        }
        if (vb->id_len > _schedLastFailureLength
            && memcmp(vb->id, schedLastFailure, sizeof(schedLastFailure)) == 0) {
            schedEntry->schedLastFailure = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedLastFailedLength
            && memcmp(vb->id, schedLastFailed, sizeof(schedLastFailed)) == 0) {
            schedEntry->_schedLastFailedLength = vb->syntax_len;
            schedEntry->schedLastFailed = vb->syntax.uc;
        }
        if (vb->id_len > _schedStorageTypeLength
            && memcmp(vb->id, schedStorageType, sizeof(schedStorageType)) == 0) {
            schedEntry->schedStorageType = &(vb->syntax.i32[0]);
        }
        if (vb->id_len > _schedRowStatusLength
            && memcmp(vb->id, schedRowStatus, sizeof(schedRowStatus)) == 0) {
            schedEntry->schedRowStatus = &(vb->syntax.i32[0]);
        }
    }

    return schedEntry;
}

int
disman_schedule_mib_get_schedEntry(host_snmp *s, schedEntry_t ***schedEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;

    *schedEntry = NULL;

    stls_vbl_add_null(&in, schedDescr, _schedDescrLength);
    stls_vbl_add_null(&in, schedInterval, _schedIntervalLength);
    stls_vbl_add_null(&in, schedWeekDay, _schedWeekDayLength);
    stls_vbl_add_null(&in, schedMonth, _schedMonthLength);
    stls_vbl_add_null(&in, schedDay, _schedDayLength);
    stls_vbl_add_null(&in, schedHour, _schedHourLength);
    stls_vbl_add_null(&in, schedMinute, _schedMinuteLength);
    stls_vbl_add_null(&in, schedContextName, _schedContextNameLength);
    stls_vbl_add_null(&in, schedVariable, _schedVariableLength);
    stls_vbl_add_null(&in, schedValue, _schedValueLength);
    stls_vbl_add_null(&in, schedType, _schedTypeLength);
    stls_vbl_add_null(&in, schedAdminStatus, _schedAdminStatusLength);
    stls_vbl_add_null(&in, schedOperStatus, _schedOperStatusLength);
    stls_vbl_add_null(&in, schedFailures, _schedFailuresLength);
    stls_vbl_add_null(&in, schedLastFailure, _schedLastFailureLength);
    stls_vbl_add_null(&in, schedLastFailed, _schedLastFailedLength);
    stls_vbl_add_null(&in, schedStorageType, _schedStorageTypeLength);
    stls_vbl_add_null(&in, schedRowStatus, _schedRowStatusLength);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *schedEntry = (schedEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(schedEntry_t *));
    if (! *schedEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*schedEntry)[i] = assign_schedEntry(row->data);
    }

    return 0;
}

void
disman_schedule_mib_free_schedEntry(schedEntry_t **schedEntry)
{
    GSList *vbl;
    char *p;
    int i;

    if (schedEntry) {
        for (i = 0; schedEntry[i]; i++) {
            p = (char *) schedEntry[i] + sizeof(schedEntry_t);
            vbl = * (GSList **) p;
            stls_vbl_free(vbl);
            g_free(schedEntry[i]);
        }
        g_free(schedEntry);
    }
}


