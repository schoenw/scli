/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.17 for the scli package.
 *
 * Derived from RFC1213-MIB:
 *
 * $Id$
 */

#include "rfc1213-mib.h"

GSnmpEnum const rfc1213_mib_enums_ifType[] = {
    { RFC1213_MIB_IFTYPE_OTHER,	"other" },
    { RFC1213_MIB_IFTYPE_REGULAR1822,	"regular1822" },
    { RFC1213_MIB_IFTYPE_HDH1822,	"hdh1822" },
    { RFC1213_MIB_IFTYPE_DDN_X25,	"ddn-x25" },
    { RFC1213_MIB_IFTYPE_RFC877_X25,	"rfc877-x25" },
    { RFC1213_MIB_IFTYPE_ETHERNET_CSMACD,	"ethernet-csmacd" },
    { RFC1213_MIB_IFTYPE_ISO88023_CSMACD,	"iso88023-csmacd" },
    { RFC1213_MIB_IFTYPE_ISO88024_TOKENBUS,	"iso88024-tokenBus" },
    { RFC1213_MIB_IFTYPE_ISO88025_TOKENRING,	"iso88025-tokenRing" },
    { RFC1213_MIB_IFTYPE_ISO88026_MAN,	"iso88026-man" },
    { RFC1213_MIB_IFTYPE_STARLAN,	"starLan" },
    { RFC1213_MIB_IFTYPE_PROTEON_10MBIT,	"proteon-10Mbit" },
    { RFC1213_MIB_IFTYPE_PROTEON_80MBIT,	"proteon-80Mbit" },
    { RFC1213_MIB_IFTYPE_HYPERCHANNEL,	"hyperchannel" },
    { RFC1213_MIB_IFTYPE_FDDI,	"fddi" },
    { RFC1213_MIB_IFTYPE_LAPB,	"lapb" },
    { RFC1213_MIB_IFTYPE_SDLC,	"sdlc" },
    { RFC1213_MIB_IFTYPE_DS1,	"ds1" },
    { RFC1213_MIB_IFTYPE_E1,	"e1" },
    { RFC1213_MIB_IFTYPE_BASICISDN,	"basicISDN" },
    { RFC1213_MIB_IFTYPE_PRIMARYISDN,	"primaryISDN" },
    { RFC1213_MIB_IFTYPE_PROPPOINTTOPOINTSERIAL,	"propPointToPointSerial" },
    { RFC1213_MIB_IFTYPE_PPP,	"ppp" },
    { RFC1213_MIB_IFTYPE_SOFTWARELOOPBACK,	"softwareLoopback" },
    { RFC1213_MIB_IFTYPE_EON,	"eon" },
    { RFC1213_MIB_IFTYPE_ETHERNET_3MBIT,	"ethernet-3Mbit" },
    { RFC1213_MIB_IFTYPE_NSIP,	"nsip" },
    { RFC1213_MIB_IFTYPE_SLIP,	"slip" },
    { RFC1213_MIB_IFTYPE_ULTRA,	"ultra" },
    { RFC1213_MIB_IFTYPE_DS3,	"ds3" },
    { RFC1213_MIB_IFTYPE_SIP,	"sip" },
    { RFC1213_MIB_IFTYPE_FRAME_RELAY,	"frame-relay" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ifAdminStatus[] = {
    { RFC1213_MIB_IFADMINSTATUS_UP,	"up" },
    { RFC1213_MIB_IFADMINSTATUS_DOWN,	"down" },
    { RFC1213_MIB_IFADMINSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ifOperStatus[] = {
    { RFC1213_MIB_IFOPERSTATUS_UP,	"up" },
    { RFC1213_MIB_IFOPERSTATUS_DOWN,	"down" },
    { RFC1213_MIB_IFOPERSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ipForwarding[] = {
    { RFC1213_MIB_IPFORWARDING_FORWARDING,	"forwarding" },
    { RFC1213_MIB_IPFORWARDING_NOT_FORWARDING,	"not-forwarding" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ipRouteType[] = {
    { RFC1213_MIB_IPROUTETYPE_OTHER,	"other" },
    { RFC1213_MIB_IPROUTETYPE_INVALID,	"invalid" },
    { RFC1213_MIB_IPROUTETYPE_DIRECT,	"direct" },
    { RFC1213_MIB_IPROUTETYPE_INDIRECT,	"indirect" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ipRouteProto[] = {
    { RFC1213_MIB_IPROUTEPROTO_OTHER,	"other" },
    { RFC1213_MIB_IPROUTEPROTO_LOCAL,	"local" },
    { RFC1213_MIB_IPROUTEPROTO_NETMGMT,	"netmgmt" },
    { RFC1213_MIB_IPROUTEPROTO_ICMP,	"icmp" },
    { RFC1213_MIB_IPROUTEPROTO_EGP,	"egp" },
    { RFC1213_MIB_IPROUTEPROTO_GGP,	"ggp" },
    { RFC1213_MIB_IPROUTEPROTO_HELLO,	"hello" },
    { RFC1213_MIB_IPROUTEPROTO_RIP,	"rip" },
    { RFC1213_MIB_IPROUTEPROTO_IS_IS,	"is-is" },
    { RFC1213_MIB_IPROUTEPROTO_ES_IS,	"es-is" },
    { RFC1213_MIB_IPROUTEPROTO_CISCOIGRP,	"ciscoIgrp" },
    { RFC1213_MIB_IPROUTEPROTO_BBNSPFIGP,	"bbnSpfIgp" },
    { RFC1213_MIB_IPROUTEPROTO_OSPF,	"ospf" },
    { RFC1213_MIB_IPROUTEPROTO_BGP,	"bgp" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_ipNetToMediaType[] = {
    { RFC1213_MIB_IPNETTOMEDIATYPE_OTHER,	"other" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_INVALID,	"invalid" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_DYNAMIC,	"dynamic" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_STATIC,	"static" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_tcpRtoAlgorithm[] = {
    { RFC1213_MIB_TCPRTOALGORITHM_OTHER,	"other" },
    { RFC1213_MIB_TCPRTOALGORITHM_CONSTANT,	"constant" },
    { RFC1213_MIB_TCPRTOALGORITHM_RSRE,	"rsre" },
    { RFC1213_MIB_TCPRTOALGORITHM_VANJ,	"vanj" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_tcpConnState[] = {
    { RFC1213_MIB_TCPCONNSTATE_CLOSED,	"closed" },
    { RFC1213_MIB_TCPCONNSTATE_LISTEN,	"listen" },
    { RFC1213_MIB_TCPCONNSTATE_SYNSENT,	"synSent" },
    { RFC1213_MIB_TCPCONNSTATE_SYNRECEIVED,	"synReceived" },
    { RFC1213_MIB_TCPCONNSTATE_ESTABLISHED,	"established" },
    { RFC1213_MIB_TCPCONNSTATE_FINWAIT1,	"finWait1" },
    { RFC1213_MIB_TCPCONNSTATE_FINWAIT2,	"finWait2" },
    { RFC1213_MIB_TCPCONNSTATE_CLOSEWAIT,	"closeWait" },
    { RFC1213_MIB_TCPCONNSTATE_LASTACK,	"lastAck" },
    { RFC1213_MIB_TCPCONNSTATE_CLOSING,	"closing" },
    { RFC1213_MIB_TCPCONNSTATE_TIMEWAIT,	"timeWait" },
    { RFC1213_MIB_TCPCONNSTATE_DELETETCB,	"deleteTCB" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_egpNeighState[] = {
    { RFC1213_MIB_EGPNEIGHSTATE_IDLE,	"idle" },
    { RFC1213_MIB_EGPNEIGHSTATE_ACQUISITION,	"acquisition" },
    { RFC1213_MIB_EGPNEIGHSTATE_DOWN,	"down" },
    { RFC1213_MIB_EGPNEIGHSTATE_UP,	"up" },
    { RFC1213_MIB_EGPNEIGHSTATE_CEASE,	"cease" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_egpNeighMode[] = {
    { RFC1213_MIB_EGPNEIGHMODE_ACTIVE,	"active" },
    { RFC1213_MIB_EGPNEIGHMODE_PASSIVE,	"passive" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_egpNeighEventTrigger[] = {
    { RFC1213_MIB_EGPNEIGHEVENTTRIGGER_START,	"start" },
    { RFC1213_MIB_EGPNEIGHEVENTTRIGGER_STOP,	"stop" },
    { 0, NULL }
};

GSnmpEnum const rfc1213_mib_enums_snmpEnableAuthenTraps[] = {
    { RFC1213_MIB_SNMPENABLEAUTHENTRAPS_ENABLED,	"enabled" },
    { RFC1213_MIB_SNMPENABLEAUTHENTRAPS_DISABLED,	"disabled" },
    { 0, NULL }
};


typedef struct {
    guint32 const     subid;
    GSnmpVarBindType  type;
    gint              tag;
    gchar            *label;
} attribute_t;

static void
add_attributes(GSnmpSession *s, GSList **vbl, guint32 *base, gsize len,
                guint idx, attribute_t *attributes, gint mask)
{
    int i;

    for (i = 0; attributes[i].label; i++) {
        if (! mask || (mask & attributes[i].tag)) {
            if (attributes[i].type != G_SNMP_COUNTER64
                || s->version > G_SNMP_V1) {
                base[idx] = attributes[i].subid;
                g_snmp_vbl_add_null(vbl, base, len);
            }
        }
    }
}

static int
lookup(GSnmpVarBind *vb, guint32 const *base, gsize const base_len,
	    attribute_t *attributes, guint32 *idx)
{
    int i;

    if (vb->type == G_SNMP_ENDOFMIBVIEW
        || (vb->type == G_SNMP_NOSUCHOBJECT)
        || (vb->type == G_SNMP_NOSUCHINSTANCE)) {
        return -1;
    }
    
    if (memcmp(vb->id, base, base_len * sizeof(guint32)) != 0) {
	return -2;
    }

    for (i = 0; attributes[i].label; i++) {
	if (vb->id_len > base_len && vb->id[base_len] == attributes[i].subid) {
	    if (vb->type != attributes[i].type) {
		g_warning("type tag 0x%02x does not match 0x%02x (%s)",
			  vb->type, attributes[i].type, attributes[i].label);
		return -3;
	    }
	    *idx = attributes[i].subid;
	    return 0;
	}
    }
    
    return -4;
}

static guint32 const oid_system[] = {1, 3, 6, 1, 2, 1, 1};

static attribute_t attr_system[] = {
    { 1, G_SNMP_OCTET_STRING, RFC1213_MIB_SYSDESCR, "sysDescr" },
    { 2, G_SNMP_OBJECT_ID, RFC1213_MIB_SYSOBJECTID, "sysObjectID" },
    { 3, G_SNMP_TIMETICKS, RFC1213_MIB_SYSUPTIME, "sysUpTime" },
    { 4, G_SNMP_OCTET_STRING, RFC1213_MIB_SYSCONTACT, "sysContact" },
    { 5, G_SNMP_OCTET_STRING, RFC1213_MIB_SYSNAME, "sysName" },
    { 6, G_SNMP_OCTET_STRING, RFC1213_MIB_SYSLOCATION, "sysLocation" },
    { 7, G_SNMP_INTEGER32, RFC1213_MIB_SYSSERVICES, "sysServices" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_interfaces[] = {1, 3, 6, 1, 2, 1, 2};

static attribute_t attr_interfaces[] = {
    { 1, G_SNMP_INTEGER32, RFC1213_MIB_IFNUMBER, "ifNumber" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ifEntry[] = {1, 3, 6, 1, 2, 1, 2, 2, 1};

static attribute_t attr_ifEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RFC1213_MIB_IFDESCR, "ifDescr" },
    { 3, G_SNMP_INTEGER32, RFC1213_MIB_IFTYPE, "ifType" },
    { 4, G_SNMP_INTEGER32, RFC1213_MIB_IFMTU, "ifMtu" },
    { 5, G_SNMP_UNSIGNED32, RFC1213_MIB_IFSPEED, "ifSpeed" },
    { 6, G_SNMP_OCTET_STRING, RFC1213_MIB_IFPHYSADDRESS, "ifPhysAddress" },
    { 7, G_SNMP_INTEGER32, RFC1213_MIB_IFADMINSTATUS, "ifAdminStatus" },
    { 8, G_SNMP_INTEGER32, RFC1213_MIB_IFOPERSTATUS, "ifOperStatus" },
    { 9, G_SNMP_TIMETICKS, RFC1213_MIB_IFLASTCHANGE, "ifLastChange" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_IFINOCTETS, "ifInOctets" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_IFINUCASTPKTS, "ifInUcastPkts" },
    { 12, G_SNMP_COUNTER32, RFC1213_MIB_IFINNUCASTPKTS, "ifInNUcastPkts" },
    { 13, G_SNMP_COUNTER32, RFC1213_MIB_IFINDISCARDS, "ifInDiscards" },
    { 14, G_SNMP_COUNTER32, RFC1213_MIB_IFINERRORS, "ifInErrors" },
    { 15, G_SNMP_COUNTER32, RFC1213_MIB_IFINUNKNOWNPROTOS, "ifInUnknownProtos" },
    { 16, G_SNMP_COUNTER32, RFC1213_MIB_IFOUTOCTETS, "ifOutOctets" },
    { 17, G_SNMP_COUNTER32, RFC1213_MIB_IFOUTUCASTPKTS, "ifOutUcastPkts" },
    { 18, G_SNMP_COUNTER32, RFC1213_MIB_IFOUTNUCASTPKTS, "ifOutNUcastPkts" },
    { 19, G_SNMP_COUNTER32, RFC1213_MIB_IFOUTDISCARDS, "ifOutDiscards" },
    { 20, G_SNMP_COUNTER32, RFC1213_MIB_IFOUTERRORS, "ifOutErrors" },
    { 21, G_SNMP_UNSIGNED32, RFC1213_MIB_IFOUTQLEN, "ifOutQLen" },
    { 22, G_SNMP_OBJECT_ID, RFC1213_MIB_IFSPECIFIC, "ifSpecific" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_atEntry[] = {1, 3, 6, 1, 2, 1, 3, 1, 1};

static attribute_t attr_atEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RFC1213_MIB_ATPHYSADDRESS, "atPhysAddress" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ip[] = {1, 3, 6, 1, 2, 1, 4};

static attribute_t attr_ip[] = {
    { 1, G_SNMP_INTEGER32, RFC1213_MIB_IPFORWARDING, "ipForwarding" },
    { 2, G_SNMP_INTEGER32, RFC1213_MIB_IPDEFAULTTTL, "ipDefaultTTL" },
    { 3, G_SNMP_COUNTER32, RFC1213_MIB_IPINRECEIVES, "ipInReceives" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_IPINHDRERRORS, "ipInHdrErrors" },
    { 5, G_SNMP_COUNTER32, RFC1213_MIB_IPINADDRERRORS, "ipInAddrErrors" },
    { 6, G_SNMP_COUNTER32, RFC1213_MIB_IPFORWDATAGRAMS, "ipForwDatagrams" },
    { 7, G_SNMP_COUNTER32, RFC1213_MIB_IPINUNKNOWNPROTOS, "ipInUnknownProtos" },
    { 8, G_SNMP_COUNTER32, RFC1213_MIB_IPINDISCARDS, "ipInDiscards" },
    { 9, G_SNMP_COUNTER32, RFC1213_MIB_IPINDELIVERS, "ipInDelivers" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_IPOUTREQUESTS, "ipOutRequests" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_IPOUTDISCARDS, "ipOutDiscards" },
    { 12, G_SNMP_COUNTER32, RFC1213_MIB_IPOUTNOROUTES, "ipOutNoRoutes" },
    { 13, G_SNMP_INTEGER32, RFC1213_MIB_IPREASMTIMEOUT, "ipReasmTimeout" },
    { 14, G_SNMP_COUNTER32, RFC1213_MIB_IPREASMREQDS, "ipReasmReqds" },
    { 15, G_SNMP_COUNTER32, RFC1213_MIB_IPREASMOKS, "ipReasmOKs" },
    { 16, G_SNMP_COUNTER32, RFC1213_MIB_IPREASMFAILS, "ipReasmFails" },
    { 17, G_SNMP_COUNTER32, RFC1213_MIB_IPFRAGOKS, "ipFragOKs" },
    { 18, G_SNMP_COUNTER32, RFC1213_MIB_IPFRAGFAILS, "ipFragFails" },
    { 19, G_SNMP_COUNTER32, RFC1213_MIB_IPFRAGCREATES, "ipFragCreates" },
    { 23, G_SNMP_COUNTER32, RFC1213_MIB_IPROUTINGDISCARDS, "ipRoutingDiscards" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ipAddrEntry[] = {1, 3, 6, 1, 2, 1, 4, 20, 1};

static attribute_t attr_ipAddrEntry[] = {
    { 2, G_SNMP_INTEGER32, RFC1213_MIB_IPADENTIFINDEX, "ipAdEntIfIndex" },
    { 3, G_SNMP_IPADDRESS, RFC1213_MIB_IPADENTNETMASK, "ipAdEntNetMask" },
    { 4, G_SNMP_INTEGER32, RFC1213_MIB_IPADENTBCASTADDR, "ipAdEntBcastAddr" },
    { 5, G_SNMP_INTEGER32, RFC1213_MIB_IPADENTREASMMAXSIZE, "ipAdEntReasmMaxSize" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ipRouteEntry[] = {1, 3, 6, 1, 2, 1, 4, 21, 1};

static attribute_t attr_ipRouteEntry[] = {
    { 2, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEIFINDEX, "ipRouteIfIndex" },
    { 3, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEMETRIC1, "ipRouteMetric1" },
    { 4, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEMETRIC2, "ipRouteMetric2" },
    { 5, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEMETRIC3, "ipRouteMetric3" },
    { 6, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEMETRIC4, "ipRouteMetric4" },
    { 7, G_SNMP_IPADDRESS, RFC1213_MIB_IPROUTENEXTHOP, "ipRouteNextHop" },
    { 8, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTETYPE, "ipRouteType" },
    { 9, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEPROTO, "ipRouteProto" },
    { 10, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEAGE, "ipRouteAge" },
    { 11, G_SNMP_IPADDRESS, RFC1213_MIB_IPROUTEMASK, "ipRouteMask" },
    { 12, G_SNMP_INTEGER32, RFC1213_MIB_IPROUTEMETRIC5, "ipRouteMetric5" },
    { 13, G_SNMP_OBJECT_ID, RFC1213_MIB_IPROUTEINFO, "ipRouteInfo" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_ipNetToMediaEntry[] = {1, 3, 6, 1, 2, 1, 4, 22, 1};

static attribute_t attr_ipNetToMediaEntry[] = {
    { 2, G_SNMP_OCTET_STRING, RFC1213_MIB_IPNETTOMEDIAPHYSADDRESS, "ipNetToMediaPhysAddress" },
    { 4, G_SNMP_INTEGER32, RFC1213_MIB_IPNETTOMEDIATYPE, "ipNetToMediaType" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_icmp[] = {1, 3, 6, 1, 2, 1, 5};

static attribute_t attr_icmp[] = {
    { 1, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINMSGS, "icmpInMsgs" },
    { 2, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINERRORS, "icmpInErrors" },
    { 3, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINDESTUNREACHS, "icmpInDestUnreachs" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINTIMEEXCDS, "icmpInTimeExcds" },
    { 5, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINPARMPROBS, "icmpInParmProbs" },
    { 6, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINSRCQUENCHS, "icmpInSrcQuenchs" },
    { 7, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINREDIRECTS, "icmpInRedirects" },
    { 8, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINECHOS, "icmpInEchos" },
    { 9, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINECHOREPS, "icmpInEchoReps" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINTIMESTAMPS, "icmpInTimestamps" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINTIMESTAMPREPS, "icmpInTimestampReps" },
    { 12, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINADDRMASKS, "icmpInAddrMasks" },
    { 13, G_SNMP_COUNTER32, RFC1213_MIB_ICMPINADDRMASKREPS, "icmpInAddrMaskReps" },
    { 14, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTMSGS, "icmpOutMsgs" },
    { 15, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTERRORS, "icmpOutErrors" },
    { 16, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTDESTUNREACHS, "icmpOutDestUnreachs" },
    { 17, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTTIMEEXCDS, "icmpOutTimeExcds" },
    { 18, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTPARMPROBS, "icmpOutParmProbs" },
    { 19, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTSRCQUENCHS, "icmpOutSrcQuenchs" },
    { 20, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTREDIRECTS, "icmpOutRedirects" },
    { 21, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTECHOS, "icmpOutEchos" },
    { 22, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTECHOREPS, "icmpOutEchoReps" },
    { 23, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTTIMESTAMPS, "icmpOutTimestamps" },
    { 24, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTTIMESTAMPREPS, "icmpOutTimestampReps" },
    { 25, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTADDRMASKS, "icmpOutAddrMasks" },
    { 26, G_SNMP_COUNTER32, RFC1213_MIB_ICMPOUTADDRMASKREPS, "icmpOutAddrMaskReps" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_tcp[] = {1, 3, 6, 1, 2, 1, 6};

static attribute_t attr_tcp[] = {
    { 1, G_SNMP_INTEGER32, RFC1213_MIB_TCPRTOALGORITHM, "tcpRtoAlgorithm" },
    { 2, G_SNMP_INTEGER32, RFC1213_MIB_TCPRTOMIN, "tcpRtoMin" },
    { 3, G_SNMP_INTEGER32, RFC1213_MIB_TCPRTOMAX, "tcpRtoMax" },
    { 4, G_SNMP_INTEGER32, RFC1213_MIB_TCPMAXCONN, "tcpMaxConn" },
    { 5, G_SNMP_COUNTER32, RFC1213_MIB_TCPACTIVEOPENS, "tcpActiveOpens" },
    { 6, G_SNMP_COUNTER32, RFC1213_MIB_TCPPASSIVEOPENS, "tcpPassiveOpens" },
    { 7, G_SNMP_COUNTER32, RFC1213_MIB_TCPATTEMPTFAILS, "tcpAttemptFails" },
    { 8, G_SNMP_COUNTER32, RFC1213_MIB_TCPESTABRESETS, "tcpEstabResets" },
    { 9, G_SNMP_UNSIGNED32, RFC1213_MIB_TCPCURRESTAB, "tcpCurrEstab" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_TCPINSEGS, "tcpInSegs" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_TCPOUTSEGS, "tcpOutSegs" },
    { 12, G_SNMP_COUNTER32, RFC1213_MIB_TCPRETRANSSEGS, "tcpRetransSegs" },
    { 14, G_SNMP_COUNTER32, RFC1213_MIB_TCPINERRS, "tcpInErrs" },
    { 15, G_SNMP_COUNTER32, RFC1213_MIB_TCPOUTRSTS, "tcpOutRsts" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_tcpConnEntry[] = {1, 3, 6, 1, 2, 1, 6, 13, 1};

static attribute_t attr_tcpConnEntry[] = {
    { 1, G_SNMP_INTEGER32, RFC1213_MIB_TCPCONNSTATE, "tcpConnState" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_udp[] = {1, 3, 6, 1, 2, 1, 7};

static attribute_t attr_udp[] = {
    { 1, G_SNMP_COUNTER32, RFC1213_MIB_UDPINDATAGRAMS, "udpInDatagrams" },
    { 2, G_SNMP_COUNTER32, RFC1213_MIB_UDPNOPORTS, "udpNoPorts" },
    { 3, G_SNMP_COUNTER32, RFC1213_MIB_UDPINERRORS, "udpInErrors" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_UDPOUTDATAGRAMS, "udpOutDatagrams" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_udpEntry[] = {1, 3, 6, 1, 2, 1, 7, 5, 1};

static attribute_t attr_udpEntry[] = {
    { 1, G_SNMP_IPADDRESS, RFC1213_MIB_UDPLOCALADDRESS, "udpLocalAddress" },
    { 2, G_SNMP_INTEGER32, RFC1213_MIB_UDPLOCALPORT, "udpLocalPort" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_egp[] = {1, 3, 6, 1, 2, 1, 8};

static attribute_t attr_egp[] = {
    { 1, G_SNMP_COUNTER32, RFC1213_MIB_EGPINMSGS, "egpInMsgs" },
    { 2, G_SNMP_COUNTER32, RFC1213_MIB_EGPINERRORS, "egpInErrors" },
    { 3, G_SNMP_COUNTER32, RFC1213_MIB_EGPOUTMSGS, "egpOutMsgs" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_EGPOUTERRORS, "egpOutErrors" },
    { 6, G_SNMP_INTEGER32, RFC1213_MIB_EGPAS, "egpAs" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_egpNeighEntry[] = {1, 3, 6, 1, 2, 1, 8, 5, 1};

static attribute_t attr_egpNeighEntry[] = {
    { 1, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHSTATE, "egpNeighState" },
    { 3, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHAS, "egpNeighAs" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHINMSGS, "egpNeighInMsgs" },
    { 5, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHINERRS, "egpNeighInErrs" },
    { 6, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHOUTMSGS, "egpNeighOutMsgs" },
    { 7, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHOUTERRS, "egpNeighOutErrs" },
    { 8, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHINERRMSGS, "egpNeighInErrMsgs" },
    { 9, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHOUTERRMSGS, "egpNeighOutErrMsgs" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHSTATEUPS, "egpNeighStateUps" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_EGPNEIGHSTATEDOWNS, "egpNeighStateDowns" },
    { 12, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHINTERVALHELLO, "egpNeighIntervalHello" },
    { 13, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHINTERVALPOLL, "egpNeighIntervalPoll" },
    { 14, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHMODE, "egpNeighMode" },
    { 15, G_SNMP_INTEGER32, RFC1213_MIB_EGPNEIGHEVENTTRIGGER, "egpNeighEventTrigger" },
    { 0, 0, 0, NULL }
};

static guint32 const oid_snmp[] = {1, 3, 6, 1, 2, 1, 11};

static attribute_t attr_snmp[] = {
    { 1, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINPKTS, "snmpInPkts" },
    { 2, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTPKTS, "snmpOutPkts" },
    { 3, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINBADVERSIONS, "snmpInBadVersions" },
    { 4, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINBADCOMMUNITYNAMES, "snmpInBadCommunityNames" },
    { 5, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINBADCOMMUNITYUSES, "snmpInBadCommunityUses" },
    { 6, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINASNPARSEERRS, "snmpInASNParseErrs" },
    { 8, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINTOOBIGS, "snmpInTooBigs" },
    { 9, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINNOSUCHNAMES, "snmpInNoSuchNames" },
    { 10, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINBADVALUES, "snmpInBadValues" },
    { 11, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINREADONLYS, "snmpInReadOnlys" },
    { 12, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINGENERRS, "snmpInGenErrs" },
    { 13, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINTOTALREQVARS, "snmpInTotalReqVars" },
    { 14, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINTOTALSETVARS, "snmpInTotalSetVars" },
    { 15, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINGETREQUESTS, "snmpInGetRequests" },
    { 16, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINGETNEXTS, "snmpInGetNexts" },
    { 17, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINSETREQUESTS, "snmpInSetRequests" },
    { 18, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINGETRESPONSES, "snmpInGetResponses" },
    { 19, G_SNMP_COUNTER32, RFC1213_MIB_SNMPINTRAPS, "snmpInTraps" },
    { 20, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTTOOBIGS, "snmpOutTooBigs" },
    { 21, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTNOSUCHNAMES, "snmpOutNoSuchNames" },
    { 22, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTBADVALUES, "snmpOutBadValues" },
    { 24, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTGENERRS, "snmpOutGenErrs" },
    { 25, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTGETREQUESTS, "snmpOutGetRequests" },
    { 26, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTGETNEXTS, "snmpOutGetNexts" },
    { 27, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTSETREQUESTS, "snmpOutSetRequests" },
    { 28, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTGETRESPONSES, "snmpOutGetResponses" },
    { 29, G_SNMP_COUNTER32, RFC1213_MIB_SNMPOUTTRAPS, "snmpOutTraps" },
    { 30, G_SNMP_INTEGER32, RFC1213_MIB_SNMPENABLEAUTHENTRAPS, "snmpEnableAuthenTraps" },
    { 0, 0, 0, NULL }
};


rfc1213_mib_system_t *
rfc1213_mib_new_system()
{
    rfc1213_mib_system_t *system;

    system = (rfc1213_mib_system_t *) g_malloc0(sizeof(rfc1213_mib_system_t) + sizeof(gpointer));
    return system;
}

static rfc1213_mib_system_t *
assign_system(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_system_t *system;
    guint32 idx;
    char *p;

    system = rfc1213_mib_new_system();
    if (! system) {
        return NULL;
    }

    p = (char *) system + sizeof(rfc1213_mib_system_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_system, sizeof(oid_system)/sizeof(guint32),
                   attr_system, &idx) < 0) continue;

        switch (idx) {
        case 1:
            system->_sysDescrLength = vb->syntax_len;
            system->sysDescr = vb->syntax.uc;
            break;
        case 2:
            system->_sysObjectIDLength = vb->syntax_len / sizeof(guint32);
            system->sysObjectID = vb->syntax.ui32;
            break;
        case 3:
            system->sysUpTime = &(vb->syntax.ui32[0]);
            break;
        case 4:
            system->_sysContactLength = vb->syntax_len;
            system->sysContact = vb->syntax.uc;
            break;
        case 5:
            system->_sysNameLength = vb->syntax_len;
            system->sysName = vb->syntax.uc;
            break;
        case 6:
            system->_sysLocationLength = vb->syntax_len;
            system->sysLocation = vb->syntax.uc;
            break;
        case 7:
            system->sysServices = &(vb->syntax.i32[0]);
            break;
        };
    }

    return system;
}

void
rfc1213_mib_get_system(GSnmpSession *s, rfc1213_mib_system_t **system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0};

    *system = NULL;

    add_attributes(s, &in, base, 8, 7, attr_system, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *system = assign_system(out);
    }
}

void
rfc1213_mib_set_system(GSnmpSession *s, rfc1213_mib_system_t *system, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0, 0};

    if (system->sysContact) {
        base[7] = 4;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysContact,
                       system->_sysContactLength);
    }
    if (system->sysName) {
        base[7] = 5;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysName,
                       system->_sysNameLength);
    }
    if (system->sysLocation) {
        base[7] = 6;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_OCTET_STRING,
                       system->sysLocation,
                       system->_sysLocationLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_system(rfc1213_mib_system_t *system)
{
    GSList *vbl;
    char *p;

    if (system) {
        p = (char *) system + sizeof(rfc1213_mib_system_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(system);
    }
}

rfc1213_mib_interfaces_t *
rfc1213_mib_new_interfaces()
{
    rfc1213_mib_interfaces_t *interfaces;

    interfaces = (rfc1213_mib_interfaces_t *) g_malloc0(sizeof(rfc1213_mib_interfaces_t) + sizeof(gpointer));
    return interfaces;
}

static rfc1213_mib_interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_interfaces_t *interfaces;
    guint32 idx;
    char *p;

    interfaces = rfc1213_mib_new_interfaces();
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(rfc1213_mib_interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_interfaces, sizeof(oid_interfaces)/sizeof(guint32),
                   attr_interfaces, &idx) < 0) continue;

        switch (idx) {
        case 1:
            interfaces->ifNumber = &(vb->syntax.i32[0]);
            break;
        };
    }

    return interfaces;
}

void
rfc1213_mib_get_interfaces(GSnmpSession *s, rfc1213_mib_interfaces_t **interfaces, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 0};

    *interfaces = NULL;

    add_attributes(s, &in, base, 8, 7, attr_interfaces, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *interfaces = assign_interfaces(out);
    }
}

void
rfc1213_mib_free_interfaces(rfc1213_mib_interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(rfc1213_mib_interfaces_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(interfaces);
    }
}

rfc1213_mib_ifEntry_t *
rfc1213_mib_new_ifEntry()
{
    rfc1213_mib_ifEntry_t *ifEntry;

    ifEntry = (rfc1213_mib_ifEntry_t *) g_malloc0(sizeof(rfc1213_mib_ifEntry_t) + sizeof(gpointer));
    return ifEntry;
}

static int
unpack_ifEntry(GSnmpVarBind *vb, rfc1213_mib_ifEntry_t *ifEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    ifEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ifEntry(guint32 *base, gint32 ifIndex)
{
    int idx = 10;

    base[idx++] = ifIndex;
    return idx;
}

static rfc1213_mib_ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ifEntry_t *ifEntry;
    guint32 idx;
    char *p;

    ifEntry = rfc1213_mib_new_ifEntry();
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(rfc1213_mib_ifEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifEntry((GSnmpVarBind *) vbl->data, ifEntry) < 0) {
        g_warning("illegal ifEntry instance identifier");
        g_free(ifEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ifEntry, sizeof(oid_ifEntry)/sizeof(guint32),
                   attr_ifEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ifEntry->_ifDescrLength = vb->syntax_len;
            ifEntry->ifDescr = vb->syntax.uc;
            break;
        case 3:
            ifEntry->ifType = &(vb->syntax.i32[0]);
            break;
        case 4:
            ifEntry->ifMtu = &(vb->syntax.i32[0]);
            break;
        case 5:
            ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ifEntry->_ifPhysAddressLength = vb->syntax_len;
            ifEntry->ifPhysAddress = vb->syntax.uc;
            break;
        case 7:
            ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 14:
            ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 20:
            ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 21:
            ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
            break;
        case 22:
            ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
            ifEntry->ifSpecific = vb->syntax.ui32;
            break;
        };
    }

    return ifEntry;
}

void
rfc1213_mib_get_ifTable(GSnmpSession *s, rfc1213_mib_ifEntry_t ***ifEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 0};

    *ifEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ifEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ifEntry = (rfc1213_mib_ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ifEntry_t *));
        if (! *ifEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ifEntry)[i] = assign_ifEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_ifEntry(GSnmpSession *s, rfc1213_mib_ifEntry_t **ifEntry, gint32 ifIndex, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ifEntry, sizeof(oid_ifEntry));
    len = pack_ifEntry(base, ifIndex);
    if (len < 0) {
        g_warning("illegal ifEntry index values");
        return;
    }

    *ifEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ifEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *ifEntry = assign_ifEntry(out);
    }
}

void
rfc1213_mib_set_ifEntry(GSnmpSession *s, rfc1213_mib_ifEntry_t *ifEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ifEntry, sizeof(oid_ifEntry));
    len = pack_ifEntry(base, ifEntry->ifIndex);
    if (len < 0) {
        g_warning("illegal ifEntry index values");
        return;
    }

    if (ifEntry->ifAdminStatus) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ifEntry->ifAdminStatus,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_ifEntry(rfc1213_mib_ifEntry_t *ifEntry)
{
    GSList *vbl;
    char *p;

    if (ifEntry) {
        p = (char *) ifEntry + sizeof(rfc1213_mib_ifEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ifEntry);
    }
}

void
rfc1213_mib_free_ifTable(rfc1213_mib_ifEntry_t **ifEntry)
{
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            rfc1213_mib_free_ifEntry(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

rfc1213_mib_atEntry_t *
rfc1213_mib_new_atEntry()
{
    rfc1213_mib_atEntry_t *atEntry;

    atEntry = (rfc1213_mib_atEntry_t *) g_malloc0(sizeof(rfc1213_mib_atEntry_t) + sizeof(gpointer));
    return atEntry;
}

static int
unpack_atEntry(GSnmpVarBind *vb, rfc1213_mib_atEntry_t *atEntry)
{
    int i, len, idx = 10;

    if (vb->id_len < idx) return -1;
    atEntry->atIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        atEntry->atNetAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_atEntry(guint32 *base, gint32 atIfIndex, guchar *atNetAddress)
{
    int i, len, idx = 10;

    base[idx++] = atIfIndex;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = atNetAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rfc1213_mib_atEntry_t *
assign_atEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_atEntry_t *atEntry;
    guint32 idx;
    char *p;

    atEntry = rfc1213_mib_new_atEntry();
    if (! atEntry) {
        return NULL;
    }

    p = (char *) atEntry + sizeof(rfc1213_mib_atEntry_t);
    * (GSList **) p = vbl;

    if (unpack_atEntry((GSnmpVarBind *) vbl->data, atEntry) < 0) {
        g_warning("illegal atEntry instance identifier");
        g_free(atEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_atEntry, sizeof(oid_atEntry)/sizeof(guint32),
                   attr_atEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            atEntry->_atPhysAddressLength = vb->syntax_len;
            atEntry->atPhysAddress = vb->syntax.uc;
            break;
        };
    }

    return atEntry;
}

void
rfc1213_mib_get_atTable(GSnmpSession *s, rfc1213_mib_atEntry_t ***atEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 3, 1, 1, 0};

    *atEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_atEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *atEntry = (rfc1213_mib_atEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_atEntry_t *));
        if (! *atEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*atEntry)[i] = assign_atEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_atEntry(GSnmpSession *s, rfc1213_mib_atEntry_t **atEntry, gint32 atIfIndex, guchar *atNetAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_atEntry, sizeof(oid_atEntry));
    len = pack_atEntry(base, atIfIndex, atNetAddress);
    if (len < 0) {
        g_warning("illegal atEntry index values");
        return;
    }

    *atEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_atEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *atEntry = assign_atEntry(out);
    }
}

void
rfc1213_mib_set_atEntry(GSnmpSession *s, rfc1213_mib_atEntry_t *atEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_atEntry, sizeof(oid_atEntry));
    len = pack_atEntry(base, atEntry->atIfIndex, atEntry->atNetAddress);
    if (len < 0) {
        g_warning("illegal atEntry index values");
        return;
    }

    if (atEntry->atPhysAddress) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       atEntry->atPhysAddress,
                       atEntry->_atPhysAddressLength);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_atEntry(rfc1213_mib_atEntry_t *atEntry)
{
    GSList *vbl;
    char *p;

    if (atEntry) {
        p = (char *) atEntry + sizeof(rfc1213_mib_atEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(atEntry);
    }
}

void
rfc1213_mib_free_atTable(rfc1213_mib_atEntry_t **atEntry)
{
    int i;

    if (atEntry) {
        for (i = 0; atEntry[i]; i++) {
            rfc1213_mib_free_atEntry(atEntry[i]);
        }
        g_free(atEntry);
    }
}

rfc1213_mib_ip_t *
rfc1213_mib_new_ip()
{
    rfc1213_mib_ip_t *ip;

    ip = (rfc1213_mib_ip_t *) g_malloc0(sizeof(rfc1213_mib_ip_t) + sizeof(gpointer));
    return ip;
}

static rfc1213_mib_ip_t *
assign_ip(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ip_t *ip;
    guint32 idx;
    char *p;

    ip = rfc1213_mib_new_ip();
    if (! ip) {
        return NULL;
    }

    p = (char *) ip + sizeof(rfc1213_mib_ip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ip, sizeof(oid_ip)/sizeof(guint32),
                   attr_ip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ip->ipForwarding = &(vb->syntax.i32[0]);
            break;
        case 2:
            ip->ipDefaultTTL = &(vb->syntax.i32[0]);
            break;
        case 3:
            ip->ipInReceives = &(vb->syntax.ui32[0]);
            break;
        case 4:
            ip->ipInHdrErrors = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ip->ipInAddrErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ip->ipForwDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ip->ipInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ip->ipInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ip->ipInDelivers = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ip->ipOutRequests = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ip->ipOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ip->ipOutNoRoutes = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ip->ipReasmTimeout = &(vb->syntax.i32[0]);
            break;
        case 14:
            ip->ipReasmReqds = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ip->ipReasmOKs = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ip->ipReasmFails = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ip->ipFragOKs = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ip->ipFragFails = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ip->ipFragCreates = &(vb->syntax.ui32[0]);
            break;
        case 23:
            ip->ipRoutingDiscards = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return ip;
}

void
rfc1213_mib_get_ip(GSnmpSession *s, rfc1213_mib_ip_t **ip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0};

    *ip = NULL;

    add_attributes(s, &in, base, 8, 7, attr_ip, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *ip = assign_ip(out);
    }
}

void
rfc1213_mib_set_ip(GSnmpSession *s, rfc1213_mib_ip_t *ip, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0, 0};

    if (ip->ipForwarding) {
        base[7] = 1;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ip->ipForwarding,
                       0);
    }
    if (ip->ipDefaultTTL) {
        base[7] = 2;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       ip->ipDefaultTTL,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_ip(rfc1213_mib_ip_t *ip)
{
    GSList *vbl;
    char *p;

    if (ip) {
        p = (char *) ip + sizeof(rfc1213_mib_ip_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ip);
    }
}

rfc1213_mib_ipAddrEntry_t *
rfc1213_mib_new_ipAddrEntry()
{
    rfc1213_mib_ipAddrEntry_t *ipAddrEntry;

    ipAddrEntry = (rfc1213_mib_ipAddrEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipAddrEntry_t) + sizeof(gpointer));
    return ipAddrEntry;
}

static int
unpack_ipAddrEntry(GSnmpVarBind *vb, rfc1213_mib_ipAddrEntry_t *ipAddrEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddrEntry->ipAdEntAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ipAddrEntry(guint32 *base, guchar *ipAdEntAddr)
{
    int i, len, idx = 10;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = ipAdEntAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rfc1213_mib_ipAddrEntry_t *
assign_ipAddrEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipAddrEntry_t *ipAddrEntry;
    guint32 idx;
    char *p;

    ipAddrEntry = rfc1213_mib_new_ipAddrEntry();
    if (! ipAddrEntry) {
        return NULL;
    }

    p = (char *) ipAddrEntry + sizeof(rfc1213_mib_ipAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipAddrEntry((GSnmpVarBind *) vbl->data, ipAddrEntry) < 0) {
        g_warning("illegal ipAddrEntry instance identifier");
        g_free(ipAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ipAddrEntry, sizeof(oid_ipAddrEntry)/sizeof(guint32),
                   attr_ipAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipAddrEntry->ipAdEntIfIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            ipAddrEntry->ipAdEntNetMask = vb->syntax.uc;
            break;
        case 4:
            ipAddrEntry->ipAdEntBcastAddr = &(vb->syntax.i32[0]);
            break;
        case 5:
            ipAddrEntry->ipAdEntReasmMaxSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipAddrEntry;
}

void
rfc1213_mib_get_ipAddrTable(GSnmpSession *s, rfc1213_mib_ipAddrEntry_t ***ipAddrEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 20, 1, 0};

    *ipAddrEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ipAddrEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ipAddrEntry = (rfc1213_mib_ipAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipAddrEntry_t *));
        if (! *ipAddrEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ipAddrEntry)[i] = assign_ipAddrEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_ipAddrEntry(GSnmpSession *s, rfc1213_mib_ipAddrEntry_t **ipAddrEntry, guchar *ipAdEntAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipAddrEntry, sizeof(oid_ipAddrEntry));
    len = pack_ipAddrEntry(base, ipAdEntAddr);
    if (len < 0) {
        g_warning("illegal ipAddrEntry index values");
        return;
    }

    *ipAddrEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ipAddrEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *ipAddrEntry = assign_ipAddrEntry(out);
    }
}

void
rfc1213_mib_free_ipAddrEntry(rfc1213_mib_ipAddrEntry_t *ipAddrEntry)
{
    GSList *vbl;
    char *p;

    if (ipAddrEntry) {
        p = (char *) ipAddrEntry + sizeof(rfc1213_mib_ipAddrEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ipAddrEntry);
    }
}

void
rfc1213_mib_free_ipAddrTable(rfc1213_mib_ipAddrEntry_t **ipAddrEntry)
{
    int i;

    if (ipAddrEntry) {
        for (i = 0; ipAddrEntry[i]; i++) {
            rfc1213_mib_free_ipAddrEntry(ipAddrEntry[i]);
        }
        g_free(ipAddrEntry);
    }
}

rfc1213_mib_ipRouteEntry_t *
rfc1213_mib_new_ipRouteEntry()
{
    rfc1213_mib_ipRouteEntry_t *ipRouteEntry;

    ipRouteEntry = (rfc1213_mib_ipRouteEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipRouteEntry_t) + sizeof(gpointer));
    return ipRouteEntry;
}

static int
unpack_ipRouteEntry(GSnmpVarBind *vb, rfc1213_mib_ipRouteEntry_t *ipRouteEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipRouteEntry->ipRouteDest[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ipRouteEntry(guint32 *base, guchar *ipRouteDest)
{
    int i, len, idx = 10;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = ipRouteDest[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rfc1213_mib_ipRouteEntry_t *
assign_ipRouteEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipRouteEntry_t *ipRouteEntry;
    guint32 idx;
    char *p;

    ipRouteEntry = rfc1213_mib_new_ipRouteEntry();
    if (! ipRouteEntry) {
        return NULL;
    }

    p = (char *) ipRouteEntry + sizeof(rfc1213_mib_ipRouteEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipRouteEntry((GSnmpVarBind *) vbl->data, ipRouteEntry) < 0) {
        g_warning("illegal ipRouteEntry instance identifier");
        g_free(ipRouteEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ipRouteEntry, sizeof(oid_ipRouteEntry)/sizeof(guint32),
                   attr_ipRouteEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipRouteEntry->ipRouteIfIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            ipRouteEntry->ipRouteMetric1 = &(vb->syntax.i32[0]);
            break;
        case 4:
            ipRouteEntry->ipRouteMetric2 = &(vb->syntax.i32[0]);
            break;
        case 5:
            ipRouteEntry->ipRouteMetric3 = &(vb->syntax.i32[0]);
            break;
        case 6:
            ipRouteEntry->ipRouteMetric4 = &(vb->syntax.i32[0]);
            break;
        case 7:
            ipRouteEntry->ipRouteNextHop = vb->syntax.uc;
            break;
        case 8:
            ipRouteEntry->ipRouteType = &(vb->syntax.i32[0]);
            break;
        case 9:
            ipRouteEntry->ipRouteProto = &(vb->syntax.i32[0]);
            break;
        case 10:
            ipRouteEntry->ipRouteAge = &(vb->syntax.i32[0]);
            break;
        case 11:
            ipRouteEntry->ipRouteMask = vb->syntax.uc;
            break;
        case 12:
            ipRouteEntry->ipRouteMetric5 = &(vb->syntax.i32[0]);
            break;
        case 13:
            ipRouteEntry->_ipRouteInfoLength = vb->syntax_len / sizeof(guint32);
            ipRouteEntry->ipRouteInfo = vb->syntax.ui32;
            break;
        };
    }

    return ipRouteEntry;
}

void
rfc1213_mib_get_ipRouteTable(GSnmpSession *s, rfc1213_mib_ipRouteEntry_t ***ipRouteEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 21, 1, 0};

    *ipRouteEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ipRouteEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ipRouteEntry = (rfc1213_mib_ipRouteEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipRouteEntry_t *));
        if (! *ipRouteEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ipRouteEntry)[i] = assign_ipRouteEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_ipRouteEntry(GSnmpSession *s, rfc1213_mib_ipRouteEntry_t **ipRouteEntry, guchar *ipRouteDest, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipRouteEntry, sizeof(oid_ipRouteEntry));
    len = pack_ipRouteEntry(base, ipRouteDest);
    if (len < 0) {
        g_warning("illegal ipRouteEntry index values");
        return;
    }

    *ipRouteEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ipRouteEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *ipRouteEntry = assign_ipRouteEntry(out);
    }
}

void
rfc1213_mib_set_ipRouteEntry(GSnmpSession *s, rfc1213_mib_ipRouteEntry_t *ipRouteEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipRouteEntry, sizeof(oid_ipRouteEntry));
    len = pack_ipRouteEntry(base, ipRouteEntry->ipRouteDest);
    if (len < 0) {
        g_warning("illegal ipRouteEntry index values");
        return;
    }

    if (ipRouteEntry->ipRouteIfIndex) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteIfIndex,
                       0);
    }
    if (ipRouteEntry->ipRouteMetric1) {
        base[9] = 3;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteMetric1,
                       0);
    }
    if (ipRouteEntry->ipRouteMetric2) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteMetric2,
                       0);
    }
    if (ipRouteEntry->ipRouteMetric3) {
        base[9] = 5;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteMetric3,
                       0);
    }
    if (ipRouteEntry->ipRouteMetric4) {
        base[9] = 6;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteMetric4,
                       0);
    }
    if (ipRouteEntry->ipRouteNextHop) {
        base[9] = 7;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       ipRouteEntry->ipRouteNextHop,
                       4);
    }
    if (ipRouteEntry->ipRouteType) {
        base[9] = 8;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteType,
                       0);
    }
    if (ipRouteEntry->ipRouteAge) {
        base[9] = 10;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteAge,
                       0);
    }
    if (ipRouteEntry->ipRouteMask) {
        base[9] = 11;
        g_snmp_vbl_add(&in, base, len, G_SNMP_IPADDRESS,
                       ipRouteEntry->ipRouteMask,
                       4);
    }
    if (ipRouteEntry->ipRouteMetric5) {
        base[9] = 12;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipRouteEntry->ipRouteMetric5,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_ipRouteEntry(rfc1213_mib_ipRouteEntry_t *ipRouteEntry)
{
    GSList *vbl;
    char *p;

    if (ipRouteEntry) {
        p = (char *) ipRouteEntry + sizeof(rfc1213_mib_ipRouteEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ipRouteEntry);
    }
}

void
rfc1213_mib_free_ipRouteTable(rfc1213_mib_ipRouteEntry_t **ipRouteEntry)
{
    int i;

    if (ipRouteEntry) {
        for (i = 0; ipRouteEntry[i]; i++) {
            rfc1213_mib_free_ipRouteEntry(ipRouteEntry[i]);
        }
        g_free(ipRouteEntry);
    }
}

rfc1213_mib_ipNetToMediaEntry_t *
rfc1213_mib_new_ipNetToMediaEntry()
{
    rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;

    ipNetToMediaEntry = (rfc1213_mib_ipNetToMediaEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipNetToMediaEntry_t) + sizeof(gpointer));
    return ipNetToMediaEntry;
}

static int
unpack_ipNetToMediaEntry(GSnmpVarBind *vb, rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    int i, len, idx = 10;

    if (vb->id_len < idx) return -1;
    ipNetToMediaEntry->ipNetToMediaIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipNetToMediaEntry->ipNetToMediaNetAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_ipNetToMediaEntry(guint32 *base, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress)
{
    int i, len, idx = 10;

    base[idx++] = ipNetToMediaIfIndex;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = ipNetToMediaNetAddress[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rfc1213_mib_ipNetToMediaEntry_t *
assign_ipNetToMediaEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;
    guint32 idx;
    char *p;

    ipNetToMediaEntry = rfc1213_mib_new_ipNetToMediaEntry();
    if (! ipNetToMediaEntry) {
        return NULL;
    }

    p = (char *) ipNetToMediaEntry + sizeof(rfc1213_mib_ipNetToMediaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipNetToMediaEntry((GSnmpVarBind *) vbl->data, ipNetToMediaEntry) < 0) {
        g_warning("illegal ipNetToMediaEntry instance identifier");
        g_free(ipNetToMediaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry)/sizeof(guint32),
                   attr_ipNetToMediaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipNetToMediaEntry->_ipNetToMediaPhysAddressLength = vb->syntax_len;
            ipNetToMediaEntry->ipNetToMediaPhysAddress = vb->syntax.uc;
            break;
        case 4:
            ipNetToMediaEntry->ipNetToMediaType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipNetToMediaEntry;
}

void
rfc1213_mib_get_ipNetToMediaTable(GSnmpSession *s, rfc1213_mib_ipNetToMediaEntry_t ***ipNetToMediaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 22, 1, 0};

    *ipNetToMediaEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_ipNetToMediaEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *ipNetToMediaEntry = (rfc1213_mib_ipNetToMediaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipNetToMediaEntry_t *));
        if (! *ipNetToMediaEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*ipNetToMediaEntry)[i] = assign_ipNetToMediaEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_ipNetToMediaEntry(GSnmpSession *s, rfc1213_mib_ipNetToMediaEntry_t **ipNetToMediaEntry, gint32 ipNetToMediaIfIndex, guchar *ipNetToMediaNetAddress, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaIfIndex, ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("illegal ipNetToMediaEntry index values");
        return;
    }

    *ipNetToMediaEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_ipNetToMediaEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *ipNetToMediaEntry = assign_ipNetToMediaEntry(out);
    }
}

void
rfc1213_mib_set_ipNetToMediaEntry(GSnmpSession *s, rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_ipNetToMediaEntry, sizeof(oid_ipNetToMediaEntry));
    len = pack_ipNetToMediaEntry(base, ipNetToMediaEntry->ipNetToMediaIfIndex, ipNetToMediaEntry->ipNetToMediaNetAddress);
    if (len < 0) {
        g_warning("illegal ipNetToMediaEntry index values");
        return;
    }

    if (ipNetToMediaEntry->ipNetToMediaPhysAddress) {
        base[9] = 2;
        g_snmp_vbl_add(&in, base, len, G_SNMP_OCTET_STRING,
                       ipNetToMediaEntry->ipNetToMediaPhysAddress,
                       ipNetToMediaEntry->_ipNetToMediaPhysAddressLength);
    }
    if (ipNetToMediaEntry->ipNetToMediaType) {
        base[9] = 4;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       ipNetToMediaEntry->ipNetToMediaType,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_ipNetToMediaEntry(rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    GSList *vbl;
    char *p;

    if (ipNetToMediaEntry) {
        p = (char *) ipNetToMediaEntry + sizeof(rfc1213_mib_ipNetToMediaEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(ipNetToMediaEntry);
    }
}

void
rfc1213_mib_free_ipNetToMediaTable(rfc1213_mib_ipNetToMediaEntry_t **ipNetToMediaEntry)
{
    int i;

    if (ipNetToMediaEntry) {
        for (i = 0; ipNetToMediaEntry[i]; i++) {
            rfc1213_mib_free_ipNetToMediaEntry(ipNetToMediaEntry[i]);
        }
        g_free(ipNetToMediaEntry);
    }
}

rfc1213_mib_icmp_t *
rfc1213_mib_new_icmp()
{
    rfc1213_mib_icmp_t *icmp;

    icmp = (rfc1213_mib_icmp_t *) g_malloc0(sizeof(rfc1213_mib_icmp_t) + sizeof(gpointer));
    return icmp;
}

static rfc1213_mib_icmp_t *
assign_icmp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_icmp_t *icmp;
    guint32 idx;
    char *p;

    icmp = rfc1213_mib_new_icmp();
    if (! icmp) {
        return NULL;
    }

    p = (char *) icmp + sizeof(rfc1213_mib_icmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_icmp, sizeof(oid_icmp)/sizeof(guint32),
                   attr_icmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            icmp->icmpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            icmp->icmpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            icmp->icmpInDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            icmp->icmpInTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 5:
            icmp->icmpInParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            icmp->icmpInSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 7:
            icmp->icmpInRedirects = &(vb->syntax.ui32[0]);
            break;
        case 8:
            icmp->icmpInEchos = &(vb->syntax.ui32[0]);
            break;
        case 9:
            icmp->icmpInEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 10:
            icmp->icmpInTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 11:
            icmp->icmpInTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 12:
            icmp->icmpInAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 13:
            icmp->icmpInAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        case 14:
            icmp->icmpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 15:
            icmp->icmpOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 16:
            icmp->icmpOutDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 17:
            icmp->icmpOutTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 18:
            icmp->icmpOutParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 19:
            icmp->icmpOutSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 20:
            icmp->icmpOutRedirects = &(vb->syntax.ui32[0]);
            break;
        case 21:
            icmp->icmpOutEchos = &(vb->syntax.ui32[0]);
            break;
        case 22:
            icmp->icmpOutEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 23:
            icmp->icmpOutTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 24:
            icmp->icmpOutTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 25:
            icmp->icmpOutAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 26:
            icmp->icmpOutAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return icmp;
}

void
rfc1213_mib_get_icmp(GSnmpSession *s, rfc1213_mib_icmp_t **icmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 5, 0};

    *icmp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_icmp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *icmp = assign_icmp(out);
    }
}

void
rfc1213_mib_free_icmp(rfc1213_mib_icmp_t *icmp)
{
    GSList *vbl;
    char *p;

    if (icmp) {
        p = (char *) icmp + sizeof(rfc1213_mib_icmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(icmp);
    }
}

rfc1213_mib_tcp_t *
rfc1213_mib_new_tcp()
{
    rfc1213_mib_tcp_t *tcp;

    tcp = (rfc1213_mib_tcp_t *) g_malloc0(sizeof(rfc1213_mib_tcp_t) + sizeof(gpointer));
    return tcp;
}

static rfc1213_mib_tcp_t *
assign_tcp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_tcp_t *tcp;
    guint32 idx;
    char *p;

    tcp = rfc1213_mib_new_tcp();
    if (! tcp) {
        return NULL;
    }

    p = (char *) tcp + sizeof(rfc1213_mib_tcp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_tcp, sizeof(oid_tcp)/sizeof(guint32),
                   attr_tcp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            tcp->tcpRtoAlgorithm = &(vb->syntax.i32[0]);
            break;
        case 2:
            tcp->tcpRtoMin = &(vb->syntax.i32[0]);
            break;
        case 3:
            tcp->tcpRtoMax = &(vb->syntax.i32[0]);
            break;
        case 4:
            tcp->tcpMaxConn = &(vb->syntax.i32[0]);
            break;
        case 5:
            tcp->tcpActiveOpens = &(vb->syntax.ui32[0]);
            break;
        case 6:
            tcp->tcpPassiveOpens = &(vb->syntax.ui32[0]);
            break;
        case 7:
            tcp->tcpAttemptFails = &(vb->syntax.ui32[0]);
            break;
        case 8:
            tcp->tcpEstabResets = &(vb->syntax.ui32[0]);
            break;
        case 9:
            tcp->tcpCurrEstab = &(vb->syntax.ui32[0]);
            break;
        case 10:
            tcp->tcpInSegs = &(vb->syntax.ui32[0]);
            break;
        case 11:
            tcp->tcpOutSegs = &(vb->syntax.ui32[0]);
            break;
        case 12:
            tcp->tcpRetransSegs = &(vb->syntax.ui32[0]);
            break;
        case 14:
            tcp->tcpInErrs = &(vb->syntax.ui32[0]);
            break;
        case 15:
            tcp->tcpOutRsts = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return tcp;
}

void
rfc1213_mib_get_tcp(GSnmpSession *s, rfc1213_mib_tcp_t **tcp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 0};

    *tcp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_tcp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *tcp = assign_tcp(out);
    }
}

void
rfc1213_mib_free_tcp(rfc1213_mib_tcp_t *tcp)
{
    GSList *vbl;
    char *p;

    if (tcp) {
        p = (char *) tcp + sizeof(rfc1213_mib_tcp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(tcp);
    }
}

rfc1213_mib_tcpConnEntry_t *
rfc1213_mib_new_tcpConnEntry()
{
    rfc1213_mib_tcpConnEntry_t *tcpConnEntry;

    tcpConnEntry = (rfc1213_mib_tcpConnEntry_t *) g_malloc0(sizeof(rfc1213_mib_tcpConnEntry_t) + sizeof(gpointer));
    return tcpConnEntry;
}

static int
unpack_tcpConnEntry(GSnmpVarBind *vb, rfc1213_mib_tcpConnEntry_t *tcpConnEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        tcpConnEntry->tcpConnLocalAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    tcpConnEntry->tcpConnLocalPort = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        tcpConnEntry->tcpConnRemAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    tcpConnEntry->tcpConnRemPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_tcpConnEntry(guint32 *base, guchar *tcpConnLocalAddress, gint32 tcpConnLocalPort, guchar *tcpConnRemAddress, gint32 tcpConnRemPort)
{
    int i, len, idx = 10;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = tcpConnLocalAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = tcpConnLocalPort;
    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = tcpConnRemAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = tcpConnRemPort;
    return idx;
}

static rfc1213_mib_tcpConnEntry_t *
assign_tcpConnEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_tcpConnEntry_t *tcpConnEntry;
    guint32 idx;
    char *p;

    tcpConnEntry = rfc1213_mib_new_tcpConnEntry();
    if (! tcpConnEntry) {
        return NULL;
    }

    p = (char *) tcpConnEntry + sizeof(rfc1213_mib_tcpConnEntry_t);
    * (GSList **) p = vbl;

    if (unpack_tcpConnEntry((GSnmpVarBind *) vbl->data, tcpConnEntry) < 0) {
        g_warning("illegal tcpConnEntry instance identifier");
        g_free(tcpConnEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_tcpConnEntry, sizeof(oid_tcpConnEntry)/sizeof(guint32),
                   attr_tcpConnEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            tcpConnEntry->tcpConnState = &(vb->syntax.i32[0]);
            break;
        };
    }

    return tcpConnEntry;
}

void
rfc1213_mib_get_tcpConnTable(GSnmpSession *s, rfc1213_mib_tcpConnEntry_t ***tcpConnEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 0};

    *tcpConnEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_tcpConnEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *tcpConnEntry = (rfc1213_mib_tcpConnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_tcpConnEntry_t *));
        if (! *tcpConnEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*tcpConnEntry)[i] = assign_tcpConnEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_tcpConnEntry(GSnmpSession *s, rfc1213_mib_tcpConnEntry_t **tcpConnEntry, guchar *tcpConnLocalAddress, gint32 tcpConnLocalPort, guchar *tcpConnRemAddress, gint32 tcpConnRemPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_tcpConnEntry, sizeof(oid_tcpConnEntry));
    len = pack_tcpConnEntry(base, tcpConnLocalAddress, tcpConnLocalPort, tcpConnRemAddress, tcpConnRemPort);
    if (len < 0) {
        g_warning("illegal tcpConnEntry index values");
        return;
    }

    *tcpConnEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_tcpConnEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *tcpConnEntry = assign_tcpConnEntry(out);
    }
}

void
rfc1213_mib_set_tcpConnEntry(GSnmpSession *s, rfc1213_mib_tcpConnEntry_t *tcpConnEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_tcpConnEntry, sizeof(oid_tcpConnEntry));
    len = pack_tcpConnEntry(base, tcpConnEntry->tcpConnLocalAddress, tcpConnEntry->tcpConnLocalPort, tcpConnEntry->tcpConnRemAddress, tcpConnEntry->tcpConnRemPort);
    if (len < 0) {
        g_warning("illegal tcpConnEntry index values");
        return;
    }

    if (tcpConnEntry->tcpConnState) {
        base[9] = 1;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       tcpConnEntry->tcpConnState,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_tcpConnEntry(rfc1213_mib_tcpConnEntry_t *tcpConnEntry)
{
    GSList *vbl;
    char *p;

    if (tcpConnEntry) {
        p = (char *) tcpConnEntry + sizeof(rfc1213_mib_tcpConnEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(tcpConnEntry);
    }
}

void
rfc1213_mib_free_tcpConnTable(rfc1213_mib_tcpConnEntry_t **tcpConnEntry)
{
    int i;

    if (tcpConnEntry) {
        for (i = 0; tcpConnEntry[i]; i++) {
            rfc1213_mib_free_tcpConnEntry(tcpConnEntry[i]);
        }
        g_free(tcpConnEntry);
    }
}

rfc1213_mib_udp_t *
rfc1213_mib_new_udp()
{
    rfc1213_mib_udp_t *udp;

    udp = (rfc1213_mib_udp_t *) g_malloc0(sizeof(rfc1213_mib_udp_t) + sizeof(gpointer));
    return udp;
}

static rfc1213_mib_udp_t *
assign_udp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_udp_t *udp;
    guint32 idx;
    char *p;

    udp = rfc1213_mib_new_udp();
    if (! udp) {
        return NULL;
    }

    p = (char *) udp + sizeof(rfc1213_mib_udp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_udp, sizeof(oid_udp)/sizeof(guint32),
                   attr_udp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            udp->udpInDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 2:
            udp->udpNoPorts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            udp->udpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 4:
            udp->udpOutDatagrams = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return udp;
}

void
rfc1213_mib_get_udp(GSnmpSession *s, rfc1213_mib_udp_t **udp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 7, 0};

    *udp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_udp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *udp = assign_udp(out);
    }
}

void
rfc1213_mib_free_udp(rfc1213_mib_udp_t *udp)
{
    GSList *vbl;
    char *p;

    if (udp) {
        p = (char *) udp + sizeof(rfc1213_mib_udp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(udp);
    }
}

rfc1213_mib_udpEntry_t *
rfc1213_mib_new_udpEntry()
{
    rfc1213_mib_udpEntry_t *udpEntry;

    udpEntry = (rfc1213_mib_udpEntry_t *) g_malloc0(sizeof(rfc1213_mib_udpEntry_t) + sizeof(gpointer));
    return udpEntry;
}

static int
unpack_udpEntry(GSnmpVarBind *vb, rfc1213_mib_udpEntry_t *udpEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        udpEntry->udpLocalAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    udpEntry->udpLocalPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_udpEntry(guint32 *base, guchar *udpLocalAddress, gint32 udpLocalPort)
{
    int i, len, idx = 10;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = udpLocalAddress[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = udpLocalPort;
    return idx;
}

static rfc1213_mib_udpEntry_t *
assign_udpEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_udpEntry_t *udpEntry;
    guint32 idx;
    char *p;

    udpEntry = rfc1213_mib_new_udpEntry();
    if (! udpEntry) {
        return NULL;
    }

    p = (char *) udpEntry + sizeof(rfc1213_mib_udpEntry_t);
    * (GSList **) p = vbl;

    if (unpack_udpEntry((GSnmpVarBind *) vbl->data, udpEntry) < 0) {
        g_warning("illegal udpEntry instance identifier");
        g_free(udpEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_udpEntry, sizeof(oid_udpEntry)/sizeof(guint32),
                   attr_udpEntry, &idx) < 0) continue;

        switch (idx) {
        };
    }

    return udpEntry;
}

void
rfc1213_mib_get_udpTable(GSnmpSession *s, rfc1213_mib_udpEntry_t ***udpEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 7, 5, 1, 0};

    *udpEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_udpEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *udpEntry = (rfc1213_mib_udpEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_udpEntry_t *));
        if (! *udpEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*udpEntry)[i] = assign_udpEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_udpEntry(GSnmpSession *s, rfc1213_mib_udpEntry_t **udpEntry, guchar *udpLocalAddress, gint32 udpLocalPort, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_udpEntry, sizeof(oid_udpEntry));
    len = pack_udpEntry(base, udpLocalAddress, udpLocalPort);
    if (len < 0) {
        g_warning("illegal udpEntry index values");
        return;
    }

    *udpEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_udpEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *udpEntry = assign_udpEntry(out);
    }
}

void
rfc1213_mib_free_udpEntry(rfc1213_mib_udpEntry_t *udpEntry)
{
    GSList *vbl;
    char *p;

    if (udpEntry) {
        p = (char *) udpEntry + sizeof(rfc1213_mib_udpEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(udpEntry);
    }
}

void
rfc1213_mib_free_udpTable(rfc1213_mib_udpEntry_t **udpEntry)
{
    int i;

    if (udpEntry) {
        for (i = 0; udpEntry[i]; i++) {
            rfc1213_mib_free_udpEntry(udpEntry[i]);
        }
        g_free(udpEntry);
    }
}

rfc1213_mib_egp_t *
rfc1213_mib_new_egp()
{
    rfc1213_mib_egp_t *egp;

    egp = (rfc1213_mib_egp_t *) g_malloc0(sizeof(rfc1213_mib_egp_t) + sizeof(gpointer));
    return egp;
}

static rfc1213_mib_egp_t *
assign_egp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_egp_t *egp;
    guint32 idx;
    char *p;

    egp = rfc1213_mib_new_egp();
    if (! egp) {
        return NULL;
    }

    p = (char *) egp + sizeof(rfc1213_mib_egp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_egp, sizeof(oid_egp)/sizeof(guint32),
                   attr_egp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            egp->egpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            egp->egpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            egp->egpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            egp->egpOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            egp->egpAs = &(vb->syntax.i32[0]);
            break;
        };
    }

    return egp;
}

void
rfc1213_mib_get_egp(GSnmpSession *s, rfc1213_mib_egp_t **egp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 8, 0};

    *egp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_egp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *egp = assign_egp(out);
    }
}

void
rfc1213_mib_free_egp(rfc1213_mib_egp_t *egp)
{
    GSList *vbl;
    char *p;

    if (egp) {
        p = (char *) egp + sizeof(rfc1213_mib_egp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(egp);
    }
}

rfc1213_mib_egpNeighEntry_t *
rfc1213_mib_new_egpNeighEntry()
{
    rfc1213_mib_egpNeighEntry_t *egpNeighEntry;

    egpNeighEntry = (rfc1213_mib_egpNeighEntry_t *) g_malloc0(sizeof(rfc1213_mib_egpNeighEntry_t) + sizeof(gpointer));
    return egpNeighEntry;
}

static int
unpack_egpNeighEntry(GSnmpVarBind *vb, rfc1213_mib_egpNeighEntry_t *egpNeighEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        egpNeighEntry->egpNeighAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static int
pack_egpNeighEntry(guint32 *base, guchar *egpNeighAddr)
{
    int i, len, idx = 10;

    len = 4;
    for (i = 0; i < len; i++) {
        base[idx++] = egpNeighAddr[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static rfc1213_mib_egpNeighEntry_t *
assign_egpNeighEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_egpNeighEntry_t *egpNeighEntry;
    guint32 idx;
    char *p;

    egpNeighEntry = rfc1213_mib_new_egpNeighEntry();
    if (! egpNeighEntry) {
        return NULL;
    }

    p = (char *) egpNeighEntry + sizeof(rfc1213_mib_egpNeighEntry_t);
    * (GSList **) p = vbl;

    if (unpack_egpNeighEntry((GSnmpVarBind *) vbl->data, egpNeighEntry) < 0) {
        g_warning("illegal egpNeighEntry instance identifier");
        g_free(egpNeighEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_egpNeighEntry, sizeof(oid_egpNeighEntry)/sizeof(guint32),
                   attr_egpNeighEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            egpNeighEntry->egpNeighState = &(vb->syntax.i32[0]);
            break;
        case 3:
            egpNeighEntry->egpNeighAs = &(vb->syntax.i32[0]);
            break;
        case 4:
            egpNeighEntry->egpNeighInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 5:
            egpNeighEntry->egpNeighInErrs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            egpNeighEntry->egpNeighOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 7:
            egpNeighEntry->egpNeighOutErrs = &(vb->syntax.ui32[0]);
            break;
        case 8:
            egpNeighEntry->egpNeighInErrMsgs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            egpNeighEntry->egpNeighOutErrMsgs = &(vb->syntax.ui32[0]);
            break;
        case 10:
            egpNeighEntry->egpNeighStateUps = &(vb->syntax.ui32[0]);
            break;
        case 11:
            egpNeighEntry->egpNeighStateDowns = &(vb->syntax.ui32[0]);
            break;
        case 12:
            egpNeighEntry->egpNeighIntervalHello = &(vb->syntax.i32[0]);
            break;
        case 13:
            egpNeighEntry->egpNeighIntervalPoll = &(vb->syntax.i32[0]);
            break;
        case 14:
            egpNeighEntry->egpNeighMode = &(vb->syntax.i32[0]);
            break;
        case 15:
            egpNeighEntry->egpNeighEventTrigger = &(vb->syntax.i32[0]);
            break;
        };
    }

    return egpNeighEntry;
}

void
rfc1213_mib_get_egpNeighTable(GSnmpSession *s, rfc1213_mib_egpNeighEntry_t ***egpNeighEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 8, 5, 1, 0};

    *egpNeighEntry = NULL;

    add_attributes(s, &in, base, 10, 9, attr_egpNeighEntry, mask);

    out = gsnmp_gettable(s, in);
    /* g_snmp_vbl_free(in); */

    if (out) {
        *egpNeighEntry = (rfc1213_mib_egpNeighEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_egpNeighEntry_t *));
        if (! *egpNeighEntry) {
            s->error_status = G_SNMP_ERR_INTERNAL;
            g_snmp_vbl_free(out);
            return;
        }
        for (row = out, i = 0; row; row = g_slist_next(row), i++) {
            (*egpNeighEntry)[i] = assign_egpNeighEntry(row->data);
        }
    }
}

void
rfc1213_mib_get_egpNeighEntry(GSnmpSession *s, rfc1213_mib_egpNeighEntry_t **egpNeighEntry, guchar *egpNeighAddr, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_egpNeighEntry, sizeof(oid_egpNeighEntry));
    len = pack_egpNeighEntry(base, egpNeighAddr);
    if (len < 0) {
        g_warning("illegal egpNeighEntry index values");
        return;
    }

    *egpNeighEntry = NULL;

    add_attributes(s, &in, base, len, 9, attr_egpNeighEntry, mask);

    out = g_snmp_session_sync_get(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *egpNeighEntry = assign_egpNeighEntry(out);
    }
}

void
rfc1213_mib_set_egpNeighEntry(GSnmpSession *s, rfc1213_mib_egpNeighEntry_t *egpNeighEntry, gint mask)
{
    GSList *in = NULL, *out = NULL;
    guint32 base[128];
    int len;

    memset(base, 0, sizeof(base));
    memcpy(base, oid_egpNeighEntry, sizeof(oid_egpNeighEntry));
    len = pack_egpNeighEntry(base, egpNeighEntry->egpNeighAddr);
    if (len < 0) {
        g_warning("illegal egpNeighEntry index values");
        return;
    }

    if (egpNeighEntry->egpNeighEventTrigger) {
        base[9] = 15;
        g_snmp_vbl_add(&in, base, len, G_SNMP_INTEGER32,
                       egpNeighEntry->egpNeighEventTrigger,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_egpNeighEntry(rfc1213_mib_egpNeighEntry_t *egpNeighEntry)
{
    GSList *vbl;
    char *p;

    if (egpNeighEntry) {
        p = (char *) egpNeighEntry + sizeof(rfc1213_mib_egpNeighEntry_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(egpNeighEntry);
    }
}

void
rfc1213_mib_free_egpNeighTable(rfc1213_mib_egpNeighEntry_t **egpNeighEntry)
{
    int i;

    if (egpNeighEntry) {
        for (i = 0; egpNeighEntry[i]; i++) {
            rfc1213_mib_free_egpNeighEntry(egpNeighEntry[i]);
        }
        g_free(egpNeighEntry);
    }
}

rfc1213_mib_snmp_t *
rfc1213_mib_new_snmp()
{
    rfc1213_mib_snmp_t *snmp;

    snmp = (rfc1213_mib_snmp_t *) g_malloc0(sizeof(rfc1213_mib_snmp_t) + sizeof(gpointer));
    return snmp;
}

static rfc1213_mib_snmp_t *
assign_snmp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_snmp_t *snmp;
    guint32 idx;
    char *p;

    snmp = rfc1213_mib_new_snmp();
    if (! snmp) {
        return NULL;
    }

    p = (char *) snmp + sizeof(rfc1213_mib_snmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (lookup(vb, oid_snmp, sizeof(oid_snmp)/sizeof(guint32),
                   attr_snmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            snmp->snmpInPkts = &(vb->syntax.ui32[0]);
            break;
        case 2:
            snmp->snmpOutPkts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            snmp->snmpInBadVersions = &(vb->syntax.ui32[0]);
            break;
        case 4:
            snmp->snmpInBadCommunityNames = &(vb->syntax.ui32[0]);
            break;
        case 5:
            snmp->snmpInBadCommunityUses = &(vb->syntax.ui32[0]);
            break;
        case 6:
            snmp->snmpInASNParseErrs = &(vb->syntax.ui32[0]);
            break;
        case 8:
            snmp->snmpInTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            snmp->snmpInNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 10:
            snmp->snmpInBadValues = &(vb->syntax.ui32[0]);
            break;
        case 11:
            snmp->snmpInReadOnlys = &(vb->syntax.ui32[0]);
            break;
        case 12:
            snmp->snmpInGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 13:
            snmp->snmpInTotalReqVars = &(vb->syntax.ui32[0]);
            break;
        case 14:
            snmp->snmpInTotalSetVars = &(vb->syntax.ui32[0]);
            break;
        case 15:
            snmp->snmpInGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 16:
            snmp->snmpInGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 17:
            snmp->snmpInSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 18:
            snmp->snmpInGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 19:
            snmp->snmpInTraps = &(vb->syntax.ui32[0]);
            break;
        case 20:
            snmp->snmpOutTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 21:
            snmp->snmpOutNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 22:
            snmp->snmpOutBadValues = &(vb->syntax.ui32[0]);
            break;
        case 24:
            snmp->snmpOutGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 25:
            snmp->snmpOutGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 26:
            snmp->snmpOutGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 27:
            snmp->snmpOutSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 28:
            snmp->snmpOutGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 29:
            snmp->snmpOutTraps = &(vb->syntax.ui32[0]);
            break;
        case 30:
            snmp->snmpEnableAuthenTraps = &(vb->syntax.i32[0]);
            break;
        };
    }

    return snmp;
}

void
rfc1213_mib_get_snmp(GSnmpSession *s, rfc1213_mib_snmp_t **snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0};

    *snmp = NULL;

    add_attributes(s, &in, base, 8, 7, attr_snmp, mask);

    out = g_snmp_session_sync_getnext(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        *snmp = assign_snmp(out);
    }
}

void
rfc1213_mib_set_snmp(GSnmpSession *s, rfc1213_mib_snmp_t *snmp, gint mask)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0, 0};

    if (snmp->snmpEnableAuthenTraps) {
        base[7] = 30;
        g_snmp_vbl_add(&in, base, sizeof(base)/sizeof(guint32),
                       G_SNMP_INTEGER32,
                       snmp->snmpEnableAuthenTraps,
                       0);
    }

    out = g_snmp_session_sync_set(s, in);
    g_snmp_vbl_free(in);
    if (out) {
        g_snmp_vbl_free(out);
    }
}

void
rfc1213_mib_free_snmp(rfc1213_mib_snmp_t *snmp)
{
    GSList *vbl;
    char *p;

    if (snmp) {
        p = (char *) snmp + sizeof(rfc1213_mib_snmp_t);
        vbl = * (GSList **) p;
        g_snmp_vbl_free(vbl);
        g_free(snmp);
    }
}


