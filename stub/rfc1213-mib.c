/*							-- DO NOT EDIT --
 * This file has been generated by smidump
 * version 0.2.14 for the stools package.
 *
 * Derived from RFC1213-MIB:
 *
 * $Id$
 */

#include "rfc1213-mib.h"

stls_enum_t const rfc1213_mib_enums_ifType[] = {
    { RFC1213_MIB_IFTYPE_OTHER,	"other" },
    { RFC1213_MIB_IFTYPE_REGULAR1822,	"regular1822" },
    { RFC1213_MIB_IFTYPE_HDH1822,	"hdh1822" },
    { RFC1213_MIB_IFTYPE_DDN_X25,	"ddn-x25" },
    { RFC1213_MIB_IFTYPE_RFC877_X25,	"rfc877-x25" },
    { RFC1213_MIB_IFTYPE_ETHERNET_CSMACD,	"ethernet-csmacd" },
    { RFC1213_MIB_IFTYPE_ISO88023_CSMACD,	"iso88023-csmacd" },
    { RFC1213_MIB_IFTYPE_ISO88024_TOKENBUS,	"iso88024-tokenBus" },
    { RFC1213_MIB_IFTYPE_ISO88025_TOKENRING,	"iso88025-tokenRing" },
    { RFC1213_MIB_IFTYPE_ISO88026_MAN,	"iso88026-man" },
    { RFC1213_MIB_IFTYPE_STARLAN,	"starLan" },
    { RFC1213_MIB_IFTYPE_PROTEON_10MBIT,	"proteon-10Mbit" },
    { RFC1213_MIB_IFTYPE_PROTEON_80MBIT,	"proteon-80Mbit" },
    { RFC1213_MIB_IFTYPE_HYPERCHANNEL,	"hyperchannel" },
    { RFC1213_MIB_IFTYPE_FDDI,	"fddi" },
    { RFC1213_MIB_IFTYPE_LAPB,	"lapb" },
    { RFC1213_MIB_IFTYPE_SDLC,	"sdlc" },
    { RFC1213_MIB_IFTYPE_DS1,	"ds1" },
    { RFC1213_MIB_IFTYPE_E1,	"e1" },
    { RFC1213_MIB_IFTYPE_BASICISDN,	"basicISDN" },
    { RFC1213_MIB_IFTYPE_PRIMARYISDN,	"primaryISDN" },
    { RFC1213_MIB_IFTYPE_PROPPOINTTOPOINTSERIAL,	"propPointToPointSerial" },
    { RFC1213_MIB_IFTYPE_PPP,	"ppp" },
    { RFC1213_MIB_IFTYPE_SOFTWARELOOPBACK,	"softwareLoopback" },
    { RFC1213_MIB_IFTYPE_EON,	"eon" },
    { RFC1213_MIB_IFTYPE_ETHERNET_3MBIT,	"ethernet-3Mbit" },
    { RFC1213_MIB_IFTYPE_NSIP,	"nsip" },
    { RFC1213_MIB_IFTYPE_SLIP,	"slip" },
    { RFC1213_MIB_IFTYPE_ULTRA,	"ultra" },
    { RFC1213_MIB_IFTYPE_DS3,	"ds3" },
    { RFC1213_MIB_IFTYPE_SIP,	"sip" },
    { RFC1213_MIB_IFTYPE_FRAME_RELAY,	"frame-relay" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ifAdminStatus[] = {
    { RFC1213_MIB_IFADMINSTATUS_UP,	"up" },
    { RFC1213_MIB_IFADMINSTATUS_DOWN,	"down" },
    { RFC1213_MIB_IFADMINSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ifOperStatus[] = {
    { RFC1213_MIB_IFOPERSTATUS_UP,	"up" },
    { RFC1213_MIB_IFOPERSTATUS_DOWN,	"down" },
    { RFC1213_MIB_IFOPERSTATUS_TESTING,	"testing" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ipForwarding[] = {
    { RFC1213_MIB_IPFORWARDING_FORWARDING,	"forwarding" },
    { RFC1213_MIB_IPFORWARDING_NOT_FORWARDING,	"not-forwarding" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ipRouteType[] = {
    { RFC1213_MIB_IPROUTETYPE_OTHER,	"other" },
    { RFC1213_MIB_IPROUTETYPE_INVALID,	"invalid" },
    { RFC1213_MIB_IPROUTETYPE_DIRECT,	"direct" },
    { RFC1213_MIB_IPROUTETYPE_INDIRECT,	"indirect" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ipRouteProto[] = {
    { RFC1213_MIB_IPROUTEPROTO_OTHER,	"other" },
    { RFC1213_MIB_IPROUTEPROTO_LOCAL,	"local" },
    { RFC1213_MIB_IPROUTEPROTO_NETMGMT,	"netmgmt" },
    { RFC1213_MIB_IPROUTEPROTO_ICMP,	"icmp" },
    { RFC1213_MIB_IPROUTEPROTO_EGP,	"egp" },
    { RFC1213_MIB_IPROUTEPROTO_GGP,	"ggp" },
    { RFC1213_MIB_IPROUTEPROTO_HELLO,	"hello" },
    { RFC1213_MIB_IPROUTEPROTO_RIP,	"rip" },
    { RFC1213_MIB_IPROUTEPROTO_IS_IS,	"is-is" },
    { RFC1213_MIB_IPROUTEPROTO_ES_IS,	"es-is" },
    { RFC1213_MIB_IPROUTEPROTO_CISCOIGRP,	"ciscoIgrp" },
    { RFC1213_MIB_IPROUTEPROTO_BBNSPFIGP,	"bbnSpfIgp" },
    { RFC1213_MIB_IPROUTEPROTO_OSPF,	"ospf" },
    { RFC1213_MIB_IPROUTEPROTO_BGP,	"bgp" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_ipNetToMediaType[] = {
    { RFC1213_MIB_IPNETTOMEDIATYPE_OTHER,	"other" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_INVALID,	"invalid" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_DYNAMIC,	"dynamic" },
    { RFC1213_MIB_IPNETTOMEDIATYPE_STATIC,	"static" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_tcpRtoAlgorithm[] = {
    { RFC1213_MIB_TCPRTOALGORITHM_OTHER,	"other" },
    { RFC1213_MIB_TCPRTOALGORITHM_CONSTANT,	"constant" },
    { RFC1213_MIB_TCPRTOALGORITHM_RSRE,	"rsre" },
    { RFC1213_MIB_TCPRTOALGORITHM_VANJ,	"vanj" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_tcpConnState[] = {
    { RFC1213_MIB_TCPCONNSTATE_CLOSED,	"closed" },
    { RFC1213_MIB_TCPCONNSTATE_LISTEN,	"listen" },
    { RFC1213_MIB_TCPCONNSTATE_SYNSENT,	"synSent" },
    { RFC1213_MIB_TCPCONNSTATE_SYNRECEIVED,	"synReceived" },
    { RFC1213_MIB_TCPCONNSTATE_ESTABLISHED,	"established" },
    { RFC1213_MIB_TCPCONNSTATE_FINWAIT1,	"finWait1" },
    { RFC1213_MIB_TCPCONNSTATE_FINWAIT2,	"finWait2" },
    { RFC1213_MIB_TCPCONNSTATE_CLOSEWAIT,	"closeWait" },
    { RFC1213_MIB_TCPCONNSTATE_LASTACK,	"lastAck" },
    { RFC1213_MIB_TCPCONNSTATE_CLOSING,	"closing" },
    { RFC1213_MIB_TCPCONNSTATE_TIMEWAIT,	"timeWait" },
    { RFC1213_MIB_TCPCONNSTATE_DELETETCB,	"deleteTCB" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_egpNeighState[] = {
    { RFC1213_MIB_EGPNEIGHSTATE_IDLE,	"idle" },
    { RFC1213_MIB_EGPNEIGHSTATE_ACQUISITION,	"acquisition" },
    { RFC1213_MIB_EGPNEIGHSTATE_DOWN,	"down" },
    { RFC1213_MIB_EGPNEIGHSTATE_UP,	"up" },
    { RFC1213_MIB_EGPNEIGHSTATE_CEASE,	"cease" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_egpNeighMode[] = {
    { RFC1213_MIB_EGPNEIGHMODE_ACTIVE,	"active" },
    { RFC1213_MIB_EGPNEIGHMODE_PASSIVE,	"passive" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_egpNeighEventTrigger[] = {
    { RFC1213_MIB_EGPNEIGHEVENTTRIGGER_START,	"start" },
    { RFC1213_MIB_EGPNEIGHEVENTTRIGGER_STOP,	"stop" },
    { 0, NULL }
};

stls_enum_t const rfc1213_mib_enums_snmpEnableAuthenTraps[] = {
    { RFC1213_MIB_SNMPENABLEAUTHENTRAPS_ENABLED,	"enabled" },
    { RFC1213_MIB_SNMPENABLEAUTHENTRAPS_DISABLED,	"disabled" },
    { 0, NULL }
};


static stls_stub_attr_t _system[] = {
    { 1, G_SNMP_OCTET_STRING, "sysDescr" },
    { 2, G_SNMP_OBJECT_ID, "sysObjectID" },
    { 3, G_SNMP_TIMETICKS, "sysUpTime" },
    { 4, G_SNMP_OCTET_STRING, "sysContact" },
    { 5, G_SNMP_OCTET_STRING, "sysName" },
    { 6, G_SNMP_OCTET_STRING, "sysLocation" },
    { 7, G_SNMP_INTEGER32, "sysServices" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _interfaces[] = {
    { 1, G_SNMP_INTEGER32, "ifNumber" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ifEntry[] = {
    { 2, G_SNMP_OCTET_STRING, "ifDescr" },
    { 3, G_SNMP_INTEGER32, "ifType" },
    { 4, G_SNMP_INTEGER32, "ifMtu" },
    { 5, G_SNMP_UNSIGNED32, "ifSpeed" },
    { 6, G_SNMP_OCTET_STRING, "ifPhysAddress" },
    { 7, G_SNMP_INTEGER32, "ifAdminStatus" },
    { 8, G_SNMP_INTEGER32, "ifOperStatus" },
    { 9, G_SNMP_TIMETICKS, "ifLastChange" },
    { 10, G_SNMP_COUNTER32, "ifInOctets" },
    { 11, G_SNMP_COUNTER32, "ifInUcastPkts" },
    { 12, G_SNMP_COUNTER32, "ifInNUcastPkts" },
    { 13, G_SNMP_COUNTER32, "ifInDiscards" },
    { 14, G_SNMP_COUNTER32, "ifInErrors" },
    { 15, G_SNMP_COUNTER32, "ifInUnknownProtos" },
    { 16, G_SNMP_COUNTER32, "ifOutOctets" },
    { 17, G_SNMP_COUNTER32, "ifOutUcastPkts" },
    { 18, G_SNMP_COUNTER32, "ifOutNUcastPkts" },
    { 19, G_SNMP_COUNTER32, "ifOutDiscards" },
    { 20, G_SNMP_COUNTER32, "ifOutErrors" },
    { 21, G_SNMP_UNSIGNED32, "ifOutQLen" },
    { 22, G_SNMP_OBJECT_ID, "ifSpecific" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _atEntry[] = {
    { 2, G_SNMP_OCTET_STRING, "atPhysAddress" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ip[] = {
    { 1, G_SNMP_INTEGER32, "ipForwarding" },
    { 2, G_SNMP_INTEGER32, "ipDefaultTTL" },
    { 3, G_SNMP_COUNTER32, "ipInReceives" },
    { 4, G_SNMP_COUNTER32, "ipInHdrErrors" },
    { 5, G_SNMP_COUNTER32, "ipInAddrErrors" },
    { 6, G_SNMP_COUNTER32, "ipForwDatagrams" },
    { 7, G_SNMP_COUNTER32, "ipInUnknownProtos" },
    { 8, G_SNMP_COUNTER32, "ipInDiscards" },
    { 9, G_SNMP_COUNTER32, "ipInDelivers" },
    { 10, G_SNMP_COUNTER32, "ipOutRequests" },
    { 11, G_SNMP_COUNTER32, "ipOutDiscards" },
    { 12, G_SNMP_COUNTER32, "ipOutNoRoutes" },
    { 13, G_SNMP_INTEGER32, "ipReasmTimeout" },
    { 14, G_SNMP_COUNTER32, "ipReasmReqds" },
    { 15, G_SNMP_COUNTER32, "ipReasmOKs" },
    { 16, G_SNMP_COUNTER32, "ipReasmFails" },
    { 17, G_SNMP_COUNTER32, "ipFragOKs" },
    { 18, G_SNMP_COUNTER32, "ipFragFails" },
    { 19, G_SNMP_COUNTER32, "ipFragCreates" },
    { 23, G_SNMP_COUNTER32, "ipRoutingDiscards" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ipAddrEntry[] = {
    { 2, G_SNMP_INTEGER32, "ipAdEntIfIndex" },
    { 3, G_SNMP_IPADDRESS, "ipAdEntNetMask" },
    { 4, G_SNMP_INTEGER32, "ipAdEntBcastAddr" },
    { 5, G_SNMP_INTEGER32, "ipAdEntReasmMaxSize" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ipRouteEntry[] = {
    { 2, G_SNMP_INTEGER32, "ipRouteIfIndex" },
    { 3, G_SNMP_INTEGER32, "ipRouteMetric1" },
    { 4, G_SNMP_INTEGER32, "ipRouteMetric2" },
    { 5, G_SNMP_INTEGER32, "ipRouteMetric3" },
    { 6, G_SNMP_INTEGER32, "ipRouteMetric4" },
    { 7, G_SNMP_IPADDRESS, "ipRouteNextHop" },
    { 8, G_SNMP_INTEGER32, "ipRouteType" },
    { 9, G_SNMP_INTEGER32, "ipRouteProto" },
    { 10, G_SNMP_INTEGER32, "ipRouteAge" },
    { 11, G_SNMP_IPADDRESS, "ipRouteMask" },
    { 12, G_SNMP_INTEGER32, "ipRouteMetric5" },
    { 13, G_SNMP_OBJECT_ID, "ipRouteInfo" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _ipNetToMediaEntry[] = {
    { 2, G_SNMP_OCTET_STRING, "ipNetToMediaPhysAddress" },
    { 4, G_SNMP_INTEGER32, "ipNetToMediaType" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _icmp[] = {
    { 1, G_SNMP_COUNTER32, "icmpInMsgs" },
    { 2, G_SNMP_COUNTER32, "icmpInErrors" },
    { 3, G_SNMP_COUNTER32, "icmpInDestUnreachs" },
    { 4, G_SNMP_COUNTER32, "icmpInTimeExcds" },
    { 5, G_SNMP_COUNTER32, "icmpInParmProbs" },
    { 6, G_SNMP_COUNTER32, "icmpInSrcQuenchs" },
    { 7, G_SNMP_COUNTER32, "icmpInRedirects" },
    { 8, G_SNMP_COUNTER32, "icmpInEchos" },
    { 9, G_SNMP_COUNTER32, "icmpInEchoReps" },
    { 10, G_SNMP_COUNTER32, "icmpInTimestamps" },
    { 11, G_SNMP_COUNTER32, "icmpInTimestampReps" },
    { 12, G_SNMP_COUNTER32, "icmpInAddrMasks" },
    { 13, G_SNMP_COUNTER32, "icmpInAddrMaskReps" },
    { 14, G_SNMP_COUNTER32, "icmpOutMsgs" },
    { 15, G_SNMP_COUNTER32, "icmpOutErrors" },
    { 16, G_SNMP_COUNTER32, "icmpOutDestUnreachs" },
    { 17, G_SNMP_COUNTER32, "icmpOutTimeExcds" },
    { 18, G_SNMP_COUNTER32, "icmpOutParmProbs" },
    { 19, G_SNMP_COUNTER32, "icmpOutSrcQuenchs" },
    { 20, G_SNMP_COUNTER32, "icmpOutRedirects" },
    { 21, G_SNMP_COUNTER32, "icmpOutEchos" },
    { 22, G_SNMP_COUNTER32, "icmpOutEchoReps" },
    { 23, G_SNMP_COUNTER32, "icmpOutTimestamps" },
    { 24, G_SNMP_COUNTER32, "icmpOutTimestampReps" },
    { 25, G_SNMP_COUNTER32, "icmpOutAddrMasks" },
    { 26, G_SNMP_COUNTER32, "icmpOutAddrMaskReps" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _tcp[] = {
    { 1, G_SNMP_INTEGER32, "tcpRtoAlgorithm" },
    { 2, G_SNMP_INTEGER32, "tcpRtoMin" },
    { 3, G_SNMP_INTEGER32, "tcpRtoMax" },
    { 4, G_SNMP_INTEGER32, "tcpMaxConn" },
    { 5, G_SNMP_COUNTER32, "tcpActiveOpens" },
    { 6, G_SNMP_COUNTER32, "tcpPassiveOpens" },
    { 7, G_SNMP_COUNTER32, "tcpAttemptFails" },
    { 8, G_SNMP_COUNTER32, "tcpEstabResets" },
    { 9, G_SNMP_UNSIGNED32, "tcpCurrEstab" },
    { 10, G_SNMP_COUNTER32, "tcpInSegs" },
    { 11, G_SNMP_COUNTER32, "tcpOutSegs" },
    { 12, G_SNMP_COUNTER32, "tcpRetransSegs" },
    { 14, G_SNMP_COUNTER32, "tcpInErrs" },
    { 15, G_SNMP_COUNTER32, "tcpOutRsts" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _tcpConnEntry[] = {
    { 1, G_SNMP_INTEGER32, "tcpConnState" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _udp[] = {
    { 1, G_SNMP_COUNTER32, "udpInDatagrams" },
    { 2, G_SNMP_COUNTER32, "udpNoPorts" },
    { 3, G_SNMP_COUNTER32, "udpInErrors" },
    { 4, G_SNMP_COUNTER32, "udpOutDatagrams" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _udpEntry[] = {
    { 1, G_SNMP_IPADDRESS, "udpLocalAddress" },
    { 2, G_SNMP_INTEGER32, "udpLocalPort" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _egp[] = {
    { 1, G_SNMP_COUNTER32, "egpInMsgs" },
    { 2, G_SNMP_COUNTER32, "egpInErrors" },
    { 3, G_SNMP_COUNTER32, "egpOutMsgs" },
    { 4, G_SNMP_COUNTER32, "egpOutErrors" },
    { 6, G_SNMP_INTEGER32, "egpAs" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _egpNeighEntry[] = {
    { 1, G_SNMP_INTEGER32, "egpNeighState" },
    { 3, G_SNMP_INTEGER32, "egpNeighAs" },
    { 4, G_SNMP_COUNTER32, "egpNeighInMsgs" },
    { 5, G_SNMP_COUNTER32, "egpNeighInErrs" },
    { 6, G_SNMP_COUNTER32, "egpNeighOutMsgs" },
    { 7, G_SNMP_COUNTER32, "egpNeighOutErrs" },
    { 8, G_SNMP_COUNTER32, "egpNeighInErrMsgs" },
    { 9, G_SNMP_COUNTER32, "egpNeighOutErrMsgs" },
    { 10, G_SNMP_COUNTER32, "egpNeighStateUps" },
    { 11, G_SNMP_COUNTER32, "egpNeighStateDowns" },
    { 12, G_SNMP_INTEGER32, "egpNeighIntervalHello" },
    { 13, G_SNMP_INTEGER32, "egpNeighIntervalPoll" },
    { 14, G_SNMP_INTEGER32, "egpNeighMode" },
    { 15, G_SNMP_INTEGER32, "egpNeighEventTrigger" },
    { 0, 0, NULL }
};

static stls_stub_attr_t _snmp[] = {
    { 1, G_SNMP_COUNTER32, "snmpInPkts" },
    { 2, G_SNMP_COUNTER32, "snmpOutPkts" },
    { 3, G_SNMP_COUNTER32, "snmpInBadVersions" },
    { 4, G_SNMP_COUNTER32, "snmpInBadCommunityNames" },
    { 5, G_SNMP_COUNTER32, "snmpInBadCommunityUses" },
    { 6, G_SNMP_COUNTER32, "snmpInASNParseErrs" },
    { 8, G_SNMP_COUNTER32, "snmpInTooBigs" },
    { 9, G_SNMP_COUNTER32, "snmpInNoSuchNames" },
    { 10, G_SNMP_COUNTER32, "snmpInBadValues" },
    { 11, G_SNMP_COUNTER32, "snmpInReadOnlys" },
    { 12, G_SNMP_COUNTER32, "snmpInGenErrs" },
    { 13, G_SNMP_COUNTER32, "snmpInTotalReqVars" },
    { 14, G_SNMP_COUNTER32, "snmpInTotalSetVars" },
    { 15, G_SNMP_COUNTER32, "snmpInGetRequests" },
    { 16, G_SNMP_COUNTER32, "snmpInGetNexts" },
    { 17, G_SNMP_COUNTER32, "snmpInSetRequests" },
    { 18, G_SNMP_COUNTER32, "snmpInGetResponses" },
    { 19, G_SNMP_COUNTER32, "snmpInTraps" },
    { 20, G_SNMP_COUNTER32, "snmpOutTooBigs" },
    { 21, G_SNMP_COUNTER32, "snmpOutNoSuchNames" },
    { 22, G_SNMP_COUNTER32, "snmpOutBadValues" },
    { 24, G_SNMP_COUNTER32, "snmpOutGenErrs" },
    { 25, G_SNMP_COUNTER32, "snmpOutGetRequests" },
    { 26, G_SNMP_COUNTER32, "snmpOutGetNexts" },
    { 27, G_SNMP_COUNTER32, "snmpOutSetRequests" },
    { 28, G_SNMP_COUNTER32, "snmpOutGetResponses" },
    { 29, G_SNMP_COUNTER32, "snmpOutTraps" },
    { 30, G_SNMP_INTEGER32, "snmpEnableAuthenTraps" },
    { 0, 0, NULL }
};


rfc1213_mib_system_t *
rfc1213_mib_new_system()
{
    rfc1213_mib_system_t *system;

    system = (rfc1213_mib_system_t *) g_malloc0(sizeof(rfc1213_mib_system_t) + sizeof(gpointer));
    return system;
}

static rfc1213_mib_system_t *
assign_system(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_system_t *system;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 1};

    system = rfc1213_mib_new_system();
    if (! system) {
        return NULL;
    }

    p = (char *) system + sizeof(rfc1213_mib_system_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _system, &idx) < 0) continue;

        switch (idx) {
        case 1:
            system->_sysDescrLength = vb->syntax_len;
            system->sysDescr = vb->syntax.uc;
            break;
        case 2:
            system->_sysObjectIDLength = vb->syntax_len / sizeof(guint32);
            system->sysObjectID = vb->syntax.ui32;
            break;
        case 3:
            system->sysUpTime = &(vb->syntax.ui32[0]);
            break;
        case 4:
            system->_sysContactLength = vb->syntax_len;
            system->sysContact = vb->syntax.uc;
            break;
        case 5:
            system->_sysNameLength = vb->syntax_len;
            system->sysName = vb->syntax.uc;
            break;
        case 6:
            system->_sysLocationLength = vb->syntax_len;
            system->sysLocation = vb->syntax.uc;
            break;
        case 7:
            system->sysServices = &(vb->syntax.i32[0]);
            break;
        };
    }

    return system;
}

int
rfc1213_mib_get_system(host_snmp *s, rfc1213_mib_system_t **system)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 1, 0};

    *system = NULL;

    stls_vbl_attributes(s, &in, base, 7, _system);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *system = assign_system(out);

    return 0;
}

void
rfc1213_mib_free_system(rfc1213_mib_system_t *system)
{
    GSList *vbl;
    char *p;

    if (system) {
        p = (char *) system + sizeof(rfc1213_mib_system_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(system);
    }
}

rfc1213_mib_interfaces_t *
rfc1213_mib_new_interfaces()
{
    rfc1213_mib_interfaces_t *interfaces;

    interfaces = (rfc1213_mib_interfaces_t *) g_malloc0(sizeof(rfc1213_mib_interfaces_t) + sizeof(gpointer));
    return interfaces;
}

static rfc1213_mib_interfaces_t *
assign_interfaces(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_interfaces_t *interfaces;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2};

    interfaces = rfc1213_mib_new_interfaces();
    if (! interfaces) {
        return NULL;
    }

    p = (char *) interfaces + sizeof(rfc1213_mib_interfaces_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _interfaces, &idx) < 0) continue;

        switch (idx) {
        case 1:
            interfaces->ifNumber = &(vb->syntax.i32[0]);
            break;
        };
    }

    return interfaces;
}

int
rfc1213_mib_get_interfaces(host_snmp *s, rfc1213_mib_interfaces_t **interfaces)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 0};

    *interfaces = NULL;

    stls_vbl_attributes(s, &in, base, 7, _interfaces);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *interfaces = assign_interfaces(out);

    return 0;
}

void
rfc1213_mib_free_interfaces(rfc1213_mib_interfaces_t *interfaces)
{
    GSList *vbl;
    char *p;

    if (interfaces) {
        p = (char *) interfaces + sizeof(rfc1213_mib_interfaces_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(interfaces);
    }
}

rfc1213_mib_ifEntry_t *
rfc1213_mib_new_ifEntry()
{
    rfc1213_mib_ifEntry_t *ifEntry;

    ifEntry = (rfc1213_mib_ifEntry_t *) g_malloc0(sizeof(rfc1213_mib_ifEntry_t) + sizeof(gpointer));
    return ifEntry;
}

static int
unpack_ifEntry(GSnmpVarBind *vb, rfc1213_mib_ifEntry_t *ifEntry)
{
    int idx = 10;

    if (vb->id_len < idx) return -1;
    ifEntry->ifIndex = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_ifEntry_t *
assign_ifEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ifEntry_t *ifEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1};

    ifEntry = rfc1213_mib_new_ifEntry();
    if (! ifEntry) {
        return NULL;
    }

    p = (char *) ifEntry + sizeof(rfc1213_mib_ifEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ifEntry((GSnmpVarBind *) vbl->data, ifEntry) < 0) {
        g_warning("illegal ifEntry instance identifier");
        g_free(ifEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ifEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ifEntry->_ifDescrLength = vb->syntax_len;
            ifEntry->ifDescr = vb->syntax.uc;
            break;
        case 3:
            ifEntry->ifType = &(vb->syntax.i32[0]);
            break;
        case 4:
            ifEntry->ifMtu = &(vb->syntax.i32[0]);
            break;
        case 5:
            ifEntry->ifSpeed = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ifEntry->_ifPhysAddressLength = vb->syntax_len;
            ifEntry->ifPhysAddress = vb->syntax.uc;
            break;
        case 7:
            ifEntry->ifAdminStatus = &(vb->syntax.i32[0]);
            break;
        case 8:
            ifEntry->ifOperStatus = &(vb->syntax.i32[0]);
            break;
        case 9:
            ifEntry->ifLastChange = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ifEntry->ifInOctets = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ifEntry->ifInUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ifEntry->ifInNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ifEntry->ifInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 14:
            ifEntry->ifInErrors = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ifEntry->ifInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ifEntry->ifOutOctets = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ifEntry->ifOutUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ifEntry->ifOutNUcastPkts = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ifEntry->ifOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 20:
            ifEntry->ifOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 21:
            ifEntry->ifOutQLen = &(vb->syntax.ui32[0]);
            break;
        case 22:
            ifEntry->_ifSpecificLength = vb->syntax_len / sizeof(guint32);
            ifEntry->ifSpecific = vb->syntax.ui32;
            break;
        };
    }

    return ifEntry;
}

int
rfc1213_mib_get_ifTable(host_snmp *s, rfc1213_mib_ifEntry_t ***ifEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 0};

    *ifEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ifEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ifEntry = (rfc1213_mib_ifEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ifEntry_t *));
    if (! *ifEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ifEntry)[i] = assign_ifEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_ifEntry(rfc1213_mib_ifEntry_t *ifEntry)
{
    GSList *vbl;
    char *p;

    if (ifEntry) {
        p = (char *) ifEntry + sizeof(rfc1213_mib_ifEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ifEntry);
    }
}

void
rfc1213_mib_free_ifTable(rfc1213_mib_ifEntry_t **ifEntry)
{
    int i;

    if (ifEntry) {
        for (i = 0; ifEntry[i]; i++) {
            rfc1213_mib_free_ifEntry(ifEntry[i]);
        }
        g_free(ifEntry);
    }
}

rfc1213_mib_atEntry_t *
rfc1213_mib_new_atEntry()
{
    rfc1213_mib_atEntry_t *atEntry;

    atEntry = (rfc1213_mib_atEntry_t *) g_malloc0(sizeof(rfc1213_mib_atEntry_t) + sizeof(gpointer));
    return atEntry;
}

static int
unpack_atEntry(GSnmpVarBind *vb, rfc1213_mib_atEntry_t *atEntry)
{
    int i, len, idx = 10;

    if (vb->id_len < idx) return -1;
    atEntry->atIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        atEntry->atNetAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_atEntry_t *
assign_atEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_atEntry_t *atEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 3, 1, 1};

    atEntry = rfc1213_mib_new_atEntry();
    if (! atEntry) {
        return NULL;
    }

    p = (char *) atEntry + sizeof(rfc1213_mib_atEntry_t);
    * (GSList **) p = vbl;

    if (unpack_atEntry((GSnmpVarBind *) vbl->data, atEntry) < 0) {
        g_warning("illegal atEntry instance identifier");
        g_free(atEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _atEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            atEntry->_atPhysAddressLength = vb->syntax_len;
            atEntry->atPhysAddress = vb->syntax.uc;
            break;
        };
    }

    return atEntry;
}

int
rfc1213_mib_get_atTable(host_snmp *s, rfc1213_mib_atEntry_t ***atEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 3, 1, 1, 0};

    *atEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _atEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *atEntry = (rfc1213_mib_atEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_atEntry_t *));
    if (! *atEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*atEntry)[i] = assign_atEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_atEntry(rfc1213_mib_atEntry_t *atEntry)
{
    GSList *vbl;
    char *p;

    if (atEntry) {
        p = (char *) atEntry + sizeof(rfc1213_mib_atEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(atEntry);
    }
}

void
rfc1213_mib_free_atTable(rfc1213_mib_atEntry_t **atEntry)
{
    int i;

    if (atEntry) {
        for (i = 0; atEntry[i]; i++) {
            rfc1213_mib_free_atEntry(atEntry[i]);
        }
        g_free(atEntry);
    }
}

rfc1213_mib_ip_t *
rfc1213_mib_new_ip()
{
    rfc1213_mib_ip_t *ip;

    ip = (rfc1213_mib_ip_t *) g_malloc0(sizeof(rfc1213_mib_ip_t) + sizeof(gpointer));
    return ip;
}

static rfc1213_mib_ip_t *
assign_ip(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ip_t *ip;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 4};

    ip = rfc1213_mib_new_ip();
    if (! ip) {
        return NULL;
    }

    p = (char *) ip + sizeof(rfc1213_mib_ip_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ip, &idx) < 0) continue;

        switch (idx) {
        case 1:
            ip->ipForwarding = &(vb->syntax.i32[0]);
            break;
        case 2:
            ip->ipDefaultTTL = &(vb->syntax.i32[0]);
            break;
        case 3:
            ip->ipInReceives = &(vb->syntax.ui32[0]);
            break;
        case 4:
            ip->ipInHdrErrors = &(vb->syntax.ui32[0]);
            break;
        case 5:
            ip->ipInAddrErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            ip->ipForwDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 7:
            ip->ipInUnknownProtos = &(vb->syntax.ui32[0]);
            break;
        case 8:
            ip->ipInDiscards = &(vb->syntax.ui32[0]);
            break;
        case 9:
            ip->ipInDelivers = &(vb->syntax.ui32[0]);
            break;
        case 10:
            ip->ipOutRequests = &(vb->syntax.ui32[0]);
            break;
        case 11:
            ip->ipOutDiscards = &(vb->syntax.ui32[0]);
            break;
        case 12:
            ip->ipOutNoRoutes = &(vb->syntax.ui32[0]);
            break;
        case 13:
            ip->ipReasmTimeout = &(vb->syntax.i32[0]);
            break;
        case 14:
            ip->ipReasmReqds = &(vb->syntax.ui32[0]);
            break;
        case 15:
            ip->ipReasmOKs = &(vb->syntax.ui32[0]);
            break;
        case 16:
            ip->ipReasmFails = &(vb->syntax.ui32[0]);
            break;
        case 17:
            ip->ipFragOKs = &(vb->syntax.ui32[0]);
            break;
        case 18:
            ip->ipFragFails = &(vb->syntax.ui32[0]);
            break;
        case 19:
            ip->ipFragCreates = &(vb->syntax.ui32[0]);
            break;
        case 23:
            ip->ipRoutingDiscards = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return ip;
}

int
rfc1213_mib_get_ip(host_snmp *s, rfc1213_mib_ip_t **ip)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 0};

    *ip = NULL;

    stls_vbl_attributes(s, &in, base, 7, _ip);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *ip = assign_ip(out);

    return 0;
}

void
rfc1213_mib_free_ip(rfc1213_mib_ip_t *ip)
{
    GSList *vbl;
    char *p;

    if (ip) {
        p = (char *) ip + sizeof(rfc1213_mib_ip_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ip);
    }
}

rfc1213_mib_ipAddrEntry_t *
rfc1213_mib_new_ipAddrEntry()
{
    rfc1213_mib_ipAddrEntry_t *ipAddrEntry;

    ipAddrEntry = (rfc1213_mib_ipAddrEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipAddrEntry_t) + sizeof(gpointer));
    return ipAddrEntry;
}

static int
unpack_ipAddrEntry(GSnmpVarBind *vb, rfc1213_mib_ipAddrEntry_t *ipAddrEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipAddrEntry->ipAdEntAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_ipAddrEntry_t *
assign_ipAddrEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipAddrEntry_t *ipAddrEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 4, 20, 1};

    ipAddrEntry = rfc1213_mib_new_ipAddrEntry();
    if (! ipAddrEntry) {
        return NULL;
    }

    p = (char *) ipAddrEntry + sizeof(rfc1213_mib_ipAddrEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipAddrEntry((GSnmpVarBind *) vbl->data, ipAddrEntry) < 0) {
        g_warning("illegal ipAddrEntry instance identifier");
        g_free(ipAddrEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ipAddrEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipAddrEntry->ipAdEntIfIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            ipAddrEntry->ipAdEntNetMask = vb->syntax.uc;
            break;
        case 4:
            ipAddrEntry->ipAdEntBcastAddr = &(vb->syntax.i32[0]);
            break;
        case 5:
            ipAddrEntry->ipAdEntReasmMaxSize = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipAddrEntry;
}

int
rfc1213_mib_get_ipAddrTable(host_snmp *s, rfc1213_mib_ipAddrEntry_t ***ipAddrEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 20, 1, 0};

    *ipAddrEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ipAddrEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ipAddrEntry = (rfc1213_mib_ipAddrEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipAddrEntry_t *));
    if (! *ipAddrEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ipAddrEntry)[i] = assign_ipAddrEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_ipAddrEntry(rfc1213_mib_ipAddrEntry_t *ipAddrEntry)
{
    GSList *vbl;
    char *p;

    if (ipAddrEntry) {
        p = (char *) ipAddrEntry + sizeof(rfc1213_mib_ipAddrEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ipAddrEntry);
    }
}

void
rfc1213_mib_free_ipAddrTable(rfc1213_mib_ipAddrEntry_t **ipAddrEntry)
{
    int i;

    if (ipAddrEntry) {
        for (i = 0; ipAddrEntry[i]; i++) {
            rfc1213_mib_free_ipAddrEntry(ipAddrEntry[i]);
        }
        g_free(ipAddrEntry);
    }
}

rfc1213_mib_ipRouteEntry_t *
rfc1213_mib_new_ipRouteEntry()
{
    rfc1213_mib_ipRouteEntry_t *ipRouteEntry;

    ipRouteEntry = (rfc1213_mib_ipRouteEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipRouteEntry_t) + sizeof(gpointer));
    return ipRouteEntry;
}

static int
unpack_ipRouteEntry(GSnmpVarBind *vb, rfc1213_mib_ipRouteEntry_t *ipRouteEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipRouteEntry->ipRouteDest[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_ipRouteEntry_t *
assign_ipRouteEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipRouteEntry_t *ipRouteEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 4, 21, 1};

    ipRouteEntry = rfc1213_mib_new_ipRouteEntry();
    if (! ipRouteEntry) {
        return NULL;
    }

    p = (char *) ipRouteEntry + sizeof(rfc1213_mib_ipRouteEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipRouteEntry((GSnmpVarBind *) vbl->data, ipRouteEntry) < 0) {
        g_warning("illegal ipRouteEntry instance identifier");
        g_free(ipRouteEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ipRouteEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipRouteEntry->ipRouteIfIndex = &(vb->syntax.i32[0]);
            break;
        case 3:
            ipRouteEntry->ipRouteMetric1 = &(vb->syntax.i32[0]);
            break;
        case 4:
            ipRouteEntry->ipRouteMetric2 = &(vb->syntax.i32[0]);
            break;
        case 5:
            ipRouteEntry->ipRouteMetric3 = &(vb->syntax.i32[0]);
            break;
        case 6:
            ipRouteEntry->ipRouteMetric4 = &(vb->syntax.i32[0]);
            break;
        case 7:
            ipRouteEntry->ipRouteNextHop = vb->syntax.uc;
            break;
        case 8:
            ipRouteEntry->ipRouteType = &(vb->syntax.i32[0]);
            break;
        case 9:
            ipRouteEntry->ipRouteProto = &(vb->syntax.i32[0]);
            break;
        case 10:
            ipRouteEntry->ipRouteAge = &(vb->syntax.i32[0]);
            break;
        case 11:
            ipRouteEntry->ipRouteMask = vb->syntax.uc;
            break;
        case 12:
            ipRouteEntry->ipRouteMetric5 = &(vb->syntax.i32[0]);
            break;
        case 13:
            ipRouteEntry->_ipRouteInfoLength = vb->syntax_len / sizeof(guint32);
            ipRouteEntry->ipRouteInfo = vb->syntax.ui32;
            break;
        };
    }

    return ipRouteEntry;
}

int
rfc1213_mib_get_ipRouteTable(host_snmp *s, rfc1213_mib_ipRouteEntry_t ***ipRouteEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 21, 1, 0};

    *ipRouteEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ipRouteEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ipRouteEntry = (rfc1213_mib_ipRouteEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipRouteEntry_t *));
    if (! *ipRouteEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ipRouteEntry)[i] = assign_ipRouteEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_ipRouteEntry(rfc1213_mib_ipRouteEntry_t *ipRouteEntry)
{
    GSList *vbl;
    char *p;

    if (ipRouteEntry) {
        p = (char *) ipRouteEntry + sizeof(rfc1213_mib_ipRouteEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ipRouteEntry);
    }
}

void
rfc1213_mib_free_ipRouteTable(rfc1213_mib_ipRouteEntry_t **ipRouteEntry)
{
    int i;

    if (ipRouteEntry) {
        for (i = 0; ipRouteEntry[i]; i++) {
            rfc1213_mib_free_ipRouteEntry(ipRouteEntry[i]);
        }
        g_free(ipRouteEntry);
    }
}

rfc1213_mib_ipNetToMediaEntry_t *
rfc1213_mib_new_ipNetToMediaEntry()
{
    rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;

    ipNetToMediaEntry = (rfc1213_mib_ipNetToMediaEntry_t *) g_malloc0(sizeof(rfc1213_mib_ipNetToMediaEntry_t) + sizeof(gpointer));
    return ipNetToMediaEntry;
}

static int
unpack_ipNetToMediaEntry(GSnmpVarBind *vb, rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    int i, len, idx = 10;

    if (vb->id_len < idx) return -1;
    ipNetToMediaEntry->ipNetToMediaIfIndex = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        ipNetToMediaEntry->ipNetToMediaNetAddress[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_ipNetToMediaEntry_t *
assign_ipNetToMediaEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 4, 22, 1};

    ipNetToMediaEntry = rfc1213_mib_new_ipNetToMediaEntry();
    if (! ipNetToMediaEntry) {
        return NULL;
    }

    p = (char *) ipNetToMediaEntry + sizeof(rfc1213_mib_ipNetToMediaEntry_t);
    * (GSList **) p = vbl;

    if (unpack_ipNetToMediaEntry((GSnmpVarBind *) vbl->data, ipNetToMediaEntry) < 0) {
        g_warning("illegal ipNetToMediaEntry instance identifier");
        g_free(ipNetToMediaEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _ipNetToMediaEntry, &idx) < 0) continue;

        switch (idx) {
        case 2:
            ipNetToMediaEntry->_ipNetToMediaPhysAddressLength = vb->syntax_len;
            ipNetToMediaEntry->ipNetToMediaPhysAddress = vb->syntax.uc;
            break;
        case 4:
            ipNetToMediaEntry->ipNetToMediaType = &(vb->syntax.i32[0]);
            break;
        };
    }

    return ipNetToMediaEntry;
}

int
rfc1213_mib_get_ipNetToMediaTable(host_snmp *s, rfc1213_mib_ipNetToMediaEntry_t ***ipNetToMediaEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 4, 22, 1, 0};

    *ipNetToMediaEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _ipNetToMediaEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *ipNetToMediaEntry = (rfc1213_mib_ipNetToMediaEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_ipNetToMediaEntry_t *));
    if (! *ipNetToMediaEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*ipNetToMediaEntry)[i] = assign_ipNetToMediaEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_ipNetToMediaEntry(rfc1213_mib_ipNetToMediaEntry_t *ipNetToMediaEntry)
{
    GSList *vbl;
    char *p;

    if (ipNetToMediaEntry) {
        p = (char *) ipNetToMediaEntry + sizeof(rfc1213_mib_ipNetToMediaEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(ipNetToMediaEntry);
    }
}

void
rfc1213_mib_free_ipNetToMediaTable(rfc1213_mib_ipNetToMediaEntry_t **ipNetToMediaEntry)
{
    int i;

    if (ipNetToMediaEntry) {
        for (i = 0; ipNetToMediaEntry[i]; i++) {
            rfc1213_mib_free_ipNetToMediaEntry(ipNetToMediaEntry[i]);
        }
        g_free(ipNetToMediaEntry);
    }
}

rfc1213_mib_icmp_t *
rfc1213_mib_new_icmp()
{
    rfc1213_mib_icmp_t *icmp;

    icmp = (rfc1213_mib_icmp_t *) g_malloc0(sizeof(rfc1213_mib_icmp_t) + sizeof(gpointer));
    return icmp;
}

static rfc1213_mib_icmp_t *
assign_icmp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_icmp_t *icmp;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 5};

    icmp = rfc1213_mib_new_icmp();
    if (! icmp) {
        return NULL;
    }

    p = (char *) icmp + sizeof(rfc1213_mib_icmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _icmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            icmp->icmpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            icmp->icmpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            icmp->icmpInDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            icmp->icmpInTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 5:
            icmp->icmpInParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            icmp->icmpInSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 7:
            icmp->icmpInRedirects = &(vb->syntax.ui32[0]);
            break;
        case 8:
            icmp->icmpInEchos = &(vb->syntax.ui32[0]);
            break;
        case 9:
            icmp->icmpInEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 10:
            icmp->icmpInTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 11:
            icmp->icmpInTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 12:
            icmp->icmpInAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 13:
            icmp->icmpInAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        case 14:
            icmp->icmpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 15:
            icmp->icmpOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 16:
            icmp->icmpOutDestUnreachs = &(vb->syntax.ui32[0]);
            break;
        case 17:
            icmp->icmpOutTimeExcds = &(vb->syntax.ui32[0]);
            break;
        case 18:
            icmp->icmpOutParmProbs = &(vb->syntax.ui32[0]);
            break;
        case 19:
            icmp->icmpOutSrcQuenchs = &(vb->syntax.ui32[0]);
            break;
        case 20:
            icmp->icmpOutRedirects = &(vb->syntax.ui32[0]);
            break;
        case 21:
            icmp->icmpOutEchos = &(vb->syntax.ui32[0]);
            break;
        case 22:
            icmp->icmpOutEchoReps = &(vb->syntax.ui32[0]);
            break;
        case 23:
            icmp->icmpOutTimestamps = &(vb->syntax.ui32[0]);
            break;
        case 24:
            icmp->icmpOutTimestampReps = &(vb->syntax.ui32[0]);
            break;
        case 25:
            icmp->icmpOutAddrMasks = &(vb->syntax.ui32[0]);
            break;
        case 26:
            icmp->icmpOutAddrMaskReps = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return icmp;
}

int
rfc1213_mib_get_icmp(host_snmp *s, rfc1213_mib_icmp_t **icmp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 5, 0};

    *icmp = NULL;

    stls_vbl_attributes(s, &in, base, 7, _icmp);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *icmp = assign_icmp(out);

    return 0;
}

void
rfc1213_mib_free_icmp(rfc1213_mib_icmp_t *icmp)
{
    GSList *vbl;
    char *p;

    if (icmp) {
        p = (char *) icmp + sizeof(rfc1213_mib_icmp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(icmp);
    }
}

rfc1213_mib_tcp_t *
rfc1213_mib_new_tcp()
{
    rfc1213_mib_tcp_t *tcp;

    tcp = (rfc1213_mib_tcp_t *) g_malloc0(sizeof(rfc1213_mib_tcp_t) + sizeof(gpointer));
    return tcp;
}

static rfc1213_mib_tcp_t *
assign_tcp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_tcp_t *tcp;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 6};

    tcp = rfc1213_mib_new_tcp();
    if (! tcp) {
        return NULL;
    }

    p = (char *) tcp + sizeof(rfc1213_mib_tcp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _tcp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            tcp->tcpRtoAlgorithm = &(vb->syntax.i32[0]);
            break;
        case 2:
            tcp->tcpRtoMin = &(vb->syntax.i32[0]);
            break;
        case 3:
            tcp->tcpRtoMax = &(vb->syntax.i32[0]);
            break;
        case 4:
            tcp->tcpMaxConn = &(vb->syntax.i32[0]);
            break;
        case 5:
            tcp->tcpActiveOpens = &(vb->syntax.ui32[0]);
            break;
        case 6:
            tcp->tcpPassiveOpens = &(vb->syntax.ui32[0]);
            break;
        case 7:
            tcp->tcpAttemptFails = &(vb->syntax.ui32[0]);
            break;
        case 8:
            tcp->tcpEstabResets = &(vb->syntax.ui32[0]);
            break;
        case 9:
            tcp->tcpCurrEstab = &(vb->syntax.ui32[0]);
            break;
        case 10:
            tcp->tcpInSegs = &(vb->syntax.ui32[0]);
            break;
        case 11:
            tcp->tcpOutSegs = &(vb->syntax.ui32[0]);
            break;
        case 12:
            tcp->tcpRetransSegs = &(vb->syntax.ui32[0]);
            break;
        case 14:
            tcp->tcpInErrs = &(vb->syntax.ui32[0]);
            break;
        case 15:
            tcp->tcpOutRsts = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return tcp;
}

int
rfc1213_mib_get_tcp(host_snmp *s, rfc1213_mib_tcp_t **tcp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 0};

    *tcp = NULL;

    stls_vbl_attributes(s, &in, base, 7, _tcp);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *tcp = assign_tcp(out);

    return 0;
}

void
rfc1213_mib_free_tcp(rfc1213_mib_tcp_t *tcp)
{
    GSList *vbl;
    char *p;

    if (tcp) {
        p = (char *) tcp + sizeof(rfc1213_mib_tcp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(tcp);
    }
}

rfc1213_mib_tcpConnEntry_t *
rfc1213_mib_new_tcpConnEntry()
{
    rfc1213_mib_tcpConnEntry_t *tcpConnEntry;

    tcpConnEntry = (rfc1213_mib_tcpConnEntry_t *) g_malloc0(sizeof(rfc1213_mib_tcpConnEntry_t) + sizeof(gpointer));
    return tcpConnEntry;
}

static int
unpack_tcpConnEntry(GSnmpVarBind *vb, rfc1213_mib_tcpConnEntry_t *tcpConnEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        tcpConnEntry->tcpConnLocalAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    tcpConnEntry->tcpConnLocalPort = vb->id[idx++];
    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        tcpConnEntry->tcpConnRemAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    tcpConnEntry->tcpConnRemPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_tcpConnEntry_t *
assign_tcpConnEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_tcpConnEntry_t *tcpConnEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 6, 13, 1};

    tcpConnEntry = rfc1213_mib_new_tcpConnEntry();
    if (! tcpConnEntry) {
        return NULL;
    }

    p = (char *) tcpConnEntry + sizeof(rfc1213_mib_tcpConnEntry_t);
    * (GSList **) p = vbl;

    if (unpack_tcpConnEntry((GSnmpVarBind *) vbl->data, tcpConnEntry) < 0) {
        g_warning("illegal tcpConnEntry instance identifier");
        g_free(tcpConnEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _tcpConnEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            tcpConnEntry->tcpConnState = &(vb->syntax.i32[0]);
            break;
        };
    }

    return tcpConnEntry;
}

int
rfc1213_mib_get_tcpConnTable(host_snmp *s, rfc1213_mib_tcpConnEntry_t ***tcpConnEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 6, 13, 1, 0};

    *tcpConnEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _tcpConnEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *tcpConnEntry = (rfc1213_mib_tcpConnEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_tcpConnEntry_t *));
    if (! *tcpConnEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*tcpConnEntry)[i] = assign_tcpConnEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_tcpConnEntry(rfc1213_mib_tcpConnEntry_t *tcpConnEntry)
{
    GSList *vbl;
    char *p;

    if (tcpConnEntry) {
        p = (char *) tcpConnEntry + sizeof(rfc1213_mib_tcpConnEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(tcpConnEntry);
    }
}

void
rfc1213_mib_free_tcpConnTable(rfc1213_mib_tcpConnEntry_t **tcpConnEntry)
{
    int i;

    if (tcpConnEntry) {
        for (i = 0; tcpConnEntry[i]; i++) {
            rfc1213_mib_free_tcpConnEntry(tcpConnEntry[i]);
        }
        g_free(tcpConnEntry);
    }
}

rfc1213_mib_udp_t *
rfc1213_mib_new_udp()
{
    rfc1213_mib_udp_t *udp;

    udp = (rfc1213_mib_udp_t *) g_malloc0(sizeof(rfc1213_mib_udp_t) + sizeof(gpointer));
    return udp;
}

static rfc1213_mib_udp_t *
assign_udp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_udp_t *udp;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 7};

    udp = rfc1213_mib_new_udp();
    if (! udp) {
        return NULL;
    }

    p = (char *) udp + sizeof(rfc1213_mib_udp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _udp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            udp->udpInDatagrams = &(vb->syntax.ui32[0]);
            break;
        case 2:
            udp->udpNoPorts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            udp->udpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 4:
            udp->udpOutDatagrams = &(vb->syntax.ui32[0]);
            break;
        };
    }

    return udp;
}

int
rfc1213_mib_get_udp(host_snmp *s, rfc1213_mib_udp_t **udp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 7, 0};

    *udp = NULL;

    stls_vbl_attributes(s, &in, base, 7, _udp);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *udp = assign_udp(out);

    return 0;
}

void
rfc1213_mib_free_udp(rfc1213_mib_udp_t *udp)
{
    GSList *vbl;
    char *p;

    if (udp) {
        p = (char *) udp + sizeof(rfc1213_mib_udp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(udp);
    }
}

rfc1213_mib_udpEntry_t *
rfc1213_mib_new_udpEntry()
{
    rfc1213_mib_udpEntry_t *udpEntry;

    udpEntry = (rfc1213_mib_udpEntry_t *) g_malloc0(sizeof(rfc1213_mib_udpEntry_t) + sizeof(gpointer));
    return udpEntry;
}

static int
unpack_udpEntry(GSnmpVarBind *vb, rfc1213_mib_udpEntry_t *udpEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        udpEntry->udpLocalAddress[i] = vb->id[idx++];
    }
    if (vb->id_len < idx) return -1;
    udpEntry->udpLocalPort = vb->id[idx++];
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_udpEntry_t *
assign_udpEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_udpEntry_t *udpEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 7, 5, 1};

    udpEntry = rfc1213_mib_new_udpEntry();
    if (! udpEntry) {
        return NULL;
    }

    p = (char *) udpEntry + sizeof(rfc1213_mib_udpEntry_t);
    * (GSList **) p = vbl;

    if (unpack_udpEntry((GSnmpVarBind *) vbl->data, udpEntry) < 0) {
        g_warning("illegal udpEntry instance identifier");
        g_free(udpEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _udpEntry, &idx) < 0) continue;

        switch (idx) {
        };
    }

    return udpEntry;
}

int
rfc1213_mib_get_udpTable(host_snmp *s, rfc1213_mib_udpEntry_t ***udpEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 7, 5, 1, 0};

    *udpEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _udpEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *udpEntry = (rfc1213_mib_udpEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_udpEntry_t *));
    if (! *udpEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*udpEntry)[i] = assign_udpEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_udpEntry(rfc1213_mib_udpEntry_t *udpEntry)
{
    GSList *vbl;
    char *p;

    if (udpEntry) {
        p = (char *) udpEntry + sizeof(rfc1213_mib_udpEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(udpEntry);
    }
}

void
rfc1213_mib_free_udpTable(rfc1213_mib_udpEntry_t **udpEntry)
{
    int i;

    if (udpEntry) {
        for (i = 0; udpEntry[i]; i++) {
            rfc1213_mib_free_udpEntry(udpEntry[i]);
        }
        g_free(udpEntry);
    }
}

rfc1213_mib_egp_t *
rfc1213_mib_new_egp()
{
    rfc1213_mib_egp_t *egp;

    egp = (rfc1213_mib_egp_t *) g_malloc0(sizeof(rfc1213_mib_egp_t) + sizeof(gpointer));
    return egp;
}

static rfc1213_mib_egp_t *
assign_egp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_egp_t *egp;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 8};

    egp = rfc1213_mib_new_egp();
    if (! egp) {
        return NULL;
    }

    p = (char *) egp + sizeof(rfc1213_mib_egp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _egp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            egp->egpInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 2:
            egp->egpInErrors = &(vb->syntax.ui32[0]);
            break;
        case 3:
            egp->egpOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 4:
            egp->egpOutErrors = &(vb->syntax.ui32[0]);
            break;
        case 6:
            egp->egpAs = &(vb->syntax.i32[0]);
            break;
        };
    }

    return egp;
}

int
rfc1213_mib_get_egp(host_snmp *s, rfc1213_mib_egp_t **egp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 8, 0};

    *egp = NULL;

    stls_vbl_attributes(s, &in, base, 7, _egp);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *egp = assign_egp(out);

    return 0;
}

void
rfc1213_mib_free_egp(rfc1213_mib_egp_t *egp)
{
    GSList *vbl;
    char *p;

    if (egp) {
        p = (char *) egp + sizeof(rfc1213_mib_egp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(egp);
    }
}

rfc1213_mib_egpNeighEntry_t *
rfc1213_mib_new_egpNeighEntry()
{
    rfc1213_mib_egpNeighEntry_t *egpNeighEntry;

    egpNeighEntry = (rfc1213_mib_egpNeighEntry_t *) g_malloc0(sizeof(rfc1213_mib_egpNeighEntry_t) + sizeof(gpointer));
    return egpNeighEntry;
}

static int
unpack_egpNeighEntry(GSnmpVarBind *vb, rfc1213_mib_egpNeighEntry_t *egpNeighEntry)
{
    int i, len, idx = 10;

    len = 4;
    if (vb->id_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        egpNeighEntry->egpNeighAddr[i] = vb->id[idx++];
    }
    if (vb->id_len > idx) return -1;
    return 0;
}

static rfc1213_mib_egpNeighEntry_t *
assign_egpNeighEntry(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_egpNeighEntry_t *egpNeighEntry;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 8, 5, 1};

    egpNeighEntry = rfc1213_mib_new_egpNeighEntry();
    if (! egpNeighEntry) {
        return NULL;
    }

    p = (char *) egpNeighEntry + sizeof(rfc1213_mib_egpNeighEntry_t);
    * (GSList **) p = vbl;

    if (unpack_egpNeighEntry((GSnmpVarBind *) vbl->data, egpNeighEntry) < 0) {
        g_warning("illegal egpNeighEntry instance identifier");
        g_free(egpNeighEntry);
        return NULL;
    }

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _egpNeighEntry, &idx) < 0) continue;

        switch (idx) {
        case 1:
            egpNeighEntry->egpNeighState = &(vb->syntax.i32[0]);
            break;
        case 3:
            egpNeighEntry->egpNeighAs = &(vb->syntax.i32[0]);
            break;
        case 4:
            egpNeighEntry->egpNeighInMsgs = &(vb->syntax.ui32[0]);
            break;
        case 5:
            egpNeighEntry->egpNeighInErrs = &(vb->syntax.ui32[0]);
            break;
        case 6:
            egpNeighEntry->egpNeighOutMsgs = &(vb->syntax.ui32[0]);
            break;
        case 7:
            egpNeighEntry->egpNeighOutErrs = &(vb->syntax.ui32[0]);
            break;
        case 8:
            egpNeighEntry->egpNeighInErrMsgs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            egpNeighEntry->egpNeighOutErrMsgs = &(vb->syntax.ui32[0]);
            break;
        case 10:
            egpNeighEntry->egpNeighStateUps = &(vb->syntax.ui32[0]);
            break;
        case 11:
            egpNeighEntry->egpNeighStateDowns = &(vb->syntax.ui32[0]);
            break;
        case 12:
            egpNeighEntry->egpNeighIntervalHello = &(vb->syntax.i32[0]);
            break;
        case 13:
            egpNeighEntry->egpNeighIntervalPoll = &(vb->syntax.i32[0]);
            break;
        case 14:
            egpNeighEntry->egpNeighMode = &(vb->syntax.i32[0]);
            break;
        case 15:
            egpNeighEntry->egpNeighEventTrigger = &(vb->syntax.i32[0]);
            break;
        };
    }

    return egpNeighEntry;
}

int
rfc1213_mib_get_egpNeighTable(host_snmp *s, rfc1213_mib_egpNeighEntry_t ***egpNeighEntry)
{
    GSList *in = NULL, *out = NULL;
    GSList *row;
    int i;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 8, 5, 1, 0};

    *egpNeighEntry = NULL;

    stls_vbl_attributes(s, &in, base, 9, _egpNeighEntry);

    out = stls_snmp_gettable(s, in);
    /* stls_vbl_free(in); */
    if (! out) {
        return -2;
    }

    *egpNeighEntry = (rfc1213_mib_egpNeighEntry_t **) g_malloc0((g_slist_length(out) + 1) * sizeof(rfc1213_mib_egpNeighEntry_t *));
    if (! *egpNeighEntry) {
        return -4;
    }

    for (row = out, i = 0; row; row = g_slist_next(row), i++) {
        (*egpNeighEntry)[i] = assign_egpNeighEntry(row->data);
    }

    return 0;
}

void
rfc1213_mib_free_egpNeighEntry(rfc1213_mib_egpNeighEntry_t *egpNeighEntry)
{
    GSList *vbl;
    char *p;

    if (egpNeighEntry) {
        p = (char *) egpNeighEntry + sizeof(rfc1213_mib_egpNeighEntry_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(egpNeighEntry);
    }
}

void
rfc1213_mib_free_egpNeighTable(rfc1213_mib_egpNeighEntry_t **egpNeighEntry)
{
    int i;

    if (egpNeighEntry) {
        for (i = 0; egpNeighEntry[i]; i++) {
            rfc1213_mib_free_egpNeighEntry(egpNeighEntry[i]);
        }
        g_free(egpNeighEntry);
    }
}

rfc1213_mib_snmp_t *
rfc1213_mib_new_snmp()
{
    rfc1213_mib_snmp_t *snmp;

    snmp = (rfc1213_mib_snmp_t *) g_malloc0(sizeof(rfc1213_mib_snmp_t) + sizeof(gpointer));
    return snmp;
}

static rfc1213_mib_snmp_t *
assign_snmp(GSList *vbl)
{
    GSList *elem;
    rfc1213_mib_snmp_t *snmp;
    guint32 idx;
    char *p;
    static guint32 const base[] = {1, 3, 6, 1, 2, 1, 11};

    snmp = rfc1213_mib_new_snmp();
    if (! snmp) {
        return NULL;
    }

    p = (char *) snmp + sizeof(rfc1213_mib_snmp_t);
    * (GSList **) p = vbl;

    for (elem = vbl; elem; elem = g_slist_next(elem)) {
        GSnmpVarBind *vb = (GSnmpVarBind *) elem->data;

        if (stls_vb_lookup(vb, base, sizeof(base)/sizeof(guint32),
                           _snmp, &idx) < 0) continue;

        switch (idx) {
        case 1:
            snmp->snmpInPkts = &(vb->syntax.ui32[0]);
            break;
        case 2:
            snmp->snmpOutPkts = &(vb->syntax.ui32[0]);
            break;
        case 3:
            snmp->snmpInBadVersions = &(vb->syntax.ui32[0]);
            break;
        case 4:
            snmp->snmpInBadCommunityNames = &(vb->syntax.ui32[0]);
            break;
        case 5:
            snmp->snmpInBadCommunityUses = &(vb->syntax.ui32[0]);
            break;
        case 6:
            snmp->snmpInASNParseErrs = &(vb->syntax.ui32[0]);
            break;
        case 8:
            snmp->snmpInTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 9:
            snmp->snmpInNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 10:
            snmp->snmpInBadValues = &(vb->syntax.ui32[0]);
            break;
        case 11:
            snmp->snmpInReadOnlys = &(vb->syntax.ui32[0]);
            break;
        case 12:
            snmp->snmpInGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 13:
            snmp->snmpInTotalReqVars = &(vb->syntax.ui32[0]);
            break;
        case 14:
            snmp->snmpInTotalSetVars = &(vb->syntax.ui32[0]);
            break;
        case 15:
            snmp->snmpInGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 16:
            snmp->snmpInGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 17:
            snmp->snmpInSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 18:
            snmp->snmpInGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 19:
            snmp->snmpInTraps = &(vb->syntax.ui32[0]);
            break;
        case 20:
            snmp->snmpOutTooBigs = &(vb->syntax.ui32[0]);
            break;
        case 21:
            snmp->snmpOutNoSuchNames = &(vb->syntax.ui32[0]);
            break;
        case 22:
            snmp->snmpOutBadValues = &(vb->syntax.ui32[0]);
            break;
        case 24:
            snmp->snmpOutGenErrs = &(vb->syntax.ui32[0]);
            break;
        case 25:
            snmp->snmpOutGetRequests = &(vb->syntax.ui32[0]);
            break;
        case 26:
            snmp->snmpOutGetNexts = &(vb->syntax.ui32[0]);
            break;
        case 27:
            snmp->snmpOutSetRequests = &(vb->syntax.ui32[0]);
            break;
        case 28:
            snmp->snmpOutGetResponses = &(vb->syntax.ui32[0]);
            break;
        case 29:
            snmp->snmpOutTraps = &(vb->syntax.ui32[0]);
            break;
        case 30:
            snmp->snmpEnableAuthenTraps = &(vb->syntax.i32[0]);
            break;
        };
    }

    return snmp;
}

int
rfc1213_mib_get_snmp(host_snmp *s, rfc1213_mib_snmp_t **snmp)
{
    GSList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 2, 1, 11, 0};

    *snmp = NULL;

    stls_vbl_attributes(s, &in, base, 7, _snmp);

    out = stls_snmp_getnext(s, in);
    stls_vbl_free(in);
    if (! out) {
        return -2;
    }

    *snmp = assign_snmp(out);

    return 0;
}

void
rfc1213_mib_free_snmp(rfc1213_mib_snmp_t *snmp)
{
    GSList *vbl;
    char *p;

    if (snmp) {
        p = (char *) snmp + sizeof(rfc1213_mib_snmp_t);
        vbl = * (GSList **) p;
        stls_vbl_free(vbl);
        g_free(snmp);
    }
}


