/*							-- DO NOT EDIT --
 * Generated by smidump version 0.4.8:
 *   smidump -f scli JACOBS-RPL-MIB
 *
 * Derived from JACOBS-RPL-MIB:
 *   The MIB module for monitoring nodes implementing the IPv6
 *   routing protocol for low power and lossy networks (RPL).
 *   
 *   Copyright (c) 2011 IETF Trust and the persons identified as
 *   authors of the code.  All rights reserved.
 *   
 *   Redistribution and use in source and binary forms, with or
 *   without modification, is permitted pursuant to, and subject
 *   to the license terms contained in, the Simplified BSD
 *   License set forth in Section 4.c of the IETF Trust's
 *   Legal Provisions Relating to IETF Documents
 *   (http://trustee.ietf.org/license-info).
 *
 * Revision 2011-03-10 00:00:
 *   Initial version, published as RFC XXXX.
 *
 * $Id$
 */

#include "jacobs-rpl-mib.h"

GNetSnmpEnum const jacobs_rpl_mib_enums_rplRPLInstanceDAOAcknowledgement[] = {
    { JACOBS_RPL_MIB_RPLRPLINSTANCEDAOACKNOWLEDGEMENT_NOPE, "nope" },
    { 0, NULL }
};

GNetSnmpEnum const jacobs_rpl_mib_enums_rplDodagState[] = {
    { JACOBS_RPL_MIB_RPLDODAGSTATE_OTHER,      "other" },
    { JACOBS_RPL_MIB_RPLDODAGSTATE_ASSOCIATED, "associated" },
    { JACOBS_RPL_MIB_RPLDODAGSTATE_GROUNDED,   "grounded" },
    { JACOBS_RPL_MIB_RPLDODAGSTATE_FLOATING,   "floating" },
    { 0, NULL }
};

GNetSnmpEnum const jacobs_rpl_mib_enums_RplDISMode[] = {
    { JACOBS_RPL_MIB_RPLDISMODE_SILENT, "silent" },
    { JACOBS_RPL_MIB_RPLDISMODE_SEND,   "send" },
    { 0, NULL }
};

GNetSnmpEnum const jacobs_rpl_mib_enums_RplModeOfOperation[] = {
    { JACOBS_RPL_MIB_RPLMODEOFOPERATION_NODOWNWARDROUTES,               "noDownwardRoutes" },
    { JACOBS_RPL_MIB_RPLMODEOFOPERATION_NONSTORINGMODE,                 "nonStoringMode" },
    { JACOBS_RPL_MIB_RPLMODEOFOPERATION_STORINGWITHOUTMULTICASTSUPPORT, "storingWithoutMulticastSupport" },
    { JACOBS_RPL_MIB_RPLMODEOFOPERATION_STORINGWITHMULTICASTSUPPORT,    "storingWithMulticastSupport" },
    { 0, NULL }
};


static guint32 rplActiveInstance_constraints[] = {0UL, 255UL, 0, 0};
static guint16 rplActiveDodag_constraints[] = {16U, 16U, 0, 0};
static guint32 rplActiveDodagDAOSequence_constraints[] = {0UL, 255UL, 0, 0};
static guint32 rplActiveDodagTriggerSequence_constraints[] = {0UL, 255UL, 0, 0};
static guint32 rplRPLInstanceOCP_constraints[] = {0UL, 65535UL, 0, 0};
static guint32 rplDodagVersion_constraints[] = {0UL, 255UL, 0, 0};
static guint32 rplDodagRank_constraints[] = {0UL, 65535UL, 0, 0};
static guint32 rplDodagPreference_constraints[] = {0UL, 7UL, 0, 0};
static guint32 rplDodagMinHopRankIncrease_constraints[] = {0UL, 131071UL, 0, 0};
static guint32 rplDodagPathControlSize_constraints[] = {0UL, 7UL, 0, 0};
static gint32 rplDodagParentIf_constraints[] = {1L, 2147483647L, 0, 0};
static guint16 rplDodagChildID_constraints[] = {16U, 16U, 0, 0};
static guint16 rplDodagPrefixIpv6Prefix_constraints[] = {16U, 16U, 0, 0};
static guint32 rplDodagPrefixIpv6PrefixLength_constraints[] = {0UL, 2040UL, 0, 0};


static guint32 const rplGeneral_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 1};

static GNetSnmpAttribute rplGeneral_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLDEFAULTDISMODE, "rplDefaultDISMode",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplGeneral_t, rplDefaultDISMode),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const rplActive_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 2};

static GNetSnmpAttribute rplActive_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLACTIVEINSTANCE, "rplActiveInstance",
       rplActiveInstance_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplActive_t, rplActiveInstance),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 2, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      JACOBS_RPL_MIB_RPLACTIVEDODAG, "rplActiveDodag",
       rplActiveDodag_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplActive_t, rplActiveDodag),
      16,
      GSNMP_ATTR_FLAG_WRITABLE|GSNMP_ATTR_FLAG_FIXED_LENGTH },
    { 3, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLACTIVEDODAGDAOSEQUENCE, "rplActiveDodagDAOSequence",
       rplActiveDodagDAOSequence_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplActive_t, rplActiveDodagDAOSequence),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLACTIVEDODAGTRIGGERSEQUENCE, "rplActiveDodagTriggerSequence",
       rplActiveDodagTriggerSequence_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplActive_t, rplActiveDodagTriggerSequence),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const rplOCPEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 3, 1};

static GNetSnmpAttribute rplOCPEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLOCPENABLED, "rplOCPEnabled",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplOCPEntry_t, rplOCPEnabled),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const rplRPLInstanceEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 4, 1};

static GNetSnmpAttribute rplRPLInstanceEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLRPLINSTANCEOCP, "rplRPLInstanceOCP",
       rplRPLInstanceOCP_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplRPLInstanceEntry_t, rplRPLInstanceOCP),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 3, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLRPLINSTANCEDISMODE, "rplRPLInstanceDisMode",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplRPLInstanceEntry_t, rplRPLInstanceDisMode),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLRPLINSTANCEDAOACKNOWLEDGEMENT, "rplRPLInstanceDAOAcknowledgement",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplRPLInstanceEntry_t, rplRPLInstanceDAOAcknowledgement),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 5, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLRPLINSTANCEMODEOFOPERATION, "rplRPLInstanceModeOfOperation",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplRPLInstanceEntry_t, rplRPLInstanceModeOfOperation),
      0,
      GSNMP_ATTR_FLAG_WRITABLE },
    { 0, 0, 0, NULL }
};

static guint32 const rplDodagEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 5, 1};

static GNetSnmpAttribute rplDodagEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGVERSION, "rplDodagVersion",
       rplDodagVersion_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagVersion),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGRANK, "rplDodagRank",
       rplDodagRank_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagRank),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLDODAGSTATE, "rplDodagState",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagState),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGDAODELAY, "rplDodagDAODelay",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagDAODelay),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGPREFERENCE, "rplDodagPreference",
       rplDodagPreference_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagPreference),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGMINHOPRANKINCREASE, "rplDodagMinHopRankIncrease",
       rplDodagMinHopRankIncrease_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagMinHopRankIncrease),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGPATHCONTROLSIZE, "rplDodagPathControlSize",
       rplDodagPathControlSize_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagEntry_t, rplDodagPathControlSize),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const rplDodagParentEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 6, 1};

static GNetSnmpAttribute rplDodagParentEntry_attr[] = {
    { 2, GNET_SNMP_VARBIND_TYPE_INTEGER32,
      JACOBS_RPL_MIB_RPLDODAGPARENTIF, "rplDodagParentIf",
       rplDodagParentIf_constraints,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplDodagParentEntry_t, rplDodagParentIf),
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const rplDodagChildEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 7, 1};

static GNetSnmpAttribute rplDodagChildEntry_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      JACOBS_RPL_MIB_RPLDODAGCHILDID, "rplDodagChildID",
       rplDodagChildID_constraints,
      -1,
      16,
      GSNMP_ATTR_FLAG_FIXED_LENGTH },
    { 0, 0, 0, NULL }
};

static guint32 const rplDodagPrefixEntry_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 8, 1};

static GNetSnmpAttribute rplDodagPrefixEntry_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_OCTETSTRING,
      JACOBS_RPL_MIB_RPLDODAGPREFIXIPV6PREFIX, "rplDodagPrefixIpv6Prefix",
       rplDodagPrefixIpv6Prefix_constraints,
      -1,
      16,
      GSNMP_ATTR_FLAG_FIXED_LENGTH },
    { 2, GNET_SNMP_VARBIND_TYPE_UNSIGNED32,
      JACOBS_RPL_MIB_RPLDODAGPREFIXIPV6PREFIXLENGTH, "rplDodagPrefixIpv6PrefixLength",
       rplDodagPrefixIpv6PrefixLength_constraints,
      -1,
      0,
      0 },
    { 0, 0, 0, NULL }
};

static guint32 const rplStats_oid[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 9};

static GNetSnmpAttribute rplStats_attr[] = {
    { 1, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSMEMOVERFLOWS, "rplStatsMemOverflows",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsMemOverflows),
      0,
      0 },
    { 2, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSVALIDPARENTFAILURES, "rplStatsValidParentFailures",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsValidParentFailures),
      0,
      0 },
    { 3, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSNOINSTANCEIDS, "rplStatsNoInstanceIDs",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsNoInstanceIDs),
      0,
      0 },
    { 4, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSTRIGGEREDLOCALREPAIRS, "rplStatsTriggeredLocalRepairs",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsTriggeredLocalRepairs),
      0,
      0 },
    { 5, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSTRIGGEREDGLOBALREPAIRS, "rplStatsTriggeredGlobalRepairs",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsTriggeredGlobalRepairs),
      0,
      0 },
    { 6, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSPARSEERRORS, "rplStatsParseErrors",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsParseErrors),
      0,
      0 },
    { 7, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSNOPARENTSECS, "rplStatsNoParentSecs",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsNoParentSecs),
      0,
      0 },
    { 8, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSACTIVENOPARENTSECS, "rplStatsActiveNoParentSecs",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsActiveNoParentSecs),
      0,
      0 },
    { 9, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSOBITSETDOWNWARDS, "rplStatsOBitSetDownwards",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsOBitSetDownwards),
      0,
      0 },
    { 10, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSOBITCLEAREDUPWARDS, "rplStatsOBitClearedUpwards",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsOBitClearedUpwards),
      0,
      0 },
    { 11, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSFBITSET, "rplStatsFBitSet",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsFBitSet),
      0,
      0 },
    { 12, GNET_SNMP_VARBIND_TYPE_COUNTER32,
      JACOBS_RPL_MIB_RPLSTATSRBITSET, "rplStatsRBitSet",
       NULL,
      G_STRUCT_OFFSET(jacobs_rpl_mib_rplStats_t, rplStatsRBitSet),
      0,
      0 },
    { 0, 0, 0, NULL }
};


jacobs_rpl_mib_rplGeneral_t *
jacobs_rpl_mib_new_rplGeneral()
{
    jacobs_rpl_mib_rplGeneral_t *rplGeneral;

    rplGeneral = (jacobs_rpl_mib_rplGeneral_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplGeneral_t) + sizeof(gpointer));
    return rplGeneral;
}

static inline jacobs_rpl_mib_rplGeneral_t *
assign_rplGeneral(GList *vbl)
{
    jacobs_rpl_mib_rplGeneral_t *rplGeneral;
    char *p;

    rplGeneral = jacobs_rpl_mib_new_rplGeneral();
    p = (char *) rplGeneral + sizeof(jacobs_rpl_mib_rplGeneral_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, rplGeneral_oid, G_N_ELEMENTS(rplGeneral_oid),
                      rplGeneral_attr, rplGeneral);

    return rplGeneral;
}

void
jacobs_rpl_mib_get_rplGeneral(GNetSnmp *s, jacobs_rpl_mib_rplGeneral_t **rplGeneral, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 1, 0};
    guint32 base[128];

    *rplGeneral = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 12, 11, rplGeneral_attr, mask);

    out = gnet_snmp_sync_getnext(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if ((error && *error) || s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplGeneral = assign_rplGeneral(out);
    }
}

void
jacobs_rpl_mib_set_rplGeneral(GNetSnmp *s, jacobs_rpl_mib_rplGeneral_t *rplGeneral, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 1, 0, 0};

    gnet_snmp_attr_set(s, &in, base, 13, 11, rplGeneral_attr, mask, rplGeneral);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
jacobs_rpl_mib_free_rplGeneral(jacobs_rpl_mib_rplGeneral_t *rplGeneral)
{
    GList *vbl;
    char *p;

    if (rplGeneral) {
        p = (char *) rplGeneral + sizeof(jacobs_rpl_mib_rplGeneral_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplGeneral);
    }
}

jacobs_rpl_mib_rplActive_t *
jacobs_rpl_mib_new_rplActive()
{
    jacobs_rpl_mib_rplActive_t *rplActive;

    rplActive = (jacobs_rpl_mib_rplActive_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplActive_t) + sizeof(gpointer));
    return rplActive;
}

static inline jacobs_rpl_mib_rplActive_t *
assign_rplActive(GList *vbl)
{
    jacobs_rpl_mib_rplActive_t *rplActive;
    char *p;

    rplActive = jacobs_rpl_mib_new_rplActive();
    p = (char *) rplActive + sizeof(jacobs_rpl_mib_rplActive_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, rplActive_oid, G_N_ELEMENTS(rplActive_oid),
                      rplActive_attr, rplActive);

    return rplActive;
}

void
jacobs_rpl_mib_get_rplActive(GNetSnmp *s, jacobs_rpl_mib_rplActive_t **rplActive, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 2, 0};
    guint32 base[128];

    *rplActive = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 12, 11, rplActive_attr, mask);

    out = gnet_snmp_sync_getnext(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if ((error && *error) || s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplActive = assign_rplActive(out);
    }
}

void
jacobs_rpl_mib_set_rplActive(GNetSnmp *s, jacobs_rpl_mib_rplActive_t *rplActive, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static guint32 base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 2, 0, 0};

    gnet_snmp_attr_set(s, &in, base, 13, 11, rplActive_attr, mask, rplActive);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
jacobs_rpl_mib_free_rplActive(jacobs_rpl_mib_rplActive_t *rplActive)
{
    GList *vbl;
    char *p;

    if (rplActive) {
        p = (char *) rplActive + sizeof(jacobs_rpl_mib_rplActive_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplActive);
    }
}

jacobs_rpl_mib_rplOCPEntry_t *
jacobs_rpl_mib_new_rplOCPEntry()
{
    jacobs_rpl_mib_rplOCPEntry_t *rplOCPEntry;

    rplOCPEntry = (jacobs_rpl_mib_rplOCPEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplOCPEntry_t) + sizeof(gpointer));
    return rplOCPEntry;
}

static inline int
unpack_rplOCPEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplOCPEntry_t *rplOCPEntry)
{
    guint8 idx = 13;

    if (vb->oid_len < idx) return -1;
    rplOCPEntry->rplOCPCodepoint = vb->oid[idx++];
     if ((rplOCPEntry->rplOCPCodepoint > 65535)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplOCPEntry(guint32 *base, guint32 rplOCPCodepoint)
{
    guint8 idx = 13;

    base[idx++] = rplOCPCodepoint;
    return idx;
}

static inline jacobs_rpl_mib_rplOCPEntry_t *
assign_rplOCPEntry(GList *vbl)
{
    jacobs_rpl_mib_rplOCPEntry_t *rplOCPEntry;
    char *p;

    rplOCPEntry = jacobs_rpl_mib_new_rplOCPEntry();
    p = (char *) rplOCPEntry + sizeof(jacobs_rpl_mib_rplOCPEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplOCPEntry((GNetSnmpVarBind *) vbl->data, rplOCPEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplOCPEntry");
        g_free(rplOCPEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplOCPEntry_oid, G_N_ELEMENTS(rplOCPEntry_oid),
                      rplOCPEntry_attr, rplOCPEntry);

    return rplOCPEntry;
}

void
jacobs_rpl_mib_get_rplOCPTable(GNetSnmp *s, jacobs_rpl_mib_rplOCPEntry_t ***rplOCPEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 3, 1, 0};
    guint32 base[128];

    *rplOCPEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplOCPEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplOCPEntry = (jacobs_rpl_mib_rplOCPEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplOCPEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplOCPEntry)[i] = assign_rplOCPEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplOCPEntry(GNetSnmp *s, jacobs_rpl_mib_rplOCPEntry_t **rplOCPEntry, guint32 rplOCPCodepoint, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplOCPEntry_oid, sizeof(rplOCPEntry_oid));
    len = pack_rplOCPEntry(base, rplOCPCodepoint);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplOCPEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplOCPEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplOCPEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplOCPEntry = assign_rplOCPEntry(out);
    }
}

void
jacobs_rpl_mib_set_rplOCPEntry(GNetSnmp *s, jacobs_rpl_mib_rplOCPEntry_t *rplOCPEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplOCPEntry_oid, sizeof(rplOCPEntry_oid));
    len = pack_rplOCPEntry(base, rplOCPEntry->rplOCPCodepoint);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplOCPEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 12, rplOCPEntry_attr, mask, rplOCPEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
jacobs_rpl_mib_free_rplOCPEntry(jacobs_rpl_mib_rplOCPEntry_t *rplOCPEntry)
{
    GList *vbl;
    char *p;

    if (rplOCPEntry) {
        p = (char *) rplOCPEntry + sizeof(jacobs_rpl_mib_rplOCPEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplOCPEntry);
    }
}

void
jacobs_rpl_mib_free_rplOCPTable(jacobs_rpl_mib_rplOCPEntry_t **rplOCPEntry)
{
    int i;

    if (rplOCPEntry) {
        for (i = 0; rplOCPEntry[i]; i++) {
            jacobs_rpl_mib_free_rplOCPEntry(rplOCPEntry[i]);
        }
        g_free(rplOCPEntry);
    }
}

jacobs_rpl_mib_rplRPLInstanceEntry_t *
jacobs_rpl_mib_new_rplRPLInstanceEntry()
{
    jacobs_rpl_mib_rplRPLInstanceEntry_t *rplRPLInstanceEntry;

    rplRPLInstanceEntry = (jacobs_rpl_mib_rplRPLInstanceEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplRPLInstanceEntry_t) + sizeof(gpointer));
    return rplRPLInstanceEntry;
}

static inline int
unpack_rplRPLInstanceEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplRPLInstanceEntry_t *rplRPLInstanceEntry)
{
    guint8 idx = 13;

    if (vb->oid_len < idx) return -1;
    rplRPLInstanceEntry->rplRPLInstanceID = vb->oid[idx++];
     if ((rplRPLInstanceEntry->rplRPLInstanceID > 255)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplRPLInstanceEntry(guint32 *base, guint32 rplRPLInstanceID)
{
    guint8 idx = 13;

    base[idx++] = rplRPLInstanceID;
    return idx;
}

static inline jacobs_rpl_mib_rplRPLInstanceEntry_t *
assign_rplRPLInstanceEntry(GList *vbl)
{
    jacobs_rpl_mib_rplRPLInstanceEntry_t *rplRPLInstanceEntry;
    char *p;

    rplRPLInstanceEntry = jacobs_rpl_mib_new_rplRPLInstanceEntry();
    p = (char *) rplRPLInstanceEntry + sizeof(jacobs_rpl_mib_rplRPLInstanceEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplRPLInstanceEntry((GNetSnmpVarBind *) vbl->data, rplRPLInstanceEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplRPLInstanceEntry");
        g_free(rplRPLInstanceEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplRPLInstanceEntry_oid, G_N_ELEMENTS(rplRPLInstanceEntry_oid),
                      rplRPLInstanceEntry_attr, rplRPLInstanceEntry);

    return rplRPLInstanceEntry;
}

void
jacobs_rpl_mib_get_rplRPLInstanceTable(GNetSnmp *s, jacobs_rpl_mib_rplRPLInstanceEntry_t ***rplRPLInstanceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 4, 1, 0};
    guint32 base[128];

    *rplRPLInstanceEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplRPLInstanceEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplRPLInstanceEntry = (jacobs_rpl_mib_rplRPLInstanceEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplRPLInstanceEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplRPLInstanceEntry)[i] = assign_rplRPLInstanceEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplRPLInstanceEntry(GNetSnmp *s, jacobs_rpl_mib_rplRPLInstanceEntry_t **rplRPLInstanceEntry, guint32 rplRPLInstanceID, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplRPLInstanceEntry_oid, sizeof(rplRPLInstanceEntry_oid));
    len = pack_rplRPLInstanceEntry(base, rplRPLInstanceID);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplRPLInstanceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplRPLInstanceEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplRPLInstanceEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplRPLInstanceEntry = assign_rplRPLInstanceEntry(out);
    }
}

void
jacobs_rpl_mib_set_rplRPLInstanceEntry(GNetSnmp *s, jacobs_rpl_mib_rplRPLInstanceEntry_t *rplRPLInstanceEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplRPLInstanceEntry_oid, sizeof(rplRPLInstanceEntry_oid));
    len = pack_rplRPLInstanceEntry(base, rplRPLInstanceEntry->rplRPLInstanceID);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplRPLInstanceEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    gnet_snmp_attr_set(s, &in, base, len, 12, rplRPLInstanceEntry_attr, mask, rplRPLInstanceEntry);

    out = gnet_snmp_sync_set(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(out);
    }
}

void
jacobs_rpl_mib_free_rplRPLInstanceEntry(jacobs_rpl_mib_rplRPLInstanceEntry_t *rplRPLInstanceEntry)
{
    GList *vbl;
    char *p;

    if (rplRPLInstanceEntry) {
        p = (char *) rplRPLInstanceEntry + sizeof(jacobs_rpl_mib_rplRPLInstanceEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplRPLInstanceEntry);
    }
}

void
jacobs_rpl_mib_free_rplRPLInstanceTable(jacobs_rpl_mib_rplRPLInstanceEntry_t **rplRPLInstanceEntry)
{
    int i;

    if (rplRPLInstanceEntry) {
        for (i = 0; rplRPLInstanceEntry[i]; i++) {
            jacobs_rpl_mib_free_rplRPLInstanceEntry(rplRPLInstanceEntry[i]);
        }
        g_free(rplRPLInstanceEntry);
    }
}

jacobs_rpl_mib_rplDodagEntry_t *
jacobs_rpl_mib_new_rplDodagEntry()
{
    jacobs_rpl_mib_rplDodagEntry_t *rplDodagEntry;

    rplDodagEntry = (jacobs_rpl_mib_rplDodagEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplDodagEntry_t) + sizeof(gpointer));
    return rplDodagEntry;
}

static inline int
unpack_rplDodagEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplDodagEntry_t *rplDodagEntry)
{
    guint8 idx = 13;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    rplDodagEntry->rplRPLInstanceID = vb->oid[idx++];
     if ((rplDodagEntry->rplRPLInstanceID > 255)) {
         return -1;
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagEntry->rplDodagRoot[i] = vb->oid[idx++];
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplDodagEntry(guint32 *base, guint32 rplRPLInstanceID, guchar *rplDodagRoot)
{
    guint8 idx = 13;
    guint16 i, len;

    base[idx++] = rplRPLInstanceID;
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagRoot[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline jacobs_rpl_mib_rplDodagEntry_t *
assign_rplDodagEntry(GList *vbl)
{
    jacobs_rpl_mib_rplDodagEntry_t *rplDodagEntry;
    char *p;

    rplDodagEntry = jacobs_rpl_mib_new_rplDodagEntry();
    p = (char *) rplDodagEntry + sizeof(jacobs_rpl_mib_rplDodagEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplDodagEntry((GNetSnmpVarBind *) vbl->data, rplDodagEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplDodagEntry");
        g_free(rplDodagEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplDodagEntry_oid, G_N_ELEMENTS(rplDodagEntry_oid),
                      rplDodagEntry_attr, rplDodagEntry);

    return rplDodagEntry;
}

void
jacobs_rpl_mib_get_rplDodagTable(GNetSnmp *s, jacobs_rpl_mib_rplDodagEntry_t ***rplDodagEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 5, 1, 0};
    guint32 base[128];

    *rplDodagEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplDodagEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplDodagEntry = (jacobs_rpl_mib_rplDodagEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplDodagEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplDodagEntry)[i] = assign_rplDodagEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplDodagEntry(GNetSnmp *s, jacobs_rpl_mib_rplDodagEntry_t **rplDodagEntry, guint32 rplRPLInstanceID, guchar *rplDodagRoot, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplDodagEntry_oid, sizeof(rplDodagEntry_oid));
    len = pack_rplDodagEntry(base, rplRPLInstanceID, rplDodagRoot);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplDodagEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplDodagEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplDodagEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplDodagEntry = assign_rplDodagEntry(out);
    }
}

void
jacobs_rpl_mib_free_rplDodagEntry(jacobs_rpl_mib_rplDodagEntry_t *rplDodagEntry)
{
    GList *vbl;
    char *p;

    if (rplDodagEntry) {
        p = (char *) rplDodagEntry + sizeof(jacobs_rpl_mib_rplDodagEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplDodagEntry);
    }
}

void
jacobs_rpl_mib_free_rplDodagTable(jacobs_rpl_mib_rplDodagEntry_t **rplDodagEntry)
{
    int i;

    if (rplDodagEntry) {
        for (i = 0; rplDodagEntry[i]; i++) {
            jacobs_rpl_mib_free_rplDodagEntry(rplDodagEntry[i]);
        }
        g_free(rplDodagEntry);
    }
}

jacobs_rpl_mib_rplDodagParentEntry_t *
jacobs_rpl_mib_new_rplDodagParentEntry()
{
    jacobs_rpl_mib_rplDodagParentEntry_t *rplDodagParentEntry;

    rplDodagParentEntry = (jacobs_rpl_mib_rplDodagParentEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplDodagParentEntry_t) + sizeof(gpointer));
    return rplDodagParentEntry;
}

static inline int
unpack_rplDodagParentEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplDodagParentEntry_t *rplDodagParentEntry)
{
    guint8 idx = 13;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    rplDodagParentEntry->rplRPLInstanceID = vb->oid[idx++];
     if ((rplDodagParentEntry->rplRPLInstanceID > 255)) {
         return -1;
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagParentEntry->rplDodagRoot[i] = vb->oid[idx++];
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagParentEntry->rplDodagParentID[i] = vb->oid[idx++];
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplDodagParentEntry(guint32 *base, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagParentID)
{
    guint8 idx = 13;
    guint16 i, len;

    base[idx++] = rplRPLInstanceID;
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagRoot[i];
        if (idx >= 128) return -1;
    }
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagParentID[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline jacobs_rpl_mib_rplDodagParentEntry_t *
assign_rplDodagParentEntry(GList *vbl)
{
    jacobs_rpl_mib_rplDodagParentEntry_t *rplDodagParentEntry;
    char *p;

    rplDodagParentEntry = jacobs_rpl_mib_new_rplDodagParentEntry();
    p = (char *) rplDodagParentEntry + sizeof(jacobs_rpl_mib_rplDodagParentEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplDodagParentEntry((GNetSnmpVarBind *) vbl->data, rplDodagParentEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplDodagParentEntry");
        g_free(rplDodagParentEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplDodagParentEntry_oid, G_N_ELEMENTS(rplDodagParentEntry_oid),
                      rplDodagParentEntry_attr, rplDodagParentEntry);

    return rplDodagParentEntry;
}

void
jacobs_rpl_mib_get_rplDodagParentTable(GNetSnmp *s, jacobs_rpl_mib_rplDodagParentEntry_t ***rplDodagParentEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 6, 1, 0};
    guint32 base[128];

    *rplDodagParentEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplDodagParentEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplDodagParentEntry = (jacobs_rpl_mib_rplDodagParentEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplDodagParentEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplDodagParentEntry)[i] = assign_rplDodagParentEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplDodagParentEntry(GNetSnmp *s, jacobs_rpl_mib_rplDodagParentEntry_t **rplDodagParentEntry, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagParentID, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplDodagParentEntry_oid, sizeof(rplDodagParentEntry_oid));
    len = pack_rplDodagParentEntry(base, rplRPLInstanceID, rplDodagRoot, rplDodagParentID);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplDodagParentEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplDodagParentEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplDodagParentEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplDodagParentEntry = assign_rplDodagParentEntry(out);
    }
}

void
jacobs_rpl_mib_free_rplDodagParentEntry(jacobs_rpl_mib_rplDodagParentEntry_t *rplDodagParentEntry)
{
    GList *vbl;
    char *p;

    if (rplDodagParentEntry) {
        p = (char *) rplDodagParentEntry + sizeof(jacobs_rpl_mib_rplDodagParentEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplDodagParentEntry);
    }
}

void
jacobs_rpl_mib_free_rplDodagParentTable(jacobs_rpl_mib_rplDodagParentEntry_t **rplDodagParentEntry)
{
    int i;

    if (rplDodagParentEntry) {
        for (i = 0; rplDodagParentEntry[i]; i++) {
            jacobs_rpl_mib_free_rplDodagParentEntry(rplDodagParentEntry[i]);
        }
        g_free(rplDodagParentEntry);
    }
}

jacobs_rpl_mib_rplDodagChildEntry_t *
jacobs_rpl_mib_new_rplDodagChildEntry()
{
    jacobs_rpl_mib_rplDodagChildEntry_t *rplDodagChildEntry;

    rplDodagChildEntry = (jacobs_rpl_mib_rplDodagChildEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplDodagChildEntry_t) + sizeof(gpointer));
    return rplDodagChildEntry;
}

static inline int
unpack_rplDodagChildEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplDodagChildEntry_t *rplDodagChildEntry)
{
    guint8 idx = 13;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    rplDodagChildEntry->rplRPLInstanceID = vb->oid[idx++];
     if ((rplDodagChildEntry->rplRPLInstanceID > 255)) {
         return -1;
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagChildEntry->rplDodagRoot[i] = vb->oid[idx++];
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagChildEntry->rplDodagChildID[i] = vb->oid[idx++];
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplDodagChildEntry(guint32 *base, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagChildID)
{
    guint8 idx = 13;
    guint16 i, len;

    base[idx++] = rplRPLInstanceID;
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagRoot[i];
        if (idx >= 128) return -1;
    }
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagChildID[i];
        if (idx >= 128) return -1;
    }
    return idx;
}

static inline jacobs_rpl_mib_rplDodagChildEntry_t *
assign_rplDodagChildEntry(GList *vbl)
{
    jacobs_rpl_mib_rplDodagChildEntry_t *rplDodagChildEntry;
    char *p;

    rplDodagChildEntry = jacobs_rpl_mib_new_rplDodagChildEntry();
    p = (char *) rplDodagChildEntry + sizeof(jacobs_rpl_mib_rplDodagChildEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplDodagChildEntry((GNetSnmpVarBind *) vbl->data, rplDodagChildEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplDodagChildEntry");
        g_free(rplDodagChildEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplDodagChildEntry_oid, G_N_ELEMENTS(rplDodagChildEntry_oid),
                      rplDodagChildEntry_attr, rplDodagChildEntry);

    return rplDodagChildEntry;
}

void
jacobs_rpl_mib_get_rplDodagChildTable(GNetSnmp *s, jacobs_rpl_mib_rplDodagChildEntry_t ***rplDodagChildEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 7, 1, 0};
    guint32 base[128];

    *rplDodagChildEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplDodagChildEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplDodagChildEntry = (jacobs_rpl_mib_rplDodagChildEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplDodagChildEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplDodagChildEntry)[i] = assign_rplDodagChildEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplDodagChildEntry(GNetSnmp *s, jacobs_rpl_mib_rplDodagChildEntry_t **rplDodagChildEntry, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagChildID, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplDodagChildEntry_oid, sizeof(rplDodagChildEntry_oid));
    len = pack_rplDodagChildEntry(base, rplRPLInstanceID, rplDodagRoot, rplDodagChildID);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplDodagChildEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplDodagChildEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplDodagChildEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplDodagChildEntry = assign_rplDodagChildEntry(out);
    }
}

void
jacobs_rpl_mib_free_rplDodagChildEntry(jacobs_rpl_mib_rplDodagChildEntry_t *rplDodagChildEntry)
{
    GList *vbl;
    char *p;

    if (rplDodagChildEntry) {
        p = (char *) rplDodagChildEntry + sizeof(jacobs_rpl_mib_rplDodagChildEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplDodagChildEntry);
    }
}

void
jacobs_rpl_mib_free_rplDodagChildTable(jacobs_rpl_mib_rplDodagChildEntry_t **rplDodagChildEntry)
{
    int i;

    if (rplDodagChildEntry) {
        for (i = 0; rplDodagChildEntry[i]; i++) {
            jacobs_rpl_mib_free_rplDodagChildEntry(rplDodagChildEntry[i]);
        }
        g_free(rplDodagChildEntry);
    }
}

jacobs_rpl_mib_rplDodagPrefixEntry_t *
jacobs_rpl_mib_new_rplDodagPrefixEntry()
{
    jacobs_rpl_mib_rplDodagPrefixEntry_t *rplDodagPrefixEntry;

    rplDodagPrefixEntry = (jacobs_rpl_mib_rplDodagPrefixEntry_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplDodagPrefixEntry_t) + sizeof(gpointer));
    return rplDodagPrefixEntry;
}

static inline int
unpack_rplDodagPrefixEntry(GNetSnmpVarBind *vb, jacobs_rpl_mib_rplDodagPrefixEntry_t *rplDodagPrefixEntry)
{
    guint8 idx = 13;
    guint16 i, len;

    if (vb->oid_len < idx) return -1;
    rplDodagPrefixEntry->rplRPLInstanceID = vb->oid[idx++];
     if ((rplDodagPrefixEntry->rplRPLInstanceID > 255)) {
         return -1;
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagPrefixEntry->rplDodagRoot[i] = vb->oid[idx++];
    }
    len = 16;
    if (vb->oid_len < idx + len) return -1;
    for (i = 0; i < len; i++) {
        rplDodagPrefixEntry->rplDodagPrefixIpv6Prefix[i] = vb->oid[idx++];
    }
    if (vb->oid_len < idx) return -1;
    rplDodagPrefixEntry->rplDodagPrefixIpv6PrefixLength = vb->oid[idx++];
     if ((rplDodagPrefixEntry->rplDodagPrefixIpv6PrefixLength > 2040)) {
         return -1;
    }
    if (vb->oid_len > idx) return -1;
    return 0;
}

static inline gint8
pack_rplDodagPrefixEntry(guint32 *base, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagPrefixIpv6Prefix, guint32 rplDodagPrefixIpv6PrefixLength)
{
    guint8 idx = 13;
    guint16 i, len;

    base[idx++] = rplRPLInstanceID;
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagRoot[i];
        if (idx >= 128) return -1;
    }
    len = 16;
    if (len != 16) return -1;
    for (i = 0; i < len; i++) {
        base[idx++] = rplDodagPrefixIpv6Prefix[i];
        if (idx >= 128) return -1;
    }
    base[idx++] = rplDodagPrefixIpv6PrefixLength;
    return idx;
}

static inline jacobs_rpl_mib_rplDodagPrefixEntry_t *
assign_rplDodagPrefixEntry(GList *vbl)
{
    jacobs_rpl_mib_rplDodagPrefixEntry_t *rplDodagPrefixEntry;
    char *p;

    rplDodagPrefixEntry = jacobs_rpl_mib_new_rplDodagPrefixEntry();
    p = (char *) rplDodagPrefixEntry + sizeof(jacobs_rpl_mib_rplDodagPrefixEntry_t);
    * (GList **) p = vbl;

    if (unpack_rplDodagPrefixEntry((GNetSnmpVarBind *) vbl->data, rplDodagPrefixEntry) < 0) {
        g_warning("%s: invalid instance identifier", "rplDodagPrefixEntry");
        g_free(rplDodagPrefixEntry);
        return NULL;
    }

    gnet_snmp_attr_assign(vbl, rplDodagPrefixEntry_oid, G_N_ELEMENTS(rplDodagPrefixEntry_oid),
                      rplDodagPrefixEntry_attr, rplDodagPrefixEntry);

    return rplDodagPrefixEntry;
}

void
jacobs_rpl_mib_get_rplDodagPrefixTable(GNetSnmp *s, jacobs_rpl_mib_rplDodagPrefixEntry_t ***rplDodagPrefixEntry, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    GList *row;
    int i;
    static guint32 const _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 8, 1, 0};
    guint32 base[128];

    *rplDodagPrefixEntry = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 13, 12, rplDodagPrefixEntry_attr, mask);

    out = gnet_snmp_sync_table(s, in, error);
    /* gnet_snmp_varbind_list_free(in); */

    if (out) {
        *rplDodagPrefixEntry = (jacobs_rpl_mib_rplDodagPrefixEntry_t **) g_malloc0((g_list_length(out) + 1) * sizeof(jacobs_rpl_mib_rplDodagPrefixEntry_t *));
        for (row = out, i = 0; row; row = g_list_next(row), i++) {
            (*rplDodagPrefixEntry)[i] = assign_rplDodagPrefixEntry(row->data);
        }
    }
}

void
jacobs_rpl_mib_get_rplDodagPrefixEntry(GNetSnmp *s, jacobs_rpl_mib_rplDodagPrefixEntry_t **rplDodagPrefixEntry, guint32 rplRPLInstanceID, guchar *rplDodagRoot, guchar *rplDodagPrefixIpv6Prefix, guint32 rplDodagPrefixIpv6PrefixLength, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    guint32 base[128];
    gint8 len;

    memcpy(base, rplDodagPrefixEntry_oid, sizeof(rplDodagPrefixEntry_oid));
    len = pack_rplDodagPrefixEntry(base, rplRPLInstanceID, rplDodagRoot, rplDodagPrefixIpv6Prefix, rplDodagPrefixIpv6PrefixLength);
    if (len < 0) {
        g_warning("%s: invalid index values", "rplDodagPrefixEntry");
        s->error_status = GNET_SNMP_PDU_ERR_INTERNAL;
        return;
    }

    *rplDodagPrefixEntry = NULL;

    gnet_snmp_attr_get(s, &in, base, len, 12, rplDodagPrefixEntry_attr, mask);

    out = gnet_snmp_sync_get(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if (s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplDodagPrefixEntry = assign_rplDodagPrefixEntry(out);
    }
}

void
jacobs_rpl_mib_free_rplDodagPrefixEntry(jacobs_rpl_mib_rplDodagPrefixEntry_t *rplDodagPrefixEntry)
{
    GList *vbl;
    char *p;

    if (rplDodagPrefixEntry) {
        p = (char *) rplDodagPrefixEntry + sizeof(jacobs_rpl_mib_rplDodagPrefixEntry_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplDodagPrefixEntry);
    }
}

void
jacobs_rpl_mib_free_rplDodagPrefixTable(jacobs_rpl_mib_rplDodagPrefixEntry_t **rplDodagPrefixEntry)
{
    int i;

    if (rplDodagPrefixEntry) {
        for (i = 0; rplDodagPrefixEntry[i]; i++) {
            jacobs_rpl_mib_free_rplDodagPrefixEntry(rplDodagPrefixEntry[i]);
        }
        g_free(rplDodagPrefixEntry);
    }
}

jacobs_rpl_mib_rplStats_t *
jacobs_rpl_mib_new_rplStats()
{
    jacobs_rpl_mib_rplStats_t *rplStats;

    rplStats = (jacobs_rpl_mib_rplStats_t *) g_malloc0(sizeof(jacobs_rpl_mib_rplStats_t) + sizeof(gpointer));
    return rplStats;
}

static inline jacobs_rpl_mib_rplStats_t *
assign_rplStats(GList *vbl)
{
    jacobs_rpl_mib_rplStats_t *rplStats;
    char *p;

    rplStats = jacobs_rpl_mib_new_rplStats();
    p = (char *) rplStats + sizeof(jacobs_rpl_mib_rplStats_t);
    * (GList **) p = vbl;

    gnet_snmp_attr_assign(vbl, rplStats_oid, G_N_ELEMENTS(rplStats_oid),
                      rplStats_attr, rplStats);

    return rplStats;
}

void
jacobs_rpl_mib_get_rplStats(GNetSnmp *s, jacobs_rpl_mib_rplStats_t **rplStats, gint64 mask, GError **error)
{
    GList *in = NULL, *out = NULL;
    static const guint32 _base[] = {1, 3, 6, 1, 4, 1, 30982, 1, 2, 1, 9, 0};
    guint32 base[128];

    *rplStats = NULL;
    memcpy(base, _base, sizeof(_base));

    gnet_snmp_attr_get(s, &in, base, 12, 11, rplStats_attr, mask);

    out = gnet_snmp_sync_getnext(s, in, error);
    g_list_foreach(in, (GFunc) gnet_snmp_varbind_delete, NULL);
    g_list_free(in);
    if (out) {
        if ((error && *error) || s->error_status != GNET_SNMP_PDU_ERR_NOERROR) {
            g_list_foreach(out, (GFunc) gnet_snmp_varbind_delete, NULL);
            g_list_free(out);
            return;
        }
        *rplStats = assign_rplStats(out);
    }
}

void
jacobs_rpl_mib_free_rplStats(jacobs_rpl_mib_rplStats_t *rplStats)
{
    GList *vbl;
    char *p;

    if (rplStats) {
        p = (char *) rplStats + sizeof(jacobs_rpl_mib_rplStats_t);
        vbl = * (GList **) p;
        g_list_foreach(vbl, (GFunc) gnet_snmp_varbind_delete, NULL);
        g_list_free(vbl);
        g_free(rplStats);
    }
}


